(ns bitclojn.core)

(defmacro § [& _])

(defmacro def- [s i] `(def ~(vary-meta s assoc :private true) ~i))

(defmacro when' [y & w]
    (let [[_ & w] (if (= '=> (first w)) (rest w) (cons nil w))]
        `(if ~y (do ~@w) ~_)))
(defmacro let-when [x y & w]
    (let [[_ & w] (if (= '=> (first w)) (rest w) (cons nil w))]
        `(let [~@x] (if ~y (do ~@w) ~_))))

(defn -main [& args]
    )

(ns org.bitcoinj.core #_"AbstractBlockChain"
    (:import #_[java.util *]
             #_[java.util.concurrent *]
             #_[java.util.concurrent.locks *])
    (:import #_[com.google.common.base *]
             #_[com.google.common.collect *]
             #_[com.google.common.util.concurrent *]
             #_[org.slf4j *])
  #_(:require #_[org.bitcoinj.core.listeners *]
             #_[org.bitcoinj.store *]
             #_[org.bitcoinj.utils *]
             [org.bitcoinj.wallet Wallet]))

;;;
 ; <p>An AbstractBlockChain holds a series of {@link Block} objects, links them together, and knows how to verify that
 ; the chain follows the rules of the {@link NetworkParameters} for this chain.</p>
 ;
 ; <p>It can be connected to a {@link Wallet}, and also {@link TransactionReceivedInBlockListener}s that can receive
 ; transactions and notifications of re-organizations.</p>
 ;
 ; <p>An AbstractBlockChain implementation must be connected to a {@link BlockStore} implementation.  The chain object
 ; by itself doesn't store any data, that's delegated to the store.  Which store you use is a decision best made by
 ; reading the getting started guide, but briefly, fully validating block chains need fully validating stores.  In
 ; the lightweight SPV mode, a {@link org.bitcoinj.store.SPVBlockStore} is the right choice.</p>
 ;
 ; <p>This class implements an abstract class which makes it simple to create a BlockChain that does/doesn't do
 ; full verification.  It verifies headers and is implements most of what is required to implement SPV mode, but
 ; also provides callback hooks which can be used to do full verification.</p>
 ;
 ; <p>There are two subclasses of AbstractBlockChain that are useful: {@link BlockChain}, which is the simplest
 ; class and implements <i>simplified payment verification</i>.  This is a lightweight and efficient mode that
 ; does not verify the contents of blocks, just their headers.  A {@link FullPrunedBlockChain} paired with a
 ; {@link org.bitcoinj.store.H2FullPrunedBlockStore} implements full verification, which is equivalent to
 ; Bitcoin Core.  To learn more about the alternative security models, please consult the articles on the
 ; website.</p>
 ;
 ; <b>Theory</b>
 ;
 ; <p>The 'chain' is actually a tree although in normal operation it operates mostly as a list of {@link Block}s.
 ; When multiple new head blocks are found simultaneously, there are multiple stories of the economy competing to become
 ; the one true consensus.  This can happen naturally when two miners solve a block within a few seconds of each other,
 ; or it can happen when the chain is under attack.</p>
 ;
 ; <p>A reference to the head block of the best known chain is stored.  If you can reach the genesis block by repeatedly
 ; walking through the prevBlock pointers, then we say this is a full chain.  If you cannot reach the genesis block
 ; we say it is an orphan chain.  Orphan chains can occur when blocks are solved and received during the initial block
 ; chain download, or if we connect to a peer that doesn't send us blocks in order.</p>
 ;
 ; <p>A reorganize occurs when the blocks that make up the best known chain changes.  Note that simply adding a
 ; new block to the top of the best chain isn't as reorganize, but that a reorganize is always triggered by adding
 ; a new block that connects to some other (non best head) block.  By "best" we mean the chain representing the largest
 ; amount of work done.</p>
 ;
 ; <p>Every so often the block chain passes a difficulty transition point.  At that time, all the blocks in the last
 ; 2016 blocks are examined and a new difficulty target is calculated from them.</p>
 ;;
#_public
#_abstract
class AbstractBlockChain
(§
#_private
#_static
#_final
    Logger log = LoggerFactory.getLogger(AbstractBlockChain.class);

#_protected
#_final
    ReentrantLock lock = Threading.lock("blockchain");

    ;;; Keeps a map of block hashes to StoredBlocks. ;;
#_private
#_final
    BlockStore blockStore;

    ;;;
     ; Tracks the top of the best known chain.
     ;
     ; Following this one down to the genesis block produces the story of the economy from the creation of Bitcoin
     ; until the present day.  The chain head can change if a new set of blocks is received that results in a chain of
     ; greater work than the one obtained by following this one down.  In that case a reorganize is triggered,
     ; potentially invalidating transactions in our wallet.
     ;;
#_protected
    StoredBlock chainHead;

    ;; TODO: Scrap this and use a proper read/write for all of the block chain objects.
    ;; The chainHead field is read/written synchronized with this object rather than BlockChain.  However writing is
    ;; also guaranteed to happen whilst BlockChain is synchronized (see setChainHead).  The goal of this is to let
    ;; clients quickly access the chain head even whilst the block chain is downloading and thus the BlockChain is
    ;; locked most of the time.
#_private
#_final
    Object chainHeadLock = new Object();

#_protected
#_final
    NetworkParameters params;
#_private
#_final
    CopyOnWriteArrayList<ListenerRegistration<NewBestBlockListener>> newBestBlockListeners;
#_private
#_final
    CopyOnWriteArrayList<ListenerRegistration<ReorganizeListener>> reorganizeListeners;
#_private
#_final
    CopyOnWriteArrayList<ListenerRegistration<TransactionReceivedInBlockListener>> transactionReceivedListeners;

    ;; Holds a block header and, optionally, a list of tx hashes or block's transactions.
    class OrphanBlock
    (§
#_final
        Block block;
#_final
        List<Sha256Hash> filteredTxHashes;
#_final
        Map<Sha256Hash, Transaction> filteredTxn;

        OrphanBlock(Block block, #_nilable List<Sha256Hash> filteredTxHashes, #_nilable Map<Sha256Hash, Transaction> filteredTxn)
        (§
#_final
            boolean filtered = (filteredTxHashes != nil && filteredTxn != nil);
            Preconditions.checkArgument((block.transactions == nil && filtered) || (block.transactions != nil && !filtered));
            this.block = block;
            this.filteredTxHashes = filteredTxHashes;
            this.filteredTxn = filteredTxn;
        )
    )
    ;; Holds blocks that we have received but can't plug into the chain yet, e.g. because they were created whilst we
    ;; were downloading the block chain.
#_private
#_final
    LinkedHashMap<Sha256Hash, OrphanBlock> orphanBlocks = new LinkedHashMap<>();

    ;;; False positive estimation uses a double exponential moving average. ;;
#_public
#_static
#_final
    double FP_ESTIMATOR_ALPHA = 0.0001;
    ;;; False positive estimation uses a double exponential moving average. ;;
#_public
#_static
#_final
    double FP_ESTIMATOR_BETA = 0.01;

#_private
    double falsePositiveRate;
#_private
    double falsePositiveTrend;
#_private
    double previousFalsePositiveRate;

#_private
#_final
    VersionTally versionTally;

    ;;; See {@link #AbstractBlockChain(Context, List, BlockStore)} ;;
#_public
    AbstractBlockChain(NetworkParameters params, List<? extends Wallet> transactionReceivedListeners, BlockStore blockStore)
        throws BlockStoreException
    (§
        this(Context.getOrCreate(params), transactionReceivedListeners, blockStore);
    )

    ;;;
     ; Constructs a BlockChain connected to the given list of listeners (e.g. wallets) and a store.
     ;;
#_public
    AbstractBlockChain(Context context, List<? extends Wallet> wallets, BlockStore blockStore)
        throws BlockStoreException
    (§
        this.blockStore = blockStore;
        chainHead = blockStore.getChainHead();
        log.info("chain head is at height {}:\n{}", chainHead.getHeight(), chainHead.getHeader());
        this.params = context.getParams();

        this.newBestBlockListeners = new CopyOnWriteArrayList<>();
        this.reorganizeListeners = new CopyOnWriteArrayList<>();
        this.transactionReceivedListeners = new CopyOnWriteArrayList<>();
        for (NewBestBlockListener l : wallets)
            addNewBestBlockListener(Threading.SAME_THREAD, l);
        for (ReorganizeListener l : wallets)
            addReorganizeListener(Threading.SAME_THREAD, l);
        for (TransactionReceivedInBlockListener l : wallets)
            addTransactionReceivedListener(Threading.SAME_THREAD, l);

        this.versionTally = new VersionTally(context.getParams());
        this.versionTally.initialize(blockStore, chainHead);
    )

    ;;;
     ; Add a wallet to the BlockChain.  Note that the wallet will be unaffected by any blocks received while it
     ; was not part of this BlockChain.  This method is useful if the wallet has just been created, and its keys
     ; have never been in use, or if the wallet has been loaded along with the BlockChain.  Note that adding
     ; multiple wallets is not well tested!
     ;;
#_public
#_final
    void addWallet(Wallet wallet)
    (§
        addNewBestBlockListener(Threading.SAME_THREAD, wallet);
        addReorganizeListener(Threading.SAME_THREAD, wallet);
        addTransactionReceivedListener(Threading.SAME_THREAD, wallet);

        int walletHeight = wallet.getLastBlockSeenHeight();
        int chainHeight = getBestChainHeight();
        if (walletHeight != chainHeight)
        (§
            log.warn("Wallet/chain height mismatch: {} vs {}", walletHeight, chainHeight);
            log.warn("Hashes: {} vs {}", wallet.getLastBlockSeenHash(), getChainHead().getHeader().getHash());

            ;; This special case happens when the VM crashes because of a transaction received.  It causes the updated
            ;; block store to persist, but not the wallet.  In order to fix the issue, we roll back the block store to
            ;; the wallet height to make it look like as if the block has never been received.
            if (0 < walletHeight && walletHeight < chainHeight)
            (§
                try
                (§
                    rollbackBlockStore(walletHeight);
                    log.info("Rolled back block store to height {}.", walletHeight);
                )
                catch (BlockStoreException _)
                (§
                    log.warn("Rollback of block store failed, continuing with mismatched heights. This can happen due to a replay.");
                )
            )
        )
    )

    ;;; Removes a wallet from the chain. ;;
#_public
    void removeWallet(Wallet wallet)
    (§
        removeNewBestBlockListener(wallet);
        removeReorganizeListener(wallet);
        removeTransactionReceivedListener(wallet);
    )

    ;;; Replaced with more specific listener methods: use them instead. ;;
#_deprecated
#_suppress("deprecation")
#_public
    void addListener(BlockChainListener listener)
    (§
        addListener(listener, Threading.USER_THREAD);
    )

    ;;; Replaced with more specific listener methods: use them instead. ;;
#_deprecated
#_public
    void addListener(BlockChainListener listener, Executor executor)
    (§
        addReorganizeListener(executor, listener);
        addNewBestBlockListener(executor, listener);
        addTransactionReceivedListener(executor, listener);
    )

#_deprecated
#_public
    void removeListener(BlockChainListener listener)
    (§
        removeReorganizeListener(listener);
        removeNewBestBlockListener(listener);
        removeTransactionReceivedListener(listener);
    )

    ;;;
     ; Adds a {@link NewBestBlockListener} listener to the chain.
     ;;
#_public
    void addNewBestBlockListener(NewBestBlockListener listener)
    (§
        addNewBestBlockListener(Threading.USER_THREAD, listener);
    )

    ;;;
     ; Adds a {@link NewBestBlockListener} listener to the chain.
     ;;
#_public
#_final
    void addNewBestBlockListener(Executor executor, NewBestBlockListener listener)
    (§
        newBestBlockListeners.add(new ListenerRegistration<>(listener, executor));
    )

    ;;;
     ; Adds a generic {@link ReorganizeListener} listener to the chain.
     ;;
#_public
    void addReorganizeListener(ReorganizeListener listener)
    (§
        addReorganizeListener(Threading.USER_THREAD, listener);
    )

    ;;;
     ; Adds a generic {@link ReorganizeListener} listener to the chain.
     ;;
#_public
#_final
    void addReorganizeListener(Executor executor, ReorganizeListener listener)
    (§
        reorganizeListeners.add(new ListenerRegistration<>(listener, executor));
    )

    ;;;
     ; Adds a generic {@link TransactionReceivedInBlockListener} listener to the chain.
     ;;
#_public
    void addTransactionReceivedListener(TransactionReceivedInBlockListener listener)
    (§
        addTransactionReceivedListener(Threading.USER_THREAD, listener);
    )

    ;;;
     ; Adds a generic {@link TransactionReceivedInBlockListener} listener to the chain.
     ;;
#_public
#_final
    void addTransactionReceivedListener(Executor executor, TransactionReceivedInBlockListener listener)
    (§
        transactionReceivedListeners.add(new ListenerRegistration<>(listener, executor));
    )

    ;;;
     ; Removes the given {@link NewBestBlockListener} from the chain.
     ;;
#_public
    void removeNewBestBlockListener(NewBestBlockListener listener)
    (§
        ListenerRegistration.removeFromList(listener, newBestBlockListeners);
    )

    ;;;
     ; Removes the given {@link ReorganizeListener} from the chain.
     ;;
#_public
    void removeReorganizeListener(ReorganizeListener listener)
    (§
        ListenerRegistration.removeFromList(listener, reorganizeListeners);
    )

    ;;;
     ; Removes the given {@link TransactionReceivedInBlockListener} from the chain.
     ;;
#_public
    void removeTransactionReceivedListener(TransactionReceivedInBlockListener listener)
    (§
        ListenerRegistration.removeFromList(listener, transactionReceivedListeners);
    )

    ;;;
     ; Returns the {@link BlockStore} the chain was constructed with.  You can use this to iterate over the chain.
     ;;
#_public
    BlockStore getBlockStore()
    (§
        return blockStore;
    )

    ;;;
     ; Adds/updates the given {@link Block} with the block store.
     ; This version is used when the transactions have not been verified.
     ; @param storedPrev The {@link StoredBlock} which immediately precedes block.
     ; @param block The {@link Block} to add/update.
     ; @return the newly created {@link StoredBlock}
     ;;
#_protected
#_abstract
    StoredBlock addToBlockStore(StoredBlock storedPrev, Block block)
        throws BlockStoreException, VerificationException;

    ;;;
     ; Adds/updates the given {@link StoredBlock} with the block store.
     ; This version is used when the transactions have already been verified to properly spend txOutputChanges.
     ; @param storedPrev The {@link StoredBlock} which immediately precedes block.
     ; @param header The {@link StoredBlock} to add/update.
     ; @param txOutputChanges The total sum of all changes made by this block to the set of open transaction outputs
     ;                        (from a call to connectTransactions), if in fully verifying mode (null otherwise).
     ; @return the newly created {@link StoredBlock}
     ;;
#_protected
#_abstract
    StoredBlock addToBlockStore(StoredBlock storedPrev, Block header, #_nilable TransactionOutputChanges txOutputChanges)
        throws BlockStoreException, VerificationException;

    ;;;
     ; Rollback the block store to a given height.  This is currently only supported by {@link BlockChain} instances.
     ;
     ; @throws BlockStoreException
     ;             if the operation fails or is unsupported.
     ;;
#_protected
#_abstract
    void rollbackBlockStore(int height)
        throws BlockStoreException;

    ;;;
     ; Called before setting chain head in memory.
     ; Should write the new head to block store and then commit any database transactions
     ; that were started by disconnectTransactions/connectTransactions.
     ;;
#_protected
#_abstract
    void doSetChainHead(StoredBlock chainHead)
        throws BlockStoreException;

    ;;;
     ; Called if we (possibly) previously called disconnectTransaction/connectTransactions,
     ; but will not be calling preSetChainHead as a block failed verification.
     ; Can be used to abort database transactions that were started by
     ; disconnectTransactions/connectTransactions.
     ;;
#_protected
#_abstract
    void notSettingChainHead()
        throws BlockStoreException;

    ;;;
     ; For a standard BlockChain, this should return blockStore.get(hash),
     ; for a FullPrunedBlockChain blockStore.getOnceUndoableStoredBlock(hash)
     ;;
#_protected
#_abstract
    StoredBlock getStoredBlockInCurrentScope(Sha256Hash hash)
        throws BlockStoreException;

    ;;;
     ; Processes a received block and tries to add it to the chain.  If there's something wrong with the block an
     ; exception is thrown.  If the block is OK but cannot be connected to the chain at this time, returns false.
     ; If the block can be connected to the chain, returns true.
     ; Accessing block's transactions in another thread while this method runs may result in undefined behavior.
     ;;
#_public
    boolean add(Block block)
        throws VerificationException, PrunedException
    (§
        try
        (§
            return add(block, true, nil, nil);
        )
        catch (BlockStoreException e)
        (§
            ;; TODO: Figure out a better way to propagate this exception to the user.
            throw new RuntimeException(e);
        )
        catch (VerificationException e)
        (§
            try
            (§
                notSettingChainHead();
            )
            catch (BlockStoreException e1)
            (§
                throw new RuntimeException(e1);
            )
            throw new VerificationException("Could not verify block:\n" + block.toString(), e);
        )
    )

    ;;;
     ; Processes a received block and tries to add it to the chain.  If there's something wrong with the block an
     ; exception is thrown.  If the block is OK but cannot be connected to the chain at this time, returns false.
     ; If the block can be connected to the chain, returns true.
     ;;
#_public
    boolean add(FilteredBlock block)
        throws VerificationException, PrunedException
    (§
        try
        (§
            ;; The block has a list of hashes of transactions that matched the Bloom filter, and a list of associated
            ;; Transaction objects.  There may be fewer Transaction objects than hashes, this is expected.  It can happen
            ;; in the case where we were already around to witness the initial broadcast, so we downloaded the
            ;; transaction and sent it to the wallet before this point (the wallet may have thrown it away if it was
            ;; a false positive, as expected in any Bloom filtering scheme).  The filteredTxn list here will usually
            ;; only be full of data when we are catching up to the head of the chain and thus haven't witnessed any
            ;; of the transactions.
            return add(block.getBlockHeader(), true, block.getTransactionHashes(), block.getAssociatedTransactions());
        )
        catch (BlockStoreException e)
        (§
            ;; TODO: Figure out a better way to propagate this exception to the user.
            throw new RuntimeException(e);
        )
        catch (VerificationException e)
        (§
            try
            (§
                notSettingChainHead();
            )
            catch (BlockStoreException e1)
            (§
                throw new RuntimeException(e1);
            )
            throw new VerificationException("Could not verify block " + block.getHash().toString() + "\n" + block.toString(), e);
        )
    )

    ;;;
     ; Whether or not we are maintaining a set of unspent outputs and are verifying all transactions.
     ; Also indicates that all calls to add() should provide a block containing transactions
     ;;
#_protected
#_abstract
    boolean shouldVerifyTransactions();

    ;;;
     ; Connect each transaction in block.transactions, verifying them as we go and removing spent outputs
     ; If an error is encountered in a transaction, no changes should be made to the underlying BlockStore
     ; and a VerificationException should be thrown.
     ; Only called if shouldVerifyTransactions().
     ; @throws VerificationException if an attempt was made to spend an already-spent output, or if a transaction incorrectly solved an output script.
     ; @throws BlockStoreException if the block store had an underlying error.
     ; @return The full set of all changes made to the set of open transaction outputs.
     ;;
#_protected
#_abstract
    TransactionOutputChanges connectTransactions(int height, Block block)
        throws VerificationException, BlockStoreException;

    ;;;
     ; Load newBlock from BlockStore and connect its transactions, returning changes to the set of unspent transactions.
     ; If an error is encountered in a transaction, no changes should be made to the underlying BlockStore.
     ; Only called if shouldVerifyTransactions().
     ; @throws PrunedException if newBlock does not exist as a {@link StoredUndoableBlock} in the block store.
     ; @throws VerificationException if an attempt was made to spend an already-spent output, or if a transaction incorrectly solved an output script.
     ; @throws BlockStoreException if the block store had an underlying error or newBlock does not exist in the block store at all.
     ; @return The full set of all changes made to the set of open transaction outputs.
     ;;
#_protected
#_abstract
    TransactionOutputChanges connectTransactions(StoredBlock newBlock)
        throws VerificationException, BlockStoreException, PrunedException;

    ;; filteredTxHashList contains all transactions, filteredTxn just a subset
#_private
    boolean add(Block block, boolean tryConnecting, #_nilable List<Sha256Hash> filteredTxHashList, #_nilable Map<Sha256Hash, Transaction> filteredTxn)
        throws BlockStoreException, VerificationException, PrunedException
    (§
        ;; TODO: Use read/write locks to ensure that during chain download properties are still low latency.
        lock.lock();
        try
        (§
            ;; Quick check for duplicates to avoid an expensive check further down (in findSplit).
            ;; This can happen a lot when connecting orphan transactions due to the dumb brute force algorithm we use.
            if (block.equals(getChainHead().getHeader()))
                return true;
            if (tryConnecting && orphanBlocks.containsKey(block.getHash()))
                return false;

            ;; If we want to verify transactions (i.e. we are running with full blocks), verify that block has transactions.
            if (shouldVerifyTransactions() && block.transactions == nil)
                throw new VerificationException("Got a block header while running in full-block mode");

            ;; Check for already-seen block, but only for full pruned mode, where the DB is
            ;; more likely able to handle these queries quickly.
            if (shouldVerifyTransactions() && blockStore.get(block.getHash()) != nil)
                return true;

#_final
            StoredBlock storedPrev;
#_final
            int height;
#_final
            EnumSet<Block.VerifyFlag> flags;

            ;; Prove the block is internally valid: hash is lower than target, etc.  This only checks the block contents
            ;; if there is a tx sending or receiving coins using an address in one of our wallets.  And those transactions
            ;; are only lightly verified: presence in a valid connecting block is taken as proof of validity.  See the
            ;; article here for more details: https://bitcoinj.github.io/security-model
            try
            (§
                block.verifyHeader();
                storedPrev = getStoredBlockInCurrentScope(block.getPrevBlockHash());
                if (storedPrev != nil)
                    height = storedPrev.getHeight() + 1;
                else
                    height = Block.BLOCK_HEIGHT_UNKNOWN;
                flags = params.getBlockVerificationFlags(block, versionTally, height);
                if (shouldVerifyTransactions())
                    block.verifyTransactions(height, flags);
            )
            catch (VerificationException e)
            (§
                log.error("Failed to verify block: ", e);
                log.error(block.getHashAsString());
                throw e;
            )

            ;; Try linking it to a place in the currently known blocks.

            if (storedPrev == nil)
            (§
                ;; We can't find the previous block.  Probably we are still in the process of downloading the chain and
                ;; a block was solved whilst we were doing it.  We put it to one side and try to connect it later when we
                ;; have more blocks.
                Preconditions.checkState(tryConnecting, "bug in tryConnectingOrphans");
                log.warn("Block does not connect: {} prev {}", block.getHashAsString(), block.getPrevBlockHash());
                orphanBlocks.put(block.getHash(), new OrphanBlock(block, filteredTxHashList, filteredTxn));
                return false;
            )

            Preconditions.checkState(lock.isHeldByCurrentThread());
            ;; It connects to somewhere on the chain.  Not necessarily the top of the best known chain.
            params.checkDifficultyTransitions(storedPrev, block, blockStore);
            connectBlock(block, storedPrev, shouldVerifyTransactions(), filteredTxHashList, filteredTxn);

            if (tryConnecting)
                tryConnectingOrphans();

            return true;
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Returns the hashes of the currently stored orphan blocks and then deletes them from this objects storage.
     ; Used by Peer when a filter exhaustion event has occurred and thus any orphan blocks that have been downloaded
     ; might be inaccurate/incomplete.
     ;;
#_public
    Set<Sha256Hash> drainOrphanBlocks()
    (§
        lock.lock();
        try
        (§
            Set<Sha256Hash> hashes = new HashSet<>(orphanBlocks.keySet());
            orphanBlocks.clear();
            return hashes;
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;; expensiveChecks enables checks that require looking at blocks further back in the chain
    ;; than the previous one when connecting (e.g. median timestamp check)
    ;; It could be exposed, but for now we just set it to shouldVerifyTransactions()
#_private
    void connectBlock(final Block block, StoredBlock storedPrev, boolean expensiveChecks, #_nilable final List<Sha256Hash> filteredTxHashList, #_nilable final Map<Sha256Hash, Transaction> filteredTxn)
        throws BlockStoreException, VerificationException, PrunedException
    (§
        Preconditions.checkState(lock.isHeldByCurrentThread());
        boolean filtered = (filteredTxHashList != nil && filteredTxn != nil);
        ;; Check that we aren't connecting a block that fails a checkpoint check.
        if (!params.passesCheckpoint(storedPrev.getHeight() + 1, block.getHash()))
            throw new VerificationException("Block failed checkpoint lockin at " + (storedPrev.getHeight() + 1));
        if (shouldVerifyTransactions())
        (§
            Preconditions.checkNotNull(block.transactions);
            for (Transaction tx : block.transactions)
                if (!tx.isFinal(storedPrev.getHeight() + 1, block.getTimeSeconds()))
                   throw new VerificationException("Block contains non-final transaction");
        )

        StoredBlock head = getChainHead();
        if (storedPrev.equals(head))
        (§
            if (filtered && 0 < filteredTxn.size())
            (§
                log.debug("Block {} connects to top of best chain with {} transaction(s) of which we were sent {}",
                        block.getHashAsString(), filteredTxHashList.size(), filteredTxn.size());
                for (Sha256Hash hash : filteredTxHashList)
                    log.debug("  matched tx {}", hash);
            )
            if (expensiveChecks && block.getTimeSeconds() <= getMedianTimestampOfRecentBlocks(head, blockStore))
                throw new VerificationException("Block's timestamp is too early");

            ;; BIP 66 & 65: Enforce block version 3/4 once they are a supermajority of blocks.
            ;; NOTE: This requires 1,000 blocks since the last checkpoint (on main net, less on test) in order to be applied.
            ;; It is also limited to stopping addition of new v2/3 blocks to the tip of the chain.
            if (block.getVersion() == Block.BLOCK_VERSION_BIP34 || block.getVersion() == Block.BLOCK_VERSION_BIP66)
            (§
#_final
                Integer count = versionTally.getCountAtOrAbove(block.getVersion() + 1);
                if (count != nil && params.getMajorityRejectBlockOutdated() <= count)
                    throw new VerificationException.BlockVersionOutOfDate(block.getVersion());
            )

            ;; This block connects to the best known block, it is a normal continuation of the system.
            TransactionOutputChanges txOutChanges = nil;
            if (shouldVerifyTransactions())
                txOutChanges = connectTransactions(storedPrev.getHeight() + 1, block);
            StoredBlock newStoredBlock = addToBlockStore(storedPrev, (block.transactions == nil) ? block : block.cloneAsHeader(), txOutChanges);
            versionTally.add(block.getVersion());
            setChainHead(newStoredBlock);
            log.debug("Chain is now {} blocks high, running listeners", newStoredBlock.getHeight());
            informListenersForNewBlock(block, NewBlockType.BEST_CHAIN, filteredTxHashList, filteredTxn, newStoredBlock);
        )
        else
        (§
            ;; This block connects to somewhere other than the top of the best known chain.  We treat these differently.
            ;;
            ;; Note that we send the transactions to the wallet FIRST, even if we're about to re-organize this block
            ;; to become the new best chain head.  This simplifies handling of the re-org in the Wallet class.
            StoredBlock newBlock = storedPrev.build(block);
            boolean haveNewBestChain = newBlock.moreWorkThan(head);
            if (haveNewBestChain)
            (§
                log.info("Block is causing a re-organize");
            )
            else
            (§
                StoredBlock splitPoint = findSplit(newBlock, head, blockStore);
                if (splitPoint != nil && splitPoint.equals(newBlock))
                (§
                    ;; newStoredBlock is a part of the same chain, there's no fork.  This happens when we receive a block
                    ;; that we already saw and linked into the chain previously, which isn't the chain head.
                    ;; Re-processing it is confusing for the wallet so just skip.
                    log.warn("Saw duplicated block in main chain at height {}: {}", newBlock.getHeight(), newBlock.getHeader().getHash());
                    return;
                )

                if (splitPoint == nil)
                (§
                    ;; This should absolutely never happen.
                    ;; (lets not write the full block to disk to keep any bugs which allow this to happen from writing unreasonable amounts of data to disk)
                    throw new VerificationException("Block forks the chain but splitPoint is nil");
                )
                else
                (§
                    ;; We aren't actually spending any transactions (yet) because we are on a fork.
                    addToBlockStore(storedPrev, block);
                    int splitPointHeight = splitPoint.getHeight();
                    String splitPointHash = splitPoint.getHeader().getHashAsString();
                    log.info("Block forks the chain at height {}/block {}, but it did not cause a reorganize:\n{}", splitPointHeight, splitPointHash, newBlock.getHeader().getHashAsString());
                )
            )

            ;; We may not have any transactions if we received only a header, which can happen during fast catchup.
            ;; If we do, send them to the wallet but state that they are on a side chain so it knows not to try and
            ;; spend them until they become activated.
            if (block.transactions != nil || filtered)
                informListenersForNewBlock(block, NewBlockType.SIDE_CHAIN, filteredTxHashList, filteredTxn, newBlock);

            if (haveNewBestChain)
                handleNewBestChain(storedPrev, newBlock, block, expensiveChecks);
        )
    )

#_private
    void informListenersForNewBlock(final Block block, final NewBlockType newBlockType, #_nilable final List<Sha256Hash> filteredTxHashList, #_nilable final Map<Sha256Hash, Transaction> filteredTxn, final StoredBlock newStoredBlock)
        throws VerificationException
    (§
        ;; Notify the listeners of the new block, so the depth and workDone of stored transactions can be updated
        ;; (in the case of the listener being a wallet).  Wallets need to know how deep each transaction is, so
        ;; coinbases aren't used before maturity.
        boolean first = true;
        Set<Sha256Hash> falsePositives = Sets.newHashSet();
        if (filteredTxHashList != nil)
            falsePositives.addAll(filteredTxHashList);

        for (final ListenerRegistration<TransactionReceivedInBlockListener> registration : transactionReceivedListeners)
        (§
            if (registration.executor == Threading.SAME_THREAD)
            (§
                informListenerForNewTransactions(block, newBlockType, filteredTxHashList, filteredTxn, newStoredBlock, first, registration.listener, falsePositives);
            )
            else
            (§
                ;; Listener wants to be run on some other thread, so marshal it across here.
#_final
                boolean notFirst = !first;
                registration.executor.execute(new Runnable()
                (§
#_override
#_public
                    void run()
                    (§
                        try
                        (§
                            ;; We can't do false-positive handling when executing on another thread.
                            Set<Sha256Hash> ignoredFalsePositives = Sets.newHashSet();
                            informListenerForNewTransactions(block, newBlockType, filteredTxHashList, filteredTxn, newStoredBlock, notFirst, registration.listener, ignoredFalsePositives);
                        )
                        catch (VerificationException e)
                        (§
                            log.error("Block chain listener threw exception: ", e);
                            ;; Don't attempt to relay this back to the original peer thread if this was an async listener invocation.
                            ;; TODO: Make exception reporting a global feature and use it here.
                        )
                    )
                ));
            )
            first = false;
        )

        for (final ListenerRegistration<NewBestBlockListener> registration : newBestBlockListeners)
        (§
            if (registration.executor == Threading.SAME_THREAD)
            (§
                if (newBlockType == NewBlockType.BEST_CHAIN)
                    registration.listener.notifyNewBestBlock(newStoredBlock);
            )
            else
            (§
                ;; Listener wants to be run on some other thread, so marshal it across here.
                registration.executor.execute(new Runnable()
                (§
#_override
#_public
                    void run()
                    (§
                        try
                        (§
                            if (newBlockType == NewBlockType.BEST_CHAIN)
                                registration.listener.notifyNewBestBlock(newStoredBlock);
                        )
                        catch (VerificationException e)
                        (§
                            log.error("Block chain listener threw exception: ", e);
                            ;; Don't attempt to relay this back to the original peer thread if this was an async listener invocation.
                            ;; TODO: Make exception reporting a global feature and use it here.
                        )
                    )
                ));
            )
            first = false;
        )

        trackFalsePositives(falsePositives.size());
    )

#_private
#_static
    void informListenerForNewTransactions(Block block, NewBlockType newBlockType, #_nilable List<Sha256Hash> filteredTxHashList, #_nilable Map<Sha256Hash, Transaction> filteredTxn, StoredBlock newStoredBlock, boolean first, TransactionReceivedInBlockListener listener, Set<Sha256Hash> falsePositives)
        throws VerificationException
    (§
        if (block.transactions != nil)
        (§
            ;; If this is not the first wallet, ask for the transactions to be duplicated before being given
            ;; to the wallet when relevant.  This ensures that if we have two connected wallets and a tx that
            ;; is relevant to both of them, they don't end up accidentally sharing the same object (which can
            ;; result in temporary in-memory corruption during re-orgs).  See bug 257.  We only duplicate in
            ;; the case of multiple wallets to avoid an unnecessary efficiency hit in the common case.
            sendTransactionsToListener(newStoredBlock, newBlockType, listener, 0, block.transactions, !first, falsePositives);
        )
        else if (filteredTxHashList != nil)
        (§
            Preconditions.checkNotNull(filteredTxn);
            ;; We must send transactions to listeners in the order they appeared in the block - thus we iterate over the
            ;; set of hashes and call sendTransactionsToListener with individual txn when they have not already been
            ;; seen in loose broadcasts - otherwise notifyTransactionIsInBlock on the hash.
            int relativityOffset = 0;
            for (Sha256Hash hash : filteredTxHashList)
            (§
                Transaction tx = filteredTxn.get(hash);
                if (tx != nil)
                (§
                    sendTransactionsToListener(newStoredBlock, newBlockType, listener, relativityOffset, Collections.singletonList(tx), !first, falsePositives);
                )
                else if (listener.notifyTransactionIsInBlock(hash, newStoredBlock, newBlockType, relativityOffset))
                (§
                    falsePositives.remove(hash);
                )
                relativityOffset++;
            )
        )
    )

    ;;;
     ; Gets the median timestamp of the last 11 blocks.
     ;;
#_private
#_static
    long getMedianTimestampOfRecentBlocks(StoredBlock storedBlock, BlockStore store)
        throws BlockStoreException
    (§
        long[] timestamps = new long[11];
        int unused = 9;
        timestamps[10] = storedBlock.getHeader().getTimeSeconds();
        while (0 <= unused && (storedBlock = storedBlock.getPrev(store)) != nil)
            timestamps[unused--] = storedBlock.getHeader().getTimeSeconds();

        Arrays.sort(timestamps, unused + 1, 11);
        return timestamps[unused + (11 - unused) / 2];
    )

    ;;;
     ; Disconnect each transaction in the block (after reading it from the block store).
     ; Only called if shouldVerifyTransactions().
     ; @throws PrunedException if block does not exist as a {@link StoredUndoableBlock} in the block store.
     ; @throws BlockStoreException if the block store had an underlying error or block does not exist in the block store at all.
     ;;
#_protected
#_abstract
    void disconnectTransactions(StoredBlock block)
        throws PrunedException, BlockStoreException;

    ;;;
     ; Called as part of connecting a block when the new block results in a different chain having higher total work.
     ;
     ; if (shouldVerifyTransactions)
     ;     either newChainHead needs to be in the block store as a FullStoredBlock, or (block != null && block.transactions != null)
     ;;
#_private
    void handleNewBestChain(StoredBlock storedPrev, StoredBlock newChainHead, Block block, boolean expensiveChecks)
        throws BlockStoreException, VerificationException, PrunedException
    (§
        Preconditions.checkState(lock.isHeldByCurrentThread());

        ;; This chain has overtaken the one we currently believe is best.  Reorganize is required.
        ;;
        ;; Firstly, calculate the block at which the chain diverged.  We only need to examine the
        ;; chain from beyond this block to find differences.

        StoredBlock head = getChainHead();
#_final
        StoredBlock splitPoint = findSplit(newChainHead, head, blockStore);
        log.info("Re-organize after split at height {}", splitPoint.getHeight());
        log.info("Old chain head: {}", head.getHeader().getHashAsString());
        log.info("New chain head: {}", newChainHead.getHeader().getHashAsString());
        log.info("Split at block: {}", splitPoint.getHeader().getHashAsString());

        ;; Then build a list of all blocks in the old part of the chain and the new part.
#_final
        LinkedList<StoredBlock> oldBlocks = getPartialChain(head, splitPoint, blockStore);
#_final
        LinkedList<StoredBlock> newBlocks = getPartialChain(newChainHead, splitPoint, blockStore);

        ;; Disconnect each transaction in the previous main chain that is no longer in the new main chain.
        StoredBlock storedNewHead = splitPoint;
        if (shouldVerifyTransactions())
        (§
            for (StoredBlock oldBlock : oldBlocks)
            (§
                try
                (§
                    disconnectTransactions(oldBlock);
                )
                catch (PrunedException e)
                (§
                    ;; We threw away the data we need to re-org this deep!  We need to go back to a peer with full
                    ;; block contents and ask them for the relevant data then rebuild the indexs.  Or we could just
                    ;; give up and ask the human operator to help get us unstuck (e.g. rescan from the genesis block).
                    ;; TODO: retry adding this block when we get a block with hash e.getHash()
                    throw e;
                )
            )

            StoredBlock cursor;
            ;; Walk in ascending chronological order.
            for (Iterator<StoredBlock> it = newBlocks.descendingIterator(); it.hasNext(); )
            (§
                cursor = it.next();
                Block cursorBlock = cursor.getHeader();
                if (expensiveChecks && cursorBlock.getTimeSeconds() <= getMedianTimestampOfRecentBlocks(cursor.getPrev(blockStore), blockStore))
                    throw new VerificationException("Block's timestamp is too early during reorg");
                TransactionOutputChanges txOutChanges;
                if (cursor != newChainHead || block == nil)
                    txOutChanges = connectTransactions(cursor);
                else
                    txOutChanges = connectTransactions(newChainHead.getHeight(), block);
                storedNewHead = addToBlockStore(storedNewHead, cursorBlock.cloneAsHeader(), txOutChanges);
            )
        )
        else
        (§
            ;; (Finally) write block to block store.
            storedNewHead = addToBlockStore(storedPrev, newChainHead.getHeader());
        )

        ;; Now inform the listeners.  This is necessary so the set of currently active transactions (that we can spend)
        ;; can be updated to take into account the re-organize.  We might also have received new coins we didn't have
        ;; before and our previous spends might have been undone.
        for (final ListenerRegistration<ReorganizeListener> registration : reorganizeListeners)
        (§
            if (registration.executor == Threading.SAME_THREAD)
            (§
                ;; Short circuit the executor so we can propagate any exceptions.
                ;; TODO: Do we really need to do this or should it be irrelevant?
                registration.listener.reorganize(splitPoint, oldBlocks, newBlocks);
            )
            else
            (§
                registration.executor.execute(new Runnable()
                (§
#_override
#_public
                    void run()
                    (§
                        try
                        (§
                            registration.listener.reorganize(splitPoint, oldBlocks, newBlocks);
                        )
                        catch (VerificationException e)
                        (§
                            log.error("Block chain listener threw exception during reorg", e);
                        )
                    )
                ));
            )
        )

        ;; Update the pointer to the best known block.
        setChainHead(storedNewHead);
    )

    ;;;
     ; Returns the set of contiguous blocks between 'higher' and 'lower'.  Higher is included, lower is not.
     ;;
#_private
#_static
    LinkedList<StoredBlock> getPartialChain(StoredBlock higher, StoredBlock lower, BlockStore store)
        throws BlockStoreException
    (§
        Preconditions.checkArgument(lower.getHeight() < higher.getHeight(), "higher and lower are reversed");
        LinkedList<StoredBlock> results = new LinkedList<>();
        StoredBlock cursor = higher;
        while (true)
        (§
            results.add(cursor);
            cursor = Preconditions.checkNotNull(cursor.getPrev(store), "Ran off the end of the chain");
            if (cursor.equals(lower))
                break;
        )
        return results;
    )

    ;;;
     ; Locates the point in the chain at which newStoredBlock and chainHead diverge.  Returns null if no split point was
     ; found (i.e. they are not part of the same chain).  Returns newChainHead or chainHead if they don't actually diverge
     ; but are part of the same chain.
     ;;
#_private
#_static
    StoredBlock findSplit(StoredBlock newChainHead, StoredBlock oldChainHead, BlockStore store)
        throws BlockStoreException
    (§
        StoredBlock currentChainCursor = oldChainHead;
        StoredBlock newChainCursor = newChainHead;
        ;; Loop until we find the block both chains have in common.  Example:
        ;;
        ;;    A -> B -> C -> D
        ;;         \--> E -> F -> G
        ;;
        ;; findSplit will return block B.  oldChainHead = D and newChainHead = G.
        while (!currentChainCursor.equals(newChainCursor))
        (§
            if (newChainCursor.getHeight() < currentChainCursor.getHeight())
            (§
                currentChainCursor = currentChainCursor.getPrev(store);
                Preconditions.checkNotNull(currentChainCursor, "Attempt to follow an orphan chain");
            )
            else
            (§
                newChainCursor = newChainCursor.getPrev(store);
                Preconditions.checkNotNull(newChainCursor, "Attempt to follow an orphan chain");
            )
        )
        return currentChainCursor;
    )

    ;;;
     ; @return the height of the best known chain, convenience for <tt>getChainHead().getHeight()</tt>
     ;;
#_public
#_final
    int getBestChainHeight()
    (§
        return getChainHead().getHeight();
    )

#_public
    enum NewBlockType
    (§
        BEST_CHAIN,
        SIDE_CHAIN
    )

#_private
#_static
    void sendTransactionsToListener(StoredBlock block, NewBlockType blockType, TransactionReceivedInBlockListener listener, int relativityOffset, List<Transaction> transactions, boolean clone, Set<Sha256Hash> falsePositives)
        throws VerificationException
    (§
        for (Transaction tx : transactions)
        (§
            try
            (§
                falsePositives.remove(tx.getHash());
                if (clone)
                    tx = tx.params.getDefaultSerializer().makeTransaction(tx.bitcoinSerialize());
                listener.receiveFromBlock(tx, block, blockType, relativityOffset++);
            )
            catch (ScriptException e)
            (§
                ;; We don't want scripts we don't understand to break the block chain so just note that this tx was
                ;; not scanned here and continue.
                log.warn("Failed to parse a script: " + e.toString());
            )
            catch (ProtocolException e)
            (§
                ;; Failed to duplicate tx, should never happen.
                throw new RuntimeException(e);
            )
        )
    )

#_protected
    void setChainHead(StoredBlock chainHead)
        throws BlockStoreException
    (§
        doSetChainHead(chainHead);
#_synchronized
        (chainHeadLock)
        (§
            this.chainHead = chainHead;
        )
    )

    ;;;
     ; For each block in orphanBlocks, see if we can now fit it on top of the chain and if so, do so.
     ;;
#_private
    void tryConnectingOrphans()
        throws VerificationException, BlockStoreException, PrunedException
    (§
        Preconditions.checkState(lock.isHeldByCurrentThread());

        ;; For each block in our orphan list, try and fit it onto the head of the chain.  If we succeed remove it
        ;; from the list and keep going.  If we changed the head of the list at the end of the round try again until
        ;; we can't fit anything else on the top.
        ;;
        ;; This algorithm is kind of crappy, we should do a topo-sort then just connect them in order, but for small
        ;; numbers of orphan blocks it does OK.

        int blocksConnectedThisRound;
        do
        (§
            blocksConnectedThisRound = 0;
            Iterator<OrphanBlock> iter = orphanBlocks.values().iterator();
            while (iter.hasNext())
            (§
                OrphanBlock orphanBlock = iter.next();
                ;; Look up the blocks previous.
                StoredBlock prev = getStoredBlockInCurrentScope(orphanBlock.block.getPrevBlockHash());
                if (prev == nil)
                (§
                    ;; This is still an unconnected/orphan block.
                    log.debug("Orphan block {} is not connectable right now", orphanBlock.block.getHash());
                    continue;
                )
                ;; Otherwise we can connect it now.
                ;; False here ensures we don't recurse infinitely downwards when connecting huge chains.
                log.info("Connected orphan {}", orphanBlock.block.getHash());
                add(orphanBlock.block, false, orphanBlock.filteredTxHashes, orphanBlock.filteredTxn);
                iter.remove();
                blocksConnectedThisRound++;
            )
            if (0 < blocksConnectedThisRound)
                log.info("Connected {} orphan blocks.", blocksConnectedThisRound);
        )
        while (0 < blocksConnectedThisRound);
    )

    ;;;
     ; Returns the block at the head of the current best chain.  This is the block which represents the greatest
     ; amount of cumulative work done.
     ;;
#_public
    StoredBlock getChainHead()
    (§
#_synchronized
        (chainHeadLock)
        (§
            return chainHead;
        )
    )

    ;;;
     ; An orphan block is one that does not connect to the chain anywhere (i.e. we can't find its parent, therefore
     ; it's an orphan).  Typically this occurs when we are downloading the chain and didn't reach the head yet, and/or
     ; if a block is solved whilst we are downloading.  It's possible that we see a small amount of orphan blocks which
     ; chain together, this method tries walking backwards through the known orphan blocks to find the bottom-most.
     ;
     ; @return from or one of from's parents, or null if "from" does not identify an orphan block
     ;;
#_nilable
#_public
    Block getOrphanRoot(Sha256Hash from)
    (§
        lock.lock();
        try
        (§
            OrphanBlock cursor = orphanBlocks.get(from);
            if (cursor == nil)
                return nil;
            OrphanBlock tmp;
            while ((tmp = orphanBlocks.get(cursor.block.getPrevBlockHash())) != nil)
            (§
                cursor = tmp;
            )
            return cursor.block;
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;; Returns true if the given block is currently in the orphan blocks list. ;;
#_public
    boolean isOrphan(Sha256Hash block)
    (§
        lock.lock();
        try
        (§
            return orphanBlocks.containsKey(block);
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Returns an estimate of when the given block will be reached, assuming a perfect 10 minute average for each
     ; block.  This is useful for turning transaction lock times into human readable times.  Note that a height in
     ; the past will still be estimated, even though the time of solving is actually known (we won't scan backwards
     ; through the chain to obtain the right answer).
     ;;
#_public
    Date estimateBlockTime(int height)
    (§
#_synchronized
        (chainHeadLock)
        (§
            long offset = height - chainHead.getHeight();
            long headTime = chainHead.getHeader().getTimeSeconds();
            long estimated = (headTime * 1000) + (1000L * 60L * 10L * offset);
            return new Date(estimated);
        )
    )

    ;;;
     ; Returns a future that completes when the block chain has reached the given height.  Yields the
     ; {@link StoredBlock} of the block that reaches that height first.  The future completes on a peer thread.
     ;;
#_public
    ListenableFuture<StoredBlock> getHeightFuture(final int height)
    (§
#_final
        SettableFuture<StoredBlock> result = SettableFuture.create();
        addNewBestBlockListener(Threading.SAME_THREAD, new NewBestBlockListener()
        (§
#_override
#_public
            void notifyNewBestBlock(StoredBlock block)
                throws VerificationException
            (§
                if (height <= block.getHeight())
                (§
                    removeNewBestBlockListener(this);
                    result.set(block);
                )
            )
        ));
        return result;
    )

    ;;;
     ; The false positive rate is the average over all blockchain transactions of:
     ;
     ; - 1.0 if the transaction was false-positive (was irrelevant to all listeners)
     ; - 0.0 if the transaction was relevant or filtered out
     ;;
#_public
    double getFalsePositiveRate()
    (§
        return falsePositiveRate;
    )

    ;;
     ; We completed handling of a filtered block.  Update false-positive estimate based
     ; on the total number of transactions in the original block.
     ;
     ; count includes filtered transactions, transactions that were passed in and were relevant
     ; and transactions that were false positives (i.e. includes all transactions in the block).
     ;;
#_protected
    void trackFilteredTransactions(int count)
    (§
        ;; Track non-false-positives in batch.  Each non-false-positive counts as 0.0 towards the estimate.
        ;;
        ;; This is slightly off because we are applying false positive tracking before non-FP tracking,
        ;; which counts FP as if they came at the beginning of the block.  Assuming uniform FP
        ;; spread in a block, this will somewhat underestimate the FP rate (5% for 1000 tx block).
        double alphaDecay = Math.pow(1 - FP_ESTIMATOR_ALPHA, count);

        ;; new_rate = alpha_decay * new_rate
        falsePositiveRate = alphaDecay * falsePositiveRate;

        double betaDecay = Math.pow(1 - FP_ESTIMATOR_BETA, count);

        ;; trend = beta * (new_rate - old_rate) + beta_decay * trend
        falsePositiveTrend = FP_ESTIMATOR_BETA * count * (falsePositiveRate - previousFalsePositiveRate) + betaDecay * falsePositiveTrend;

        ;; new_rate += alpha_decay * trend
        falsePositiveRate += alphaDecay * falsePositiveTrend;

        ;; stash new_rate in old_rate
        previousFalsePositiveRate = falsePositiveRate;
    )

    ;;;Irrelevant transactions were received.  Update false-positive estimate. ;;
    void trackFalsePositives(int count)
    (§
        ;; Track false positives in batch by adding alpha to the false positive estimate once per count.
        ;; Each false positive counts as 1.0 towards the estimate.
        falsePositiveRate += FP_ESTIMATOR_ALPHA * count;
        if (0 < count)
            log.debug("{} false positives, current rate = {} trend = {}", count, falsePositiveRate, falsePositiveTrend);
    )

    ;;; Resets estimates of false positives.  Used when the filter is sent to the peer. ;;
#_public
    void resetFalsePositiveEstimate()
    (§
        falsePositiveRate = 0;
        falsePositiveTrend = 0;
        previousFalsePositiveRate = 0;
    )

#_protected
    VersionTally getVersionTally()
    (§
        return versionTally;
    )
)

(ns org.bitcoinj.core #_"Address"
    (:import [java.io IOException ObjectInputStream ObjectOutputStream])
    (:import [com.google.common.base Preconditions])
  #_(:require [org.bitcoinj.params Networks]
             [org.bitcoinj.script Script]))

;;;
 ; <p>A Bitcoin address looks like 1MsScoe2fTJoq4ZPdQgqyhgWeoNamYPevy and is derived from an elliptic curve public key
 ; plus a set of network parameters.  Not to be confused with a {@link PeerAddress} or {@link AddressMessage}
 ; which are about network (TCP) addresses.</p>
 ;
 ; <p>A standard address is built by taking the RIPE-MD160 hash of the public key bytes, with a version prefix and a
 ; checksum suffix, then encoding it textually as base58.  The version prefix is used to both denote the network for
 ; which the address is valid (see {@link NetworkParameters}, and also to indicate how the bytes inside the address
 ; should be interpreted.  Whilst almost all addresses today are hashes of public keys, another (currently unsupported
 ; type) can contain a hash of a script instead.</p>
 ;;
#_public
class Address extends VersionedChecksummedBytes
(§
    ;;;
     ; An address is a RIPEMD160 hash of a public key, therefore is always 160 bits or 20 bytes.
     ;;
#_public
#_static
#_final
    int LENGTH = 20;

#_private
    transient NetworkParameters params;

    ;;;
     ; Construct an address from parameters, the address version, and the hash160 form.  Example:
     ;
     ; <pre>new Address(MainNetParams.get(), NetworkParameters.getAddressHeader(), Hex.decode("4a22c3c4cbb31e4d03b15550636762bda0baf85a"));</pre>
     ;;
#_public
    Address(NetworkParameters params, int version, byte[] hash160)
        throws WrongNetworkException
    (§
        super(version, hash160);

        Preconditions.checkNotNull(params);
        Preconditions.checkArgument(hash160.length == 20, "Addresses are 160-bit hashes, so you must provide 20 bytes");
        if (!isAcceptableVersion(params, version))
            throw new WrongNetworkException(version, params.getAcceptableAddressCodes());
        this.params = params;
    )

    ;;; Returns an Address that represents the given P2SH script hash. ;;
#_public
#_static
    Address fromP2SHHash(NetworkParameters params, byte[] hash160)
    (§
        try
        (§
            return new Address(params, params.getP2SHHeader(), hash160);
        )
        catch (WrongNetworkException e)
        (§
            throw new RuntimeException(e); ;; Cannot happen.
        )
    )

    ;;; Returns an Address that represents the script hash extracted from the given scriptPubKey. ;;
#_public
#_static
    Address fromP2SHScript(NetworkParameters params, Script scriptPubKey)
    (§
        Preconditions.checkArgument(scriptPubKey.isPayToScriptHash(), "Not a P2SH script");
        return fromP2SHHash(params, scriptPubKey.getPubKeyHash());
    )

    ;;;
     ; Construct an address from its Base58 representation.
     ; @param params
     ;            The expected NetworkParameters or null if you don't want validation.
     ; @param base58
     ;            The textual form of the address, such as "17kzeh4N8g49GFvdDzSf8PjaPfyoD1MndL".
     ; @throws AddressFormatException
     ;             if the given base58 doesn't parse or the checksum is invalid
     ; @throws WrongNetworkException
     ;             if the given address is valid but for a different chain (e.g. testnet vs. mainnet)
     ;;
#_public
#_static
    Address fromBase58(#_nilable NetworkParameters params, String base58)
        throws AddressFormatException
    (§
        return new Address(params, base58);
    )

    ;;;
     ; Construct an address from parameters and the hash160 form.  Example:
     ;
     ; <pre>new Address(MainNetParams.get(), Hex.decode("4a22c3c4cbb31e4d03b15550636762bda0baf85a"));</pre>
     ;;
#_public
    Address(NetworkParameters params, byte[] hash160)
    (§
        super(params.getAddressHeader(), hash160);

        Preconditions.checkArgument(hash160.length == 20, "Addresses are 160-bit hashes, so you must provide 20 bytes");
        this.params = params;
    )

    ;;; @deprecated Use {@link #fromBase58(NetworkParameters, String)} ;;
#_deprecated
#_public
    Address(#_nilable NetworkParameters params, String address)
        throws AddressFormatException
    (§
        super(address);

        if (params != nil)
        (§
            if (!isAcceptableVersion(params, version))
                throw new WrongNetworkException(version, params.getAcceptableAddressCodes());
            this.params = params;
        )
        else
        (§
            NetworkParameters paramsFound = nil;
            for (NetworkParameters p : Networks.get())
            (§
                if (isAcceptableVersion(p, version))
                (§
                    paramsFound = p;
                    break;
                )
            )
            if (paramsFound == nil)
                throw new AddressFormatException("No network found for " + address);

            this.params = paramsFound;
        )
    )

    ;;; The (big endian) 20 byte hash that is the core of a Bitcoin address. ;;
#_public
    byte[] getHash160()
    (§
        return bytes;
    )

    ;;;
     ; Returns true if this address is a Pay-To-Script-Hash (P2SH) address.
     ; See also https://github.com/bitcoin/bips/blob/master/bip-0013.mediawiki: Address Format for pay-to-script-hash
     ;;
#_public
    boolean isP2SHAddress()
    (§
#_final
        NetworkParameters parameters = getParameters();
        return (parameters != nil && this.version == parameters.p2shHeader);
    )

    ;;;
     ; Examines the version byte of the address and attempts to find a matching NetworkParameters.  If you aren't sure
     ; which network the address is intended for (e.g. it was provided by a user), you can use this to decide if it is
     ; compatible with the current wallet.  You should be able to handle a null response from this method.  Note that
     ; the parameters returned is not necessarily the same as the one the Address was created with.
     ;
     ; @return a NetworkParameters representing the network the address is intended for
     ;;
#_public
    NetworkParameters getParameters()
    (§
        return params;
    )

    ;;;
     ; Given an address, examines the version byte and attempts to find a matching NetworkParameters.  If you aren't sure
     ; which network the address is intended for (e.g. it was provided by a user), you can use this to decide if it is
     ; compatible with the current wallet.
     ; @return a NetworkParameters of the address
     ; @throws AddressFormatException if the string wasn't of a known version
     ;;
#_public
#_static
    NetworkParameters getParametersFromAddress(String address)
        throws AddressFormatException
    (§
        try
        (§
            return Address.fromBase58(nil, address).getParameters();
        )
        catch (WrongNetworkException e)
        (§
            throw new RuntimeException(e); ;; Cannot happen.
        )
    )

    ;;;
     ; Check if a given address version is valid given the NetworkParameters.
     ;;
#_private
#_static
    boolean isAcceptableVersion(NetworkParameters params, int version)
    (§
        for (int v : params.getAcceptableAddressCodes())
        (§
            if (version == v)
                return true;
        )
        return false;
    )

    ;;;
     ; This implementation narrows the return type to <code>Address</code>.
     ;;
#_override
#_public
    Address clone()
        throws CloneNotSupportedException
    (§
        return (Address)super.clone();
    )

    ;; Java serialization

#_private
    void writeObject(ObjectOutputStream out)
        throws IOException
    (§
        out.defaultWriteObject();
        out.writeUTF(params.id);
    )

#_private
    void readObject(ObjectInputStream in)
        throws IOException, ClassNotFoundException
    (§
        in.defaultReadObject();
        params = NetworkParameters.fromID(in.readUTF());
    )
)

(ns org.bitcoinj.core #_"AddressFormatException"
)

#_public
class AddressFormatException extends IllegalArgumentException
(§
#_public
    AddressFormatException()
    (§
        super();
    )

#_public
    AddressFormatException(String message)
    (§
        super(message);
    )
)

(ns org.bitcoinj.core #_"AddressMessage"
    (:import [java.io IOException OutputStream]
             [java.util ArrayList Collections List]))

;;;
 ; <p>Represents an "addr" message on the P2P network, which contains broadcast IP addresses of other peers.  This is
 ; one of the ways peers can find each other without using the DNS or IRC discovery mechanisms.  However storing and
 ; using addr messages is not presently implemented.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
class AddressMessage extends Message
(§
#_private
#_static
#_final
    long MAX_ADDRESSES = 1024;

#_private
    List<PeerAddress> addresses;

    ;;;
     ; Contruct a new 'addr' message.
     ; @param params NetworkParameters object.
     ; @param offset The location of the first payload byte within the array.
     ; @param parseRetain Whether to retain the backing byte array for quick reserialization.
     ; If true and the backing byte array is invalidated due to modification of a field, then
     ; the cached bytes may be repopulated and retained if the message is serialized again in the future.
     ; @param length The length of message if known.  Usually this is provided when deserializing of the wire
     ; as the length will be provided as part of the header.  Set to Message.UNKNOWN_LENGTH, if not known.
     ; @throws ProtocolException
     ;;
    AddressMessage(NetworkParameters params, byte[] payload, int offset, MessageSerializer setSerializer, int length)
        throws ProtocolException
    (§
        super(params, payload, offset, setSerializer, length);
    )

    ;;;
     ; Contruct a new 'addr' message.
     ; @param params NetworkParameters object.
     ; @param serializer The serializer to use for this block.
     ; @param length The length of message if known.  Usually this is provided when deserializing of the wire
     ; as the length will be provided as part of the header.  Set to Message.UNKNOWN_LENGTH, if not known.
     ; @throws ProtocolException
     ;;
    AddressMessage(NetworkParameters params, byte[] payload, MessageSerializer serializer, int length)
        throws ProtocolException
    (§
        super(params, payload, 0, serializer, length);
    )

    AddressMessage(NetworkParameters params, byte[] payload, int offset)
        throws ProtocolException
    (§
        super(params, payload, offset, params.getDefaultSerializer(), UNKNOWN_LENGTH);
    )

    AddressMessage(NetworkParameters params, byte[] payload)
        throws ProtocolException
    (§
        super(params, payload, 0, params.getDefaultSerializer(), UNKNOWN_LENGTH);
    )

#_override
#_protected
    void parse()
        throws ProtocolException
    (§
        long numAddresses = readVarInt();
        ;; Guard against ultra large messages that will crash us.
        if (MAX_ADDRESSES < numAddresses)
            throw new ProtocolException("Address message too large.");
        addresses = new ArrayList<>((int)numAddresses);
        for (int i = 0; i < numAddresses; i++)
        (§
            PeerAddress addr = new PeerAddress(params, payload, cursor, protocolVersion, this, serializer);
            addresses.add(addr);
            cursor += addr.getMessageSize();
        )
        length = new VarInt(addresses.size()).getSizeInBytes();
        ;; The 4 byte difference is the uint32 timestamp that was introduced in version 31402.
        length += addresses.size() * (31402 < protocolVersion ? PeerAddress.MESSAGE_SIZE : PeerAddress.MESSAGE_SIZE - 4);
    )

#_override
#_protected
    void bitcoinSerializeToStream(OutputStream stream)
        throws IOException
    (§
        if (addresses != nil)
        (§
            stream.write(new VarInt(addresses.size()).encode());
            for (PeerAddress addr : addresses)
                addr.bitcoinSerialize(stream);
        )
    )

    ;;;
     ; @return An unmodifiableList view of the backing List of addresses.  Addresses contained within the list may be safely modified.
     ;;
#_public
    List<PeerAddress> getAddresses()
    (§
        return Collections.unmodifiableList(addresses);
    )

#_public
    void addAddress(PeerAddress address)
    (§
        unCache();
        address.setParent(this);
        addresses.add(address);
        if (length == UNKNOWN_LENGTH)
            getMessageSize();
        else
            length += address.getMessageSize();
    )

#_public
    void removeAddress(int index)
    (§
        unCache();
        PeerAddress address = addresses.remove(index);
        address.setParent(nil);
        if (length == UNKNOWN_LENGTH)
            getMessageSize();
        else
            length -= address.getMessageSize();
    )

#_override
#_public
    String toString()
    (§
        return "addr: " + Utils.SPACE_JOINER.join(addresses);
    )
)

(ns org.bitcoinj.core #_"AlertMessage"
    (:import [java.util Date HashSet Set]))

;;;
 ; Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 ; The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 ; an available upgrade or a serious network problem.  Alerts have an expiration time, data that specifies what
 ; set of software versions it matches and the ability to cancel them by broadcasting another type of alert.
 ;
 ; The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 ; log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 ; For example, you could treat it as an upgrade notification specific to your app.  Satoshi designed alerts to ensure
 ; that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 ; be purely peer-to-peer.  You don't have to use this of course, and indeed it often makes more sense not to.
 ;
 ; <p>Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
class AlertMessage extends Message
(§
#_private
    byte[] content;
#_private
    byte[] signature;

    ;; See the getters for documentation of what each field means.
#_private
    long version = 1;
#_private
    Date relayUntil;
#_private
    Date expiration;
#_private
    long id;
#_private
    long cancel;
#_private
    long minVer, maxVer;
#_private
    long priority;
#_private
    String comment, statusBar, reserved;

    ;; Chosen arbitrarily to avoid memory blowups.
#_private
#_static
#_final
    long MAX_SET_SIZE = 100;

#_public
    AlertMessage(NetworkParameters params, byte[] payloadBytes)
        throws ProtocolException
    (§
        super(params, payloadBytes, 0);
    )

#_override
#_public
    String toString()
    (§
        return "ALERT: " + getStatusBar();
    )

#_override
#_protected
    void parse()
        throws ProtocolException
    (§
        ;; Alerts are formatted in two levels.  The top level contains two byte arrays: a signature, and a serialized
        ;; data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        ;; Now we need to parse out the contents of the embedded structure.  Rewind back to the start of the message.
        cursor = startPos;
        readVarInt(); ;; Skip the length field on the content array.
        ;; We're inside the embedded structure.
        version = readUint32();
        ;; Read the timestamps.  Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        ;; Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || MAX_SET_SIZE < cancelSetSize)
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        ;; Using a hashset here is very inefficient given that this will normally be only one item.  But Java doesn't
        ;; make it easy to do better.  What we really want is just an array-backed set.
        Set<Long> cancelSet = new HashSet<>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++)
            cancelSet.add(readUint32());
        minVer = readUint32();
        maxVer = readUint32();
        ;; Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || MAX_SET_SIZE < subverSetSize)
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        Set<String> matchingSubVers = new HashSet<>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++)
            matchingSubVers.add(readStr());
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();

        length = cursor - offset;
    )

    ;;;
     ; Returns true if the digital signature attached to the message verifies.  Don't do anything with the alert if it
     ; doesn't verify, because that would allow arbitrary attackers to spam your users.
     ;;
#_public
    boolean isSignatureValid()
    (§
        return ECKey.verify(Sha256Hash.hashTwice(content), signature, params.getAlertSigningKey());
    )

    ;;;
     ; The time at which the alert should stop being broadcast across the network.  Note that you can still receive
     ; the alert after this time from other nodes if the alert still applies to them or to you.
     ;;
#_public
    Date getRelayUntil()
    (§
        return relayUntil;
    )

#_public
    void setRelayUntil(Date relayUntil)
    (§
        this.relayUntil = relayUntil;
    )

    ;;;
     ; The time at which the alert ceases to be relevant.  It should not be presented to the user or app administrator
     ; after this time.
     ;;
#_public
    Date getExpiration()
    (§
        return expiration;
    )

#_public
    void setExpiration(Date expiration)
    (§
        this.expiration = expiration;
    )

    ;;;
     ; The numeric identifier of this alert.  Each alert should have a unique ID, but the signer can choose any number.
     ; If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     ; @return uint32
     ;;
#_public
    long getId()
    (§
        return id;
    )

#_public
    void setId(long id)
    (§
        this.id = id;
    )

    ;;;
     ; A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     ; @return uint32
     ;;
#_public
    long getCancel()
    (§
        return cancel;
    )

#_public
    void setCancel(long cancel)
    (§
        this.cancel = cancel;
    )

    ;;;
     ; The inclusive lower bound on software versions that are considered for the purposes of this alert.  Bitcoin Core
     ; compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     ; alerts could use any version numbers.
     ; @return uint32
     ;;
#_public
    long getMinVer()
    (§
        return minVer;
    )

#_public
    void setMinVer(long minVer)
    (§
        this.minVer = minVer;
    )

    ;;;
     ; The inclusive upper bound on software versions considered for the purposes of this alert.  Bitcoin Core
     ; compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     ; alerts could use any version numbers.
     ;;
#_public
    long getMaxVer()
    (§
        return maxVer;
    )

#_public
    void setMaxVer(long maxVer)
    (§
        this.maxVer = maxVer;
    )

    ;;;
     ; Provides an integer ordering amongst simultaneously active alerts.
     ; @return uint32
     ;;
#_public
    long getPriority()
    (§
        return priority;
    )

#_public
    void setPriority(long priority)
    (§
        this.priority = priority;
    )

    ;;;
     ; This field is unused.  It is presumably intended for the author of the alert to provide a justification for it
     ; visible to protocol developers but not users.
     ;;
#_public
    String getComment()
    (§
        return comment;
    )

#_public
    void setComment(String comment)
    (§
        this.comment = comment;
    )

    ;;;
     ; A string that is intended to display in the status bar of Bitcoin Core's GUI client.  It contains the user-visible
     ; message.  English only.
     ;;
#_public
    String getStatusBar()
    (§
        return statusBar;
    )

#_public
    void setStatusBar(String statusBar)
    (§
        this.statusBar = statusBar;
    )

    ;;;
     ; This field is never used.
     ;;
#_public
    String getReserved()
    (§
        return reserved;
    )

#_public
    void setReserved(String reserved)
    (§
        this.reserved = reserved;
    )

#_public
    long getVersion()
    (§
        return version;
    )
)

(ns org.bitcoinj.core #_"Base58"
    (:import [java.math BigInteger]
             [java.util Arrays]))

;;;
 ; Base58 is a way to encode Bitcoin addresses (or arbitrary data) as alphanumeric strings.
 ;
 ; Note that this is not the same base58 as used by Flickr, which you may find referenced around the Internet.
 ;
 ; You may want to consider working with {@link VersionedChecksummedBytes} instead, which
 ; adds support for testing the prefix and suffix bytes commonly found in addresses.
 ;
 ; Satoshi explains: why base-58 instead of standard base-64 encoding?
 ; <ul>
 ; <li>Don't want 0OIl characters that look the same in some fonts and
 ;     could be used to create visually identical looking account numbers.</li>
 ; <li>A string with non-alphanumeric characters is not as easily accepted as an account number.</li>
 ; <li>E-mail usually won't line-break if there's no punctuation to break at.</li>
 ; <li>Doubleclicking selects the whole number as one word if it's all alphanumeric.</li>
 ; </ul>
 ;
 ; However, note that the encoding/decoding runs in O(n&sup2;) time, so it is not useful for large data.
 ;
 ; The basic idea of the encoding is to treat the data bytes as a large number represented using
 ; base-256 digits, convert the number to be represented using base-58 digits, preserve the exact
 ; number of leading zeros (which are otherwise lost during the mathematical operations on the
 ; numbers), and finally represent the resulting base-58 digits as alphanumeric ASCII characters.
 ;;
#_public
class Base58
(§
#_public
#_static
#_final
    char[] ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz".toCharArray();
#_private
#_static
#_final
    char ENCODED_ZERO = ALPHABET[0];
#_private
#_static
#_final
    int[] INDEXES = new int[128];
    #_static
    (§
        Arrays.fill(INDEXES, -1);
        for (int i = 0; i < ALPHABET.length; i++)
        (§
            INDEXES[ALPHABET[i]] = i;
        )
    )

    ;;;
     ; Encodes the given bytes as a base58 string (no checksum is appended).
     ;
     ; @param input the bytes to encode
     ; @return the base58-encoded string
     ;;
#_public
#_static
    String encode(byte[] input)
    (§
        if (input.length == 0)
            return "";

        ;; Count leading zeros.
        int zeros = 0;
        while (zeros < input.length && input[zeros] == 0)
            ++zeros;

        ;; Convert base-256 digits to base-58 digits (plus conversion to ASCII characters).
        input = Arrays.copyOf(input, input.length); ;; since we modify it in-place
        char[] encoded = new char[input.length * 2]; ;; upper bound
        int outputStart = encoded.length;
        for (int inputStart = zeros; inputStart < input.length; )
        (§
            encoded[--outputStart] = ALPHABET[divmod(input, inputStart, 256, 58)];
            if (input[inputStart] == 0)
                ++inputStart; ;; optimization - skip leading zeros
        )
        ;; Preserve exactly as many leading encoded zeros in output as there were leading zeros in input.
        while (outputStart < encoded.length && encoded[outputStart] == ENCODED_ZERO)
            ++outputStart;
        while (0 <= --zeros)
            encoded[--outputStart] = ENCODED_ZERO;

        ;; Return encoded string (including encoded leading zeros).
        return new String(encoded, outputStart, encoded.length - outputStart);
    )

    ;;;
     ; Decodes the given base58 string into the original data bytes.
     ;
     ; @param input the base58-encoded string to decode
     ; @return the decoded data bytes
     ; @throws AddressFormatException if the given string is not a valid base58 string
     ;;
#_public
#_static
    byte[] decode(String input)
        throws AddressFormatException
    (§
        if (input.length() == 0)
            return new byte[0];

        ;; Convert the base58-encoded ASCII chars to a base58 byte sequence (base58 digits).
        byte[] input58 = new byte[input.length()];
        for (int i = 0; i < input.length(); ++i)
        (§
            char c = input.charAt(i);
            int digit = (c < 128) ? INDEXES[c] : -1;
            if (digit < 0)
                throw new AddressFormatException("Illegal character " + c + " at position " + i);
            input58[i] = (byte)digit;
        )
        ;; Count leading zeros.
        int zeros = 0;
        while (zeros < input58.length && input58[zeros] == 0)
            ++zeros;
        ;; Convert base-58 digits to base-256 digits.
        byte[] decoded = new byte[input.length()];
        int outputStart = decoded.length;
        for (int inputStart = zeros; inputStart < input58.length; )
        (§
            decoded[--outputStart] = divmod(input58, inputStart, 58, 256);
            if (input58[inputStart] == 0)
                ++inputStart; ;; optimization - skip leading zeros
        )
        ;; Ignore extra leading zeroes that were added during the calculation.
        while (outputStart < decoded.length && decoded[outputStart] == 0)
            ++outputStart;

        ;; Return decoded data (including original number of leading zeros).
        return Arrays.copyOfRange(decoded, outputStart - zeros, decoded.length);
    )

#_public
#_static
    BigInteger decodeToBigInteger(String input)
        throws AddressFormatException
    (§
        return new BigInteger(1, decode(input));
    )

    ;;;
     ; Decodes the given base58 string into the original data bytes, using the checksum in the
     ; last 4 bytes of the decoded data to verify that the rest are correct.  The checksum is
     ; removed from the returned data.
     ;
     ; @param input the base58-encoded string to decode (which should include the checksum)
     ; @throws AddressFormatException if the input is not base 58 or the checksum does not validate
     ;;
#_public
#_static
    byte[] decodeChecked(String input)
        throws AddressFormatException
    (§
        byte[] decoded = decode(input);
        if (decoded.length < 4)
            throw new AddressFormatException("Input too short");
        byte[] data = Arrays.copyOfRange(decoded, 0, decoded.length - 4);
        byte[] checksum = Arrays.copyOfRange(decoded, decoded.length - 4, decoded.length);
        byte[] actualChecksum = Arrays.copyOfRange(Sha256Hash.hashTwice(data), 0, 4);
        if (!Arrays.equals(checksum, actualChecksum))
            throw new AddressFormatException("Checksum does not validate");
        return data;
    )

    ;;;
     ; Divides a number, represented as an array of bytes each containing a single digit
     ; in the specified base, by the given divisor.  The given number is modified in-place
     ; to contain the quotient, and the return value is the remainder.
     ;
     ; @param number the number to divide
     ; @param firstDigit the index within the array of the first non-zero digit
     ;        (this is used for optimization by skipping the leading zeros)
     ; @param base the base in which the number's digits are represented (up to 256)
     ; @param divisor the number to divide by (up to 256)
     ; @return the remainder of the division operation
     ;;
#_private
#_static
    byte divmod(byte[] number, int firstDigit, int base, int divisor)
    (§
        ;; This is just long division which accounts for the base of the input digits.
        int remainder = 0;
        for (int i = firstDigit; i < number.length; i++)
        (§
            int digit = (int)number[i] & 0xFF;
            int temp = remainder * base + digit;
            number[i] = (byte)(temp / divisor);
            remainder = temp % divisor;
        )
        return (byte)remainder;
    )
)

(ns org.bitcoinj.core #_"BitcoinSerializer"
    (:import [java.io IOException OutputStream]
             [java.nio BufferUnderflowException ByteBuffer]
             [java.util HashMap Map])
    (:import [org.slf4j Logger LoggerFactory])
    (:import #_static #_[org.bitcoinj.core.Utils *]))

;;;
 ; <p>Methods to serialize and de-serialize messages to the Bitcoin network format as defined in
 ; <a href="https://en.bitcoin.it/wiki/Protocol_specification">the protocol specification</a>.</p>
 ;
 ; <p>To be able to serialize and deserialize new Message subclasses the following criteria needs to be met.</p>
 ;
 ; <ul>
 ; <li>The proper Class instance needs to be mapped to its message name in the names variable below.</li>
 ; <li>There needs to be a constructor matching: NetworkParameters params, byte[] payload.</li>
 ; <li>Message.bitcoinSerializeToStream() needs to be properly subclassed.</li>
 ; </ul>
 ;;
#_public
class BitcoinSerializer extends MessageSerializer
(§
#_private
#_static
#_final
    Logger log = LoggerFactory.getLogger(BitcoinSerializer.class);
#_private
#_static
#_final
    int COMMAND_LEN = 12;

#_private
#_static
#_final
    Map<Class<? extends Message>, String> names = new HashMap<>();
    #_static
    (§
        names.put(VersionMessage.class, "version");
        names.put(InventoryMessage.class, "inv");
        names.put(Block.class, "block");
        names.put(GetDataMessage.class, "getdata");
        names.put(Transaction.class, "tx");
        names.put(AddressMessage.class, "addr");
        names.put(Ping.class, "ping");
        names.put(Pong.class, "pong");
        names.put(VersionAck.class, "verack");
        names.put(GetBlocksMessage.class, "getblocks");
        names.put(GetHeadersMessage.class, "getheaders");
        names.put(GetAddrMessage.class, "getaddr");
        names.put(HeadersMessage.class, "headers");
        names.put(BloomFilter.class, "filterload");
        names.put(FilteredBlock.class, "merkleblock");
        names.put(NotFoundMessage.class, "notfound");
        names.put(MemoryPoolMessage.class, "mempool");
        names.put(RejectMessage.class, "reject");
    )

#_private
#_final
    NetworkParameters params;
#_private
#_final
    boolean parseRetain;

    ;;;
     ; Constructs a BitcoinSerializer with the given behavior.
     ;
     ; @param params           networkParams used to create Messages instances and termining packetMagic
     ; @param parseRetain      retain the backing byte array of a message for fast reserialization
     ;;
#_public
    BitcoinSerializer(NetworkParameters params, boolean parseRetain)
    (§
        this.params = params;
        this.parseRetain = parseRetain;
    )

    ;;;
     ; Writes message to to the output stream.
     ;;
#_override
#_public
    void serialize(String name, byte[] message, OutputStream out)
        throws IOException
    (§
        byte[] header = new byte[4 + COMMAND_LEN + 4 + 4]; ;; checksum
        uint32ToByteArrayBE(params.getPacketMagic(), header, 0);

        ;; The header array is initialized to zero by Java so we don't have to worry
        ;; about NULL terminating the string here.
        for (int i = 0; i < name.length() && i < COMMAND_LEN; i++)
            header[4 + i] = (byte)(name.codePointAt(i) & 0xFF);

        Utils.uint32ToByteArrayLE(message.length, header, 4 + COMMAND_LEN);

        byte[] hash = Sha256Hash.hashTwice(message);
        System.arraycopy(hash, 0, header, 4 + COMMAND_LEN + 4, 4);
        out.write(header);
        out.write(message);

        if (log.isDebugEnabled())
            log.debug("Sending {} message: {}", name, HEX.encode(header) + HEX.encode(message));
    )

    ;;;
     ; Writes message to to the output stream.
     ;;
#_override
#_public
    void serialize(Message message, OutputStream out)
        throws IOException
    (§
        String name = names.get(message.getClass());
        if (name == nil)
            throw new Error("BitcoinSerializer doesn't currently know how to serialize " + message.getClass());

        serialize(name, message.bitcoinSerialize(), out);
    )

    ;;;
     ; Reads a message from the given ByteBuffer and returns it.
     ;;
#_override
#_public
    Message deserialize(ByteBuffer in)
        throws ProtocolException, IOException
    (§
        ;; A Bitcoin protocol message has the following format:
        ;;
        ;;   - 4 byte magic number: 0xfabfb5da for the testnet or
        ;;                          0xf9beb4d9 for production
        ;;   - 12 byte command in ASCII
        ;;   - 4 byte payload size
        ;;   - 4 byte checksum
        ;;   - Payload data
        ;;
        ;; The checksum is the first 4 bytes of a SHA256 hash of the message payload. It isn't
        ;; present for all messages, notably, the first one on a connection.
        ;;
        ;; Bitcoin Core ignores garbage before the magic header bytes. We have to do the same because
        ;; sometimes it sends us stuff that isn't part of any message.
        seekPastMagicBytes(in);
        BitcoinPacketHeader header = new BitcoinPacketHeader(in);
        ;; Now try to read the whole message.
        return deserializePayload(header, in);
    )

    ;;;
     ; Deserializes only the header in case packet meta data is needed before decoding
     ; the payload.  This method assumes you have already called seekPastMagicBytes().
     ;;
#_override
#_public
    BitcoinPacketHeader deserializeHeader(ByteBuffer in)
        throws ProtocolException, IOException
    (§
        return new BitcoinPacketHeader(in);
    )

    ;;;
     ; Deserialize payload only.  You must provide a header, typically obtained by calling
     ; {@link BitcoinSerializer#deserializeHeader}.
     ;;
#_override
#_public
    Message deserializePayload(BitcoinPacketHeader header, ByteBuffer in)
        throws ProtocolException, BufferUnderflowException
    (§
        byte[] payloadBytes = new byte[header.size];
        in.get(payloadBytes, 0, header.size);

        ;; Verify the checksum.
        byte[] hash;
        hash = Sha256Hash.hashTwice(payloadBytes);
        if (header.checksum[0] != hash[0] || header.checksum[1] != hash[1] || header.checksum[2] != hash[2] || header.checksum[3] != hash[3])
            throw new ProtocolException("Checksum failed to verify, actual " + HEX.encode(hash) + " vs " + HEX.encode(header.checksum));

        if (log.isDebugEnabled())
            log.debug("Received {} byte '{}' message: {}", header.size, header.command, HEX.encode(payloadBytes));

        try
        (§
            return makeMessage(header.command, header.size, payloadBytes, hash, header.checksum);
        )
        catch (Exception e)
        (§
            throw new ProtocolException("Error deserializing message " + HEX.encode(payloadBytes) + "\n", e);
        )
    )

#_private
    Message makeMessage(String command, int length, byte[] payloadBytes, byte[] hash, byte[] checksum)
        throws ProtocolException
    (§
        ;; We use an if ladder rather than reflection because reflection is very slow on Android.
        if (command.equals("version"))
            return new VersionMessage(params, payloadBytes);
        if (command.equals("inv"))
            return makeInventoryMessage(payloadBytes, length);
        if (command.equals("block"))
            return makeBlock(payloadBytes, length);
        if (command.equals("merkleblock"))
            return makeFilteredBlock(payloadBytes);
        if (command.equals("getdata"))
            return new GetDataMessage(params, payloadBytes, this, length);
        if (command.equals("getblocks"))
            return new GetBlocksMessage(params, payloadBytes);
        if (command.equals("getheaders"))
            return new GetHeadersMessage(params, payloadBytes);
        if (command.equals("tx"))
            return makeTransaction(payloadBytes, 0, length, hash);
        if (command.equals("addr"))
            return makeAddressMessage(payloadBytes, length);
        if (command.equals("ping"))
            return new Ping(params, payloadBytes);
        if (command.equals("pong"))
            return new Pong(params, payloadBytes);
        if (command.equals("verack"))
            return new VersionAck(params, payloadBytes);
        if (command.equals("headers"))
            return new HeadersMessage(params, payloadBytes);
        if (command.equals("alert"))
            return makeAlertMessage(payloadBytes);
        if (command.equals("filterload"))
            return makeBloomFilter(payloadBytes);
        if (command.equals("notfound"))
            return new NotFoundMessage(params, payloadBytes);
        if (command.equals("mempool"))
            return new MemoryPoolMessage();
        if (command.equals("reject"))
            return new RejectMessage(params, payloadBytes);
        log.warn("No support for deserializing message with name {}", command);
        return new UnknownMessage(params, command, payloadBytes);
    )

    ;;;
     ; Get the network parameters for this serializer.
     ;;
#_public
    NetworkParameters getParameters()
    (§
        return params;
    )

    ;;;
     ; Make an address message from the payload.  Extension point for alternative serialization format support.
     ;;
#_override
#_public
    AddressMessage makeAddressMessage(byte[] payloadBytes, int length)
        throws ProtocolException
    (§
        return new AddressMessage(params, payloadBytes, this, length);
    )

    ;;;
     ; Make an alert message from the payload.  Extension point for alternative serialization format support.
     ;;
#_override
#_public
    Message makeAlertMessage(byte[] payloadBytes)
        throws ProtocolException
    (§
        return new AlertMessage(params, payloadBytes);
    )

    ;;;
     ; Make a block from the payload.  Extension point for alternative serialization format support.
     ;;
#_override
#_public
    Block makeBlock(final byte[] payloadBytes, final int offset, final int length)
        throws ProtocolException
    (§
        return new Block(params, payloadBytes, offset, this, length);
    )

    ;;;
     ; Make an filter message from the payload.  Extension point for alternative serialization format support.
     ;;
#_override
#_public
    Message makeBloomFilter(byte[] payloadBytes)
        throws ProtocolException
    (§
        return new BloomFilter(params, payloadBytes);
    )

    ;;;
     ; Make a filtered block from the payload.  Extension point for alternative serialization format support.
     ;;
#_override
#_public
    FilteredBlock makeFilteredBlock(byte[] payloadBytes)
        throws ProtocolException
    (§
        return new FilteredBlock(params, payloadBytes);
    )

    ;;;
     ; Make an inventory message from the payload.  Extension point for alternative serialization format support.
     ;;
#_override
#_public
    InventoryMessage makeInventoryMessage(byte[] payloadBytes, int length)
        throws ProtocolException
    (§
        return new InventoryMessage(params, payloadBytes, this, length);
    )

    ;;;
     ; Make a transaction from the payload.  Extension point for alternative serialization format support.
     ;;
#_override
#_public
    Transaction makeTransaction(byte[] payloadBytes, int offset, int length, byte[] hash)
        throws ProtocolException
    (§
        Transaction tx = new Transaction(params, payloadBytes, offset, nil, this, length);
        if (hash != nil)
            tx.setHash(Sha256Hash.wrapReversed(hash));
        return tx;
    )

#_override
#_public
    void seekPastMagicBytes(ByteBuffer in)
        throws BufferUnderflowException
    (§
        int magicCursor = 3; ;; Which byte of the magic we're looking for currently.
        while (true)
        (§
            byte b = in.get();
            ;; We're looking for a run of bytes that is the same as the packet magic but we want to ignore partial
            ;; magics that aren't complete.  So we keep track of where we're up to with magicCursor.
            byte expectedByte = (byte)(0xff & params.getPacketMagic() >>> (magicCursor << 3));
            if (b == expectedByte)
            (§
                magicCursor--;
                if (magicCursor < 0)
                (§
                    ;; We found the magic sequence.
                    return;
                )
                else
                (§
                    ;; We still have further to go to find the next message.
                )
            )
            else
            (§
                magicCursor = 3;
            )
        )
    )

    ;;;
     ; Whether the serializer will produce cached mode Messages.
     ;;
#_override
#_public
    boolean isParseRetainMode()
    (§
        return parseRetain;
    )

#_public
#_static
    class BitcoinPacketHeader
    (§
        ;;; The largest number of bytes that a header can represent. ;;
#_public
#_static
#_final
        int HEADER_LENGTH = COMMAND_LEN + 4 + 4;

#_public
#_final
        byte[] header;
#_public
#_final
        String command;
#_public
#_final
        int size;
#_public
#_final
        byte[] checksum;

#_public
        BitcoinPacketHeader(ByteBuffer in)
            throws ProtocolException, BufferUnderflowException
        (§
            header = new byte[HEADER_LENGTH];
            in.get(header, 0, header.length);

            int cursor = 0;

            ;; The command is a NULL terminated string, unless the command fills all twelve bytes
            ;; in which case the termination is implicit.
            while (header[cursor] != 0 && cursor < COMMAND_LEN)
                cursor++;
            byte[] commandBytes = new byte[cursor];
            System.arraycopy(header, 0, commandBytes, 0, cursor);
            command = Utils.toString(commandBytes, "US-ASCII");
            cursor = COMMAND_LEN;

            size = (int)readUint32(header, cursor);
            cursor += 4;

            if (Message.MAX_SIZE < size || size < 0)
                throw new ProtocolException("Message size too large: " + size);

            ;; Old clients don't send the checksum.
            checksum = new byte[4];
            ;; Note that the size read above includes the checksum bytes.
            System.arraycopy(header, cursor, checksum, 0, 4);
            cursor += 4;
        )
    )
)

(ns org.bitcoinj.core #_"Block"
    (:import #_[java.io *]
             #_[java.math *]
             #_[java.util *])
    (:import #_[com.google.common.annotations *]
             #_[com.google.common.base *]
             #_[com.google.common.collect *]
             #_[org.slf4j *])
  #_(:require #_[org.bitcoinj.script *]
             #_static #_[org.bitcoinj.core.Coin *]
             #_static #_[org.bitcoinj.core.Sha256Hash *]))

;;;
 ; <p>A block is a group of transactions, and is one of the fundamental data structures of the Bitcoin system.
 ; It records a set of {@link Transaction}s together with some data that links it into a place in the global block chain,
 ; and proves that a difficult calculation was done over its contents.
 ; See <a href="http://www.bitcoin.org/bitcoin.pdf">the Bitcoin technical paper</a> for more detail on blocks.
 ;
 ; <p>To get a block, you can either build one from the raw bytes you can get from another implementation, or request one
 ; specifically using {@link Peer#getBlock(Sha256Hash)}, or grab one from a downloaded {@link BlockChain}.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
class Block extends Message
(§
    ;;;
     ; Flags used to control which elements of block validation are done on received blocks.
     ;;
#_public
    enum VerifyFlag
    (§
        ;;; Check that block height is in coinbase transaction (BIP 34). ;;
        HEIGHT_IN_COINBASE
    )

#_private
#_static
#_final
    Logger log = LoggerFactory.getLogger(Block.class);

    ;;; How many bytes are required to represent a block header WITHOUT the trailing 00 length byte. ;;
#_public
#_static
#_final
    int HEADER_SIZE = 80;

#_static
#_final
    long ALLOWED_TIME_DRIFT = 2 * 60 * 60; ;; Same value as Bitcoin Core.

    ;;;
     ; A constant shared by the entire network: how large in bytes a block is allowed to be.  One day we may have to
     ; upgrade everyone to change this, so Bitcoin can continue to grow.  For now it exists as an anti-DoS measure to
     ; avoid somebody creating a titanically huge but valid block and forcing everyone to download/store it forever.
     ;;
#_public
#_static
#_final
    int MAX_BLOCK_SIZE = 1 * 1000 * 1000;
    ;;;
     ; A "sigop" is a signature verification operation.  Because they're expensive, we also impose a separate limit on
     ; the number in a block to prevent somebody mining a huge block that has way more sigops than normal, so is very
     ; expensive/slow to verify.
     ;;
#_public
#_static
#_final
    int MAX_BLOCK_SIGOPS = MAX_BLOCK_SIZE / 50;

    ;;; A value for difficultyTarget (nBits) that allows half of all possible hash solutions.  Used in unit testing. ;;
#_public
#_static
#_final
    long EASIEST_DIFFICULTY_TARGET = 0x207fffffL;

    ;;; Value to use if the block height is unknown. ;;
#_public
#_static
#_final
    int BLOCK_HEIGHT_UNKNOWN = -1;
    ;;; Height of the first block. ;;
#_public
#_static
#_final
    int BLOCK_HEIGHT_GENESIS = 0;

#_public
#_static
#_final
    long BLOCK_VERSION_GENESIS = 1;
    ;;; Block version introduced in BIP 34: Height in coinbase. ;;
#_public
#_static
#_final
    long BLOCK_VERSION_BIP34 = 2;
    ;;; Block version introduced in BIP 66: Strict DER signatures. ;;
#_public
#_static
#_final
    long BLOCK_VERSION_BIP66 = 3;
    ;;; Block version introduced in BIP 65: OP_CHECKLOCKTIMEVERIFY ;;
#_public
#_static
#_final
    long BLOCK_VERSION_BIP65 = 4;

    ;; Fields defined as part of the protocol format.
#_private
    long version;
#_private
    Sha256Hash prevBlockHash;
#_private
    Sha256Hash merkleRoot;
#_private
    long time;
#_private
    long difficultyTarget; ;; "nBits"
#_private
    long nonce;

    ;; TODO: Get rid of all the direct accesses to this field.  It's a long-since unnecessary holdover from the Dalvik days.
    ;;; If null, it means this object holds only the headers. ;;
#_nilable
    List<Transaction> transactions;

    ;;; Stores the hash of the block.  If null, getHash() will recalculate it. ;;
#_private
    Sha256Hash hash;

#_protected
    boolean headerBytesValid;
#_protected
    boolean transactionBytesValid;

    ;; Blocks can be encoded in a way that will use more bytes than is optimal (due to VarInts having multiple encodings).
    ;; MAX_BLOCK_SIZE must be compared to the optimal encoding, not the actual encoding, so when parsing, we keep track
    ;; of the size of the ideal encoding in addition to the actual message size (which Message needs).
#_protected
    int optimalEncodingMessageSize;

    ;;; Special case constructor, used for the genesis node, cloneAsHeader and unit tests. ;;
    Block(NetworkParameters params, long setVersion)
    (§
        super(params);

        ;; Set up a few basic things.  We are not complete after this though.
        version = setVersion;
        difficultyTarget = 0x1d07fff8L;
        time = System.currentTimeMillis() / 1000;
        prevBlockHash = Sha256Hash.ZERO_HASH;

        length = HEADER_SIZE;
    )

    ;;;
     ; Constructs a block object from the Bitcoin wire format.
     ; @deprecated Use {@link BitcoinSerializer#makeBlock(byte[])} instead.
     ;;
#_deprecated
#_public
    Block(NetworkParameters params, byte[] payloadBytes)
        throws ProtocolException
    (§
        super(params, payloadBytes, 0, params.getDefaultSerializer(), payloadBytes.length);
    )

    ;;;
     ; Construct a block object from the Bitcoin wire format.
     ; @param params NetworkParameters object.
     ; @param payloadBytes The payload to extract the block from.
     ; @param serializer The serializer to use for this message.
     ; @param length The length of message if known.  Usually this is provided when deserializing of the wire
     ; as the length will be provided as part of the header.  Set to Message.UNKNOWN_LENGTH, if not known.
     ; @throws ProtocolException
     ;;
#_public
    Block(NetworkParameters params, byte[] payloadBytes, MessageSerializer serializer, int length)
        throws ProtocolException
    (§
        super(params, payloadBytes, 0, serializer, length);
    )

    ;;;
     ; Construct a block object from the Bitcoin wire format.
     ; @param params NetworkParameters object.
     ; @param payloadBytes The payload to extract the block from.
     ; @param offset The location of the first payload byte within the array.
     ; @param serializer The serializer to use for this message.
     ; @param length The length of message if known.  Usually this is provided when deserializing of the wire
     ; as the length will be provided as part of the header.  Set to Message.UNKNOWN_LENGTH, if not known.
     ; @throws ProtocolException
     ;;
#_public
    Block(NetworkParameters params, byte[] payloadBytes, int offset, MessageSerializer serializer, int length)
        throws ProtocolException
    (§
        super(params, payloadBytes, offset, serializer, length);
    )

    ;;;
     ; Construct a block object from the Bitcoin wire format.  Used in the case of a block
     ; contained within another message (i.e. for AuxPoW header).
     ;
     ; @param params NetworkParameters object.
     ; @param payloadBytes Bitcoin protocol formatted byte array containing message content.
     ; @param offset The location of the first payload byte within the array.
     ; @param parent The message element which contains this block, maybe null for no parent.
     ; @param serializer The serializer to use for this block.
     ; @param length The length of message if known.  Usually this is provided when deserializing of the wire
     ; as the length will be provided as part of the header.  Set to Message.UNKNOWN_LENGTH, if not known.
     ; @throws ProtocolException
     ;;
#_public
    Block(NetworkParameters params, byte[] payloadBytes, int offset, #_nilable Message parent, MessageSerializer serializer, int length)
        throws ProtocolException
    (§
        ;; TODO: Keep the parent.
        super(params, payloadBytes, offset, serializer, length);
    )

    ;;;
     ; Construct a block initialized with all the given fields.
     ; @param params Which network the block is for.
     ; @param version This should usually be set to 1 or 2, depending on if the height is in the coinbase input.
     ; @param prevBlockHash Reference to previous block in the chain or {@link Sha256Hash#ZERO_HASH} if genesis.
     ; @param merkleRoot The root of the merkle tree formed by the transactions.
     ; @param time UNIX time when the block was mined.
     ; @param difficultyTarget Number which this block hashes lower than.
     ; @param nonce Arbitrary number to make the block hash lower than the target.
     ; @param transactions List of transactions including the coinbase.
     ;;
#_public
    Block(NetworkParameters params, long version, Sha256Hash prevBlockHash, Sha256Hash merkleRoot, long time, long difficultyTarget, long nonce, List<Transaction> transactions)
    (§
        super(params);

        this.version = version;
        this.prevBlockHash = prevBlockHash;
        this.merkleRoot = merkleRoot;
        this.time = time;
        this.difficultyTarget = difficultyTarget;
        this.nonce = nonce;
        this.transactions = new LinkedList<>();
        this.transactions.addAll(transactions);
    )

    ;;;
     ; <p>A utility method that calculates how much new Bitcoin would be created by the block at the given height.
     ; The inflation of Bitcoin is predictable and drops roughly every 4 years (210,000 blocks).  At the dawn of
     ; the system it was 50 coins per block, in late 2012 it went to 25 coins per block, and so on.  The size of
     ; a coinbase transaction is inflation plus fees.</p>
     ;
     ; The half-life is controlled by {@link org.bitcoinj.core.NetworkParameters#getSubsidyDecreaseBlockCount()}.
     ;;
#_public
    Coin getBlockInflation(int height)
    (§
        return FIFTY_COINS.shiftRight(height / params.getSubsidyDecreaseBlockCount());
    )

    ;;;
     ; Parse transactions from the block.
     ;
     ; @param transactionsOffset Offset of the transactions within the block.
     ; Useful for non-Bitcoin chains where the block header may not be a fixed size.
     ;;
#_protected
    void parseTransactions(final int transactionsOffset)
        throws ProtocolException
    (§
        cursor = transactionsOffset;
        optimalEncodingMessageSize = HEADER_SIZE;
        if (payload.length == cursor)
        (§
            ;; This message is just a header, it has no transactions.
            transactionBytesValid = false;
            return;
        )

        int numTransactions = (int)readVarInt();
        optimalEncodingMessageSize += VarInt.sizeOf(numTransactions);
        transactions = new ArrayList<>(numTransactions);
        for (int i = 0; i < numTransactions; i++)
        (§
            Transaction tx = new Transaction(params, payload, cursor, this, serializer, UNKNOWN_LENGTH);
            ;; Label the transaction as coming from the P2P network, so code that cares where we first saw it knows.
            tx.getConfidence().setSource(TransactionConfidence.Source.NETWORK);
            transactions.add(tx);
            cursor += tx.getMessageSize();
            optimalEncodingMessageSize += tx.getOptimalEncodingMessageSize();
        )
        transactionBytesValid = serializer.isParseRetainMode();
    )

#_override
#_protected
    void parse()
        throws ProtocolException
    (§
        ;; header
        cursor = offset;
        version = readUint32();
        prevBlockHash = readHash();
        merkleRoot = readHash();
        time = readUint32();
        difficultyTarget = readUint32();
        nonce = readUint32();
        hash = Sha256Hash.wrapReversed(Sha256Hash.hashTwice(payload, offset, cursor - offset));
        headerBytesValid = serializer.isParseRetainMode();

        ;; transactions
        parseTransactions(offset + HEADER_SIZE);
        length = cursor - offset;
    )

#_public
    int getOptimalEncodingMessageSize()
    (§
        if (optimalEncodingMessageSize != 0)
            return optimalEncodingMessageSize;
        optimalEncodingMessageSize = bitcoinSerialize().length;
        return optimalEncodingMessageSize;
    )

    ;; default for testing
    void writeHeader(OutputStream stream)
        throws IOException
    (§
        ;; try for cached write first
        if (headerBytesValid && payload != nil && offset + HEADER_SIZE <= payload.length)
        (§
            stream.write(payload, offset, HEADER_SIZE);
            return;
        )

        ;; fall back to manual write
        Utils.uint32ToByteStreamLE(version, stream);
        stream.write(prevBlockHash.getReversedBytes());
        stream.write(getMerkleRoot().getReversedBytes());
        Utils.uint32ToByteStreamLE(time, stream);
        Utils.uint32ToByteStreamLE(difficultyTarget, stream);
        Utils.uint32ToByteStreamLE(nonce, stream);
    )

#_private
    void writeTransactions(OutputStream stream)
        throws IOException
    (§
        ;; check for no transaction conditions first
        if (transactions == nil)
            return;

        ;; confirmed we must have transactions either cached or as objects
        if (transactionBytesValid && payload != nil && offset + length <= payload.length)
        (§
            stream.write(payload, offset + HEADER_SIZE, length - HEADER_SIZE);
            return;
        )

        if (transactions != nil)
        (§
            stream.write(new VarInt(transactions.size()).encode());
            for (Transaction tx : transactions)
                tx.bitcoinSerialize(stream);
        )
    )

    ;;;
     ; Special handling to check if we have a valid byte array for both header and transactions.
     ;
     ; @throws IOException
     ;;
#_override
#_public
    byte[] bitcoinSerialize()
    (§
        ;; we have completely cached byte array
        if (headerBytesValid && transactionBytesValid)
        (§
            Preconditions.checkNotNull(payload, "Bytes should never be nil if headerBytesValid && transactionBytesValid");
            if (length == payload.length)
                return payload;

            ;; byte array is offset, so copy out the correct range
            byte[] buf = new byte[length];
            System.arraycopy(payload, offset, buf, 0, length);
            return buf;
        )

        ;; At least one of the two cacheable components is invalid, so fall back to stream write since we can't be sure of the length.
        ByteArrayOutputStream stream = new UnsafeByteArrayOutputStream((length == UNKNOWN_LENGTH) ? HEADER_SIZE + guessTransactionsLength() : length);
        try
        (§
            writeHeader(stream);
            writeTransactions(stream);
        )
        catch (IOException e)
        (§
            ;; Cannot happen, we are serializing to a memory stream.
        )
        return stream.toByteArray();
    )

#_override
#_protected
    void bitcoinSerializeToStream(OutputStream stream)
        throws IOException
    (§
        writeHeader(stream);
        ;; We may only have enough data to write the header.
        writeTransactions(stream);
    )

    ;;;
     ; Provides a reasonable guess at the byte length of the transactions part of the block.
     ; The returned value will be accurate in 99% of cases and in those cases where not will probably slightly oversize.
     ;
     ; This is used to preallocate the underlying byte array for a ByteArrayOutputStream.  If the size is under the
     ; real value the only penalty is resizing of the underlying byte array.
     ;;
#_private
    int guessTransactionsLength()
    (§
        if (transactionBytesValid)
            return payload.length - HEADER_SIZE;
        if (transactions == nil)
            return 0;
        int len = VarInt.sizeOf(transactions.size());
        for (Transaction tx : transactions)
        (§
            ;; 255 is just a guess at an average tx length
            len += (tx.length == UNKNOWN_LENGTH) ? 255 : tx.length;
        )
        return len;
    )

#_override
#_protected
    void unCache()
    (§
        ;; Since we have alternate uncache methods to use internally, this will only ever be called by a child
        ;; transaction, so we only need to invalidate that part of the cache.
        unCacheTransactions();
    )

#_private
    void unCacheHeader()
    (§
        headerBytesValid = false;
        if (!transactionBytesValid)
            payload = nil;
        hash = nil;
    )

#_private
    void unCacheTransactions()
    (§
        transactionBytesValid = false;
        if (!headerBytesValid)
            payload = nil;
        ;; Current implementation has to uncache headers as well as any change to a tx will alter the merkle root.
        ;; In future, we can go more granular and cache merkle root separately so rest of the header does not need to be rewritten.
        unCacheHeader();
        ;; Clear merkleRoot last as it may end up being parsed during unCacheHeader().
        merkleRoot = nil;
    )

    ;;;
     ; Calculates the block hash by serializing the block and hashing the resulting bytes.
     ;;
#_private
    Sha256Hash calculateHash()
    (§
        try
        (§
            ByteArrayOutputStream bos = new UnsafeByteArrayOutputStream(HEADER_SIZE);
            writeHeader(bos);
            return Sha256Hash.wrapReversed(Sha256Hash.hashTwice(bos.toByteArray()));
        )
        catch (IOException e)
        (§
            throw new RuntimeException(e); ;; Cannot happen.
        )
    )

    ;;;
     ; Returns the hash of the block (which for a valid, solved block should be below the target) in the form seen on
     ; the block explorer.  If you call this on block 1 in the mainnet chain,
     ; you will get "00000000839a8e6886ab5951d76f411475428afc90947ee320161bbf18eb6048".
     ;;
#_public
    String getHashAsString()
    (§
        return getHash().toString();
    )

    ;;;
     ; Returns the hash of the block (which for a valid, solved block should be
     ; below the target).  Big endian.
     ;;
#_override
#_public
    Sha256Hash getHash()
    (§
        if (hash == nil)
            hash = calculateHash();
        return hash;
    )

    ;;;
     ; The number that is one greater than the largest representable SHA-256 hash.
     ;;
#_private
#_static
    BigInteger LARGEST_HASH = BigInteger.ONE.shiftLeft(256);

    ;;;
     ; Returns the work represented by this block.
     ;
     ; Work is defined as the number of tries needed to solve a block in the
     ; average case.  Consider a difficulty target that covers 5% of all possible
     ; hash values.  Then the work of the block will be 20.  As the target gets
     ; lower, the amount of work goes up.
     ;;
#_public
    BigInteger getWork()
        throws VerificationException
    (§
        BigInteger target = getDifficultyTargetAsInteger();
        return LARGEST_HASH.divide(target.add(BigInteger.ONE));
    )

    ;;; Returns a copy of the block, but without any transactions. ;;
#_public
    Block cloneAsHeader()
    (§
        Block block = new Block(params, BLOCK_VERSION_GENESIS);
        copyBitcoinHeaderTo(block);
        return block;
    )

    ;;; Copy the block without transactions into the provided empty block. ;;
#_protected
#_final
    void copyBitcoinHeaderTo(final Block block)
    (§
        block.nonce = nonce;
        block.prevBlockHash = prevBlockHash;
        block.merkleRoot = getMerkleRoot();
        block.version = version;
        block.time = time;
        block.difficultyTarget = difficultyTarget;
        block.transactions = nil;
        block.hash = getHash();
    )

    ;;;
     ; Returns a multi-line string containing a description of the contents of the block.
     ; Use for debugging purposes only.
     ;;
#_override
#_public
    String toString()
    (§
        StringBuilder sb = new StringBuilder();
        sb.append(" block: \n");
        sb.append("   hash: ").append(getHashAsString()).append('\n');
        sb.append("   version: ").append(version);
        String bips = Joiner.on(", ").skipNulls().join(isBIP34() ? "BIP34" : nil, isBIP66() ? "BIP66" : nil, isBIP65() ? "BIP65" : nil);
        if (!bips.isEmpty())
            sb.append(" (").append(bips).append(')');
        sb.append('\n');
        sb.append("   previous block: ").append(getPrevBlockHash()).append("\n");
        sb.append("   merkle root: ").append(getMerkleRoot()).append("\n");
        sb.append("   time: ").append(time).append(" (").append(Utils.dateTimeFormat(time * 1000)).append(")\n");
        sb.append("   difficulty target (nBits): ").append(difficultyTarget).append("\n");
        sb.append("   nonce: ").append(nonce).append("\n");
        if (transactions != nil && 0 < transactions.size())
        (§
            sb.append("   with ").append(transactions.size()).append(" transaction(s):\n");
            for (Transaction tx : transactions)
                sb.append(tx);
        )
        return sb.toString();
    )

    ;;;
     ; <p>Finds a value of nonce that makes the blocks hash lower than the difficulty target.  This is called mining,
     ; but solve() is far too slow to do real mining with.  It exists only for unit testing purposes.
     ;
     ; <p>This can loop forever if a solution cannot be found solely by incrementing nonce.  It doesn't change
     ; extraNonce.</p>
     ;;
#_public
    void solve()
    (§
        while (true)
        (§
            try
            (§
                ;; Is our proof of work valid yet?
                if (checkProofOfWork(false))
                    return;
                ;; No, so increment the nonce and try again.
                setNonce(getNonce() + 1);
            )
            catch (VerificationException e)
            (§
                throw new RuntimeException(e); ;; Cannot happen.
            )
        )
    )

    ;;;
     ; Returns the difficulty target as a 256 bit value that can be compared to a SHA-256 hash.  Inside a block the
     ; target is represented using a compact form.  If this form decodes to a value that is out of bounds, an exception
     ; is thrown.
     ;;
#_public
    BigInteger getDifficultyTargetAsInteger()
        throws VerificationException
    (§
        BigInteger target = Utils.decodeCompactBits(difficultyTarget);
        if (target.signum() <= 0 || 0 < target.compareTo(params.maxTarget))
            throw new VerificationException("Difficulty target is bad: " + target.toString());
        return target;
    )

    ;;; Returns true if the hash of the block is OK (lower than difficulty target). ;;
#_protected
    boolean checkProofOfWork(boolean throwException)
        throws VerificationException
    (§
        ;; This part is key - it is what proves the block was as difficult to make as it claims
        ;; to be.  Note however that in the context of this function, the block can claim to be
        ;; as difficult as it wants to be .... if somebody was able to take control of our network
        ;; connection and fork us onto a different chain, they could send us valid blocks with
        ;; ridiculously easy difficulty and this function would accept them.
        ;;
        ;; To prevent this attack from being possible, elsewhere we check that the difficultyTarget
        ;; field is of the right value.  This requires us to have the preceeding blocks.
        BigInteger target = getDifficultyTargetAsInteger();

        BigInteger h = getHash().toBigInteger();
        if (0 < h.compareTo(target))
        (§
            ;; Proof of work check failed!
            if (throwException)
                throw new VerificationException("Hash is higher than target: " + getHashAsString() + " vs " + target.toString(16));
            else
                return false;
        )
        return true;
    )

#_private
    void checkTimestamp()
        throws VerificationException
    (§
#_final
        long allowedTime = Utils.currentTimeSeconds() + ALLOWED_TIME_DRIFT;
        if (allowedTime < time)
            throw new VerificationException(String.format(Locale.US, "Block too far in future: %s (%d) vs allowed %s (%d)",
                    Utils.dateTimeFormat(time * 1000), time, Utils.dateTimeFormat(allowedTime * 1000), allowedTime));
    )

#_private
    void checkSigOps()
        throws VerificationException
    (§
        ;; Check there aren't too many signature verifications in the block.  This is an anti-DoS measure, see the
        ;; comments for MAX_BLOCK_SIGOPS.
        int sigOps = 0;
        for (Transaction tx : transactions)
            sigOps += tx.getSigOpCount();

        if (MAX_BLOCK_SIGOPS < sigOps)
            throw new VerificationException("Block had too many Signature Operations");
    )

#_private
    void checkMerkleRoot()
        throws VerificationException
    (§
        Sha256Hash calculatedRoot = calculateMerkleRoot();
        if (!calculatedRoot.equals(merkleRoot))
        (§
            log.error("Merkle tree did not verify");
            throw new VerificationException("Merkle hashes do not match: " + calculatedRoot + " vs " + merkleRoot);
        )
    )

#_private
    Sha256Hash calculateMerkleRoot()
    (§
        List<byte[]> tree = buildMerkleTree();
        return Sha256Hash.wrap(tree.get(tree.size() - 1));
    )

#_private
    List<byte[]> buildMerkleTree()
    (§
        ;; The Merkle root is based on a tree of hashes calculated from the transactions:
        ;;
        ;;     root
        ;;     /  \
        ;;   A      B
        ;;  / \    / \
        ;; t1 t2  t3 t4
        ;;
        ;; The tree is represented as a list: (t1 t2 t3 t4 A B root), where each entry is a hash.
        ;;
        ;; The hashing algorithm is double SHA-256.  The leaves are a hash of the serialized contents of the transaction.
        ;; The interior nodes are hashes of the concenation of the two child hashes.
        ;;
        ;; This structure allows the creation of proof that a transaction was included into a block without having to
        ;; provide the full block contents.  Instead, you can provide only a Merkle branch.  For example to prove tx2 was
        ;; in a block you can just provide tx2, the hash(tx1) and B.  Now the other party has everything they need to
        ;; derive the root, which can be checked against the block header.  These proofs aren't used right now but
        ;; will be helpful later when we want to download partial block contents.
        ;;
        ;; Note that if the number of transactions is not even, the last tx is repeated to make it so (see tx3 above).
        ;; A tree with 5 transactions would look like this:
        ;;
        ;;          root
        ;;        /      \
        ;;      1          5
        ;;    /   \       / \
        ;;   2     3     4   4
        ;;  / \   / \   / \
        ;; t1 t2 t3 t4 t5 t5
        ArrayList<byte[]> tree = new ArrayList<>();
        ;; Start by adding all the hashes of the transactions as leaves of the tree.
        for (Transaction t : transactions)
            tree.add(t.getHash().getBytes());

        ;; Offset in the list where the currently processed level starts.
        int levelOffset = 0;
        ;; Step through each level, stopping when we reach the root (levelSize == 1).
        for (int levelSize = transactions.size(); 1 < levelSize; levelSize = (levelSize + 1) / 2)
        (§
            ;; For each pair of nodes on that level:
            for (int left = 0; left < levelSize; left += 2)
            (§
                ;; The right hand node can be the same as the left hand, in the case where we don't have enough transactions.
                int right = Math.min(left + 1, levelSize - 1);
                byte[] leftBytes = Utils.reverseBytes(tree.get(levelOffset + left));
                byte[] rightBytes = Utils.reverseBytes(tree.get(levelOffset + right));
                tree.add(Utils.reverseBytes(hashTwice(leftBytes, 0, 32, rightBytes, 0, 32)));
            )
            ;; Move to the next level.
            levelOffset += levelSize;
        )
        return tree;
    )

    ;;;
     ; Verify the transactions on a block.
     ;
     ; @param height Block height, if known, or -1 otherwise.
     ;               If provided, used to validate the coinbase input script of v2 and above blocks.
     ; @throws VerificationException if there was an error verifying the block.
     ;;
#_private
    void checkTransactions(final int height, final EnumSet<VerifyFlag> flags)
        throws VerificationException
    (§
        ;; The first transaction in a block must always be a coinbase transaction.
        if (!transactions.get(0).isCoinBase())
            throw new VerificationException("First tx is not coinbase");

        if (flags.contains(Block.VerifyFlag.HEIGHT_IN_COINBASE) && BLOCK_HEIGHT_GENESIS <= height)
            transactions.get(0).checkCoinBaseHeight(height);

        ;; The rest must not be.
        for (int i = 1; i < transactions.size(); i++)
            if (transactions.get(i).isCoinBase())
                throw new VerificationException("TX " + i + " is coinbase when it should not be.");
    )

    ;;;
     ; Checks the block data to ensure it follows the rules laid out in the network parameters.  Specifically,
     ; throws an exception if the proof of work is invalid, or if the timestamp is too far from what it should be.
     ; This is <b>not</b> everything that is required for a block to be valid, only what is checkable independent
     ; of the chain and without a transaction index.
     ;
     ; @throws VerificationException
     ;;
#_public
    void verifyHeader()
        throws VerificationException
    (§
        ;; Prove that this block is OK.  It might seem that we can just ignore most of these checks given that the
        ;; network is also verifying the blocks, but we cannot as it'd open us to a variety of obscure attacks.
        ;;
        ;; Firstly we need to ensure this block does in fact represent real work done.  If the difficulty is high
        ;; enough, it's probably been done by the network.
        checkProofOfWork(true);
        checkTimestamp();
    )

    ;;;
     ; Checks the block contents.
     ;
     ; @param height Block height, if known, or -1 otherwise.
     ;               If valid, used to validate the coinbase input script of v2 and above blocks.
     ; @param flags Flags to indicate which tests should be applied (i.e. whether to test for height in the coinbase transaction).
     ; @throws VerificationException if there was an error verifying the block.
     ;;
#_public
    void verifyTransactions(final int height, final EnumSet<VerifyFlag> flags)
        throws VerificationException
    (§
        ;; Now we need to check that the body of the block actually matches the headers.  The network won't generate
        ;; an invalid block, but if we didn't validate this then an untrusted man-in-the-middle could obtain the next
        ;; valid block from the network and simply replace the transactions in it with their own fictional
        ;; transactions that reference spent or non-existant inputs.
        if (transactions.isEmpty())
            throw new VerificationException("Block had no transactions");
        if (MAX_BLOCK_SIZE < this.getOptimalEncodingMessageSize())
            throw new VerificationException("Block larger than MAX_BLOCK_SIZE");
        checkTransactions(height, flags);
        checkMerkleRoot();
        checkSigOps();
        for (Transaction transaction : transactions)
            transaction.verify();
    )

    ;;;
     ; Verifies both the header and that the transactions hash to the merkle root.
     ;
     ; @param height Block height, if known, or -1 otherwise.
     ; @param flags Flags to indicate which tests should be applied (i.e. whether to test for height in the coinbase transaction).
     ; @throws VerificationException if there was an error verifying the block.
     ;;
#_public
    void verify(final int height, final EnumSet<VerifyFlag> flags)
        throws VerificationException
    (§
        verifyHeader();
        verifyTransactions(height, flags);
    )

#_override
#_public
    boolean equals(Object o)
    (§
        if (this == o)
            return true;
        if (o == nil || getClass() != o.getClass())
            return false;
        return getHash().equals(((Block)o).getHash());
    )

#_override
#_public
    int hashCode()
    (§
        return getHash().hashCode();
    )

    ;;;
     ; Returns the merkle root in big endian form, calculating it from transactions if necessary.
     ;;
#_public
    Sha256Hash getMerkleRoot()
    (§
        if (merkleRoot == nil)
        (§
            ;; TODO: Check if this is really necessary.
            unCacheHeader();
            merkleRoot = calculateMerkleRoot();
        )
        return merkleRoot;
    )

    ;;; Exists only for unit testing. ;;
    void setMerkleRoot(Sha256Hash value)
    (§
        unCacheHeader();
        merkleRoot = value;
        hash = nil;
    )

    ;;; Adds a transaction to this block.  The nonce and merkle root are invalid after this. ;;
#_public
    void addTransaction(Transaction t)
    (§
        addTransaction(t, true);
    )

    ;;; Adds a transaction to this block, with or without checking the sanity of doing so. ;;
    void addTransaction(Transaction t, boolean runSanityChecks)
    (§
        unCacheTransactions();
        if (transactions == nil)
            transactions = new ArrayList<>();
        t.setParent(this);
        if (runSanityChecks && transactions.size() == 0 && !t.isCoinBase())
            throw new RuntimeException("Attempted to add a non-coinbase transaction as the first transaction: " + t);
        if (runSanityChecks && 0 < transactions.size() && t.isCoinBase())
            throw new RuntimeException("Attempted to add a coinbase transaction when there already is one: " + t);
        transactions.add(t);
        adjustLength(transactions.size(), t.length);
        ;; Force a recalculation next time the values are needed.
        merkleRoot = nil;
        hash = nil;
    )

    ;;;
     ; Returns the version of the block data structure as defined by the Bitcoin protocol.
     ;;
#_public
    long getVersion()
    (§
        return version;
    )

    ;;;
     ; Returns the hash of the previous block in the chain, as defined by the block header.
     ;;
#_public
    Sha256Hash getPrevBlockHash()
    (§
        return prevBlockHash;
    )

    void setPrevBlockHash(Sha256Hash prevBlockHash)
    (§
        unCacheHeader();
        this.prevBlockHash = prevBlockHash;
        this.hash = nil;
    )

    ;;;
     ; Returns the time at which the block was solved and broadcast, according to the clock of the solving node.
     ; This is measured in seconds since the UNIX epoch (midnight Jan 1st 1970).
     ;;
#_public
    long getTimeSeconds()
    (§
        return time;
    )

    ;;;
     ; Returns the time at which the block was solved and broadcast, according to the clock of the solving node.
     ;;
#_public
    Date getTime()
    (§
        return new Date(getTimeSeconds() * 1000);
    )

#_public
    void setTime(long time)
    (§
        unCacheHeader();
        this.time = time;
        this.hash = nil;
    )

    ;;;
     ; Returns the difficulty of the proof of work that this block should meet encoded <b>in compact form</b>.
     ; The {@link BlockChain} verifies that this is not too easy by looking at the length of the chain when the block is added.
     ; To find the actual value the hash should be compared against, use {@link org.bitcoinj.core.Block#getDifficultyTargetAsInteger()}.
     ; Note that this is <b>not</b> the same as the difficulty value reported by the Bitcoin "getdifficulty" RPC that you may see on various block explorers.
     ; That number is the result of applying a formula to the underlying difficulty to normalize the minimum to 1.
     ; Calculating the difficulty that way is currently unsupported.
     ;;
#_public
    long getDifficultyTarget()
    (§
        return difficultyTarget;
    )

    ;;; Sets the difficulty target in compact form. ;;
#_public
    void setDifficultyTarget(long compactForm)
    (§
        unCacheHeader();
        this.difficultyTarget = compactForm;
        this.hash = nil;
    )

    ;;;
     ; Returns the nonce, an arbitrary value that exists only to make the hash of the block header fall below the difficulty target.
     ;;
#_public
    long getNonce()
    (§
        return nonce;
    )

    ;;;
     ; Sets the nonce and clears any cached data.
     ;;
#_public
    void setNonce(long nonce)
    (§
        unCacheHeader();
        this.nonce = nonce;
        this.hash = nil;
    )

    ;;; Returns an immutable list of transactions held in this block, or null if this object represents just a header. ;;
#_nilable
#_public
    List<Transaction> getTransactions()
    (§
        return (transactions == nil) ? nil : ImmutableList.copyOf(transactions);
    )

    ;; Used to make transactions unique.
#_private
#_static
    int txCounter;

    ;;; Adds a coinbase transaction to the block.  This exists for unit tests.
     ;
     ; @param height Block height, if known, or -1 otherwise.
     ;;
#_testing
    void addCoinbaseTransaction(byte[] pubKeyTo, Coin value, final int height)
    (§
        unCacheTransactions();
        transactions = new ArrayList<>();
        Transaction coinbase = new Transaction(params);
#_final
        ScriptBuilder inputBuilder = new ScriptBuilder();

        if (Block.BLOCK_HEIGHT_GENESIS <= height)
            inputBuilder.number(height);
        inputBuilder.data(new byte[] { (byte)txCounter, (byte)(txCounter++ >> 8) });

        ;; A real coinbase transaction has some stuff in the scriptSig like the extraNonce and difficulty.
        ;; The transactions are distinguished by every TX output going to a different key.
        ;;
        ;; Here we will do things a bit differently so a new address isn't needed every time.
        ;; We'll put a simple counter in the scriptSig, so every transaction has a different hash.
        coinbase.addInput(new TransactionInput(params, coinbase, inputBuilder.build().getProgram()));
        coinbase.addOutput(new TransactionOutput(params, coinbase, value, ScriptBuilder.createOutputScript(ECKey.fromPublicOnly(pubKeyTo)).getProgram()));
        transactions.add(coinbase);
        coinbase.setParent(this);
        coinbase.length = coinbase.unsafeBitcoinSerialize().length;
        adjustLength(transactions.size(), coinbase.length);
    )

#_static
#_final
    byte[] EMPTY_BYTES = new byte[32];

    ;; It's pretty weak to have this around at runtime: fix later.
#_private
#_static
#_final
    byte[] pubkeyForTesting = new ECKey().getPubKey();

    ;;;
     ; Returns a solved block that builds on top of this one.  This exists for unit tests.
     ;;
#_testing
#_public
    Block createNextBlock(Address to, long version, long time, int blockHeight)
    (§
        return createNextBlock(to, version, nil, time, pubkeyForTesting, FIFTY_COINS, blockHeight);
    )

    ;;;
     ; Returns a solved block that builds on top of this one.  This exists for unit tests.
     ; In this variant you can specify a public key (pubkey) for use in generating coinbase blocks.
     ;
     ; @param height Block height, if known, or -1 otherwise.
     ;;
    Block createNextBlock(#_nilable final Address to, final long version, #_nilable TransactionOutPoint prevOut, final long time, final byte[] pubKey, final Coin coinbaseValue, final int height)
    (§
        Block b = new Block(params, version);
        b.setDifficultyTarget(difficultyTarget);
        b.addCoinbaseTransaction(pubKey, coinbaseValue, height);

        if (to != nil)
        (§
            ;; Add a transaction paying 50 coins to the "to" address.
            Transaction t = new Transaction(params);
            t.addOutput(new TransactionOutput(params, t, FIFTY_COINS, to));
            ;; The input does not really need to be a valid signature, as long as it has the right general form.
            TransactionInput input;
            if (prevOut == nil)
            (§
                input = new TransactionInput(params, t, Script.createInputScript(EMPTY_BYTES, EMPTY_BYTES));
                ;; Importantly, the outpoint hash cannot be zero as that's how we detect a coinbase transaction in isolation,
                ;; but it must be unique to avoid 'different' transactions looking the same.
                byte[] counter = new byte[32];
                counter[0] = (byte)txCounter;
                counter[1] = (byte)(txCounter++ >> 8);
                input.getOutpoint().setHash(Sha256Hash.wrap(counter));
            )
            else
            (§
                input = new TransactionInput(params, t, Script.createInputScript(EMPTY_BYTES, EMPTY_BYTES), prevOut);
            )
            t.addInput(input);
            b.addTransaction(t);
        )

        b.setPrevBlockHash(getHash());
        ;; Don't let timestamp go backwards.
        if (time <= getTimeSeconds())
            b.setTime(getTimeSeconds() + 1);
        else
            b.setTime(time);
        b.solve();
        try
        (§
            b.verifyHeader();
        )
        catch (VerificationException e)
        (§
            throw new RuntimeException(e); ;; Cannot happen.
        )
        if (b.getVersion() != version)
        (§
            throw new RuntimeException();
        )
        return b;
    )

#_testing
#_public
    Block createNextBlock(#_nilable Address to, TransactionOutPoint prevOut)
    (§
        return createNextBlock(to, BLOCK_VERSION_GENESIS, prevOut, getTimeSeconds() + 5, pubkeyForTesting, FIFTY_COINS, BLOCK_HEIGHT_UNKNOWN);
    )

#_testing
#_public
    Block createNextBlock(#_nilable Address to, Coin value)
    (§
        return createNextBlock(to, BLOCK_VERSION_GENESIS, nil, getTimeSeconds() + 5, pubkeyForTesting, value, BLOCK_HEIGHT_UNKNOWN);
    )

#_testing
#_public
    Block createNextBlock(#_nilable Address to)
    (§
        return createNextBlock(to, FIFTY_COINS);
    )

#_testing
#_public
    Block createNextBlockWithCoinbase(long version, byte[] pubKey, Coin coinbaseValue, final int height)
    (§
        return createNextBlock(nil, version, (TransactionOutPoint)nil, Utils.currentTimeSeconds(), pubKey, coinbaseValue, height);
    )

    ;;;
     ; Create a block sending 50BTC as a coinbase transaction to the public key specified.
     ; This method is intended for test use only.
     ;;
#_testing
    Block createNextBlockWithCoinbase(long version, byte[] pubKey, final int height)
    (§
        return createNextBlock(nil, version, (TransactionOutPoint)nil, Utils.currentTimeSeconds(), pubKey, FIFTY_COINS, height);
    )

#_testing
    boolean isHeaderBytesValid()
    (§
        return headerBytesValid;
    )

#_testing
    boolean isTransactionBytesValid()
    (§
        return transactionBytesValid;
    )

    ;;;
     ; Return whether this block contains any transactions.
     ;
     ; @return true if the block contains transactions, false otherwise (is purely a header).
     ;;
#_public
    boolean hasTransactions()
    (§
        return !this.transactions.isEmpty();
    )

    ;;;
     ; Returns whether this block conforms to
     ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0034.mediawiki">BIP34: Height in Coinbase</a>.
     ;;
#_public
    boolean isBIP34()
    (§
        return (BLOCK_VERSION_BIP34 <= version);
    )

    ;;;
     ; Returns whether this block conforms to
     ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki">BIP66: Strict DER signatures</a>.
     ;;
#_public
    boolean isBIP66()
    (§
        return (BLOCK_VERSION_BIP66 <= version);
    )

    ;;;
     ; Returns whether this block conforms to
     ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki">BIP65: OP_CHECKLOCKTIMEVERIFY</a>.
     ;;
#_public
    boolean isBIP65()
    (§
        return (BLOCK_VERSION_BIP65 <= version);
    )
)

(ns org.bitcoinj.core #_"BlockChain"
    (:import [java.util ArrayList List])
    (:import [com.google.common.base Preconditions])
  #_(:require [org.bitcoinj.store BlockStore BlockStoreException]
             [org.bitcoinj.wallet Wallet]))

;; TODO: Rename this class to SPVBlockChain at some point.

;;;
 ; A BlockChain implements the <i>simplified payment verification</i> mode of the Bitcoin protocol.  It is the right
 ; choice to use for programs that have limited resources as it won't verify transactions signatures or attempt to store
 ; all of the block chain.  Really, this class should be called SPVBlockChain but for backwards compatibility it is not.
 ;;
#_public
class BlockChain extends AbstractBlockChain
(§
    ;;; Keeps a map of block hashes to StoredBlocks. ;;
#_protected
#_final
    BlockStore blockStore;

    ;;;
     ; <p>Constructs a BlockChain connected to the given wallet and store.  To obtain a {@link Wallet} you can construct
     ; one from scratch, or you can deserialize a saved wallet from disk using {@link Wallet#loadFromFile(java.io.File)}.</p>
     ;
     ; <p>For the store, you should use {@link org.bitcoinj.store.SPVBlockStore} or you could also try a
     ; {@link org.bitcoinj.store.MemoryBlockStore} if you want to hold all headers in RAM and don't care about
     ; disk serialization (this is rare).</p>
     ;;
#_public
    BlockChain(Context context, Wallet wallet, BlockStore blockStore)
        throws BlockStoreException
    (§
        this(context, new ArrayList<Wallet>(), blockStore);
        addWallet(wallet);
    )

    ;;; See {@link #BlockChain(Context, Wallet, BlockStore)}}. ;;
#_public
    BlockChain(NetworkParameters params, Wallet wallet, BlockStore blockStore)
        throws BlockStoreException
    (§
        this(Context.getOrCreate(params), wallet, blockStore);
    )

    ;;;
     ; Constructs a BlockChain that has no wallet at all.  This is helpful when you don't actually care about sending
     ; and receiving coins but rather, just want to explore the network data structures.
     ;;
#_public
    BlockChain(Context context, BlockStore blockStore)
        throws BlockStoreException
    (§
        this(context, new ArrayList<Wallet>(), blockStore);
    )

    ;;; See {@link #BlockChain(Context, BlockStore)}. ;;
#_public
    BlockChain(NetworkParameters params, BlockStore blockStore)
        throws BlockStoreException
    (§
        this(params, new ArrayList<Wallet>(), blockStore);
    )

    ;;;
     ; Constructs a BlockChain connected to the given list of listeners and a store.
     ;;
#_public
    BlockChain(Context params, List<? extends Wallet> wallets, BlockStore blockStore)
        throws BlockStoreException
    (§
        super(params, wallets, blockStore);
        this.blockStore = blockStore;
    )

    ;;; See {@link #BlockChain(Context, List, BlockStore)}. ;;
#_public
    BlockChain(NetworkParameters params, List<? extends Wallet> wallets, BlockStore blockStore)
        throws BlockStoreException
    (§
        this(Context.getOrCreate(params), wallets, blockStore);
    )

#_override
#_protected
    StoredBlock addToBlockStore(StoredBlock storedPrev, Block blockHeader, TransactionOutputChanges txOutChanges)
        throws BlockStoreException, VerificationException
    (§
        StoredBlock newBlock = storedPrev.build(blockHeader);
        blockStore.put(newBlock);
        return newBlock;
    )

#_override
#_protected
    StoredBlock addToBlockStore(StoredBlock storedPrev, Block blockHeader)
        throws BlockStoreException, VerificationException
    (§
        StoredBlock newBlock = storedPrev.build(blockHeader);
        blockStore.put(newBlock);
        return newBlock;
    )

#_override
#_protected
    void rollbackBlockStore(int height)
        throws BlockStoreException
    (§
        lock.lock();
        try
        (§
            int currentHeight = getBestChainHeight();
            Preconditions.checkArgument(0 <= height && height <= currentHeight, "Bad height: %s", height);
            if (height == currentHeight)
                return; ;; nothing to do

            ;; Look for the block we want to be the new chain head.
            StoredBlock newChainHead = blockStore.getChainHead();
            while (height < newChainHead.getHeight())
            (§
                newChainHead = newChainHead.getPrev(blockStore);
                if (newChainHead == nil)
                    throw new BlockStoreException("Unreachable height");
            )

            ;; Modify store directly.
            blockStore.put(newChainHead);
            this.setChainHead(newChainHead);
        )
        finally
        (§
            lock.unlock();
        )
    )

#_override
#_protected
    boolean shouldVerifyTransactions()
    (§
        return false;
    )

#_override
#_protected
    TransactionOutputChanges connectTransactions(int height, Block block)
    (§
        ;; Don't have to do anything as this is only called if shouldVerifyTransactions().
        throw new UnsupportedOperationException();
    )

#_override
#_protected
    TransactionOutputChanges connectTransactions(StoredBlock newBlock)
    (§
        ;; Don't have to do anything as this is only called if shouldVerifyTransactions().
        throw new UnsupportedOperationException();
    )

#_override
#_protected
    void disconnectTransactions(StoredBlock block)
    (§
        ;; Don't have to do anything as this is only called if shouldVerifyTransactions().
        throw new UnsupportedOperationException();
    )

#_override
#_protected
    void doSetChainHead(StoredBlock chainHead)
        throws BlockStoreException
    (§
        blockStore.setChainHead(chainHead);
    )

#_override
#_protected
    void notSettingChainHead()
        throws BlockStoreException
    (§
        ;; We don't use DB transactions here, so we don't need to do anything.
    )

#_override
#_protected
    StoredBlock getStoredBlockInCurrentScope(Sha256Hash hash)
        throws BlockStoreException
    (§
        return blockStore.get(hash);
    )

#_override
#_public
    boolean add(FilteredBlock block)
        throws VerificationException, PrunedException
    (§
        boolean success = super.add(block);
        if (success)
            trackFilteredTransactions(block.getTransactionCount());
        return success;
    )
)

(ns org.bitcoinj.core #_"BloomFilter"
    (:import [java.io IOException OutputStream]
             #_static #_[java.lang.Math *]
             [java.util ArrayList Arrays List])
    (:import [com.google.common.base Objects Preconditions]
             [com.google.common.collect Lists])
  #_(:require [org.bitcoinj.script Script ScriptChunk]))

;;;
 ; <p>A Bloom filter is a probabilistic data structure which can be sent to another client so that it can avoid
 ; sending us transactions that aren't relevant to our set of keys.  This allows for significantly more efficient
 ; use of available network bandwidth and CPU time.</p>
 ;
 ; <p>Because a Bloom filter is probabilistic, it has a configurable false positive rate.  So the filter will sometimes
 ; match transactions that weren't inserted into it, but it will never fail to match transactions that were.  This is
 ; a useful privacy feature - if you have spare bandwidth the false positive rate can be increased so the remote peer
 ; gets a noisy picture of what transactions are relevant to your wallet.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
class BloomFilter extends Message
(§
    ;;;
     ; The BLOOM_UPDATE_* constants control when the bloom filter is auto-updated by the peer using
     ; it as a filter, either never, for all outputs or only for pay-2-pubkey outputs (default).
     ;;
#_public
    enum BloomUpdate
    (§
        UPDATE_NONE, ;; 0
        UPDATE_ALL, ;; 1
        ;;; Only adds outpoints to the filter if the output is a pay-to-pubkey/pay-to-multisig script. ;;
        UPDATE_P2PUBKEY_ONLY ;; 2
    )

#_private
    byte[] data;
#_private
    long hashFuncs;
#_private
    long nTweak;
#_private
    byte nFlags;

    ;; Same value as of Bitcoin Core.
    ;; A filter of 20,000 items and a false positive rate of 0.1% or one of 10,000 items and 0.0001% is just under 36,000 bytes.
#_private
#_static
#_final
    long MAX_FILTER_SIZE = 36000;
    ;; There is little reason to ever have more hash functions than 50 given a limit of 36,000 bytes.
#_private
#_static
#_final
    int MAX_HASH_FUNCS = 50;

    ;;;
     ; Construct a BloomFilter by deserializing payloadBytes.
     ;;
#_public
    BloomFilter(NetworkParameters params, byte[] payloadBytes)
        throws ProtocolException
    (§
        super(params, payloadBytes, 0);
    )

    ;;;
     ; Constructs a filter with the given parameters which is updated on pay2pubkey outputs only.
     ;;
#_public
    BloomFilter(int elements, double falsePositiveRate, long randomNonce)
    (§
        this(elements, falsePositiveRate, randomNonce, BloomUpdate.UPDATE_P2PUBKEY_ONLY);
    )

    ;;;
     ; <p>Constructs a new Bloom Filter which will provide approximately the given false positive rate when the given
     ; number of elements have been inserted.  If the filter would otherwise be larger than the maximum allowed size,
     ; it will be automatically downsized to the maximum size.</p>
     ;
     ; <p>To check the theoretical false positive rate of a given filter, use {@link BloomFilter#getFalsePositiveRate(int)}.</p>
     ;
     ; <p>The anonymity of which coins are yours to any peer which you send a BloomFilter to is controlled by the
     ; false positive rate.  For reference, as of block 187,000, the total number of addresses used in the chain was
     ; roughly 4.5 million.  Thus, if you use a false positive rate of 0.001 (0.1%), there will be, on average, 4,500
     ; distinct public keys/addresses which will be thought to be yours by nodes which have your bloom filter, but
     ; which are not actually yours.  Keep in mind that a remote node can do a pretty good job estimating the order of
     ; magnitude of the false positive rate of a given filter you provide it when considering the anonymity of a given
     ; filter.</p>
     ;
     ; <p>In order for filtered block download to function efficiently, the number of matched transactions in any given
     ; block should be less than (with some headroom) the maximum size of the MemoryPool used by the Peer
     ; doing the downloading (default is {@link TxConfidenceTable#MAX_SIZE}).  See the comment in processBlock(FilteredBlock)
     ; for more information on this restriction.</p>
     ;
     ; <p>randomNonce is a tweak for the hash function used to prevent some theoretical DoS attacks.
     ; It should be a random value, however secureness of the random value is of no great consequence.</p>
     ;
     ; <p>updateFlag is used to control filter behaviour on the server (remote node) side when it encounters a hit.
     ; See {@link org.bitcoinj.core.BloomFilter.BloomUpdate} for a brief description of each mode.  The purpose
     ; of this flag is to reduce network round-tripping and avoid over-dirtying the filter for the most common
     ; wallet configurations.</p>
     ;;
#_public
    BloomFilter(int elements, double falsePositiveRate, long randomNonce, BloomUpdate updateFlag)
    (§
        ;; The following formulas were stolen from Wikipedia's page on Bloom Filters (with the addition of min(..., MAX_...)).
        ;; Size required for a given number of elements and false-positive rate.
        int size = (int)(-1 / pow(log(2), 2) * elements * log(falsePositiveRate));
        size = max(1, min(size, (int)MAX_FILTER_SIZE * 8) / 8);
        data = new byte[size];
        ;; Optimal number of hash functions for a given filter size and element count.
        hashFuncs = (int)(data.length * 8 / (double)elements * log(2));
        hashFuncs = max(1, min(hashFuncs, MAX_HASH_FUNCS));
        this.nTweak = randomNonce;
        this.nFlags = (byte)(0xff & updateFlag.ordinal());
    )

    ;;;
     ; Returns the theoretical false positive rate of this filter if were to contain the given number of elements.
     ;;
#_public
    double getFalsePositiveRate(int elements)
    (§
        return pow(1 - pow(E, -1.0 * (hashFuncs * elements) / (data.length * 8)), hashFuncs);
    )

#_override
#_public
    String toString()
    (§
        return "Bloom Filter of size " + data.length + " with " + hashFuncs + " hash functions.";
    )

#_override
#_protected
    void parse()
        throws ProtocolException
    (§
        data = readByteArray();
        if (MAX_FILTER_SIZE < data.length)
            throw new ProtocolException ("Bloom filter out of size range.");
        hashFuncs = readUint32();
        if (MAX_HASH_FUNCS < hashFuncs)
            throw new ProtocolException("Bloom filter hash function count out of range");
        nTweak = readUint32();
        nFlags = readBytes(1)[0];
        length = cursor - offset;
    )

    ;;;
     ; Serializes this message to the provided stream.  If you just want the raw bytes use bitcoinSerialize().
     ;;
#_override
#_protected
    void bitcoinSerializeToStream(OutputStream stream)
        throws IOException
    (§
        stream.write(new VarInt(data.length).encode());
        stream.write(data);
        Utils.uint32ToByteStreamLE(hashFuncs, stream);
        Utils.uint32ToByteStreamLE(nTweak, stream);
        stream.write(nFlags);
    )

#_private
#_static
    int rotateLeft32(int x, int r)
    (§
        return (x << r) | (x >>> (32 - r));
    )

    ;;;
     ; Applies the MurmurHash3 (x86_32) algorithm to the given data.
     ; See <a href="https://github.com/aappleby/smhasher/blob/master/src/MurmurHash3.cpp">this C++ code</a> for the original.
     ;;
#_public
#_static
    int murmurHash3(byte[] data, long nTweak, int hashNum, byte[] object)
    (§
        int h1 = (int)(hashNum * 0xfba4c795L + nTweak);
#_final
        int c1 = 0xcc9e2d51;
#_final
        int c2 = 0x1b873593;

        int numBlocks = (object.length / 4) * 4;

        ;; body
        for (int i = 0; i < numBlocks; i += 4)
        (§
            int k1 = (object[i] & 0xff) | ((object[i + 1] & 0xff) << 8) | ((object[i + 2] & 0xff) << 16) | ((object[i + 3] & 0xff) << 24);

            k1 *= c1;
            k1 = rotateLeft32(k1, 15);
            k1 *= c2;

            h1 ^= k1;
            h1 = rotateLeft32(h1, 13);
            h1 = h1 * 5 + 0xe6546b64;
        )

        int k1 = 0;
        switch (object.length & 3)
        (§
            case 3:
                k1 ^= (object[numBlocks + 2] & 0xff) << 16;
                ;; Fall through.
            case 2:
                k1 ^= (object[numBlocks + 1] & 0xff) << 8;
                ;; Fall through.
            case 1:
                k1 ^= (object[numBlocks] & 0xff);
                k1 *= c1;
                k1 = rotateLeft32(k1, 15);
                k1 *= c2;
                h1 ^= k1;
                ;; Fall through.
            default:
                ;; Do nothing.
                break;
        )

        ;; finalization
        h1 ^= object.length;
        h1 ^= h1 >>> 16;
        h1 *= 0x85ebca6b;
        h1 ^= h1 >>> 13;
        h1 *= 0xc2b2ae35;
        h1 ^= h1 >>> 16;

        return (int)((h1 & 0xffffffffL) % (data.length * 8));
    )

    ;;;
     ; Returns true if the given object matches the filter either because it was inserted, or because we have a false-positive.
     ;;
#_public
#_synchronized
    boolean contains(byte[] object)
    (§
        for (int i = 0; i < hashFuncs; i++)
            if (!Utils.checkBitLE(data, murmurHash3(data, nTweak, i, object)))
                return false;

        return true;
    )

    ;;; Insert the given arbitrary data into the filter. ;;
#_public
#_synchronized
    void insert(byte[] object)
    (§
        for (int i = 0; i < hashFuncs; i++)
            Utils.setBitLE(data, murmurHash3(data, nTweak, i, object));
    )

    ;;; Inserts the given key and equivalent hashed form (for the address). ;;
#_public
#_synchronized
    void insert(ECKey key)
    (§
        insert(key.getPubKey());
        insert(key.getPubKeyHash());
    )

    ;;;
     ; Sets this filter to match all objects.  A Bloom filter which matches everything may seem pointless, however,
     ; it is useful in order to reduce steady state bandwidth usage when you want full blocks.  Instead of receiving
     ; all transaction data twice, you will receive the vast majority of all transactions just once, at broadcast time.
     ; Solved blocks will then be send just as Merkle trees of tx hashes, meaning a constant 32 bytes of data for each
     ; transaction instead of 100-300 bytes as per usual.
     ;;
#_public
#_synchronized
    void setMatchAll()
    (§
        data = new byte[] { (byte)0xff };
    )

    ;;;
     ; Copies filter into this.  Filter must have the same size, hash function count and nTweak or an
     ; IllegalArgumentException will be thrown.
     ;;
#_public
#_synchronized
    void merge(BloomFilter filter)
    (§
        if (!this.matchesAll() && !filter.matchesAll())
        (§
            Preconditions.checkArgument(filter.data.length == this.data.length && filter.hashFuncs == this.hashFuncs && filter.nTweak == this.nTweak);

            for (int i = 0; i < data.length; i++)
                this.data[i] |= filter.data[i];
        )
        else
        (§
            this.data = new byte[] { (byte)0xff };
        )
    )

    ;;;
     ; Returns true if this filter will match anything.  See {@link org.bitcoinj.core.BloomFilter#setMatchAll()}
     ; for when this can be a useful thing to do.
     ;;
#_public
#_synchronized
    boolean matchesAll()
    (§
        for (byte b : data)
            if (b != (byte)0xff)
                return false;
        return true;
    )

    ;;;
     ; The update flag controls how application of the filter to a block modifies the filter.  See the enum javadocs
     ; for information on what occurs and when.
     ;;
#_public
#_synchronized
    BloomUpdate getUpdateFlag()
    (§
        if (nFlags == 0)
            return BloomUpdate.UPDATE_NONE;
        if (nFlags == 1)
            return BloomUpdate.UPDATE_ALL;
        if (nFlags == 2)
            return BloomUpdate.UPDATE_P2PUBKEY_ONLY;

        throw new IllegalStateException("Unknown flag combination");
    )

    ;;;
     ; Creates a new FilteredBlock from the given Block, using this filter to select transactions.  Matches can cause the
     ; filter to be updated with the matched element, this ensures that when a filter is applied to a block, spends of
     ; matched transactions are also matched.  However it means this filter can be mutated by the operation.  The returned
     ; filtered block already has the matched transactions associated with it.
     ;;
#_public
#_synchronized
    FilteredBlock applyAndUpdate(Block block)
    (§
        List<Transaction> txns = block.getTransactions();
        List<Sha256Hash> txHashes = new ArrayList<>(txns.size());
        List<Transaction> matched = Lists.newArrayList();
        byte[] bits = new byte[(int)Math.ceil(txns.size() / 8.0)];
        for (int i = 0; i < txns.size(); i++)
        (§
            Transaction tx = txns.get(i);
            txHashes.add(tx.getHash());
            if (applyAndUpdate(tx))
            (§
                Utils.setBitLE(bits, i);
                matched.add(tx);
            )
        )
        PartialMerkleTree pmt = PartialMerkleTree.buildFromLeaves(block.getParams(), bits, txHashes);
        FilteredBlock filteredBlock = new FilteredBlock(block.getParams(), block.cloneAsHeader(), pmt);
        for (Transaction transaction : matched)
            filteredBlock.provideTransaction(transaction);
        return filteredBlock;
    )

#_public
#_synchronized
    boolean applyAndUpdate(Transaction tx)
    (§
        if (contains(tx.getHash().getBytes()))
            return true;
        boolean found = false;
        BloomUpdate flag = getUpdateFlag();
        for (TransactionOutput output : tx.getOutputs())
        (§
            Script script = output.getScriptPubKey();
            for (ScriptChunk chunk : script.getChunks())
            (§
                if (chunk.isPushData() && contains(chunk.data))
                (§
                    boolean isSendingToPubKeys = script.isSentToRawPubKey() || script.isSentToMultiSig();
                    if (flag == BloomUpdate.UPDATE_ALL || (flag == BloomUpdate.UPDATE_P2PUBKEY_ONLY && isSendingToPubKeys))
                        insert(output.getOutPointFor().unsafeBitcoinSerialize());
                    found = true;
                )
            )
        )
        if (found)
            return true;
        for (TransactionInput input : tx.getInputs())
        (§
            if (contains(input.getOutpoint().unsafeBitcoinSerialize()))
                return true;

            for (ScriptChunk chunk : input.getScriptSig().getChunks())
                if (chunk.isPushData() && contains(chunk.data))
                    return true;
        )
        return false;
    )

#_override
#_public
#_synchronized
    boolean equals(Object o)
    (§
        if (this == o)
            return true;
        if (o == nil || getClass() != o.getClass())
            return false;
        BloomFilter other = (BloomFilter)o;
        return (hashFuncs == other.hashFuncs && nTweak == other.nTweak && Arrays.equals(data, other.data));
    )

#_override
#_public
#_synchronized
    int hashCode()
    (§
        return Objects.hashCode(hashFuncs, nTweak, Arrays.hashCode(data));
    )
)

(ns org.bitcoinj.core #_"CheckpointManager"
    (:import [java.io BufferedInputStream BufferedReader DataInputStream IOException InputStream InputStreamReader]
             [java.nio ByteBuffer ByteOrder]
             [java.security DigestInputStream MessageDigest]
             [java.util Arrays Map TreeMap])
    (:import [com.google.common.base Charsets Preconditions]
             [com.google.common.hash HashCode Hasher Hashing]
             [com.google.common.io BaseEncoding]
             [org.slf4j Logger LoggerFactory])
  #_(:require [org.bitcoinj.store BlockStore BlockStoreException FullPrunedBlockStore]))

;;;
 ; <p>Vends hard-coded {@link StoredBlock}s for blocks throughout the chain.  Checkpoints serve two purposes:</p>
 ; <ol>
 ;    <li>They act as a safety mechanism against huge re-orgs that could rewrite large chunks of history, thus
 ;    constraining the block chain to be a consensus mechanism only for recent parts of the timeline.</li>
 ;    <li>They allow synchronization to the head of the chain for new wallets/users much faster than syncing all
 ;    headers from the genesis block.</li>
 ; </ol>
 ;
 ; <p>Checkpoints are used by the SPV {@link BlockChain} to initialize fresh {@link org.bitcoinj.store.SPVBlockStore}s.
 ; They are not used by fully validating mode, which instead has a different concept of checkpoints that are used
 ; to hard-code the validity of blocks that violate BIP30 (duplicate coinbase transactions).
 ; Those "checkpoints" can be found in NetworkParameters.</p>
 ;
 ; <p>The file format consists of the string "CHECKPOINTS 1", followed by a uint32 containing the number of signatures
 ; to read.  The value may not be larger than 256 (so it could have been a byte but isn't for historical reasons).
 ; If the number of signatures is larger than zero, each 65 byte ECDSA secp256k1 signature then follows.  The signatures
 ; sign the hash of all bytes that follow the last signature.</p>
 ;
 ; <p>After the signatures come an int32 containing the number of checkpoints in the file.  Then each checkpoint follows
 ; one after the other.  A checkpoint is 12 bytes for the total work done field, 4 bytes for the height, 80 bytes
 ; for the block header and then 1 zero byte at the end (i.e. number of transactions in the block: always zero).</p>
 ;;
#_public
class CheckpointManager
(§
#_private
#_static
#_final
    Logger log = LoggerFactory.getLogger(CheckpointManager.class);

#_private
#_static
#_final
    String BINARY_MAGIC = "CHECKPOINTS 1";
#_private
#_static
#_final
    String TEXTUAL_MAGIC = "TXT CHECKPOINTS 1";
#_private
#_static
#_final
    int MAX_SIGNATURES = 256;

    ;; Map of block header time to data.
#_protected
#_final
    TreeMap<Long, StoredBlock> checkpoints = new TreeMap<>();

#_protected
#_final
    NetworkParameters params;
#_protected
#_final
    Sha256Hash dataHash;

#_public
#_static
#_final
    BaseEncoding BASE64 = BaseEncoding.base64().omitPadding();

    ;;; Loads the default checkpoints bundled with bitcoinj. ;;
#_public
    CheckpointManager(Context context)
        throws IOException
    (§
        this(context.getParams(), nil);
    )

    ;;; Loads the checkpoints from the given stream. ;;
#_public
    CheckpointManager(NetworkParameters params, #_nilable InputStream inputStream)
        throws IOException
    (§
        this.params = Preconditions.checkNotNull(params);
        if (inputStream == nil)
            inputStream = openStream(params);
        Preconditions.checkNotNull(inputStream);
        inputStream = new BufferedInputStream(inputStream);
        inputStream.mark(1);
        int first = inputStream.read();
        inputStream.reset();
        if (first == BINARY_MAGIC.charAt(0))
            dataHash = readBinary(inputStream);
        else if (first == TEXTUAL_MAGIC.charAt(0))
            dataHash = readTextual(inputStream);
        else
            throw new IOException("Unsupported format.");
    )

    ;;; Returns a checkpoints stream pointing to inside the bitcoinj JAR. ;;
#_public
#_static
    InputStream openStream(NetworkParameters params)
    (§
        return CheckpointManager.class.getResourceAsStream("/" + params.getId() + ".checkpoints.txt");
    )

#_private
    Sha256Hash readBinary(InputStream inputStream)
        throws IOException
    (§
        DataInputStream dis = nil;
        try
        (§
            MessageDigest digest = Sha256Hash.newDigest();
            DigestInputStream digestInputStream = new DigestInputStream(inputStream, digest);
            dis = new DataInputStream(digestInputStream);
            digestInputStream.on(false);
            byte[] header = new byte[BINARY_MAGIC.length()];
            dis.readFully(header);
            if (!Arrays.equals(header, BINARY_MAGIC.getBytes("US-ASCII")))
                throw new IOException("Header bytes did not match expected version");
            int numSignatures = checkPositionIndex(dis.readInt(), MAX_SIGNATURES, "Num signatures out of range");
            for (int i = 0; i < numSignatures; i++)
            (§
                byte[] sig = new byte[65];
                dis.readFully(sig);
                ;; TODO: Do something with the signature here.
            )
            digestInputStream.on(true);
            int numCheckpoints = dis.readInt();
            Preconditions.checkState(0 < numCheckpoints);
#_final
            int size = StoredBlock.COMPACT_SERIALIZED_SIZE;
            ByteBuffer buffer = ByteBuffer.allocate(size);
            for (int i = 0; i < numCheckpoints; i++)
            (§
                if (dis.read(buffer.array(), 0, size) < size)
                    throw new IOException("Incomplete read whilst loading checkpoints.");
                StoredBlock block = StoredBlock.deserializeCompact(params, buffer);
                buffer.position(0);
                checkpoints.put(block.getHeader().getTimeSeconds(), block);
            )
            Sha256Hash dataHash = Sha256Hash.wrap(digest.digest());
            log.info("Read {} checkpoints, hash is {}", checkpoints.size(), dataHash);
            return dataHash;
        )
        catch (ProtocolException e)
        (§
            throw new IOException(e);
        )
        finally
        (§
            if (dis != nil)
                dis.close();
            inputStream.close();
        )
    )

#_private
    Sha256Hash readTextual(InputStream inputStream)
        throws IOException
    (§
        Hasher hasher = Hashing.sha256().newHasher();
        BufferedReader reader = nil;
        try
        (§
            reader = new BufferedReader(new InputStreamReader(inputStream, Charsets.US_ASCII));
            String magic = reader.readLine();
            if (!TEXTUAL_MAGIC.equals(magic))
                throw new IOException("unexpected magic: " + magic);
            int numSigs = Integer.parseInt(reader.readLine());
            for (int i = 0; i < numSigs; i++)
                reader.readLine(); ;; Skip sigs for now.
            int numCheckpoints = Integer.parseInt(reader.readLine());
            Preconditions.checkState(0 < numCheckpoints);
            ;; Hash numCheckpoints in a way compatible to the binary format.
            hasher.putBytes(ByteBuffer.allocate(4).order(ByteOrder.BIG_ENDIAN).putInt(numCheckpoints).array());
#_final
            int size = StoredBlock.COMPACT_SERIALIZED_SIZE;
            ByteBuffer buffer = ByteBuffer.allocate(size);
            for (int i = 0; i < numCheckpoints; i++)
            (§
                byte[] bytes = BASE64.decode(reader.readLine());
                hasher.putBytes(bytes);
                buffer.position(0);
                buffer.put(bytes);
                buffer.position(0);
                StoredBlock block = StoredBlock.deserializeCompact(params, buffer);
                checkpoints.put(block.getHeader().getTimeSeconds(), block);
            )
            HashCode hash = hasher.hash();
            log.info("Read {} checkpoints, hash is {}", checkpoints.size(), hash);
            return Sha256Hash.wrap(hash.asBytes());
        )
        finally
        (§
            if (reader != nil)
                reader.close();
        )
    )

    ;;;
     ; Returns a {@link StoredBlock} representing the last checkpoint before the given time, for example, normally
     ; you would want to know the checkpoint before the earliest wallet birthday.
     ;;
#_public
    StoredBlock getCheckpointBefore(long time)
    (§
        try
        (§
            Preconditions.checkArgument(params.getGenesisBlock().getTimeSeconds() < time);
            ;; This is thread safe because the map never changes after creation.
            Map.Entry<Long, StoredBlock> entry = checkpoints.floorEntry(time);
            if (entry != nil)
                return entry.getValue();
            Block genesis = params.getGenesisBlock().cloneAsHeader();
            return new StoredBlock(genesis, genesis.getWork(), 0);
        )
        catch (VerificationException e)
        (§
            throw new RuntimeException(e); ;; Cannot happen.
        )
    )

    ;;; Returns the number of checkpoints that were loaded. ;;
#_public
    int numCheckpoints()
    (§
        return checkpoints.size();
    )

    ;;; Returns a hash of the concatenated checkpoint data. ;;
#_public
    Sha256Hash getDataHash()
    (§
        return dataHash;
    )

    ;;;
     ; <p>Convenience method that creates a CheckpointManager, loads the given data, gets the checkpoint for the given
     ; time, then inserts it into the store and sets that to be the chain head.  Useful when you have just created
     ; a new store from scratch and want to use configure it all in one go.</p>
     ;
     ; <p>Note that time is adjusted backwards by a week to account for possible clock drift in the block headers.</p>
     ;;
#_public
#_static
    void checkpoint(NetworkParameters params, InputStream checkpoints, BlockStore store, long time)
        throws IOException, BlockStoreException
    (§
        Preconditions.checkNotNull(params);
        Preconditions.checkNotNull(store);
        Preconditions.checkArgument(!(store instanceof FullPrunedBlockStore), "You cannot use checkpointing with a full store.");

        time -= 86400 * 7;

        Preconditions.checkArgument(0 < time);
        log.info("Attempting to initialize a new block store with a checkpoint for time {} ({})", time, Utils.dateTimeFormat(time * 1000));

        BufferedInputStream stream = new BufferedInputStream(checkpoints);
        CheckpointManager manager = new CheckpointManager(params, stream);
        StoredBlock checkpoint = manager.getCheckpointBefore(time);
        store.put(checkpoint);
        store.setChainHead(checkpoint);
    )
)

(ns org.bitcoinj.core #_"ChildMessage")

;;;
 ; <p>Represents a Message type that can be contained within another Message.  ChildMessages that have a cached
 ; backing byte array need to invalidate their parent's caches as well as their own if they are modified.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
#_abstract
class ChildMessage extends Message
(§
#_nilable
#_protected
    Message parent;

#_public
    ChildMessage(NetworkParameters params)
    (§
        super(params);
    )

#_public
    ChildMessage(NetworkParameters params, byte[] payload, int offset, int protocolVersion)
        throws ProtocolException
    (§
        super(params, payload, offset, protocolVersion);
    )

#_public
    ChildMessage(NetworkParameters params, byte[] payload, int offset, int protocolVersion, Message parent, MessageSerializer setSerializer, int length)
        throws ProtocolException
    (§
        super(params, payload, offset, protocolVersion, setSerializer, length);
        this.parent = parent;
    )

#_public
    ChildMessage(NetworkParameters params, byte[] payload, int offset)
        throws ProtocolException
    (§
        super(params, payload, offset);
    )

#_public
    ChildMessage(NetworkParameters params, byte[] payload, int offset, #_nilable Message parent, MessageSerializer setSerializer, int length)
        throws ProtocolException
    (§
        super(params, payload, offset, setSerializer, length);
        this.parent = parent;
    )

#_public
#_final
    void setParent(#_nilable Message parent)
    (§
        if (this.parent != nil && this.parent != parent && parent != nil)
        (§
            ;; After old parent is unlinked it won't be able to receive notice if this ChildMessage changes internally.
            ;; To be safe we invalidate the parent cache to ensure it rebuilds manually on serialization.
            this.parent.unCache();
        )
        this.parent = parent;
    )

#_override
#_protected
    void unCache()
    (§
        super.unCache();
        if (parent != nil)
            parent.unCache();
    )

#_protected
    void adjustLength(int adjustment)
    (§
        adjustLength(0, adjustment);
    )

#_override
#_protected
    void adjustLength(int newArraySize, int adjustment)
    (§
        super.adjustLength(newArraySize, adjustment);
        if (parent != nil)
            parent.adjustLength(newArraySize, adjustment);
    )
)

(ns org.bitcoinj.core #_"Coin"
    (:import [java.io Serializable]
             [java.math BigDecimal])
    (:import [com.google.common.base Preconditions]
             [com.google.common.math LongMath]
             [com.google.common.primitives Longs])
  #_(:require [org.bitcoinj.utils MonetaryFormat]))

;;;
 ; Represents a monetary Bitcoin value.  This class is immutable.
 ;;
#_public
#_final
class Coin implements Monetary, Comparable<Coin>, Serializable
(§
    ;;;
     ; Number of decimals for one Bitcoin.  This constant is useful for quick adapting to other coins because a lot of
     ; constants derive from it.
     ;;
#_public
#_static
#_final
    int SMALLEST_UNIT_EXPONENT = 8;

    ;;;
     ; The number of satoshis equal to one bitcoin.
     ;;
#_private
#_static
#_final
    long COIN_VALUE = LongMath.pow(10, SMALLEST_UNIT_EXPONENT);

    ;;;
     ; Zero Bitcoins.
     ;;
#_public
#_static
#_final
    Coin ZERO = Coin.valueOf(0);

    ;;;
     ; One Bitcoin.
     ;;
#_public
#_static
#_final
    Coin COIN = Coin.valueOf(COIN_VALUE);

    ;;;
     ; 0.01 Bitcoins.  This unit is not really used much.
     ;;
#_public
#_static
#_final
    Coin CENT = COIN.divide(100);

    ;;;
     ; 0.001 Bitcoins, also known as 1 mBTC.
     ;;
#_public
#_static
#_final
    Coin MILLICOIN = COIN.divide(1000);

    ;;;
     ; 0.000001 Bitcoins, also known as 1 µBTC or 1 uBTC.
     ;;
#_public
#_static
#_final
    Coin MICROCOIN = MILLICOIN.divide(1000);

    ;;;
     ; A satoshi is the smallest unit that can be transferred.  100 million of them fit into a Bitcoin.
     ;;
#_public
#_static
#_final
    Coin SATOSHI = Coin.valueOf(1);

#_public
#_static
#_final
    Coin FIFTY_COINS = COIN.multiply(50);

    ;;;
     ; Represents a monetary value of minus one satoshi.
     ;;
#_public
#_static
#_final
    Coin NEGATIVE_SATOSHI = Coin.valueOf(-1);

    ;;;
     ; The number of satoshis of this monetary value.
     ;;
#_public
#_final
    long value;

#_private
    Coin(final long satoshis)
    (§
        this.value = satoshis;
    )

#_public
#_static
    Coin valueOf(final long satoshis)
    (§
        return new Coin(satoshis);
    )

#_override
#_public
    int smallestUnitExponent()
    (§
        return SMALLEST_UNIT_EXPONENT;
    )

    ;;;
     ; Returns the number of satoshis of this monetary value.
     ;;
#_override
#_public
    long getValue()
    (§
        return value;
    )

    ;;;
     ; Convert an amount expressed in the way humans are used to into satoshis.
     ;;
#_public
#_static
    Coin valueOf(final int coins, final int cents)
    (§
        Preconditions.checkArgument(0 <= coins && 0 <= cents && cents < 100);

        return COIN.multiply(coins).add(CENT.multiply(cents));
    )

    ;;;
     ; Parses an amount expressed in the way humans are used to.
     ;
     ; This takes string in a format understood by {@link BigDecimal#BigDecimal(String)},
     ; for example "0", "1", "0.10", "1.23E3", "1234.5E-5".
     ;
     ; @throws IllegalArgumentException if you try to specify fractional satoshis, or a value out of range.
     ;;
#_public
#_static
    Coin parseCoin(final String str)
    (§
        try
        (§
            long satoshis = new BigDecimal(str).movePointRight(SMALLEST_UNIT_EXPONENT).longValueExact();
            return Coin.valueOf(satoshis);
        )
        catch (ArithmeticException e)
        (§
            throw new IllegalArgumentException(e); ;; Repackage exception to honor method contract.
        )
    )

    ;;;
     ; Parses an amount expressed in the way humans are used to.  The amount is cut to satoshi precision.
     ;
     ; This takes string in a format understood by {@link BigDecimal#BigDecimal(String)},
     ; for example "0", "1", "0.10", "1.23E3", "1234.5E-5".
     ;
     ; @throws IllegalArgumentException if you try to specify a value out of range.
     ;;
#_public
#_static
    Coin parseCoinInexact(final String str)
    (§
        try
        (§
            long satoshis = new BigDecimal(str).movePointRight(SMALLEST_UNIT_EXPONENT).longValue();
            return Coin.valueOf(satoshis);
        )
        catch (ArithmeticException e)
        (§
            throw new IllegalArgumentException(e); ;; Repackage exception to honor method contract.
        )
    )

#_public
    Coin add(final Coin value)
    (§
        return new Coin(LongMath.checkedAdd(this.value, value.value));
    )

    ;;; Alias for add. ;;
#_public
    Coin plus(final Coin value)
    (§
        return add(value);
    )

#_public
    Coin subtract(final Coin value)
    (§
        return new Coin(LongMath.checkedSubtract(this.value, value.value));
    )

    ;;; Alias for subtract. ;;
#_public
    Coin minus(final Coin value)
    (§
        return subtract(value);
    )

#_public
    Coin multiply(final long factor)
    (§
        return new Coin(LongMath.checkedMultiply(this.value, factor));
    )

    ;;; Alias for multiply. ;;
#_public
    Coin times(final long factor)
    (§
        return multiply(factor);
    )

    ;;; Alias for multiply. ;;
#_public
    Coin times(final int factor)
    (§
        return multiply(factor);
    )

#_public
    Coin divide(final long divisor)
    (§
        return new Coin(this.value / divisor);
    )

    ;;; Alias for divide. ;;
#_public
    Coin div(final long divisor)
    (§
        return divide(divisor);
    )

    ;;; Alias for divide. ;;
#_public
    Coin div(final int divisor)
    (§
        return divide(divisor);
    )

#_public
    Coin[] divideAndRemainder(final long divisor)
    (§
        return new Coin[] { new Coin(this.value / divisor), new Coin(this.value % divisor) };
    )

#_public
    long divide(final Coin divisor)
    (§
        return this.value / divisor.value;
    )

    ;;;
     ; Returns true if and only if this instance represents a monetary value greater than zero,
     ; otherwise false.
     ;;
#_public
    boolean isPositive()
    (§
        return (signum() == 1);
    )

    ;;;
     ; Returns true if and only if this instance represents a monetary value less than zero,
     ; otherwise false.
     ;;
#_public
    boolean isNegative()
    (§
        return (signum() == -1);
    )

    ;;;
     ; Returns true if and only if this instance represents zero monetary value,
     ; otherwise false.
     ;;
#_public
    boolean isZero()
    (§
        return (signum() == 0);
    )

    ;;;
     ; Returns true if the monetary value represented by this instance is greater than that
     ; of the given other Coin, otherwise false.
     ;;
#_public
    boolean isGreaterThan(Coin other)
    (§
        return (0 < compareTo(other));
    )

    ;;;
     ; Returns true if the monetary value represented by this instance is less than that
     ; of the given other Coin, otherwise false.
     ;;
#_public
    boolean isLessThan(Coin other)
    (§
        return (compareTo(other) < 0);
    )

#_public
    Coin shiftLeft(final int n)
    (§
        return new Coin(this.value << n);
    )

#_public
    Coin shiftRight(final int n)
    (§
        return new Coin(this.value >> n);
    )

#_override
#_public
    int signum()
    (§
        if (this.value == 0)
            return 0;
        return (this.value < 0) ? -1 : 1;
    )

#_public
    Coin negate()
    (§
        return new Coin(-this.value);
    )

    ;;;
     ; Returns the number of satoshis of this monetary value.  It's deprecated in favour of accessing {@link #value} directly.
     ;;
#_public
    long longValue()
    (§
        return this.value;
    )

#_private
#_static
#_final
    MonetaryFormat FRIENDLY_FORMAT = MonetaryFormat.BTC.minDecimals(2).repeatOptionalDecimals(1, 6).postfixCode();

    ;;;
     ; Returns the value as a 0.12 type string.  More digits after the decimal place will be used
     ; if necessary, but two will always be present.
     ;;
#_public
    String toFriendlyString()
    (§
        return FRIENDLY_FORMAT.format(this).toString();
    )

#_private
#_static
#_final
    MonetaryFormat PLAIN_FORMAT = MonetaryFormat.BTC.minDecimals(0).repeatOptionalDecimals(1, 8).noCode();

    ;;;
     ; Returns the value as a plain string denominated in BTC.
     ; The result is unformatted with no trailing zeroes.
     ; For instance, a value of 150000 satoshis gives an output string of "0.0015" BTC.
     ;;
#_public
    String toPlainString()
    (§
        return PLAIN_FORMAT.format(this).toString();
    )

#_override
#_public
    String toString()
    (§
        return Long.toString(value);
    )

#_override
#_public
    boolean equals(final Object o)
    (§
        if (this == o)
            return true;
        if (o == nil || getClass() != o.getClass())
            return false;
        return (this.value == ((Coin)o).value);
    )

#_override
#_public
    int hashCode()
    (§
        return (int)this.value;
    )

#_override
#_public
    int compareTo(final Coin other)
    (§
        return Longs.compare(this.value, other.value);
    )
)

(ns org.bitcoinj.core #_"Context"
    (:import [com.google.common.base Preconditions]
             #_[org.slf4j *]))

;; TODO: Finish adding Context c'tors to all the different objects so we can start deprecating the versions that take NetworkParameters.
;; TODO: Add a working directory notion to Context and make various subsystems that want to use files default to that directory (e.g. Orchid, block stores, wallet, etc).
;; TODO: Auto-register the block chain object here, and then use it in the (newly deprecated) TransactionConfidence.getDepthInBlocks() method:
;;       the new version should take an AbstractBlockChain specifically.
;;       Also use the block chain object reference from the context in PeerGroup and remove the other constructors, as it's easy to forget to wire things up.
;; TODO: Move Threading.USER_THREAD to here and leave behind just a source code stub.  Allow different instantiations of the library to use different user threads.
;; TODO: Keep a URI to where library internal data files can be found, to abstract over the lack of JAR files on Android.
;; TODO: Stash anything else that resembles global library configuration in here and use it to clean up the rest of the API without breaking people.
;; TODO: Move the TorClient into Context, so different parts of the library can read data over Tor without having to request it directly. (or maybe a general socket factory??)

;;;
 ; <p>The Context object holds various objects and pieces of configuration that are scoped to a specific instantiation of
 ; bitcoinj for a specific network.  You can get an instance of this class through calling {@link #get()}.</p>
 ;
 ; <p>Context is new in 0.13 and the library is currently in a transitional period: you should create a Context that
 ; wraps your chosen network parameters before using the rest of the library.  However if you don't, things will still
 ; work as a Context will be created for you and stashed in thread local storage.  The context is then propagated between
 ; library created threads as needed.  This automagical propagation and creation is a temporary mechanism: one day it
 ; will be removed to avoid confusing edge cases that could occur if the developer does not fully understand it e.g.
 ; in the case where multiple instances of the library are in use simultaneously.</p>
 ;;
#_public
class Context
(§
#_private
#_static
#_final
    Logger log = LoggerFactory.getLogger(Context.class);

#_public
#_static
#_final
    int DEFAULT_EVENT_HORIZON = 100;

#_final
#_private
    TxConfidenceTable confidenceTable;
#_final
#_private
    NetworkParameters params;
#_final
#_private
    int eventHorizon;
#_final
#_private
    boolean ensureMinRequiredFee;
#_final
#_private
    Coin feePerKb;

    ;;;
     ; Creates a new context object.  For now, this will be done for you by the framework.  Eventually you will be
     ; expected to do this yourself in the same manner as fetching a NetworkParameters object (at the start of your app).
     ;
     ; @param params The network parameters that will be associated with this context.
     ;;
#_public
    Context(NetworkParameters params)
    (§
        this(params, DEFAULT_EVENT_HORIZON, Transaction.DEFAULT_TX_FEE, true);
    )

    ;;;
     ; Creates a new custom context object.  This is mainly meant for unit tests for now.
     ;
     ; @param params The network parameters that will be associated with this context.
     ; @param eventHorizon Number of blocks after which the library will delete data and be unable to always process reorgs (see {@link #getEventHorizon()}.
     ; @param feePerKb The default fee per 1000 bytes of transaction data to pay when completing transactions.  For details, see {@link SendRequest#feePerKb}.
     ; @param ensureMinRequiredFee Whether to ensure the minimum required fee by default when completing transactions.  For details, see {@link SendRequest#ensureMinRequiredFee}.
     ;;
#_public
    Context(NetworkParameters params, int eventHorizon, Coin feePerKb, boolean ensureMinRequiredFee)
    (§
        log.info("Creating bitcoinj {} context.", VersionMessage.BITCOINJ_VERSION);
        this.confidenceTable = new TxConfidenceTable();
        this.params = params;
        this.eventHorizon = eventHorizon;
        this.ensureMinRequiredFee = ensureMinRequiredFee;
        this.feePerKb = feePerKb;
        lastConstructed = this;
        slot.set(this);
    )

#_private
#_static
#_volatile
    Context lastConstructed;
#_private
#_static
    boolean isStrictMode;
#_private
#_static
#_final
    ThreadLocal<Context> slot = new ThreadLocal<>();

    ;;;
     ; Returns the current context that is associated with the <b>calling thread</b>.  BitcoinJ is an API that has thread
     ; affinity: much like OpenGL it expects each thread that accesses it to have been configured with a global Context
     ; object.  This method returns that.  Note that to help you develop, this method will <i>also</i> propagate whichever
     ; context was created last onto the current thread, if it's missing.  However it will print an error when doing so
     ; because propagation of contexts is meant to be done manually: this is so two libraries or subsystems that
     ; independently use bitcoinj (or possibly alt coin forks of it) can operate correctly.
     ;
     ; @throws java.lang.IllegalStateException if no context exists at all or if we are in strict mode and there is no context.
     ;;
#_public
#_static
    Context get()
    (§
        Context tls = slot.get();
        if (tls == nil)
        (§
            if (isStrictMode)
            (§
                log.error("Thread is missing a bitcoinj context.");
                log.error("You should use Context.propagate() or a ContextPropagatingThreadFactory.");
                throw new IllegalStateException("missing context");
            )
            if (lastConstructed == nil)
                throw new IllegalStateException("You must construct a Context object before using bitcoinj!");
            slot.set(lastConstructed);
            log.error("Performing thread fixup: you are accessing bitcoinj via a thread that has not had any context set on it.");
            log.error("This error has been corrected for, but doing this makes your app less robust.");
            log.error("You should use Context.propagate() or a ContextPropagatingThreadFactory.");
            log.error("Please refer to the user guide for more information about this.");
            log.error("Thread name is {}.", Thread.currentThread().getName());
            ;; TODO: Actually write the user guide section about this.
            return lastConstructed;
        )

        return tls;
    )

    ;;;
     ; Require that new threads use {@link #propagate(Context)} or {@link org.bitcoinj.utils.ContextPropagatingThreadFactory},
     ; rather than using a heuristic for the desired context.
     ;;
#_public
#_static
    void enableStrictMode()
    (§
        isStrictMode = true;
    )

    ;; A temporary internal shim designed to help us migrate internally in a way that doesn't wreck source compatibility.
#_public
#_static
    Context getOrCreate(NetworkParameters params)
    (§
        Context context;
        try
        (§
            context = get();
        )
        catch (IllegalStateException e)
        (§
            log.warn("Implicitly creating context. This is a migration step and this message will eventually go away.");
            context = new Context(params);
            return context;
        )
        if (context.getParams() != params)
            throw new IllegalStateException("Context does not match implicit network params: " + context.getParams() + " vs " + params);
        return context;
    )

    ;;;
     ; Sets the given context as the current thread context.  You should use this if you create your own threads that
     ; want to create core BitcoinJ objects.  Generally, if a class can accept a Context in its constructor and might
     ; be used (even indirectly) by a thread, you will want to call this first.  Your task may be simplified by using
     ; a {@link org.bitcoinj.utils.ContextPropagatingThreadFactory}.
     ;;
#_public
#_static
    void propagate(Context context)
    (§
        slot.set(Preconditions.checkNotNull(context));
    )

    ;;;
     ; Returns the {@link TxConfidenceTable} created by this context.  The pool tracks advertised
     ; and downloaded transactions so their confidence can be measured as a proportion of how many peers announced it.
     ; With an un-tampered with internet connection, the more peers announce a transaction the more confidence you can
     ; have that it's really valid.
     ;;
#_public
    TxConfidenceTable getConfidenceTable()
    (§
        return confidenceTable;
    )

    ;;;
     ; Returns the {@link org.bitcoinj.core.NetworkParameters} specified when this context was (auto) created.  The
     ; network parameters defines various hard coded constants for a specific instance of a Bitcoin network, such as
     ; main net, testnet, etc.
     ;;
#_public
    NetworkParameters getParams()
    (§
        return params;
    )

    ;;;
     ; The event horizon is the number of blocks after which various bits of the library consider a transaction to be
     ; so confirmed that it's safe to delete data.  Re-orgs larger than the event horizon will not be correctly
     ; processed, so the default value is high (100).
     ;;
#_public
    int getEventHorizon()
    (§
        return eventHorizon;
    )

    ;;;
     ; The default fee per 1000 bytes of transaction data to pay when completing transactions.  For details, see {@link SendRequest#feePerKb}.
     ;;
#_public
    Coin getFeePerKb()
    (§
        return feePerKb;
    )

    ;;;
     ; Whether to ensure the minimum required fee by default when completing transactions.  For details, see {@link SendRequest#ensureMinRequiredFee}.
     ;;
#_public
    boolean isEnsureMinRequiredFee()
    (§
        return ensureMinRequiredFee;
    )
)

(ns org.bitcoinj.core #_"DummySerializer"
    (:import [java.io IOException OutputStream]
             [java.nio BufferUnderflowException ByteBuffer]))

;;;
 ; Dummy serializer used ONLY for objects which do not have network parameters set.
 ;;
class DummySerializer extends MessageSerializer
(§
#_public
#_static
#_final
    DummySerializer DEFAULT = new DummySerializer();

#_private
#_static
#_final
    String DEFAULT_EXCEPTION_MESSAGE = "Dummy serializer cannot serialize/deserialize objects as it does not know which network they belong to.";

#_public
    DummySerializer()
    (§
    )

#_override
#_public
    Message deserialize(ByteBuffer in)
        throws UnsupportedOperationException
    (§
        throw new UnsupportedOperationException(DEFAULT_EXCEPTION_MESSAGE);
    )

#_override
#_public
    BitcoinSerializer.BitcoinPacketHeader deserializeHeader(ByteBuffer in)
        throws UnsupportedOperationException
    (§
        throw new UnsupportedOperationException(DEFAULT_EXCEPTION_MESSAGE);
    )

#_override
#_public
    Message deserializePayload(BitcoinSerializer.BitcoinPacketHeader header, ByteBuffer in)
        throws UnsupportedOperationException
    (§
        throw new UnsupportedOperationException(DEFAULT_EXCEPTION_MESSAGE);
    )

#_override
#_public
    boolean isParseRetainMode()
    (§
        return false;
    )

#_override
#_public
    AddressMessage makeAddressMessage(byte[] payloadBytes, int length)
        throws UnsupportedOperationException
    (§
        throw new UnsupportedOperationException(DEFAULT_EXCEPTION_MESSAGE);
    )

#_override
#_public
    Message makeAlertMessage(byte[] payloadBytes)
        throws UnsupportedOperationException
    (§
        throw new UnsupportedOperationException(DEFAULT_EXCEPTION_MESSAGE);
    )

#_override
#_public
    Block makeBlock(byte[] payloadBytes, int offset, int length)
        throws UnsupportedOperationException
    (§
        throw new UnsupportedOperationException(DEFAULT_EXCEPTION_MESSAGE);
    )

#_override
#_public
    Message makeBloomFilter(byte[] payloadBytes)
        throws UnsupportedOperationException
    (§
        throw new UnsupportedOperationException(DEFAULT_EXCEPTION_MESSAGE);
    )

#_override
#_public
    FilteredBlock makeFilteredBlock(byte[] payloadBytes)
        throws UnsupportedOperationException
    (§
        throw new UnsupportedOperationException(DEFAULT_EXCEPTION_MESSAGE);
    )

#_override
#_public
    InventoryMessage makeInventoryMessage(byte[] payloadBytes, int length)
        throws UnsupportedOperationException
    (§
        throw new UnsupportedOperationException(DEFAULT_EXCEPTION_MESSAGE);
    )

#_override
#_public
    Transaction makeTransaction(byte[] payloadBytes, int offset, int length, byte[] hash)
        throws UnsupportedOperationException
    (§
        throw new UnsupportedOperationException(DEFAULT_EXCEPTION_MESSAGE);
    )

#_override
#_public
    void seekPastMagicBytes(ByteBuffer in)
        throws BufferUnderflowException
    (§
        throw new UnsupportedOperationException(DEFAULT_EXCEPTION_MESSAGE);
    )

#_override
#_public
    void serialize(String name, byte[] message, OutputStream out)
        throws IOException
    (§
        throw new UnsupportedOperationException(DEFAULT_EXCEPTION_MESSAGE);
    )

#_override
#_public
    void serialize(Message message, OutputStream out)
        throws IOException
    (§
        throw new UnsupportedOperationException(DEFAULT_EXCEPTION_MESSAGE);
    )
)

(ns org.bitcoinj.core #_"ECKey"
    (:import [java.io ByteArrayOutputStream IOException]
             [java.math BigInteger]
             [java.nio.charset Charset]
             [java.security SecureRandom SignatureException]
             [java.util Arrays Comparator])
    (:import [com.google.common.annotations VisibleForTesting]
             [com.google.common.base MoreObjects Objects Preconditions]
             [com.google.common.primitives Ints UnsignedBytes]
             [org.slf4j Logger LoggerFactory]
             #_[org.spongycastle.asn1 *]
             [org.spongycastle.asn1.x9 X9ECParameters X9IntegerConverter]
             [org.spongycastle.crypto AsymmetricCipherKeyPair]
             [org.spongycastle.crypto.digests SHA256Digest]
             [org.spongycastle.crypto.ec CustomNamedCurves]
             [org.spongycastle.crypto.generators ECKeyPairGenerator]
             #_[org.spongycastle.crypto.params *]
             [org.spongycastle.crypto.signers ECDSASigner HMacDSAKCalculator]
             [org.spongycastle.math.ec ECAlgorithms ECPoint FixedPointCombMultiplier FixedPointUtil]
             [org.spongycastle.math.ec.custom.sec SecP256K1Curve]
             [org.spongycastle.util.encoders Base64])
  #_(:require #_[org.bitcoinj.crypto *]
             [org.bitcoinj.wallet Protos Wallet]))

;; TODO: Move this class to tracking compression state itself.
;; The Bouncy Castle guys are deprecating their own tracking of the compression state.

;;;
 ; <p>Represents an elliptic curve public and (optionally) private key, usable for digital signatures but not encryption.
 ; Creating a new ECKey with the empty constructor will generate a new random keypair.  Other static methods can be used
 ; when you already have the public or private parts.  If you create a key with only the public part, you can check
 ; signatures but not create them.</p>
 ;
 ; <p>ECKey also provides access to Bitcoin Core compatible text message signing, as accessible via the UI or JSON-RPC.
 ; This is slightly different to signing raw bytes - if you want to sign your own data and it won't be exposed as
 ; text to people, you don't want to use this.  If in doubt, ask on the mailing list.</p>
 ;
 ; <p>The ECDSA algorithm supports <i>key recovery</i> in which a signature plus a couple of discriminator bits can
 ; be reversed to find the public key used to calculate it.  This can be convenient when you have a message and a
 ; signature and want to find out who signed it, rather than requiring the user to provide the expected identity.</p>
 ;
 ; <p>This class supports a variety of serialization forms.  The methods that accept/return byte arrays serialize
 ; private keys as raw byte arrays and public keys using the SEC standard byte encoding for public keys.  Signatures
 ; are encoded using ASN.1/DER inside the Bitcoin protocol.</p>
 ;
 ; <p>A key can be <i>compressed</i> or <i>uncompressed</i>.  This refers to whether the public key is represented
 ; when encoded into bytes as an (x, y) coordinate on the elliptic curve, or whether it's represented as just an X
 ; co-ordinate and an extra byte that carries a sign bit.  With the latter form the Y coordinate can be calculated
 ; dynamically, however, <b>because the binary serialization is different the address of a key changes if its
 ; compression status is changed</b>.  If you deviate from the defaults it's important to understand this: money sent
 ; to a compressed version of the key will have a different address to the same key in uncompressed form.  Whether
 ; a public key is compressed or not is recorded in the SEC binary serialisation format, and preserved in a flag in
 ; this class so round-tripping preserves state.  Unless you're working with old software or doing unusual things, you
 ; can usually ignore the compressed/uncompressed distinction.</p>
 ;;
#_public
class ECKey implements EncryptableItem
(§
#_private
#_static
#_final
    Logger log = LoggerFactory.getLogger(ECKey.class);

    ;;; Sorts oldest keys first, newest last. ;;
#_public
#_static
#_final
    Comparator<ECKey> AGE_COMPARATOR = new Comparator<ECKey>()
    (§
#_override
#_public
        int compare(ECKey k1, ECKey k2)
        (§
            if (k1.creationTimeSeconds == k2.creationTimeSeconds)
                return 0;

            return (k1.creationTimeSeconds < k2.creationTimeSeconds) ? -1 : 1;
        )
    );

    ;;; Compares pub key bytes using {@link com.google.common.primitives.UnsignedBytes#lexicographicalComparator()}. ;;
#_public
#_static
#_final
    Comparator<ECKey> PUBKEY_COMPARATOR = new Comparator<ECKey>()
    (§
#_private
        Comparator<byte[]> comparator = UnsignedBytes.lexicographicalComparator();

#_override
#_public
        int compare(ECKey k1, ECKey k2)
        (§
            return comparator.compare(k1.getPubKey(), k2.getPubKey());
        )
    );

    ;; The parameters of the secp256k1 curve that Bitcoin uses.
#_private
#_static
#_final
    X9ECParameters CURVE_PARAMS = CustomNamedCurves.getByName("secp256k1");

    ;;; The parameters of the secp256k1 curve that Bitcoin uses. ;;
#_public
#_static
#_final
    ECDomainParameters CURVE;

    ;;;
     ; Equal to CURVE.getN().shiftRight(1), used for canonicalising the S value of a signature.
     ; If you aren't sure what this is about, you can ignore it.
     ;;
#_public
#_static
#_final
    BigInteger HALF_CURVE_ORDER;

#_private
#_static
#_final
    SecureRandom secureRandom;

    #_static
    (§
        ;; Init proper random number generator, as some old Android installations have bugs that make it unsecure.
        if (Utils.isAndroidRuntime())
            new LinuxSecureRandom();

        ;; Tell Bouncy Castle to precompute data that's needed during secp256k1 calculations.  Increasing the width
        ;; number makes calculations faster, but at a cost of extra memory usage and with decreasing returns.  12 was
        ;; picked after consulting with the BC team.
        FixedPointUtil.precompute(CURVE_PARAMS.getG(), 12);
        CURVE = new ECDomainParameters(CURVE_PARAMS.getCurve(), CURVE_PARAMS.getG(), CURVE_PARAMS.getN(), CURVE_PARAMS.getH());
        HALF_CURVE_ORDER = CURVE_PARAMS.getN().shiftRight(1);
        secureRandom = new SecureRandom();
    )

    ;; The two parts of the key.  If "priv" is set, "pub" can always be calculated.  If "pub" is set but not "priv", we
    ;; can only verify signatures not make them.
#_protected
#_final
    BigInteger priv; ;; A field element.
#_protected
#_final
    LazyECPoint pub;

    ;; Creation time of the key in seconds since the epoch, or zero if the key was deserialized from a version that did
    ;; not have this field.
#_protected
    long creationTimeSeconds;

#_protected
    KeyCrypter keyCrypter;
#_protected
    EncryptedData encryptedPrivateKey;

#_private
    byte[] pubKeyHash;

    ;;;
     ; Generates an entirely new keypair.  Point compression is used so the resulting public key will be 33 bytes
     ; (32 for the co-ordinate and 1 byte to represent the y bit).
     ;;
#_public
    ECKey()
    (§
        this(secureRandom);
    )

    ;;;
     ; Generates an entirely new keypair with the given {@link SecureRandom} object.  Point compression is used so the
     ; resulting public key will be 33 bytes (32 for the co-ordinate and 1 byte to represent the y bit).
     ;;
#_public
    ECKey(SecureRandom secureRandom)
    (§
        ECKeyPairGenerator generator = new ECKeyPairGenerator();
        ECKeyGenerationParameters keygenParams = new ECKeyGenerationParameters(CURVE, secureRandom);
        generator.init(keygenParams);
        AsymmetricCipherKeyPair keypair = generator.generateKeyPair();
        ECPrivateKeyParameters privParams = (ECPrivateKeyParameters)keypair.getPrivate();
        ECPublicKeyParameters pubParams = (ECPublicKeyParameters)keypair.getPublic();
        priv = privParams.getD();
        pub = new LazyECPoint(CURVE.getCurve(), pubParams.getQ().getEncoded(true));
        creationTimeSeconds = Utils.currentTimeSeconds();
    )

#_protected
    ECKey(#_nilable BigInteger priv, ECPoint pub)
    (§
        this(priv, new LazyECPoint(Preconditions.checkNotNull(pub)));
    )

#_protected
    ECKey(#_nilable BigInteger priv, LazyECPoint pub)
    (§
        if (priv != nil)
        (§
            Preconditions.checkArgument(priv.bitLength() <= (32 << 3), "private key exceeds 32 bytes: {} bits", priv.bitLength());
            ;; Try and catch buggy callers or bad key imports, etc.  Zero and one are special because these are often
            ;; used as sentinel values and because scripting languages have a habit of auto-casting true and false to
            ;; 1 and 0 or vice-versa.  Type confusion bugs could therefore result in private keys with these values.
            Preconditions.checkArgument(!priv.equals(BigInteger.ZERO));
            Preconditions.checkArgument(!priv.equals(BigInteger.ONE));
        )
        this.priv = priv;
        this.pub = Preconditions.checkNotNull(pub);
    )

    ;;;
     ; Utility for compressing an elliptic curve point.  Returns the same point if it's already compressed.
     ; See the ECKey class docs for a discussion of point compression.
     ;;
#_public
#_static
    ECPoint compressPoint(ECPoint point)
    (§
        return getPointWithCompression(point, true);
    )

#_public
#_static
    LazyECPoint compressPoint(LazyECPoint point)
    (§
        return point.isCompressed() ? point : new LazyECPoint(compressPoint(point.get()));
    )

    ;;;
     ; Utility for decompressing an elliptic curve point.  Returns the same point if it's already compressed.
     ; See the ECKey class docs for a discussion of point compression.
     ;;
#_public
#_static
    ECPoint decompressPoint(ECPoint point)
    (§
        return getPointWithCompression(point, false);
    )

#_public
#_static
    LazyECPoint decompressPoint(LazyECPoint point)
    (§
        return !point.isCompressed() ? point : new LazyECPoint(decompressPoint(point.get()));
    )

#_private
#_static
    ECPoint getPointWithCompression(ECPoint point, boolean compressed)
    (§
        if (point.isCompressed() == compressed)
            return point;

        point = point.normalize();
        BigInteger x = point.getAffineXCoord().toBigInteger();
        BigInteger y = point.getAffineYCoord().toBigInteger();
        return CURVE.getCurve().createPoint(x, y, compressed);
    )

    ;;;
     ; Construct an ECKey from an ASN.1 encoded private key.  These are produced by OpenSSL and stored by Bitcoin
     ; Core in its wallet.  Note that this is slow because it requires an EC point multiply.
     ;;
#_public
#_static
    ECKey fromASN1(byte[] asn1privkey)
    (§
        return extractKeyFromASN1(asn1privkey);
    )

    ;;;
     ; Creates an ECKey given the private key only.  The public key is calculated from it (this is slow).  The resulting
     ; public key is compressed.
     ;;
#_public
#_static
    ECKey fromPrivate(BigInteger privKey)
    (§
        return fromPrivate(privKey, true);
    )

    ;;;
     ; Creates an ECKey given the private key only.  The public key is calculated from it (this is slow), either
     ; compressed or not.
     ;;
#_public
#_static
    ECKey fromPrivate(BigInteger privKey, boolean compressed)
    (§
        ECPoint point = publicPointFromPrivate(privKey);
        return new ECKey(privKey, getPointWithCompression(point, compressed));
    )

    ;;;
     ; Creates an ECKey given the private key only.  The public key is calculated from it (this is slow).  The resulting
     ; public key is compressed.
     ;;
#_public
#_static
    ECKey fromPrivate(byte[] privKeyBytes)
    (§
        return fromPrivate(new BigInteger(1, privKeyBytes));
    )

    ;;;
     ; Creates an ECKey given the private key only.  The public key is calculated from it (this is slow), either
     ; compressed or not.
     ;;
#_public
#_static
    ECKey fromPrivate(byte[] privKeyBytes, boolean compressed)
    (§
        return fromPrivate(new BigInteger(1, privKeyBytes), compressed);
    )

    ;;;
     ; Creates an ECKey that simply trusts the caller to ensure that point is really the result of multiplying the
     ; generator point by the private key.  This is used to speed things up when you know you have the right values
     ; already.  The compression state of pub will be preserved.
     ;;
#_public
#_static
    ECKey fromPrivateAndPrecalculatedPublic(BigInteger priv, ECPoint pub)
    (§
        return new ECKey(priv, pub);
    )

    ;;;
     ; Creates an ECKey that simply trusts the caller to ensure that point is really the result of multiplying the
     ; generator point by the private key.  This is used to speed things up when you know you have the right values
     ; already.  The compression state of the point will be preserved.
     ;;
#_public
#_static
    ECKey fromPrivateAndPrecalculatedPublic(byte[] priv, byte[] pub)
    (§
        Preconditions.checkNotNull(priv);
        Preconditions.checkNotNull(pub);
        return new ECKey(new BigInteger(1, priv), CURVE.getCurve().decodePoint(pub));
    )

    ;;;
     ; Creates an ECKey that cannot be used for signing, only verifying signatures, from the given point.
     ; The compression state of pub will be preserved.
     ;;
#_public
#_static
    ECKey fromPublicOnly(ECPoint pub)
    (§
        return new ECKey(nil, pub);
    )

    ;;;
     ; Creates an ECKey that cannot be used for signing, only verifying signatures, from the given encoded point.
     ; The compression state of pub will be preserved.
     ;;
#_public
#_static
    ECKey fromPublicOnly(byte[] pub)
    (§
        return new ECKey(nil, CURVE.getCurve().decodePoint(pub));
    )

    ;;;
     ; Returns a copy of this key, but with the public point represented in uncompressed form.  Normally you would
     ; never need this: it's for specialised scenarios or when backwards compatibility in encoded form is necessary.
     ;;
#_public
    ECKey decompress()
    (§
        return pub.isCompressed() ? new ECKey(priv, decompressPoint(pub.get())) : this;
    )

    ;;;
     ; Creates an ECKey given only the private key bytes.  This is the same as using the BigInteger constructor, but
     ; is more convenient if you are importing a key from elsewhere.  The public key will be automatically derived
     ; from the private key.
     ;;
#_deprecated
#_public
    ECKey(#_nilable byte[] privKeyBytes, #_nilable byte[] pubKey)
    (§
        this((privKeyBytes != nil) ? new BigInteger(1, privKeyBytes) : nil, pubKey);
    )

    ;;;
     ; Create a new ECKey with an encrypted private key, a public key and a KeyCrypter.
     ;
     ; @param encryptedPrivateKey The encrypted private key.
     ; @param pubKey The public key.
     ; @param keyCrypter The KeyCrypter that will be used, with an AES key, to encrypt and decrypt the private key.
     ;;
#_deprecated
#_public
    ECKey(EncryptedData encryptedPrivateKey, byte[] pubKey, KeyCrypter keyCrypter)
    (§
        this((byte[])nil, pubKey);

        this.keyCrypter = Preconditions.checkNotNull(keyCrypter);
        this.encryptedPrivateKey = encryptedPrivateKey;
    )

    ;;;
     ; Constructs a key that has an encrypted private component.  The given object wraps encrypted bytes and an
     ; initialization vector.  Note that the key will not be decrypted during this call: the returned ECKey is
     ; unusable for signing unless a decryption key is supplied.
     ;;
#_public
#_static
    ECKey fromEncrypted(EncryptedData encryptedPrivateKey, KeyCrypter crypter, byte[] pubKey)
    (§
        ECKey key = fromPublicOnly(pubKey);
        key.encryptedPrivateKey = Preconditions.checkNotNull(encryptedPrivateKey);
        key.keyCrypter = Preconditions.checkNotNull(crypter);
        return key;
    )

    ;;;
     ; Creates an ECKey given either the private key only, the public key only, or both.  If only the private key
     ; is supplied, the public key will be calculated from it (this is slow).  If both are supplied, it's assumed
     ; the public key already correctly matches the private key.  If only the public key is supplied, this ECKey
     ; cannot be used for signing.
     ; @param compressed If set to true and pubKey is null, the derived public key will be in compressed form.
     ;;
#_deprecated
#_public
    ECKey(#_nilable BigInteger privKey, #_nilable byte[] pubKey, boolean compressed)
    (§
        if (privKey == nil && pubKey == nil)
            throw new IllegalArgumentException("ECKey requires at least private or public key");
        this.priv = privKey;
        if (pubKey == nil)
        (§
            ;; Derive public from private.
            ECPoint point = publicPointFromPrivate(privKey);
            point = getPointWithCompression(point, compressed);
            this.pub = new LazyECPoint(point);
        )
        else
        (§
            ;; We expect the pubkey to be in regular encoded form, just as a BigInteger.
            ;; Therefore the first byte is a special marker byte.
            ;; TODO: This is probably not a useful API and may be confusing.
            this.pub = new LazyECPoint(CURVE.getCurve(), pubKey);
        )
    )

    ;;;
     ; Creates an ECKey given either the private key only, the public key only, or both.  If only the private key
     ; is supplied, the public key will be calculated from it (this is slow).  If both are supplied, it's assumed
     ; the public key already correctly matches the public key.  If only the public key is supplied, this ECKey cannot
     ; be used for signing.
     ;;
#_deprecated
#_private
    ECKey(#_nilable BigInteger privKey, #_nilable byte[] pubKey)
    (§
        this(privKey, pubKey, false);
    )

    ;;;
     ; Returns true if this key doesn't have unencrypted access to private key bytes.  This may be because
     ; it was never given any private key bytes to begin with (a watching key), or because the key is encrypted.
     ; You can use {@link #isEncrypted()} to tell the cases apart.
     ;;
#_public
    boolean isPubKeyOnly()
    (§
        return (priv == nil);
    )

    ;;;
     ; Returns true if this key has unencrypted access to private key bytes.
     ; Does the opposite of {@link #isPubKeyOnly()}.
     ;;
#_public
    boolean hasPrivKey()
    (§
        return (priv != nil);
    )

    ;;; Returns true if this key is watch only, meaning it has a public key but no private key. ;;
#_public
    boolean isWatching()
    (§
        return (isPubKeyOnly() && !isEncrypted());
    )

    ;;;
     ; Output this ECKey as an ASN.1 encoded private key, as understood by OpenSSL or used by Bitcoin Core
     ; in its wallet storage format.
     ; @throws org.bitcoinj.core.ECKey.MissingPrivateKeyException if the private key is missing or encrypted.
     ;;
#_public
    byte[] toASN1()
    (§
        try
        (§
            byte[] privKeyBytes = getPrivKeyBytes();
            ByteArrayOutputStream baos = new ByteArrayOutputStream(400);

            ;; ASN1_SEQUENCE(EC_PRIVATEKEY) = {
            ;;   ASN1_SIMPLE(EC_PRIVATEKEY, version, LONG),
            ;;   ASN1_SIMPLE(EC_PRIVATEKEY, privateKey, ASN1_OCTET_STRING),
            ;;   ASN1_EXP_OPT(EC_PRIVATEKEY, parameters, ECPKPARAMETERS, 0),
            ;;   ASN1_EXP_OPT(EC_PRIVATEKEY, publicKey, ASN1_BIT_STRING, 1)
            ;; } ASN1_SEQUENCE_END(EC_PRIVATEKEY)
            DERSequenceGenerator seq = new DERSequenceGenerator(baos);
            seq.addObject(new ASN1Integer(1)); ;; version
            seq.addObject(new DEROctetString(privKeyBytes));
            seq.addObject(new DERTaggedObject(0, CURVE_PARAMS.toASN1Primitive()));
            seq.addObject(new DERTaggedObject(1, new DERBitString(getPubKey())));
            seq.close();
            return baos.toByteArray();
        )
        catch (IOException e)
        (§
            throw new RuntimeException(e); ;; Cannot happen, writing to memory stream.
        )
    )

    ;;;
     ; Returns public key bytes from the given private key.  To convert a byte array into a BigInteger, use <tt>new BigInteger(1, bytes)</tt>.
     ;;
#_public
#_static
    byte[] publicKeyFromPrivate(BigInteger privKey, boolean compressed)
    (§
        return publicPointFromPrivate(privKey).getEncoded(compressed);
    )

    ;;;
     ; Returns public key point from the given private key.  To convert a byte array into a BigInteger, use <tt>new BigInteger(1, bytes)</tt>.
     ;;
#_public
#_static
    ECPoint publicPointFromPrivate(BigInteger privKey)
    (§
        ;;
         ; TODO: FixedPointCombMultiplier currently doesn't support scalars longer than the group order,
         ; but that could change in future versions.
         ;;
        if (CURVE.getN().bitLength() < privKey.bitLength())
            privKey = privKey.mod(CURVE.getN());

        return new FixedPointCombMultiplier().multiply(CURVE.getG(), privKey);
    )

    ;;; Gets the hash160 form of the public key (as seen in addresses). ;;
#_public
    byte[] getPubKeyHash()
    (§
        if (pubKeyHash == nil)
            pubKeyHash = Utils.sha256hash160(this.pub.getEncoded());

        return pubKeyHash;
    )

    ;;;
     ; Gets the raw public key value.  This appears in transaction scriptSigs.  Note that this is <b>not</b> the same
     ; as the pubKeyHash/address.
     ;;
#_public
    byte[] getPubKey()
    (§
        return pub.getEncoded();
    )

    ;;; Gets the public key in the form of an elliptic curve point object from Bouncy Castle. ;;
#_public
    ECPoint getPubKeyPoint()
    (§
        return pub.get();
    )

    ;;;
     ; Gets the private key in the form of an integer field element.  The public key is derived by performing EC
     ; point addition this number of times (i.e. point multiplying).
     ;
     ; @throws java.lang.IllegalStateException if the private key bytes are not available.
     ;;
#_public
    BigInteger getPrivKey()
    (§
        if (priv == nil)
            throw new MissingPrivateKeyException();

        return priv;
    )

    ;;;
     ; Returns whether this key is using the compressed form or not.  Compressed pubkeys are only 33 bytes, not 64.
     ;;
#_public
    boolean isCompressed()
    (§
        return pub.isCompressed();
    )

    ;;;
     ; Returns the address that corresponds to the public part of this ECKey.  Note that an address is derived from
     ; the RIPEMD-160 hash of the public key and is not the public key itself (which is too large to be convenient).
     ;;
#_public
    Address toAddress(NetworkParameters params)
    (§
        return new Address(params, getPubKeyHash());
    )

    ;;;
     ; Groups the two components that make up a signature, and provides a way to encode to DER form, which is
     ; how ECDSA signatures are represented when embedded in other data structures in the Bitcoin protocol.
     ; The raw components can be useful for doing further EC maths on them.
     ;;
#_public
#_static
    class ECDSASignature
    (§
        ;;; The two components of the signature. ;;
#_public
#_final
        BigInteger r, s;

        ;;;
         ; Constructs a signature with the given components.  Does NOT automatically canonicalise the signature.
         ;;
#_public
        ECDSASignature(BigInteger r, BigInteger s)
        (§
            this.r = r;
            this.s = s;
        )

        ;;;
         ; Returns true if the S component is "low", that means it is below {@link ECKey#HALF_CURVE_ORDER}.  See
         ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0062.mediawiki#Low_S_values_in_signatures">BIP62</a>.
         ;;
#_public
        boolean isCanonical()
        (§
            return (s.compareTo(HALF_CURVE_ORDER) <= 0);
        )

        ;;;
         ; Will automatically adjust the S component to be less than or equal to half the curve order, if necessary.
         ; This is required because for every signature (r,s) the signature (r, -s (mod N)) is a valid signature of
         ; the same message.  However, we dislike the ability to modify the bits of a Bitcoin transaction after it's
         ; been signed, as that violates various assumed invariants.  Thus in future only one of those forms will be
         ; considered legal and the other will be banned.
         ;;
#_public
        ECDSASignature toCanonicalised()
        (§
            if (!isCanonical())
            (§
                ;; The order of the curve is the number of valid points that exist on that curve.  If S is in the upper
                ;; half of the number of valid points, then bring it back to the lower half.  Otherwise, imagine that
                ;;    N = 10
                ;;    s = 8, so (-8 % 10 == 2) thus both (r, 8) and (r, 2) are valid solutions.
                ;;    10 - 8 == 2, giving us always the latter solution, which is canonical.
                return new ECDSASignature(r, CURVE.getN().subtract(s));
            )

            return this;
        )

        ;;;
         ; DER is an international standard for serializing data structures which is widely used in cryptography.
         ; It's somewhat like protocol buffers but less convenient.  This method returns a standard DER encoding
         ; of the signature, as recognized by OpenSSL and other libraries.
         ;;
#_public
        byte[] encodeToDER()
        (§
            try
            (§
                return derByteStream().toByteArray();
            )
            catch (IOException e)
            (§
                throw new RuntimeException(e); ;; Cannot happen.
            )
        )

#_public
#_static
        ECDSASignature decodeFromDER(byte[] bytes)
            throws IllegalArgumentException
        (§
            ASN1InputStream decoder = nil;
            try
            (§
                decoder = new ASN1InputStream(bytes);
                DLSequence seq = (DLSequence)decoder.readObject();
                if (seq == nil)
                    throw new IllegalArgumentException("Reached past end of ASN.1 stream.");

                ASN1Integer r, s;
                try
                (§
                    r = (ASN1Integer)seq.getObjectAt(0);
                    s = (ASN1Integer)seq.getObjectAt(1);
                )
                catch (ClassCastException e)
                (§
                    throw new IllegalArgumentException(e);
                )
                ;; OpenSSL deviates from the DER spec by interpreting these values as unsigned, though they should not be.
                ;; Thus, we always use the positive versions.  See http://r6.ca/blog/20111119T211504Z.html
                return new ECDSASignature(r.getPositiveValue(), s.getPositiveValue());
            )
            catch (IOException e)
            (§
                throw new IllegalArgumentException(e);
            )
            finally
            (§
                if (decoder != nil)
                    try
                    (§
                        decoder.close();
                    )
                    catch (IOException _)
                    (§
                    )
            )
        )

#_protected
        ByteArrayOutputStream derByteStream()
            throws IOException
        (§
            ;; Usually 70-72 bytes.
            ByteArrayOutputStream bos = new ByteArrayOutputStream(72);
            DERSequenceGenerator seq = new DERSequenceGenerator(bos);
            seq.addObject(new ASN1Integer(r));
            seq.addObject(new ASN1Integer(s));
            seq.close();
            return bos;
        )

#_override
#_public
        boolean equals(Object o)
        (§
            if (this == o)
                return true;
            if (o == nil || getClass() != o.getClass())
                return false;
            ECDSASignature other = (ECDSASignature)o;
            return (r.equals(other.r) && s.equals(other.s));
        )

#_override
#_public
        int hashCode()
        (§
            return Objects.hashCode(r, s);
        )
    )

    ;;;
     ; Signs the given hash and returns the R and S components as BigIntegers.  In the Bitcoin protocol, they are
     ; usually encoded using ASN.1 format, so you want {@link org.bitcoinj.core.ECKey.ECDSASignature#toASN1()}
     ; instead.  However sometimes the independent components can be useful, for instance, if you're going to do
     ; further EC maths on them.
     ; @throws KeyCrypterException if this ECKey doesn't have a private part.
     ;;
#_public
    ECDSASignature sign(Sha256Hash input)
        throws KeyCrypterException
    (§
        return sign(input, nil);
    )

    ;;;
     ; If this global variable is set to true, sign() creates a dummy signature and verify() always returns true.
     ; This is intended to help accelerate unit tests that do a lot of signing/verifying, which in the debugger
     ; can be painfully slow.
     ;;
#_testing
#_public
#_static
    boolean FAKE_SIGNATURES = false;

    ;;;
     ; Signs the given hash and returns the R and S components as BigIntegers.  In the Bitcoin protocol, they are
     ; usually encoded using DER format, so you want {@link org.bitcoinj.core.ECKey.ECDSASignature#encodeToDER()}
     ; instead.  However sometimes the independent components can be useful, for instance, if you're doing to do further
     ; EC maths on them.
     ;
     ; @param aesKey The AES key to use for decryption of the private key.  If null, then no decryption is required.
     ; @throws KeyCrypterException if there's something wrong with aesKey.
     ; @throws ECKey.MissingPrivateKeyException if this key cannot sign because it's pubkey only.
     ;;
#_public
    ECDSASignature sign(Sha256Hash input, #_nilable KeyParameter aesKey)
        throws KeyCrypterException
    (§
        KeyCrypter crypter = getKeyCrypter();
        if (crypter != nil)
        (§
            if (aesKey == nil)
                throw new KeyIsEncryptedException();
            return decrypt(aesKey).sign(input);
        )
        else
        (§
            ;; No decryption of private key required.
            if (priv == nil)
                throw new MissingPrivateKeyException();
        )
        return doSign(input, priv);
    )

#_protected
    ECDSASignature doSign(Sha256Hash input, BigInteger privateKeyForSigning)
    (§
        if (FAKE_SIGNATURES)
            return TransactionSignature.dummy();

        Preconditions.checkNotNull(privateKeyForSigning);

        ECDSASigner signer = new ECDSASigner(new HMacDSAKCalculator(new SHA256Digest()));
        ECPrivateKeyParameters privKey = new ECPrivateKeyParameters(privateKeyForSigning, CURVE);
        signer.init(true, privKey);
        BigInteger[] components = signer.generateSignature(input.getBytes());
        return new ECDSASignature(components[0], components[1]).toCanonicalised();
    )

    ;;;
     ; <p>Verifies the given ECDSA signature against the message bytes using the public key bytes.</p>
     ;
     ; <p>When using native ECDSA verification, data must be 32 bytes, and no element may be
     ; larger than 520 bytes.</p>
     ;
     ; @param data      Hash of the data to verify.
     ; @param signature ASN.1 encoded signature.
     ; @param pub       The public key bytes to use.
     ;;
#_public
#_static
    boolean verify(byte[] data, ECDSASignature signature, byte[] pub)
    (§
        if (FAKE_SIGNATURES)
            return true;

        ECDSASigner signer = new ECDSASigner();
        ECPublicKeyParameters params = new ECPublicKeyParameters(CURVE.getCurve().decodePoint(pub), CURVE);
        signer.init(false, params);
        try
        (§
            return signer.verifySignature(data, signature.r, signature.s);
        )
        catch (NullPointerException e)
        (§
            ;; Bouncy Castle contains a bug that can cause NPEs given specially crafted signatures.  Those signatures
            ;; are inherently invalid/attack sigs so we just fail them here rather than crash the thread.
            log.error("Caught NPE inside bouncy castle", e);
            return false;
        )
    )

    ;;;
     ; Verifies the given ASN.1 encoded ECDSA signature against a hash using the public key.
     ;
     ; @param data      Hash of the data to verify.
     ; @param signature ASN.1 encoded signature.
     ; @param pub       The public key bytes to use.
     ;;
#_public
#_static
    boolean verify(byte[] data, byte[] signature, byte[] pub)
    (§
        return verify(data, ECDSASignature.decodeFromDER(signature), pub);
    )

    ;;;
     ; Verifies the given ASN.1 encoded ECDSA signature against a hash using the public key.
     ;
     ; @param hash      Hash of the data to verify.
     ; @param signature ASN.1 encoded signature.
     ;;
#_public
    boolean verify(byte[] hash, byte[] signature)
    (§
        return ECKey.verify(hash, signature, getPubKey());
    )

    ;;;
     ; Verifies the given R/S pair (signature) against a hash using the public key.
     ;;
#_public
    boolean verify(Sha256Hash sigHash, ECDSASignature signature)
    (§
        return ECKey.verify(sigHash.getBytes(), signature, getPubKey());
    )

    ;;;
     ; Verifies the given ASN.1 encoded ECDSA signature against a hash using the public key, and throws an exception
     ; if the signature doesn't match.
     ; @throws java.security.SignatureException if the signature does not match.
     ;;
#_public
    void verifyOrThrow(byte[] hash, byte[] signature)
        throws SignatureException
    (§
        if (!verify(hash, signature))
            throw new SignatureException();
    )

    ;;;
     ; Verifies the given R/S pair (signature) against a hash using the public key, and throws an exception
     ; if the signature doesn't match.
     ; @throws java.security.SignatureException if the signature does not match.
     ;;
#_public
    void verifyOrThrow(Sha256Hash sigHash, ECDSASignature signature)
        throws SignatureException
    (§
        if (!ECKey.verify(sigHash.getBytes(), signature, getPubKey()))
            throw new SignatureException();
    )

    ;;;
     ; Returns true if the given pubkey is canonical, i.e. the correct length taking into account compression.
     ;;
#_public
#_static
    boolean isPubKeyCanonical(byte[] pubkey)
    (§
        if (pubkey.length < 33)
            return false;
        ;; Uncompressed pubkey.
        if (pubkey[0] == 0x04)
            return (pubkey.length == 65);
        ;; Compressed pubkey.
        if (pubkey[0] == 0x02 || pubkey[0] == 0x03)
            return (pubkey.length == 33);
        return false;
    )

#_private
#_static
    ECKey extractKeyFromASN1(byte[] asn1privkey)
    (§
        ;; To understand this code, see the definition of the ASN.1 format for EC private keys in the OpenSSL source
        ;; code in ec_asn1.c:
        ;;
        ;; ASN1_SEQUENCE(EC_PRIVATEKEY) = {
        ;;   ASN1_SIMPLE(EC_PRIVATEKEY, version, LONG),
        ;;   ASN1_SIMPLE(EC_PRIVATEKEY, privateKey, ASN1_OCTET_STRING),
        ;;   ASN1_EXP_OPT(EC_PRIVATEKEY, parameters, ECPKPARAMETERS, 0),
        ;;   ASN1_EXP_OPT(EC_PRIVATEKEY, publicKey, ASN1_BIT_STRING, 1)
        ;; } ASN1_SEQUENCE_END(EC_PRIVATEKEY)
        try
        (§
            ASN1InputStream decoder = new ASN1InputStream(asn1privkey);
            DLSequence seq = (DLSequence)decoder.readObject();
            Preconditions.checkArgument(decoder.readObject() == nil, "Input contains extra bytes");
            decoder.close();

            Preconditions.checkArgument(seq.size() == 4, "Input does not appear to be an ASN.1 OpenSSL EC private key");

            Preconditions.checkArgument(((ASN1Integer)seq.getObjectAt(0)).getValue().equals(BigInteger.ONE), "Input is of wrong version");

            byte[] privbits = ((ASN1OctetString)seq.getObjectAt(1)).getOctets();
            BigInteger privkey = new BigInteger(1, privbits);

            ASN1TaggedObject pubkey = (ASN1TaggedObject)seq.getObjectAt(3);
            Preconditions.checkArgument(pubkey.getTagNo() == 1, "Input has 'publicKey' with bad tag number");
            byte[] pubbits = ((DERBitString)pubkey.getObject()).getBytes();
            Preconditions.checkArgument(pubbits.length == 33 || pubbits.length == 65, "Input has 'publicKey' with invalid length");
            int encoding = pubbits[0] & 0xff;
            ;; Only allow compressed(2,3) and uncompressed(4), not infinity(0) or hybrid(6,7).
            Preconditions.checkArgument(2 <= encoding && encoding <= 4, "Input has 'publicKey' with invalid encoding");

            ;; Now sanity check to ensure the pubkey bytes match the privkey.
            boolean compressed = (pubbits.length == 33);
            ECKey key = new ECKey(privkey, nil, compressed);
            if (!Arrays.equals(key.getPubKey(), pubbits))
                throw new IllegalArgumentException("Public key in ASN.1 structure does not match private key.");
            return key;
        )
        catch (IOException e)
        (§
            throw new RuntimeException(e); ;; Cannot happen, reading from memory stream.
        )
    )

    ;;;
     ; Signs a text message using the standard Bitcoin messaging signing format and returns the signature as a base64
     ; encoded string.
     ;
     ; @throws IllegalStateException if this ECKey does not have the private part.
     ; @throws KeyCrypterException if this ECKey is encrypted and no AESKey is provided or it does not decrypt the ECKey.
     ;;
#_public
    String signMessage(String message)
        throws KeyCrypterException
    (§
        return signMessage(message, nil);
    )

    ;;;
     ; Signs a text message using the standard Bitcoin messaging signing format and returns the signature as a base64
     ; encoded string.
     ;
     ; @throws IllegalStateException if this ECKey does not have the private part.
     ; @throws KeyCrypterException if this ECKey is encrypted and no AESKey is provided or it does not decrypt the ECKey.
     ;;
#_public
    String signMessage(String message, #_nilable KeyParameter aesKey)
        throws KeyCrypterException
    (§
        byte[] data = Utils.formatMessageForSigning(message);
        Sha256Hash hash = Sha256Hash.twiceOf(data);
        ECDSASignature sig = sign(hash, aesKey);
        ;; Now we have to work backwards to figure out the recId needed to recover the signature.
        int recId = -1;
        for (int i = 0; i < 4; i++)
        (§
            ECKey k = ECKey.recoverFromSignature(i, sig, hash, isCompressed());
            if (k != nil && k.pub.equals(pub))
            (§
                recId = i;
                break;
            )
        )
        if (recId == -1)
            throw new RuntimeException("Could not construct a recoverable key. This should never happen.");
        int headerByte = recId + 27 + (isCompressed() ? 4 : 0);
        byte[] sigData = new byte[65]; ;; 1 header + 32 bytes for R + 32 bytes for S
        sigData[0] = (byte)headerByte;
        System.arraycopy(Utils.bigIntegerToBytes(sig.r, 32), 0, sigData, 1, 32);
        System.arraycopy(Utils.bigIntegerToBytes(sig.s, 32), 0, sigData, 33, 32);
        return new String(Base64.encode(sigData), Charset.forName("UTF-8"));
    )

    ;;;
     ; Given an arbitrary piece of text and a Bitcoin-format message signature encoded in base64, returns an ECKey
     ; containing the public key that was used to sign it.  This can then be compared to the expected public key to
     ; determine if the signature was correct.  These sorts of signatures are compatible with the Bitcoin-Qt/bitcoind
     ; format generated by signmessage/verifymessage RPCs and GUI menu options.  They are intended for humans to verify
     ; their communications with each other, hence the base64 format and the fact that the input is text.
     ;
     ; @param message Some piece of human readable text.
     ; @param signatureBase64 The Bitcoin-format message signature in base64.
     ; @throws SignatureException if the public key could not be recovered or if there was a signature format error.
     ;;
#_public
#_static
    ECKey signedMessageToKey(String message, String signatureBase64)
        throws SignatureException
    (§
        byte[] signatureEncoded;
        try
        (§
            signatureEncoded = Base64.decode(signatureBase64);
        )
        catch (RuntimeException e)
        (§
            ;; This is what you get back from Bouncy Castle if base64 doesn't decode :(
            throw new SignatureException("Could not decode base64", e);
        )
        ;; Parse the signature bytes into r/s and the selector value.
        if (signatureEncoded.length < 65)
            throw new SignatureException("Signature truncated, expected 65 bytes and got " + signatureEncoded.length);
        int header = signatureEncoded[0] & 0xff;
        ;; The header byte: 0x1B = first key with even y, 0x1C = first key with odd y,
        ;;                  0x1D = second key with even y, 0x1E = second key with odd y.
        if (header < 27 || 34 < header)
            throw new SignatureException("Header byte out of range: " + header);
        BigInteger r = new BigInteger(1, Arrays.copyOfRange(signatureEncoded, 1, 33));
        BigInteger s = new BigInteger(1, Arrays.copyOfRange(signatureEncoded, 33, 65));
        ECDSASignature sig = new ECDSASignature(r, s);
        byte[] messageBytes = Utils.formatMessageForSigning(message);
        ;; Note that the C++ code doesn't actually seem to specify any character encoding.
        ;; Presumably it's whatever JSON-SPIRIT hands back.  Assume UTF-8 for now.
        Sha256Hash messageHash = Sha256Hash.twiceOf(messageBytes);
        boolean compressed = false;
        if (31 <= header)
        (§
            compressed = true;
            header -= 4;
        )
        int recId = header - 27;
        ECKey key = ECKey.recoverFromSignature(recId, sig, messageHash, compressed);
        if (key == nil)
            throw new SignatureException("Could not recover public key from signature");
        return key;
    )

    ;;;
     ; Convenience wrapper around {@link ECKey#signedMessageToKey(String, String)}.
     ; If the key derived from the signature is not the same as this one, throws a SignatureException.
     ;;
#_public
    void verifyMessage(String message, String signatureBase64)
        throws SignatureException
    (§
        ECKey key = ECKey.signedMessageToKey(message, signatureBase64);
        if (!key.pub.equals(pub))
            throw new SignatureException("Signature did not match for message");
    )

    ;;;
     ; <p>Given the components of a signature and a selector value, recover and return the public key
     ; that generated the signature according to the algorithm in SEC1v2 section 4.1.6.</p>
     ;
     ; <p>The recId is an index from 0 to 3 which indicates which of the 4 possible keys is the correct one.  Because
     ; the key recovery operation yields multiple potential keys, the correct key must either be stored alongside the
     ; signature, or you must be willing to try each recId in turn until you find one that outputs the key you are
     ; expecting.</p>
     ;
     ; <p>If this method returns null it means recovery was not possible and recId should be iterated.</p>
     ;
     ; <p>Given the above two points, a correct usage of this method is inside a for loop from 0 to 3, and if the
     ; output is null OR a key that is not the one you expect, you try again with the next recId.</p>
     ;
     ; @param recId Which possible key to recover.
     ; @param sig The R and S components of the signature, wrapped.
     ; @param message Hash of the data that was signed.
     ; @param compressed Whether or not the original pubkey was compressed.
     ; @return An ECKey containing only the public part, or null if recovery wasn't possible.
     ;;
#_nilable
#_public
#_static
    ECKey recoverFromSignature(int recId, ECDSASignature sig, Sha256Hash message, boolean compressed)
    (§
        Preconditions.checkArgument(0 <= recId, "recId must be positive");
        Preconditions.checkArgument(0 <= sig.r.signum(), "r must be positive");
        Preconditions.checkArgument(0 <= sig.s.signum(), "s must be positive");
        Preconditions.checkNotNull(message);

        ;; 1.0 For j from 0 to h   (h == recId here and the loop is outside this function)
        ;;   1.1 Let x = r + jn
        BigInteger n = CURVE.getN(); ;; Curve order.
        BigInteger i = BigInteger.valueOf((long)recId / 2);
        BigInteger x = sig.r.add(i.multiply(n));
        ;;   1.2. Convert the integer x to an octet string X of length mlen using the conversion routine
        ;;        specified in Section 2.3.7, where mlen = ⌈(log2 p)/8⌉ or mlen = ⌈m/8⌉.
        ;;   1.3. Convert the octet string (16 set binary digits)||X to an elliptic curve point R using the
        ;;        conversion routine specified in Section 2.3.4. If this conversion routine outputs “invalid”,
        ;;        then do another iteration of Step 1.
        ;;
        ;; More concisely, what these points mean is to use X as a compressed public key.
        BigInteger prime = SecP256K1Curve.q;
        ;; Cannot have point co-ordinates larger than this as everything takes place modulo Q.
        if (0 <= x.compareTo(prime))
            return nil;

        ;; Compressed keys require you to know an extra bit of data about the y-coord as there are two possibilities.
        ;; So it's encoded in the recId.
        ECPoint R = decompressKey(x, (recId & 1) == 1);
        ;;   1.4. If nR != point at infinity, then do another iteration of Step 1 (callers responsibility).
        if (!R.multiply(n).isInfinity())
            return nil;

        ;;   1.5. Compute e from M using Steps 2 and 3 of ECDSA signature verification.
        BigInteger e = message.toBigInteger();
        ;;   1.6. For k from 1 to 2 do the following.   (loop is outside this function via iterating recId)
        ;;   1.6.1. Compute a candidate public key as:
        ;;               Q = mi(r) * (sR - eG)
        ;;
        ;; Where mi(x) is the modular multiplicative inverse. We transform this into the following:
        ;;               Q = (mi(r) * s ** R) + (mi(r) * -e ** G)
        ;; Where -e is the modular additive inverse of e, that is z such that z + e = 0 (mod n). In the above equation
        ;; ** is point multiplication and + is point addition (the EC group operator).
        ;;
        ;; We can find the additive inverse by subtracting e from zero then taking the mod. For example the additive
        ;; inverse of 3 modulo 11 is 8 because 3 + 8 mod 11 = 0, and -3 mod 11 = 8.
        BigInteger eInv = BigInteger.ZERO.subtract(e).mod(n);
        BigInteger rInv = sig.r.modInverse(n);
        BigInteger srInv = rInv.multiply(sig.s).mod(n);
        BigInteger eInvrInv = rInv.multiply(eInv).mod(n);
        ECPoint q = ECAlgorithms.sumOfTwoMultiplies(CURVE.getG(), eInvrInv, R, srInv);
        return ECKey.fromPublicOnly(q.getEncoded(compressed));
    )

    ;;; Decompress a compressed public key (x co-ord and low-bit of y-coord). ;;
#_private
#_static
    ECPoint decompressKey(BigInteger xBN, boolean yBit)
    (§
        X9IntegerConverter x9 = new X9IntegerConverter();
        byte[] compEnc = x9.integerToBytes(xBN, 1 + x9.getByteLength(CURVE.getCurve()));
        compEnc[0] = (byte)(yBit ? 0x03 : 0x02);
        return CURVE.getCurve().decodePoint(compEnc);
    )

    ;;;
     ; Returns a 32 byte array containing the private key.
     ; @throws org.bitcoinj.core.ECKey.MissingPrivateKeyException if the private key bytes are missing/encrypted.
     ;;
#_public
    byte[] getPrivKeyBytes()
    (§
        return Utils.bigIntegerToBytes(getPrivKey(), 32);
    )

    ;;;
     ; Returns the creation time of this key or zero if the key was deserialized from a version that did not store
     ; that data.
     ;;
#_override
#_public
    long getCreationTimeSeconds()
    (§
        return creationTimeSeconds;
    )

    ;;;
     ; Sets the creation time of this key.  Zero is a convention to mean "unavailable".  This method can be useful when
     ; you have a raw key you are importing from somewhere else.
     ;;
#_public
    void setCreationTimeSeconds(long newCreationTimeSeconds)
    (§
        if (newCreationTimeSeconds < 0)
            throw new IllegalArgumentException("Cannot set creation time to negative value: " + newCreationTimeSeconds);
        creationTimeSeconds = newCreationTimeSeconds;
    )

    ;;;
     ; Create an encrypted private key with the keyCrypter and the AES key supplied.
     ; This method returns a new encrypted key and leaves the original unchanged.
     ;
     ; @param keyCrypter The keyCrypter that specifies exactly how the encrypted bytes are created.
     ; @param aesKey The KeyParameter with the AES encryption key (usually constructed with keyCrypter#deriveKey and cached as it is slow to create).
     ; @return encryptedKey
     ;;
#_public
    ECKey encrypt(KeyCrypter keyCrypter, KeyParameter aesKey)
        throws KeyCrypterException
    (§
        Preconditions.checkNotNull(keyCrypter);

#_final
        byte[] privKeyBytes = getPrivKeyBytes();
        EncryptedData encryptedPrivateKey = keyCrypter.encrypt(privKeyBytes, aesKey);
        ECKey result = ECKey.fromEncrypted(encryptedPrivateKey, keyCrypter, getPubKey());
        result.setCreationTimeSeconds(creationTimeSeconds);
        return result;
    )

    ;;;
     ; Create a decrypted private key with the keyCrypter and AES key supplied.  Note that if the aesKey is wrong, this
     ; has some chance of throwing KeyCrypterException due to the corrupted padding that will result, but it can also
     ; just yield a garbage key.
     ;
     ; @param keyCrypter The keyCrypter that specifies exactly how the decrypted bytes are created.
     ; @param aesKey The KeyParameter with the AES encryption key (usually constructed with keyCrypter#deriveKey and cached).
     ;;
#_public
    ECKey decrypt(KeyCrypter keyCrypter, KeyParameter aesKey)
        throws KeyCrypterException
    (§
        Preconditions.checkNotNull(keyCrypter);

        ;; Check that the keyCrypter matches the one used to encrypt the keys, if set.
        if (this.keyCrypter != nil && !this.keyCrypter.equals(keyCrypter))
            throw new KeyCrypterException("The keyCrypter being used to decrypt the key is different to the one that was used to encrypt it");

        Preconditions.checkState(encryptedPrivateKey != nil, "This key is not encrypted");

        byte[] unencryptedPrivateKey = keyCrypter.decrypt(encryptedPrivateKey, aesKey);
        ECKey key = ECKey.fromPrivate(unencryptedPrivateKey);
        if (!isCompressed())
            key = key.decompress();
        if (!Arrays.equals(key.getPubKey(), getPubKey()))
            throw new KeyCrypterException("Provided AES key is wrong");

        key.setCreationTimeSeconds(creationTimeSeconds);
        return key;
    )

    ;;;
     ; Create a decrypted private key with AES key.  Note that if the AES key is wrong, this
     ; has some chance of throwing KeyCrypterException due to the corrupted padding that will result, but it can also
     ; just yield a garbage key.
     ;
     ; @param aesKey The KeyParameter with the AES encryption key (usually constructed with keyCrypter#deriveKey and cached).
     ;;
#_public
    ECKey decrypt(KeyParameter aesKey)
        throws KeyCrypterException
    (§
#_final
        KeyCrypter crypter = getKeyCrypter();
        if (crypter == nil)
            throw new KeyCrypterException("No key crypter available");

        return decrypt(crypter, aesKey);
    )

    ;;;
     ; Creates decrypted private key if needed.
     ;;
#_public
    ECKey maybeDecrypt(#_nilable KeyParameter aesKey)
        throws KeyCrypterException
    (§
        return (isEncrypted() && aesKey != nil) ? decrypt(aesKey) : this;
    )

    ;;;
     ; <p>Check that it is possible to decrypt the key with the keyCrypter and that the original key is returned.</p>
     ;
     ; <p>Because it is a critical failure if the private keys cannot be decrypted successfully (resulting of loss of
     ; all bitcoins controlled by the private key) you can use this method to check when you *encrypt* a wallet that
     ; it can definitely be decrypted successfully.</p>
     ;
     ; <p>See {@link Wallet#encrypt(KeyCrypter keyCrypter, KeyParameter aesKey)} for example usage.</p>
     ;
     ; @return true if the encrypted key can be decrypted back to the original key successfully.
     ;;
#_public
#_static
    boolean encryptionIsReversible(ECKey originalKey, ECKey encryptedKey, KeyCrypter keyCrypter, KeyParameter aesKey)
    (§
        try
        (§
            ECKey rebornUnencryptedKey = encryptedKey.decrypt(keyCrypter, aesKey);
            byte[] originalPrivateKeyBytes = originalKey.getPrivKeyBytes();
            byte[] rebornKeyBytes = rebornUnencryptedKey.getPrivKeyBytes();
            if (!Arrays.equals(originalPrivateKeyBytes, rebornKeyBytes))
            (§
                log.error("The check that encryption could be reversed failed for {}", originalKey);
                return false;
            )
            return true;
        )
        catch (KeyCrypterException kce)
        (§
            log.error(kce.getMessage());
            return false;
        )
    )

    ;;;
     ; Indicates whether the private key is encrypted (true) or not (false).
     ; A private key is deemed to be encrypted when there is both a KeyCrypter and the encryptedPrivateKey is non-zero.
     ;;
#_override
#_public
    boolean isEncrypted()
    (§
        return (keyCrypter != nil && encryptedPrivateKey != nil && 0 < encryptedPrivateKey.encryptedBytes.length);
    )

#_nilable
#_override
#_public
    Protos.Wallet.EncryptionType getEncryptionType()
    (§
        return (keyCrypter != nil) ? keyCrypter.getUnderstoodEncryptionType() : Protos.Wallet.EncryptionType.UNENCRYPTED;
    )

    ;;;
     ; A wrapper for {@link #getPrivKeyBytes()} that returns null if the private key bytes are missing or would have
     ; to be derived (for the HD key case).
     ;;
#_override
#_nilable
#_public
    byte[] getSecretBytes()
    (§
        if (hasPrivKey())
            return getPrivKeyBytes();

        return nil;
    )

    ;;; An alias for {@link #getEncryptedPrivateKey()}. ;;
#_nilable
#_override
#_public
    EncryptedData getEncryptedData()
    (§
        return getEncryptedPrivateKey();
    )

    ;;;
     ; Returns the the encrypted private key bytes and initialisation vector for this ECKey, or null if the ECKey
     ; is not encrypted.
     ;;
#_nilable
#_public
    EncryptedData getEncryptedPrivateKey()
    (§
        return encryptedPrivateKey;
    )

    ;;;
     ; Returns the KeyCrypter that was used to encrypt to encrypt this ECKey.  You need this to decrypt the ECKey.
     ;;
#_nilable
#_public
    KeyCrypter getKeyCrypter()
    (§
        return keyCrypter;
    )

#_public
#_static
    class MissingPrivateKeyException extends RuntimeException
    (§
    )

#_public
#_static
    class KeyIsEncryptedException extends MissingPrivateKeyException
    (§
    )

#_override
#_public
    boolean equals(Object o)
    (§
        if (this == o)
            return true;
        if (o == nil || !(o instanceof ECKey))
            return false;
        ECKey other = (ECKey)o;
        return Objects.equal(this.priv, other.priv)
            && Objects.equal(this.pub, other.pub)
            && Objects.equal(this.creationTimeSeconds, other.creationTimeSeconds)
            && Objects.equal(this.keyCrypter, other.keyCrypter)
            && Objects.equal(this.encryptedPrivateKey, other.encryptedPrivateKey);
    )

#_override
#_public
    int hashCode()
    (§
        return pub.hashCode();
    )

#_override
#_public
    String toString()
    (§
        return toString(false, nil);
    )

    ;;;
     ; Produce a string rendering of the ECKey INCLUDING the private key.
     ; Unless you absolutely need the private key it is better for security reasons to just use {@link #toString()}.
     ;;
#_public
    String toStringWithPrivate(NetworkParameters params)
    (§
        return toString(true, params);
    )

#_public
    String getPrivateKeyAsHex()
    (§
        return Utils.HEX.encode(getPrivKeyBytes());
    )

#_public
    String getPublicKeyAsHex()
    (§
        return Utils.HEX.encode(pub.getEncoded());
    )

#_private
    String toString(boolean includePrivate, NetworkParameters params)
    (§
#_final
        MoreObjects.ToStringHelper helper = MoreObjects.toStringHelper(this).omitNullValues();
        helper.add("pub HEX", getPublicKeyAsHex());
        if (includePrivate)
        (§
            try
            (§
                helper.add("priv HEX", getPrivateKeyAsHex());
            )
            catch (IllegalStateException _)
            (§
                ;; TODO: Make hasPrivKey() work for deterministic keys and fix this.
            )
            catch (Exception e)
            (§
#_final
                String message = e.getMessage();
                helper.add("priv EXCEPTION", e.getClass().getName() + (message != nil ? ": " + message : ""));
            )
        )
        if (0 < creationTimeSeconds)
            helper.add("creationTimeSeconds", creationTimeSeconds);
        helper.add("keyCrypter", keyCrypter);
        if (includePrivate)
            helper.add("encryptedPrivateKey", encryptedPrivateKey);
        helper.add("isEncrypted", isEncrypted());
        helper.add("isPubKeyOnly", isPubKeyOnly());
        return helper.toString();
    )

#_public
    void formatKeyWithAddress(boolean includePrivateKeys, StringBuilder sb, NetworkParameters params)
    (§
#_final
        Address address = toAddress(params);
        sb.append("  addr:");
        sb.append(address.toString());
        sb.append("  hash160:");
        sb.append(Utils.HEX.encode(getPubKeyHash()));
        if (0 < creationTimeSeconds)
            sb.append("  creationTimeSeconds:").append(creationTimeSeconds);
        sb.append("\n");
        if (includePrivateKeys)
        (§
            sb.append("  ");
            sb.append(toStringWithPrivate(params));
            sb.append("\n");
        )
    )
)

(ns org.bitcoinj.core #_"EmptyMessage"
    (:import [java.io IOException OutputStream]))

;;;
 ; <p>Parent class for header only messages that don't have a payload.
 ; Currently this includes getaddr, verack and special bitcoinj class UnknownMessage.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
#_abstract
class EmptyMessage extends Message
(§
#_public
    EmptyMessage()
    (§
        length = 0;
    )

#_public
    EmptyMessage(NetworkParameters params)
    (§
        super(params);
        length = 0;
    )

#_public
    EmptyMessage(NetworkParameters params, byte[] payload, int offset)
        throws ProtocolException
    (§
        super(params, payload, offset);
        length = 0;
    )

#_override
#_protected
#_final
    void bitcoinSerializeToStream(OutputStream stream)
        throws IOException
    (§
    )

#_override
#_protected
    void parse()
        throws ProtocolException
    (§
    )

#_override
#_public
    byte[] bitcoinSerialize()
    (§
        return new byte[0];
    )
)

(ns org.bitcoinj.core #_"FilteredBlock"
    (:import [java.io IOException OutputStream]
             #_[java.util *])
    (:import [com.google.common.base Objects]))

;;;
 ; <p>A FilteredBlock is used to relay a block with its transactions filtered using a {@link BloomFilter}.  It consists
 ; of the block header and a {@link PartialMerkleTree} which contains the transactions which matched the filter.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
class FilteredBlock extends Message
(§
#_private
    Block header;

#_private
    PartialMerkleTree merkleTree;
#_private
    List<Sha256Hash> cachedTransactionHashes;

    ;; A set of transactions whose hashes are a subset of getTransactionHashes().
    ;; These were relayed as a part of the filteredblock getdata, i.e. likely weren't previously received as loose transactions.
#_private
    Map<Sha256Hash, Transaction> associatedTransactions = new HashMap<>();

#_public
    FilteredBlock(NetworkParameters params, byte[] payloadBytes)
        throws ProtocolException
    (§
        super(params, payloadBytes, 0);
    )

#_public
    FilteredBlock(NetworkParameters params, Block header, PartialMerkleTree pmt)
    (§
        super(params);
        this.header = header;
        this.merkleTree = pmt;
    )

#_override
#_public
    void bitcoinSerializeToStream(OutputStream stream)
        throws IOException
    (§
        if (header.transactions == nil)
            header.bitcoinSerializeToStream(stream);
        else
            header.cloneAsHeader().bitcoinSerializeToStream(stream);
        merkleTree.bitcoinSerializeToStream(stream);
    )

#_override
#_protected
    void parse()
        throws ProtocolException
    (§
        byte[] headerBytes = new byte[Block.HEADER_SIZE];
        System.arraycopy(payload, 0, headerBytes, 0, Block.HEADER_SIZE);
        header = params.getDefaultSerializer().makeBlock(headerBytes);

        merkleTree = new PartialMerkleTree(params, payload, Block.HEADER_SIZE);

        length = Block.HEADER_SIZE + merkleTree.getMessageSize();
    )

    ;;;
     ; Gets a list of leaf hashes which are contained in the partial merkle tree in this filtered block.
     ;
     ; @throws ProtocolException if the partial merkle block is invalid or the merkle root of the partial merkle block doesnt match the block header.
     ;;
#_public
    List<Sha256Hash> getTransactionHashes()
        throws VerificationException
    (§
        if (cachedTransactionHashes != nil)
            return Collections.unmodifiableList(cachedTransactionHashes);

        List<Sha256Hash> hashesMatched = new LinkedList<>();
        if (header.getMerkleRoot().equals(merkleTree.getTxnHashAndMerkleRoot(hashesMatched)))
        (§
            cachedTransactionHashes = hashesMatched;
            return Collections.unmodifiableList(cachedTransactionHashes);
        )

        throw new VerificationException("Merkle root of block header does not match merkle root of partial merkle tree.");
    )

    ;;;
     ; Gets a copy of the block header.
     ;;
#_public
    Block getBlockHeader()
    (§
        return header.cloneAsHeader();
    )

    ;;; Gets the hash of the block represented in this FilteredBlock. ;;
#_override
#_public
    Sha256Hash getHash()
    (§
        return header.getHash();
    )

    ;;;
     ; Provide this FilteredBlock with a transaction which is in its Merkle tree.
     ; @return false if the tx is not relevant to this FilteredBlock.
     ;;
#_public
    boolean provideTransaction(Transaction tx)
        throws VerificationException
    (§
        Sha256Hash hash = tx.getHash();
        if (getTransactionHashes().contains(hash))
        (§
            associatedTransactions.put(hash, tx);
            return true;
        )
        return false;
    )

    ;;; Returns the {@link PartialMerkleTree} object that provides the mathematical proof of transaction inclusion in the block. ;;
#_public
    PartialMerkleTree getPartialMerkleTree()
    (§
        return merkleTree;
    )

    ;;; Gets the set of transactions which were provided using provideTransaction() which match in getTransactionHashes(). ;;
#_public
    Map<Sha256Hash, Transaction> getAssociatedTransactions()
    (§
        return Collections.unmodifiableMap(associatedTransactions);
    )

    ;;; Number of transactions in this block, before it was filtered. ;;
#_public
    int getTransactionCount()
    (§
        return merkleTree.getTransactionCount();
    )

#_override
#_public
    boolean equals(Object o)
    (§
        if (this == o)
            return true;
        if (o == nil || getClass() != o.getClass())
            return false;
        FilteredBlock other = (FilteredBlock)o;
        return (associatedTransactions.equals(other.associatedTransactions) && header.equals(other.header) && merkleTree.equals(other.merkleTree));
    )

#_override
#_public
    int hashCode()
    (§
        return Objects.hashCode(associatedTransactions, header, merkleTree);
    )

#_override
#_public
    String toString()
    (§
        return "FilteredBlock{merkleTree=" + merkleTree + ", header=" + header + '}';
    )
)

(ns org.bitcoinj.core #_"FullPrunedBlockChain"
    (:import [java.util ArrayList LinkedList List ListIterator Set]
             #_[java.util.concurrent *])
    (:import [com.google.common.base Preconditions]
             [org.slf4j Logger LoggerFactory])
  #_(:require [org.bitcoinj.script Script]
             [org.bitcoinj.script.Script VerifyFlag]
             [org.bitcoinj.store BlockStoreException FullPrunedBlockStore]
             #_[org.bitcoinj.utils *]
             [org.bitcoinj.wallet Wallet]))

;;;
 ; <p>A FullPrunedBlockChain works in conjunction with a {@link FullPrunedBlockStore} to verify all the rules of the
 ; Bitcoin system, with the downside being a large cost in system resources.  Fully verifying means all unspent
 ; transaction outputs are stored.  Once a transaction output is spent and that spend is buried deep enough, the data
 ; related to it is deleted to ensure disk space usage doesn't grow forever.  For this reason a pruning node cannot
 ; serve the full block chain to other clients, but it nevertheless provides the same security guarantees as Bitcoin
 ; Core does.</p>
 ;;
#_public
class FullPrunedBlockChain extends AbstractBlockChain
(§
#_private
#_static
#_final
    Logger log = LoggerFactory.getLogger(FullPrunedBlockChain.class);

    ;;;
     ; Keeps a map of block hashes to StoredBlocks.
     ;;
#_protected
#_final
    FullPrunedBlockStore blockStore;

    ;; Whether or not to execute scriptPubKeys before accepting a transaction (i.e. check signatures).
#_private
    boolean runScripts = true;

    ;;;
     ; Constructs a block chain connected to the given wallet and store.  To obtain a {@link Wallet} you can construct
     ; one from scratch, or you can deserialize a saved wallet from disk using {@link Wallet#loadFromFile(java.io.File)}.
     ;;
#_public
    FullPrunedBlockChain(Context context, Wallet wallet, FullPrunedBlockStore blockStore)
        throws BlockStoreException
    (§
        this(context, new ArrayList<Wallet>(), blockStore);
        addWallet(wallet);
    )

    ;;;
     ; Constructs a block chain connected to the given wallet and store.  To obtain a {@link Wallet} you can construct
     ; one from scratch, or you can deserialize a saved wallet from disk using {@link Wallet#loadFromFile(java.io.File)}.
     ;;
#_public
    FullPrunedBlockChain(NetworkParameters params, Wallet wallet, FullPrunedBlockStore blockStore)
        throws BlockStoreException
    (§
        this(Context.getOrCreate(params), wallet, blockStore);
    )

    ;;;
     ; Constructs a block chain connected to the given store.
     ;;
#_public
    FullPrunedBlockChain(Context context, FullPrunedBlockStore blockStore)
        throws BlockStoreException
    (§
        this(context, new ArrayList<Wallet>(), blockStore);
    )

    ;;;
     ; See {@link #FullPrunedBlockChain(Context, Wallet, FullPrunedBlockStore)}.
     ;;
#_public
    FullPrunedBlockChain(NetworkParameters params, FullPrunedBlockStore blockStore)
        throws BlockStoreException
    (§
        this(Context.getOrCreate(params), blockStore);
    )

    ;;;
     ; Constructs a block chain connected to the given list of wallets and a store.
     ;;
#_public
    FullPrunedBlockChain(Context context, List<Wallet> listeners, FullPrunedBlockStore blockStore)
        throws BlockStoreException
    (§
        super(context, listeners, blockStore);
        this.blockStore = blockStore;
        ;; Ignore upgrading for now.
        this.chainHead = blockStore.getVerifiedChainHead();
    )

    ;;;
     ; See {@link #FullPrunedBlockChain(Context, List, FullPrunedBlockStore)}.
     ;;
#_public
    FullPrunedBlockChain(NetworkParameters params, List<Wallet> listeners, FullPrunedBlockStore blockStore)
        throws BlockStoreException
    (§
        this(Context.getOrCreate(params), listeners, blockStore);
    )

#_override
#_protected
    StoredBlock addToBlockStore(StoredBlock storedPrev, Block header, TransactionOutputChanges txOutChanges)
        throws BlockStoreException, VerificationException
    (§
        StoredBlock newBlock = storedPrev.build(header);
        blockStore.put(newBlock, new StoredUndoableBlock(newBlock.getHeader().getHash(), txOutChanges));
        return newBlock;
    )

#_override
#_protected
    StoredBlock addToBlockStore(StoredBlock storedPrev, Block block)
        throws BlockStoreException, VerificationException
    (§
        StoredBlock newBlock = storedPrev.build(block);
        blockStore.put(newBlock, new StoredUndoableBlock(newBlock.getHeader().getHash(), block.transactions));
        return newBlock;
    )

#_override
#_protected
    void rollbackBlockStore(int height)
        throws BlockStoreException
    (§
        throw new BlockStoreException("Unsupported");
    )

#_override
#_protected
    boolean shouldVerifyTransactions()
    (§
        return true;
    )

    ;;;
     ; Whether or not to run scripts whilst accepting blocks (i.e. checking signatures, for most transactions).
     ; If you're accepting data from an untrusted node, such as one found via the P2P network, this should be set
     ; to true (which is the default).  If you're downloading a chain from a node you control, script execution
     ; is redundant because you know the connected node won't relay bad data to you.  In that case it's safe to set
     ; this to false and obtain a significant speedup.
     ;;
#_public
    void setRunScripts(boolean value)
    (§
        this.runScripts = value;
    )

    ;; TODO: Remove lots of duplicated code in the two connectTransactions.

    ;; TODO: Execute in order of largest transaction (by input count) first.
    ExecutorService scriptVerificationExecutor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors(), new ContextPropagatingThreadFactory("Script verification"));

    ;;;
     ; A job submitted to the executor which verifies signatures.
     ;;
#_private
#_static
    class Verifier implements Callable<VerificationException>
    (§
#_final
        Transaction tx;
#_final
        List<Script> prevOutScripts;
#_final
        Set<VerifyFlag> verifyFlags;

#_public
        Verifier(final Transaction tx, final List<Script> prevOutScripts, final Set<VerifyFlag> verifyFlags)
        (§
            this.tx = tx;
            this.prevOutScripts = prevOutScripts;
            this.verifyFlags = verifyFlags;
        )

#_nilable
#_override
#_public
        VerificationException call()
            throws Exception
        (§
            try
            (§
                ListIterator<Script> prevOutIt = prevOutScripts.listIterator();
                for (int index = 0; index < tx.getInputs().size(); index++)
                    tx.getInputs().get(index).getScriptSig().correctlySpends(tx, index, prevOutIt.next(), verifyFlags);
                return nil;
            )
            catch (VerificationException e)
            (§
                return e;
            )
        )
    )

    ;;;
     ; Get the {@link Script} from the script bytes or return Script of empty byte array.
     ;;
#_private
    Script getScript(byte[] scriptBytes)
    (§
        try
        (§
            return new Script(scriptBytes);
        )
        catch (Exception _)
        (§
            return new Script(new byte[0]);
        )
    )

    ;;;
     ; Get the address from the {@link Script} if it exists, otherwise return empty string "".
     ;
     ; @param script The script.
     ; @return The address.
     ;;
#_private
    String getScriptAddress(#_nilable Script script)
    (§
        String address = "";
        try
        (§
            if (script != nil)
                address = script.getToAddress(params, true).toString();
        )
        catch (Exception _)
        (§
        )
        return address;
    )

#_override
#_protected
    TransactionOutputChanges connectTransactions(int height, Block block)
        throws VerificationException, BlockStoreException
    (§
        Preconditions.checkState(lock.isHeldByCurrentThread());

        if (block.transactions == nil)
            throw new RuntimeException("connectTransactions called with Block that didn't have transactions!");
        if (!params.passesCheckpoint(height, block.getHash()))
            throw new VerificationException("Block failed checkpoint lockin at " + height);

        blockStore.beginDatabaseBatchWrite();

        LinkedList<UTXO> txOutsSpent = new LinkedList<>();
        LinkedList<UTXO> txOutsCreated = new LinkedList<>();
        long sigOps = 0;

        if (scriptVerificationExecutor.isShutdown())
            scriptVerificationExecutor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());

        List<Future<VerificationException>> listScriptVerificationResults = new ArrayList<>(block.transactions.size());
        try
        (§
            if (!params.isCheckpoint(height))
            (§
                ;; BIP30 violator blocks are ones that contain a duplicated transaction.  They are all in the checkpoints list
                ;; and we therefore only check non-checkpoints for duplicated transactions here.  See the BIP30 document
                ;; for more details on this: https://github.com/bitcoin/bips/blob/master/bip-0030.mediawiki
                for (Transaction tx : block.transactions)
                (§
#_final
                    Set<VerifyFlag> verifyFlags = params.getTransactionVerificationFlags(block, tx, getVersionTally(), height);
                    Sha256Hash hash = tx.getHash();
                    ;; If we already have unspent outputs for this hash, we saw the tx already.
                    ;; Either the block is being added twice (bug) or the block is a BIP30 violator.
                    if (blockStore.hasUnspentOutputs(hash, tx.getOutputs().size()))
                        throw new VerificationException("Block failed BIP30 test!");
                    ;; We already check non-BIP16 sigops in Block.verifyTransactions(true).
                    if (verifyFlags.contains(VerifyFlag.P2SH))
                        sigOps += tx.getSigOpCount();
                )
            )
            Coin totalFees = Coin.ZERO;
            Coin coinbaseValue = nil;
            for (final Transaction tx : block.transactions)
            (§
                boolean isCoinBase = tx.isCoinBase();
                Coin valueIn = Coin.ZERO;
                Coin valueOut = Coin.ZERO;
#_final
                List<Script> prevOutScripts = new LinkedList<>();
#_final
                Set<VerifyFlag> verifyFlags = params.getTransactionVerificationFlags(block, tx, getVersionTally(), height);
                if (!isCoinBase)
                (§
                    ;; For each input of the transaction remove the corresponding output from the set of unspent outputs.
                    for (int index = 0; index < tx.getInputs().size(); index++)
                    (§
                        TransactionInput in = tx.getInputs().get(index);
                        UTXO prevOut = blockStore.getTransactionOutput(in.getOutpoint().getHash(), in.getOutpoint().getIndex());
                        if (prevOut == nil)
                            throw new VerificationException("Attempted to spend a non-existent or already spent output!");
                        ;; Coinbases can't be spent until they mature, to avoid re-orgs destroying entire transaction chains.
                        ;; The assumption is there will ~never be re-orgs deeper than the spendable coinbase chain depth.
                        if (prevOut.isCoinbase())
                        (§
                            if (height - prevOut.getHeight() < params.getSpendableCoinbaseDepth())
                                throw new VerificationException("Tried to spend coinbase at depth " + (height - prevOut.getHeight()));
                        )
                        ;; TODO: Check we're not spending the genesis transaction here. Bitcoin Core won't allow it.
                        valueIn = valueIn.add(prevOut.getValue());
                        if (verifyFlags.contains(VerifyFlag.P2SH))
                        (§
                            if (prevOut.getScript().isPayToScriptHash())
                                sigOps += Script.getP2SHSigOpCount(in.getScriptBytes());
                            if (Block.MAX_BLOCK_SIGOPS < sigOps)
                                throw new VerificationException("Too many P2SH SigOps in block");
                        )

                        prevOutScripts.add(prevOut.getScript());
                        blockStore.removeUnspentTransactionOutput(prevOut);
                        txOutsSpent.add(prevOut);
                    )
                )
                Sha256Hash hash = tx.getHash();
                for (TransactionOutput out : tx.getOutputs())
                (§
                    valueOut = valueOut.add(out.getValue());
                    ;; For each output, add it to the set of unspent outputs so it can be consumed in future.
                    Script script = getScript(out.getScriptBytes());
                    UTXO newOut = new UTXO(hash, out.getIndex(), out.getValue(), height, isCoinBase, script, getScriptAddress(script));
                    blockStore.addUnspentTransactionOutput(newOut);
                    txOutsCreated.add(newOut);
                )
                ;; All values were already checked for being non-negative (as it is verified in Transaction.verify()),
                ;; but we check again here just for defence in depth.  Transactions with zero output value are OK.
                if (valueOut.signum() < 0 || 0 < valueOut.compareTo(params.getMaxMoney()))
                    throw new VerificationException("Transaction output value out of range");

                if (isCoinBase)
                (§
                    coinbaseValue = valueOut;
                )
                else
                (§
                    if (valueIn.compareTo(valueOut) < 0 || 0 < valueIn.compareTo(params.getMaxMoney()))
                        throw new VerificationException("Transaction input value out of range");
                    totalFees = totalFees.add(valueIn.subtract(valueOut));
                )

                if (!isCoinBase && runScripts)
                (§
                    ;; Because correctlySpends modifies transactions, this must come after we are done with tx.
                    FutureTask<VerificationException> future = new FutureTask<>(new Verifier(tx, prevOutScripts, verifyFlags));
                    scriptVerificationExecutor.execute(future);
                    listScriptVerificationResults.add(future);
                )
            )
            if (0 < totalFees.compareTo(params.getMaxMoney()) || block.getBlockInflation(height).add(totalFees).compareTo(coinbaseValue) < 0)
                throw new VerificationException("Transaction fees out of range");

            for (Future<VerificationException> future : listScriptVerificationResults)
            (§
                VerificationException e;
                try
                (§
                    e = future.get();
                )
                catch (InterruptedException ie)
                (§
                    throw new RuntimeException(ie); ;; Shouldn't happen.
                )
                catch (ExecutionException ee)
                (§
                    log.error("Script.correctlySpends threw a non-normal exception: " + ee.getCause());
                    throw new VerificationException("Bug in Script.correctlySpends, likely script malformed in some new and interesting way.", ee);
                )
                if (e != nil)
                    throw e;
            )
        )
        catch (VerificationException e)
        (§
            scriptVerificationExecutor.shutdownNow();
            blockStore.abortDatabaseBatchWrite();
            throw e;
        )
        catch (BlockStoreException e)
        (§
            scriptVerificationExecutor.shutdownNow();
            blockStore.abortDatabaseBatchWrite();
            throw e;
        )

        return new TransactionOutputChanges(txOutsCreated, txOutsSpent);
    )

#_override
    ;;;
     ; Used during reorgs to connect a block previously on a fork.
     ;;
#_protected
#_synchronized
    TransactionOutputChanges connectTransactions(StoredBlock newBlock)
        throws VerificationException, BlockStoreException, PrunedException
    (§
        Preconditions.checkState(lock.isHeldByCurrentThread());
        if (!params.passesCheckpoint(newBlock.getHeight(), newBlock.getHeader().getHash()))
            throw new VerificationException("Block failed checkpoint lockin at " + newBlock.getHeight());

        blockStore.beginDatabaseBatchWrite();
        StoredUndoableBlock block = blockStore.getUndoBlock(newBlock.getHeader().getHash());
        if (block == nil)
        (§
            ;; We're trying to re-org too deep and the data needed has been deleted.
            blockStore.abortDatabaseBatchWrite();
            throw new PrunedException(newBlock.getHeader().getHash());
        )

        TransactionOutputChanges txOutChanges;
        try
        (§
            List<Transaction> transactions = block.getTransactions();
            if (transactions != nil)
            (§
                LinkedList<UTXO> txOutsSpent = new LinkedList<>();
                LinkedList<UTXO> txOutsCreated = new LinkedList<>();
                long sigOps = 0;

                if (!params.isCheckpoint(newBlock.getHeight()))
                (§
                    for (Transaction tx : transactions)
                    (§
                        Sha256Hash hash = tx.getHash();
                        if (blockStore.hasUnspentOutputs(hash, tx.getOutputs().size()))
                            throw new VerificationException("Block failed BIP30 test!");
                    )
                )

                Coin totalFees = Coin.ZERO;
                Coin coinbaseValue = nil;

                if (scriptVerificationExecutor.isShutdown())
                    scriptVerificationExecutor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());

                List<Future<VerificationException>> listScriptVerificationResults = new ArrayList<>(transactions.size());
                for (final Transaction tx : transactions)
                (§
#_final
                    Set<VerifyFlag> verifyFlags = params.getTransactionVerificationFlags(newBlock.getHeader(), tx, getVersionTally(), Integer.SIZE);
                    boolean isCoinBase = tx.isCoinBase();
                    Coin valueIn = Coin.ZERO;
                    Coin valueOut = Coin.ZERO;
#_final
                    List<Script> prevOutScripts = new LinkedList<>();

                    if (!isCoinBase)
                    (§
                        for (int index = 0; index < tx.getInputs().size(); index++)
                        (§
#_final
                            TransactionInput in = tx.getInputs().get(index);
#_final
                            UTXO prevOut = blockStore.getTransactionOutput(in.getOutpoint().getHash(), in.getOutpoint().getIndex());
                            if (prevOut == nil)
                                throw new VerificationException("Attempted spend of a non-existent or already spent output!");
                            if (prevOut.isCoinbase() && newBlock.getHeight() - prevOut.getHeight() < params.getSpendableCoinbaseDepth())
                                throw new VerificationException("Tried to spend coinbase at depth " + (newBlock.getHeight() - prevOut.getHeight()));
                            valueIn = valueIn.add(prevOut.getValue());
                            if (verifyFlags.contains(VerifyFlag.P2SH))
                            (§
                                if (prevOut.getScript().isPayToScriptHash())
                                    sigOps += Script.getP2SHSigOpCount(in.getScriptBytes());
                                if (sigOps > Block.MAX_BLOCK_SIGOPS)
                                    throw new VerificationException("Too many P2SH SigOps in block");
                            )

                            ;; TODO: Enforce DER signature format.

                            prevOutScripts.add(prevOut.getScript());

                            blockStore.removeUnspentTransactionOutput(prevOut);
                            txOutsSpent.add(prevOut);
                        )
                    )
                    Sha256Hash hash = tx.getHash();
                    for (TransactionOutput out : tx.getOutputs())
                    (§
                        valueOut = valueOut.add(out.getValue());
                        Script script = getScript(out.getScriptBytes());
                        UTXO newOut = new UTXO(hash, out.getIndex(), out.getValue(), newBlock.getHeight(), isCoinBase, script, getScriptAddress(script));
                        blockStore.addUnspentTransactionOutput(newOut);
                        txOutsCreated.add(newOut);
                    )
                    ;; All values were already checked for being non-negative (as it is verified in Transaction.verify())
                    ;; but we check again here just for defence in depth.  Transactions with zero output value are OK.
                    if (valueOut.signum() < 0 || 0 < valueOut.compareTo(params.getMaxMoney()))
                        throw new VerificationException("Transaction output value out of range");

                    if (isCoinBase)
                    (§
                        coinbaseValue = valueOut;
                    )
                    else
                    (§
                        if (valueIn.compareTo(valueOut) < 0 || 0 < valueIn.compareTo(params.getMaxMoney()))
                            throw new VerificationException("Transaction input value out of range");
                        totalFees = totalFees.add(valueIn.subtract(valueOut));
                    )

                    if (!isCoinBase)
                    (§
                        ;; Because correctlySpends modifies transactions, this must come after we are done with tx.
                        FutureTask<VerificationException> future = new FutureTask<>(new Verifier(tx, prevOutScripts, verifyFlags));
                        scriptVerificationExecutor.execute(future);
                        listScriptVerificationResults.add(future);
                    )
                )
                if (0 < totalFees.compareTo(params.getMaxMoney()) || newBlock.getHeader().getBlockInflation(newBlock.getHeight()).add(totalFees).compareTo(coinbaseValue) < 0)
                    throw new VerificationException("Transaction fees out of range");

                txOutChanges = new TransactionOutputChanges(txOutsCreated, txOutsSpent);
                for (Future<VerificationException> future : listScriptVerificationResults)
                (§
                    VerificationException e;
                    try
                    (§
                        e = future.get();
                    )
                    catch (InterruptedException ie)
                    (§
                        throw new RuntimeException(ie); ;; Shouldn't happen.
                    )
                    catch (ExecutionException ee)
                    (§
                        log.error("Script.correctlySpends threw a non-normal exception: " + ee.getCause());
                        throw new VerificationException("Bug in Script.correctlySpends, likely script malformed in some new and interesting way.", ee);
                    )
                    if (e != nil)
                        throw e;
                )
            )
            else
            (§
                txOutChanges = block.getTxOutChanges();
                if (!params.isCheckpoint(newBlock.getHeight()))
                    for (UTXO out : txOutChanges.txOutsCreated)
                    (§
                        Sha256Hash hash = out.getHash();
                        if (blockStore.getTransactionOutput(hash, out.getIndex()) != nil)
                            throw new VerificationException("Block failed BIP30 test!");
                    )
                for (UTXO out : txOutChanges.txOutsCreated)
                    blockStore.addUnspentTransactionOutput(out);
                for (UTXO out : txOutChanges.txOutsSpent)
                    blockStore.removeUnspentTransactionOutput(out);
            )
        )
        catch (VerificationException e)
        (§
            scriptVerificationExecutor.shutdownNow();
            blockStore.abortDatabaseBatchWrite();
            throw e;
        )
        catch (BlockStoreException e)
        (§
            scriptVerificationExecutor.shutdownNow();
            blockStore.abortDatabaseBatchWrite();
            throw e;
        )
        return txOutChanges;
    )

    ;;;
     ; This is broken for blocks that do not pass BIP30, so all BIP30-failing blocks which are allowed to fail BIP30
     ; must be checkpointed.
     ;;
#_override
#_protected
    void disconnectTransactions(StoredBlock oldBlock)
        throws PrunedException, BlockStoreException
    (§
        Preconditions.checkState(lock.isHeldByCurrentThread());
        blockStore.beginDatabaseBatchWrite();
        try
        (§
            StoredUndoableBlock undoBlock = blockStore.getUndoBlock(oldBlock.getHeader().getHash());
            if (undoBlock == nil)
                throw new PrunedException(oldBlock.getHeader().getHash());

            TransactionOutputChanges txOutChanges = undoBlock.getTxOutChanges();
            for (UTXO out : txOutChanges.txOutsSpent)
                blockStore.addUnspentTransactionOutput(out);
            for (UTXO out : txOutChanges.txOutsCreated)
                blockStore.removeUnspentTransactionOutput(out);
        )
        catch (PrunedException e)
        (§
            blockStore.abortDatabaseBatchWrite();
            throw e;
        )
        catch (BlockStoreException e)
        (§
            blockStore.abortDatabaseBatchWrite();
            throw e;
        )
    )

#_override
#_protected
    void doSetChainHead(StoredBlock chainHead)
        throws BlockStoreException
    (§
        Preconditions.checkState(lock.isHeldByCurrentThread());
        blockStore.setVerifiedChainHead(chainHead);
        blockStore.commitDatabaseBatchWrite();
    )

#_override
#_protected
    void notSettingChainHead()
        throws BlockStoreException
    (§
        blockStore.abortDatabaseBatchWrite();
    )

#_override
#_protected
    StoredBlock getStoredBlockInCurrentScope(Sha256Hash hash)
        throws BlockStoreException
    (§
        Preconditions.checkState(lock.isHeldByCurrentThread());
        return blockStore.getOnceUndoableStoredBlock(hash);
    )
)

(ns org.bitcoinj.core #_"GetAddrMessage"
)

;;;
 ; <p>Represents the "getaddr" P2P protocol message, which requests network {@link AddressMessage}s from a peer.
 ; Not to be confused with {@link Address} which is sort of like an account number.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
class GetAddrMessage extends EmptyMessage
(§
#_public
    GetAddrMessage(NetworkParameters params)
    (§
        super(params);
    )
)

(ns org.bitcoinj.core #_"GetBlocksMessage"
    (:import [java.io IOException OutputStream]
             [java.util ArrayList List]))

;;;
 ; <p>Represents the "getblocks" P2P network message, which requests the hashes of the parts of the block chain we're missing.
 ; Those blocks can then be downloaded with a {@link GetDataMessage}.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
class GetBlocksMessage extends Message
(§
#_protected
    long version;
#_protected
    List<Sha256Hash> locator;
#_protected
    Sha256Hash stopHash;

#_public
    GetBlocksMessage(NetworkParameters params, List<Sha256Hash> locator, Sha256Hash stopHash)
    (§
        super(params);

        this.version = protocolVersion;
        this.locator = locator;
        this.stopHash = stopHash;
    )

#_public
    GetBlocksMessage(NetworkParameters params, byte[] payload)
        throws ProtocolException
    (§
        super(params, payload, 0);
    )

#_override
#_protected
    void parse()
        throws ProtocolException
    (§
        cursor = offset;
        version = readUint32();
        int startCount = (int)readVarInt();
        if (500 < startCount)
            throw new ProtocolException("Number of locators cannot be > 500, received: " + startCount);

        length = cursor - offset + ((startCount + 1) * 32);
        locator = new ArrayList<>(startCount);
        for (int i = 0; i < startCount; i++)
            locator.add(readHash());
        stopHash = readHash();
    )

#_public
    List<Sha256Hash> getLocator()
    (§
        return locator;
    )

#_public
    Sha256Hash getStopHash()
    (§
        return stopHash;
    )

#_override
#_public
    String toString()
    (§
        return "getblocks: " + Utils.SPACE_JOINER.join(locator);
    )

#_override
#_protected
    void bitcoinSerializeToStream(OutputStream stream)
        throws IOException
    (§
        ;; Version, for some reason.
        Utils.uint32ToByteStreamLE(params.getProtocolVersionNum(NetworkParameters.ProtocolVersion.CURRENT), stream);
        ;; Then a vector of block hashes.  This is actually a "block locator", a set of block
        ;; identifiers that spans the entire chain with exponentially increasing gaps between
        ;; them, until we end up at the genesis block.  See CBlockLocator::Set().
        stream.write(new VarInt(locator.size()).encode());
        for (Sha256Hash hash : locator)
        (§
            ;; Have to reverse as wire format is little endian.
            stream.write(hash.getReversedBytes());
        )
        ;; Next, a block ID to stop at.
        stream.write(stopHash.getReversedBytes());
    )

#_override
#_public
    boolean equals(Object o)
    (§
        if (this == o)
            return true;
        if (o == nil || getClass() != o.getClass())
            return false;
        GetBlocksMessage other = (GetBlocksMessage)o;
        return (version == other.version && stopHash.equals(other.stopHash) && locator.size() == other.locator.size() && locator.containsAll(other.locator)); ;; ignores locator ordering
    )

#_override
#_public
    int hashCode()
    (§
        int hashCode = (int)version ^ "getblocks".hashCode() ^ stopHash.hashCode();
        for (Sha256Hash l : locator)
            hashCode ^= l.hashCode(); ;; ignores locator ordering
        return hashCode;
    )
)

(ns org.bitcoinj.core #_"GetDataMessage"
)

;;;
 ; <p>Represents the "getdata" P2P network message, which requests the contents of blocks or transactions given their hashes.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
class GetDataMessage extends ListMessage
(§
#_public
    GetDataMessage(NetworkParameters params, byte[] payloadBytes)
        throws ProtocolException
    (§
        super(params, payloadBytes);
    )

    ;;;
     ; Deserializes a 'getdata' message.
     ; @param params NetworkParameters object.
     ; @param payload Bitcoin protocol formatted byte array containing message content.
     ; @param serializer The serializer to use for this message.
     ; @param length The length of message if known.  Usually this is provided when deserializing of the wire
     ; as the length will be provided as part of the header.  Set to Message.UNKNOWN_LENGTH, if not known.
     ; @throws ProtocolException
     ;;
#_public
    GetDataMessage(NetworkParameters params, byte[] payload, MessageSerializer serializer, int length)
        throws ProtocolException
    (§
        super(params, payload, serializer, length);
    )

#_public
    GetDataMessage(NetworkParameters params)
    (§
        super(params);
    )

#_public
    void addTransaction(Sha256Hash hash)
    (§
        addItem(new InventoryItem(InventoryItem.Type.Transaction, hash));
    )

#_public
    void addBlock(Sha256Hash hash)
    (§
        addItem(new InventoryItem(InventoryItem.Type.Block, hash));
    )

#_public
    void addFilteredBlock(Sha256Hash hash)
    (§
        addItem(new InventoryItem(InventoryItem.Type.FilteredBlock, hash));
    )

#_public
    Sha256Hash getHashOf(int i)
    (§
        return getItems().get(i).hash;
    )
)

(ns org.bitcoinj.core #_"GetHeadersMessage"
    (:import [java.util List]))

;;;
 ; <p>The "getheaders" command is structurally identical to "getblocks", but has different meaning.  On receiving this
 ; message a Bitcoin node returns matching blocks up to the limit, but without the bodies.  It is useful as an
 ; optimization: when your wallet does not contain any keys created before a particular time, you don't have to download
 ; the bodies for those blocks because you know there are no relevant transactions.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
class GetHeadersMessage extends GetBlocksMessage
(§
#_public
    GetHeadersMessage(NetworkParameters params, List<Sha256Hash> locator, Sha256Hash stopHash)
    (§
        super(params, locator, stopHash);
    )

#_public
    GetHeadersMessage(NetworkParameters params, byte[] payload)
        throws ProtocolException
    (§
        super(params, payload);
    )

#_override
#_public
    String toString()
    (§
        return "getheaders: " + Utils.SPACE_JOINER.join(locator);
    )

    ;;;
     ; Compares two getheaders messages.  Note that even though they are structurally identical a GetHeadersMessage
     ; will not compare equal to a GetBlocksMessage containing the same data.
     ;;
#_override
#_public
    boolean equals(Object o)
    (§
        if (this == o)
            return true;
        if (o == nil || getClass() != o.getClass())
            return false;
        GetHeadersMessage other = (GetHeadersMessage)o;
        return (version == other.version && stopHash.equals(other.stopHash) && locator.size() == other.locator.size() && locator.containsAll(other.locator)); ;; ignores locator ordering
    )

#_override
#_public
    int hashCode()
    (§
        int hashCode = (int)version ^ "getheaders".hashCode() ^ stopHash.hashCode();
        for (Sha256Hash l : locator)
            hashCode ^= l.hashCode(); ;; ignores locator ordering
        return hashCode;
    )
)

(ns org.bitcoinj.core #_"HeadersMessage"
    (:import [java.io IOException OutputStream]
             [java.util ArrayList Arrays List])
    (:import [org.slf4j Logger LoggerFactory]))

;;;
 ; <p>A protocol message that contains a repeated series of block headers, sent in response to the "getheaders" command.
 ; This is useful when you want to traverse the chain but know you don't care about the block contents, for example,
 ; because you have a freshly created wallet with no keys.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
class HeadersMessage extends Message
(§
#_private
#_static
#_final
    Logger log = LoggerFactory.getLogger(HeadersMessage.class);

    ;; The main client will never send us more than this number of headers.
#_public
#_static
#_final
    int MAX_HEADERS = 2000;

#_private
    List<Block> blockHeaders;

#_public
    HeadersMessage(NetworkParameters params, byte[] payload)
        throws ProtocolException
    (§
        super(params, payload, 0);
    )

#_public
    HeadersMessage(NetworkParameters params, Block... headers)
        throws ProtocolException
    (§
        super(params);
        blockHeaders = Arrays.asList(headers);
    )

#_public
    HeadersMessage(NetworkParameters params, List<Block> headers)
        throws ProtocolException
    (§
        super(params);
        blockHeaders = headers;
    )

#_override
#_public
    void bitcoinSerializeToStream(OutputStream stream)
        throws IOException
    (§
        stream.write(new VarInt(blockHeaders.size()).encode());
        for (Block header : blockHeaders)
        (§
            header.cloneAsHeader().bitcoinSerializeToStream(stream);
            stream.write(0);
        )
    )

#_override
#_protected
    void parse()
        throws ProtocolException
    (§
        long numHeaders = readVarInt();
        if (MAX_HEADERS < numHeaders)
            throw new ProtocolException("Too many headers: got " + numHeaders + " which is larger than " + MAX_HEADERS);

        blockHeaders = new ArrayList<>();
#_final
        BitcoinSerializer serializer = this.params.getSerializer(true);

        for (int i = 0; i < numHeaders; ++i)
        (§
#_final
            Block newBlockHeader = serializer.makeBlock(payload, cursor, UNKNOWN_LENGTH);
            if (newBlockHeader.hasTransactions())
                throw new ProtocolException("Block header does not end with a nil byte");

            cursor += newBlockHeader.optimalEncodingMessageSize;
            blockHeaders.add(newBlockHeader);
        )

        if (length == UNKNOWN_LENGTH)
            length = cursor - offset;

        if (log.isDebugEnabled())
            for (int i = 0; i < numHeaders; ++i)
                log.debug(this.blockHeaders.get(i).toString());
    )

#_public
    List<Block> getBlockHeaders()
    (§
        return blockHeaders;
    )
)

(ns org.bitcoinj.core #_"InsufficientMoneyException"
    (:import [com.google.common.base Preconditions]))

;;;
 ; Thrown to indicate that you don't have enough money available to perform the requested operation.
 ;;
#_public
class InsufficientMoneyException extends Exception
(§
    ;;; Contains the number of satoshis that would have been required to complete the operation. ;;
#_nilable
#_public
#_final
    Coin missing;

#_protected
    InsufficientMoneyException()
    (§
        this.missing = nil;
    )

#_public
    InsufficientMoneyException(Coin missing)
    (§
        this(missing, "Insufficient money,  missing " + missing.toFriendlyString());
    )

#_public
    InsufficientMoneyException(Coin missing, String message)
    (§
        super(message);
        this.missing = Preconditions.checkNotNull(missing);
    )
)

(ns org.bitcoinj.core #_"InventoryItem"
    (:import [com.google.common.base Objects]))

#_public
class InventoryItem
(§
    ;;;
     ; 4 byte uint32 type field + 32 byte hash
     ;;
#_static
#_final
    int MESSAGE_LENGTH = 36;

#_public
    enum Type
    (§
        Error,
        Transaction,
        Block,
        FilteredBlock
    )

#_public
#_final
    Type type;
#_public
#_final
    Sha256Hash hash;

#_public
    InventoryItem(Type type, Sha256Hash hash)
    (§
        this.type = type;
        this.hash = hash;
    )

#_override
#_public
    String toString()
    (§
        return type + ": " + hash;
    )

#_override
#_public
    boolean equals(Object o)
    (§
        if (this == o)
            return true;
        if (o == nil || getClass() != o.getClass())
            return false;
        InventoryItem other = (InventoryItem)o;
        return (type == other.type && hash.equals(other.hash));
    )

#_override
#_public
    int hashCode()
    (§
        return Objects.hashCode(type, hash);
    )
)

(ns org.bitcoinj.core #_"InventoryMessage"
    (:import [com.google.common.base Preconditions]))

;;;
 ; <p>Represents the "inv" P2P network message.  An inv contains a list of hashes of either blocks or transactions.
 ; It's a bandwidth optimization - on receiving some data, a (fully validating) peer sends every connected peer an inv
 ; containing the hash of what it saw.  It'll only transmit the full thing if a peer asks for it with a
 ; {@link GetDataMessage}.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
class InventoryMessage extends ListMessage
(§
    ;;; A hard coded constant in the protocol. ;;
#_public
#_static
#_final
    int MAX_INV_SIZE = 50000;

#_public
    InventoryMessage(NetworkParameters params, byte[] bytes)
        throws ProtocolException
    (§
        super(params, bytes);
    )

    ;;;
     ; Deserializes an 'inv' message.
     ; @param params NetworkParameters object.
     ; @param payload Bitcoin protocol formatted byte array containing message content.
     ; @param serializer The serializer to use for this message.
     ; @param length The length of message if known.  Usually this is provided when deserializing of the wire
     ; as the length will be provided as part of the header.  Set to Message.UNKNOWN_LENGTH, if not known.
     ; @throws ProtocolException
     ;;
#_public
    InventoryMessage(NetworkParameters params, byte[] payload, MessageSerializer serializer, int length)
        throws ProtocolException
    (§
        super(params, payload, serializer, length);
    )

#_public
    InventoryMessage(NetworkParameters params)
    (§
        super(params);
    )

#_public
    void addBlock(Block block)
    (§
        addItem(new InventoryItem(InventoryItem.Type.Block, block.getHash()));
    )

#_public
    void addTransaction(Transaction tx)
    (§
        addItem(new InventoryItem(InventoryItem.Type.Transaction, tx.getHash()));
    )

    ;;; Creates a new inv message for the given transactions. ;;
#_public
#_static
    InventoryMessage with(Transaction... txs)
    (§
        Preconditions.checkArgument(0 < txs.length);
        InventoryMessage result = new InventoryMessage(txs[0].getParams());
        for (Transaction tx : txs)
            result.addTransaction(tx);
        return result;
    )
)

(ns org.bitcoinj.core #_"ListMessage"
    (:import [java.io IOException OutputStream]
             [java.util ArrayList Collections List]))

;;;
 ; <p>Abstract superclass of classes with list based payload, i.e. InventoryMessage and GetDataMessage.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
#_abstract
class ListMessage extends Message
(§
#_public
#_static
#_final
    long MAX_INVENTORY_ITEMS = 50000;

#_private
    long arrayLen;
    ;; For some reason the compiler complains if this is inside InventoryItem.
#_protected
    List<InventoryItem> items;

#_public
    ListMessage(NetworkParameters params, byte[] bytes)
        throws ProtocolException
    (§
        super(params, bytes, 0);
    )

#_public
    ListMessage(NetworkParameters params, byte[] payload, MessageSerializer serializer, int length)
        throws ProtocolException
    (§
        super(params, payload, 0, serializer, length);
    )

#_public
    ListMessage(NetworkParameters params)
    (§
        super(params);

        items = new ArrayList<>();
        length = 1; ;; length of 0 varint
    )

#_public
    List<InventoryItem> getItems()
    (§
        return Collections.unmodifiableList(items);
    )

#_public
    void addItem(InventoryItem item)
    (§
        unCache();
        length -= VarInt.sizeOf(items.size());
        items.add(item);
        length += VarInt.sizeOf(items.size()) + InventoryItem.MESSAGE_LENGTH;
    )

#_public
    void removeItem(int index)
    (§
        unCache();
        length -= VarInt.sizeOf(items.size());
        items.remove(index);
        length += VarInt.sizeOf(items.size()) - InventoryItem.MESSAGE_LENGTH;
    )

#_override
#_protected
    void parse()
        throws ProtocolException
    (§
        arrayLen = readVarInt();
        if (MAX_INVENTORY_ITEMS < arrayLen)
            throw new ProtocolException("Too many items in INV message: " + arrayLen);
        length = (int)(cursor - offset + (arrayLen * InventoryItem.MESSAGE_LENGTH));

        ;; An inv is vector<CInv> where CInv is int+hash.  The int is either 1 or 2 for tx or block.
        items = new ArrayList<>((int)arrayLen);
        for (int i = 0; i < arrayLen; i++)
        (§
            if (payload.length < cursor + InventoryItem.MESSAGE_LENGTH)
                throw new ProtocolException("Ran off the end of the INV");

            int typeCode = (int)readUint32();
            InventoryItem.Type type;
            ;; see ppszTypeName in net.h
            switch (typeCode)
            (§
                case 0:
                    type = InventoryItem.Type.Error;
                    break;
                case 1:
                    type = InventoryItem.Type.Transaction;
                    break;
                case 2:
                    type = InventoryItem.Type.Block;
                    break;
                case 3:
                    type = InventoryItem.Type.FilteredBlock;
                    break;
                default:
                    throw new ProtocolException("Unknown CInv type: " + typeCode);
            )
            items.add(new InventoryItem(type, readHash()));
        )
        payload = nil;
    )

#_override
#_public
    void bitcoinSerializeToStream(OutputStream stream)
        throws IOException
    (§
        stream.write(new VarInt(items.size()).encode());
        for (InventoryItem i : items)
        (§
            ;; Write out the type code.
            Utils.uint32ToByteStreamLE(i.type.ordinal(), stream);
            ;; And now the hash.
            stream.write(i.hash.getReversedBytes());
        )
    )

#_override
#_public
    boolean equals(Object o)
    (§
        if (this == o)
            return true;
        if (o == nil || getClass() != o.getClass())
            return false;
        return items.equals(((ListMessage)o).items);
    )

#_override
#_public
    int hashCode()
    (§
        return items.hashCode();
    )
)

(ns org.bitcoinj.core #_"MemoryPoolMessage"
    (:import [java.io IOException OutputStream]))

;;;
 ; <p>The "mempool" message asks a remote peer to announce all transactions in its memory pool, possibly restricted by
 ; any Bloom filter set on the connection.  The list of transaction hashes comes back in an inv message.  Note that
 ; this is different to the {@link TxConfidenceTable} object which doesn't try to keep track of all pending transactions,
 ; it's just a holding area for transactions that a part of the app may find interesting.  The mempool message has
 ; no fields.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
class MemoryPoolMessage extends Message
(§
#_override
#_protected
    void parse()
        throws ProtocolException {}

#_override
#_protected
    void bitcoinSerializeToStream(OutputStream stream)
        throws IOException {}
)

(ns org.bitcoinj.core #_"Message"
    (:import #_[java.io *]
             [java.math BigInteger]
             [java.util Arrays])
    (:import [com.google.common.base Preconditions]
             [org.slf4j Logger LoggerFactory]))

;;;
 ; <p>A Message is a data structure that can be serialized/deserialized using the Bitcoin serialization format.
 ; Specific types of messages that are used both in the block chain, and on the wire, are derived from this class.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
#_abstract
class Message
(§
#_private
#_static
#_final
    Logger log = LoggerFactory.getLogger(Message.class);

#_public
#_static
#_final
    int MAX_SIZE = 0x02000000; ;; 32MB

#_public
#_static
#_final
    int UNKNOWN_LENGTH = Integer.MIN_VALUE;

    ;; Useful to ensure serialize/deserialize are consistent with each other.
#_private
#_static
#_final
    boolean SELF_CHECK = false;

    ;; The offset is how many bytes into the provided byte array this message payload starts at.
#_protected
    int offset;
    ;; The cursor keeps track of where we are in the byte array as we parse it.
    ;; Note that it's relative to the start of the array NOT the start of the message payload.
#_protected
    int cursor;

#_protected
    int length = UNKNOWN_LENGTH;

    ;; The raw message payload bytes themselves.
#_protected
    byte[] payload;

#_protected
    boolean recached = false;
#_protected
    MessageSerializer serializer;

#_protected
    int protocolVersion;

#_protected
    NetworkParameters params;

#_protected
    Message()
    (§
        serializer = DummySerializer.DEFAULT;
    )

#_protected
    Message(NetworkParameters params)
    (§
        this.params = params;
        serializer = params.getDefaultSerializer();
    )

#_protected
    Message(NetworkParameters params, byte[] payload, int offset, int protocolVersion)
        throws ProtocolException
    (§
        this(params, payload, offset, protocolVersion, params.getDefaultSerializer(), UNKNOWN_LENGTH);
    )

    ;;;
     ; @param params NetworkParameters object.
     ; @param payload Bitcoin protocol formatted byte array containing message content.
     ; @param offset The location of the first payload byte within the array.
     ; @param protocolVersion Bitcoin protocol version.
     ; @param serializer The serializer to use for this message.
     ; @param length The length of message payload if known.  Usually this is provided when deserializing of the wire
     ; as the length will be provided as part of the header.  Set to Message.UNKNOWN_LENGTH, if not known.
     ; @throws ProtocolException
     ;;
#_protected
    Message(NetworkParameters params, byte[] payload, int offset, int protocolVersion, MessageSerializer serializer, int length)
        throws ProtocolException
    (§
        this.serializer = serializer;
        this.protocolVersion = protocolVersion;
        this.params = params;
        this.payload = payload;
        this.cursor = this.offset = offset;
        this.length = length;

        parse();

        if (this.length == UNKNOWN_LENGTH)
            Preconditions.checkState(false, "Length field has not been set in constructor for %s after parse.", getClass().getSimpleName());

        if (SELF_CHECK)
            selfCheck(payload, offset);

        if (!serializer.isParseRetainMode())
            this.payload = nil;
    )

#_private
    void selfCheck(byte[] payload, int offset)
    (§
        if (!(this instanceof VersionMessage))
        (§
            byte[] payloadBytes = new byte[cursor - offset];
            System.arraycopy(payload, offset, payloadBytes, 0, cursor - offset);
            byte[] reserialized = bitcoinSerialize();
            if (!Arrays.equals(reserialized, payloadBytes))
                throw new RuntimeException("Serialization is wrong: \n" + Utils.HEX.encode(reserialized) + " vs \n" + Utils.HEX.encode(payloadBytes));
        )
    )

#_protected
    Message(NetworkParameters params, byte[] payload, int offset)
        throws ProtocolException
    (§
        this(params, payload, offset, params.getProtocolVersionNum(NetworkParameters.ProtocolVersion.CURRENT), params.getDefaultSerializer(), UNKNOWN_LENGTH);
    )

#_protected
    Message(NetworkParameters params, byte[] payload, int offset, MessageSerializer serializer, int length)
        throws ProtocolException
    (§
        this(params, payload, offset, params.getProtocolVersionNum(NetworkParameters.ProtocolVersion.CURRENT), serializer, length);
    )

    ;; These methods handle the serialization/deserialization using the custom Bitcoin protocol.

#_protected
#_abstract
    void parse()
        throws ProtocolException;

    ;;;
     ; <p>To be called before any change of internal values including any setters.  This ensures any cached byte array is
     ; removed.<p/>
     ; <p>Child messages of this object (e.g. Transactions belonging to a Block) will not have their internal byte caches
     ; invalidated unless they are also modified internally.</p>
     ;;
#_protected
    void unCache()
    (§
        payload = nil;
        recached = false;
    )

#_protected
    void adjustLength(int newArraySize, int adjustment)
    (§
        if (length == UNKNOWN_LENGTH)
            return;
        ;; Our own length is now unknown if we have an unknown length adjustment.
        if (adjustment == UNKNOWN_LENGTH)
        (§
            length = UNKNOWN_LENGTH;
            return;
        )
        length += adjustment;
        ;; Check if we will need more bytes to encode the length prefix.
        if (newArraySize == 1)
            length++; ;; The assumption here is we never call adjustLength with the same arraySize as before.
        else if (newArraySize != 0)
            length += VarInt.sizeOf(newArraySize) - VarInt.sizeOf(newArraySize - 1);
    )

    ;;;
     ; used for unit testing
     ;;
#_public
    boolean isCached()
    (§
        return (payload != nil);
    )

#_public
    boolean isRecached()
    (§
        return recached;
    )

    ;;;
     ; Returns a copy of the array returned by {@link Message#unsafeBitcoinSerialize()}, which is safe to mutate.
     ; If you need extra performance and can guarantee you won't write to the array, you can use the unsafe version.
     ;
     ; @return a freshly allocated serialized byte array.
     ;;
#_public
    byte[] bitcoinSerialize()
    (§
        byte[] bytes = unsafeBitcoinSerialize();
        byte[] copy = new byte[bytes.length];
        System.arraycopy(bytes, 0, copy, 0, bytes.length);
        return copy;
    )

    ;;;
     ; Serialize this message to a byte array that conforms to the bitcoin wire protocol.
     ; <br/>
     ; This method may return the original byte array used to construct this message if the
     ; following conditions are met:
     ; <ol>
     ; <li>1) The message was parsed from a byte array with parseRetain = true</li>
     ; <li>2) The message has not been modified</li>
     ; <li>3) The array had an offset of 0 and no surplus bytes</li>
     ; </ol>
     ;
     ; If condition 3 is not met then an copy of the relevant portion of the array will be returned.
     ; Otherwise a full serialize will occur.  For this reason you should only use this API
     ; if you can guarantee you will treat the resulting array as read only.
     ;
     ; @return a byte array owned by this object, do NOT mutate it.
     ;;
#_public
    byte[] unsafeBitcoinSerialize()
    (§
        ;; 1st attempt to use a cached array.
        if (payload != nil)
        (§
            ;; Cached byte array is the entire message with no extras so we can return as is and avoid an array copy.
            if (offset == 0 && length == payload.length)
                return payload;

            byte[] buf = new byte[length];
            System.arraycopy(payload, offset, buf, 0, length);
            return buf;
        )

        ;; No cached array available so serialize parts by stream.
        ByteArrayOutputStream stream = new UnsafeByteArrayOutputStream(length < 32 ? 32 : length + 32);
        try
        (§
            bitcoinSerializeToStream(stream);
        )
        catch (IOException _)
        (§
            ;; Cannot happen, we are serializing to a memory stream.
        )

        if (serializer.isParseRetainMode())
        (§
            ;; A free set of steak knives!
            ;; If there happens to be a call to this method we gain an opportunity to recache
            ;; the byte array and in this case it contains no bytes from parent messages.
            ;; This give a dual benefit.  Releasing references to the larger byte array so that it
            ;; it is more likely to be GC'd.  And preventing double serializations.  E.g. calculating
            ;; merkle root calls this method.  It is will frequently happen prior to serializing the block
            ;; which means another call to bitcoinSerialize is coming.  If we didn't recache then internal
            ;; serialization would occur a 2nd time and every subsequent time the message is serialized.
            payload = stream.toByteArray();
            cursor = cursor - offset;
            offset = 0;
            recached = true;
            length = payload.length;
            return payload;
        )
        ;; Record length.  If this Message wasn't parsed from a byte stream it won't have length field
        ;; set (except for static length message types).  Setting it makes future streaming more efficient
        ;; because we can preallocate the ByteArrayOutputStream buffer and avoid resizing.
        byte[] buf = stream.toByteArray();
        length = buf.length;
        return buf;
    )

    ;;;
     ; Serialize this message to the provided OutputStream using the bitcoin wire format.
     ;
     ; @param stream
     ; @throws IOException
     ;;
#_public
#_final
    void bitcoinSerialize(OutputStream stream)
        throws IOException
    (§
        ;; 1st check for cached bytes.
        if (payload != nil && length != UNKNOWN_LENGTH)
        (§
            stream.write(payload, offset, length);
            return;
        )

        bitcoinSerializeToStream(stream);
    )

    ;;;
     ; Serializes this message to the provided stream.  If you just want the raw bytes use bitcoinSerialize().
     ;;
#_protected
    void bitcoinSerializeToStream(OutputStream stream)
        throws IOException
    (§
        log.error("Error: {} class has not implemented bitcoinSerializeToStream method.  Generating message with no payload", getClass());
    )

    ;;;
     ; This method is a NOP for all classes except Block and Transaction.  It is only declared in Message
     ; so BitcoinSerializer can avoid 2 instanceof checks + a casting.
     ;;
#_public
    Sha256Hash getHash()
    (§
        throw new UnsupportedOperationException();
    )

    ;;;
     ; This returns a correct value by parsing the message.
     ;;
#_public
#_final
    int getMessageSize()
    (§
        if (length == UNKNOWN_LENGTH)
            Preconditions.checkState(false, "Length field has not been set in %s.", getClass().getSimpleName());
        return length;
    )

#_protected
    long readUint32()
        throws ProtocolException
    (§
        try
        (§
            long u = Utils.readUint32(payload, cursor);
            cursor += 4;
            return u;
        )
        catch (ArrayIndexOutOfBoundsException e)
        (§
            throw new ProtocolException(e);
        )
    )

#_protected
    long readInt64()
        throws ProtocolException
    (§
        try
        (§
            long u = Utils.readInt64(payload, cursor);
            cursor += 8;
            return u;
        )
        catch (ArrayIndexOutOfBoundsException e)
        (§
            throw new ProtocolException(e);
        )
    )

#_protected
    BigInteger readUint64()
        throws ProtocolException
    (§
        ;; Java does not have an unsigned 64 bit type. So scrape it off the wire then flip.
        return new BigInteger(Utils.reverseBytes(readBytes(8)));
    )

#_protected
    long readVarInt()
        throws ProtocolException
    (§
        return readVarInt(0);
    )

#_protected
    long readVarInt(int offset)
        throws ProtocolException
    (§
        try
        (§
            VarInt varint = new VarInt(payload, cursor + offset);
            cursor += offset + varint.getOriginalSizeInBytes();
            return varint.value;
        )
        catch (ArrayIndexOutOfBoundsException e)
        (§
            throw new ProtocolException(e);
        )
    )

#_protected
    byte[] readBytes(int length)
        throws ProtocolException
    (§
        if (MAX_SIZE < length)
            throw new ProtocolException("Claimed value length too large: " + length);

        try
        (§
            byte[] b = new byte[length];
            System.arraycopy(payload, cursor, b, 0, length);
            cursor += length;
            return b;
        )
        catch (IndexOutOfBoundsException e)
        (§
            throw new ProtocolException(e);
        )
    )

#_protected
    byte[] readByteArray()
        throws ProtocolException
    (§
        long len = readVarInt();
        return readBytes((int)len);
    )

#_protected
    String readStr()
        throws ProtocolException
    (§
        long length = readVarInt();
        return (length == 0) ? "" : Utils.toString(readBytes((int)length), "UTF-8"); ;; optimization for empty strings
    )

#_protected
    Sha256Hash readHash()
        throws ProtocolException
    (§
        ;; We have to flip it around, as it's been read off the wire in little endian.
        ;; Not the most efficient way to do this but the clearest.
        return Sha256Hash.wrapReversed(readBytes(32));
    )

#_protected
    boolean hasMoreBytes()
    (§
        return (cursor < payload.length);
    )

    ;;; Network parameters this message was created with. ;;
#_public
    NetworkParameters getParams()
    (§
        return params;
    )

    ;;;
     ; Set the serializer for this message when deserialized by Java.
     ;;
#_private
    void readObject(java.io.ObjectInputStream in)
        throws IOException, ClassNotFoundException
    (§
        in.defaultReadObject();
        if (nil != params)
            this.serializer = params.getDefaultSerializer();
    )
)

(ns org.bitcoinj.core #_"MessageSerializer"
    (:import [java.io IOException OutputStream]
             [java.nio BufferUnderflowException ByteBuffer]))

;;;
 ; Generic interface for classes which serialize/deserialize messages.
 ; Implementing classes should be immutable.
 ;;
#_public
#_abstract
class MessageSerializer
(§
    ;;;
     ; Reads a message from the given ByteBuffer and returns it.
     ;;
#_public
#_abstract
    Message deserialize(ByteBuffer in)
        throws ProtocolException, IOException, UnsupportedOperationException;

    ;;;
     ; Deserializes only the header in case packet meta data is needed before decoding
     ; the payload.  This method assumes you have already called seekPastMagicBytes().
     ;;
#_public
#_abstract
    BitcoinSerializer.BitcoinPacketHeader deserializeHeader(ByteBuffer in)
        throws ProtocolException, IOException, UnsupportedOperationException;

    ;;;
     ; Deserialize payload only.  You must provide a header, typically obtained by calling
     ; {@link BitcoinSerializer#deserializeHeader}.
     ;;
#_public
#_abstract
    Message deserializePayload(BitcoinSerializer.BitcoinPacketHeader header, ByteBuffer in)
        throws ProtocolException, BufferUnderflowException, UnsupportedOperationException;

    ;;;
     ; Whether the serializer will produce cached mode Messages.
     ;;
#_public
#_abstract
    boolean isParseRetainMode();

    ;;;
     ; Make an address message from the payload.  Extension point for alternative
     ; serialization format support.
     ;;
#_public
#_abstract
    AddressMessage makeAddressMessage(byte[] payloadBytes, int length)
        throws ProtocolException, UnsupportedOperationException;

    ;;;
     ; Make an alert message from the payload.  Extension point for alternative
     ; serialization format support.
     ;;
#_public
#_abstract
    Message makeAlertMessage(byte[] payloadBytes)
        throws ProtocolException, UnsupportedOperationException;

    ;;;
     ; Make a block from the payload, using an offset of zero and the payload
     ; length as block length.
     ;;
#_public
#_final
    Block makeBlock(byte[] payloadBytes)
        throws ProtocolException
    (§
        return makeBlock(payloadBytes, 0, payloadBytes.length);
    )

    ;;;
     ; Make a block from the payload, using an offset of zero and the provided
     ; length as block length.
     ;;
#_public
#_final
    Block makeBlock(byte[] payloadBytes, int length)
        throws ProtocolException
    (§
        return makeBlock(payloadBytes, 0, length);
    )

    ;;;
     ; Make a block from the payload, using an offset of zero and the provided
     ; length as block length.  Extension point for alternative
     ; serialization format support.
     ;;
#_public
#_abstract
    Block makeBlock(final byte[] payloadBytes, final int offset, final int length)
        throws ProtocolException, UnsupportedOperationException;

    ;;;
     ; Make an filter message from the payload.  Extension point for alternative
     ; serialization format support.
     ;;
#_public
#_abstract
    Message makeBloomFilter(byte[] payloadBytes)
        throws ProtocolException, UnsupportedOperationException;

    ;;;
     ; Make a filtered block from the payload.  Extension point for alternative
     ; serialization format support.
     ;;
#_public
#_abstract
    FilteredBlock makeFilteredBlock(byte[] payloadBytes)
        throws ProtocolException, UnsupportedOperationException;

    ;;;
     ; Make an inventory message from the payload.  Extension point for alternative
     ; serialization format support.
     ;;
#_public
#_abstract
    InventoryMessage makeInventoryMessage(byte[] payloadBytes, int length)
        throws ProtocolException, UnsupportedOperationException;

    ;;;
     ; Make a transaction from the payload.  Extension point for alternative
     ; serialization format support.
     ;
     ; @throws UnsupportedOperationException if this serializer/deserializer
     ; does not support deserialization.  This can occur either because it's a dummy
     ; serializer (i.e. for messages with no network parameters), or because
     ; it does not support deserializing transactions.
     ;;
#_public
#_abstract
    Transaction makeTransaction(byte[] payloadBytes, int offset, int length, byte[] hash)
        throws ProtocolException, UnsupportedOperationException;

    ;;;
     ; Make a transaction from the payload.  Extension point for alternative
     ; serialization format support.
     ;
     ; @throws UnsupportedOperationException if this serializer/deserializer
     ; does not support deserialization.  This can occur either because it's a dummy
     ; serializer (i.e. for messages with no network parameters), or because
     ; it does not support deserializing transactions.
     ;;
#_public
#_final
    Transaction makeTransaction(byte[] payloadBytes)
        throws ProtocolException, UnsupportedOperationException
    (§
        return makeTransaction(payloadBytes, 0);
    )

    ;;;
     ; Make a transaction from the payload.  Extension point for alternative
     ; serialization format support.
     ;
     ; @throws UnsupportedOperationException if this serializer/deserializer
     ; does not support deserialization.  This can occur either because it's a dummy
     ; serializer (i.e. for messages with no network parameters), or because
     ; it does not support deserializing transactions.
     ;;
#_public
#_final
    Transaction makeTransaction(byte[] payloadBytes, int offset)
        throws ProtocolException
    (§
        return makeTransaction(payloadBytes, offset, payloadBytes.length, nil);
    )

#_public
#_abstract
    void seekPastMagicBytes(ByteBuffer in)
        throws BufferUnderflowException;

    ;;;
     ; Writes message to to the output stream.
     ;
     ; @throws UnsupportedOperationException if this serializer/deserializer
     ; does not support serialization.  This can occur either because it's a dummy
     ; serializer (i.e. for messages with no network parameters), or because
     ; it does not support serializing the given message.
     ;;
#_public
#_abstract
    void serialize(String name, byte[] message, OutputStream out)
        throws IOException, UnsupportedOperationException;

    ;;;
     ; Writes message to to the output stream.
     ;
     ; @throws UnsupportedOperationException if this serializer/deserializer
     ; does not support serialization.  This can occur either because it's a dummy
     ; serializer (i.e. for messages with no network parameters), or because
     ; it does not support serializing the given message.
     ;;
#_public
#_abstract
    void serialize(Message message, OutputStream out)
        throws IOException, UnsupportedOperationException;
)

(ns org.bitcoinj.core #_"Monetary"
    (:import [java.io Serializable]))

;;;
 ; Classes implementing this interface represent a monetary value, such as a Bitcoin or fiat amount.
 ;;
#_public
interface Monetary extends Serializable
(§
    ;;;
     ; Returns the absolute value of exponent of the value of a "smallest unit" in scientific notation.
     ; For Bitcoin, a satoshi is worth 1E-8 so this would be 8.
     ;;
    int smallestUnitExponent();

    ;;;
     ; Returns the number of "smallest units" of this monetary value.
     ; For Bitcoin, this would be the number of satoshis.
     ;;
    long getValue();

    int signum();
)

(ns org.bitcoinj.core #_"NetworkParameters"
    (:import #_[java.io *]
             #_[java.math *]
             #_[java.util *])
    (:import [com.google.common.base Objects])
  #_(:require [org.bitcoinj.core Block]
             #_static #_[org.bitcoinj.core.Coin *]
             [org.bitcoinj.core StoredBlock VerificationException]
             #_[org.bitcoinj.net.discovery *]
             #_[org.bitcoinj.params *]
             #_[org.bitcoinj.script *]
             [org.bitcoinj.store BlockStore BlockStoreException]
             [org.bitcoinj.utils MonetaryFormat VersionTally]))

;;;
 ; <p>NetworkParameters contains the data needed for working with an instantiation of a Bitcoin chain.</p>
 ;
 ; <p>This is an abstract class, concrete instantiations can be found in the params package.  There are four:
 ; one for the main network ({@link MainNetParams}), one for the public test network, and two others that are
 ; intended for unit testing and local app development purposes.  Although this class contains some aliases for
 ; them, you are encouraged to call the static get() methods on each specific params class directly.</p>
 ;;
#_public
#_abstract
class NetworkParameters
(§
    ;;;
     ; The alert signing key originally owned by Satoshi, and now passed on to Gavin along with a few others.
     ;;
#_public
#_static
#_final
    byte[] SATOSHI_KEY = Utils.HEX.decode("04fc9702847840aaf195de8442ebecedf5b095cdbb9bc716bda9110971b28a49e0ead8564ff0db22209e0374782c093bb899692d524e9d6a6956e7c5ecbcd68284");

    ;;; The string returned by getId() for the main, production network where people trade things. ;;
#_public
#_static
#_final
    String ID_MAINNET = "org.bitcoin.production";
    ;;; The string returned by getId() for the testnet. ;;
#_public
#_static
#_final
    String ID_TESTNET = "org.bitcoin.test";
    ;;; Unit test network. ;;
#_public
#_static
#_final
    String ID_UNITTESTNET = "org.bitcoinj.unittest";

    ;;; The string used by the payment protocol to represent the main net. ;;
#_public
#_static
#_final
    String PAYMENT_PROTOCOL_ID_MAINNET = "main";
    ;;; The string used by the payment protocol to represent the test net. ;;
#_public
#_static
#_final
    String PAYMENT_PROTOCOL_ID_TESTNET = "test";
    ;;; The string used by the payment protocol to represent unit testing (note that this is non-standard). ;;
#_public
#_static
#_final
    String PAYMENT_PROTOCOL_ID_UNIT_TESTS = "unittest";

    ;; TODO: Seed nodes should be here as well.

#_protected
    Block genesisBlock;
#_protected
    BigInteger maxTarget;
#_protected
    int port;
#_protected
    long packetMagic; ;; Indicates message origin network and is used to seek to the next message when stream state is unknown.
#_protected
    int addressHeader;
#_protected
    int p2shHeader;
#_protected
    int interval;
#_protected
    int targetTimespan;
#_protected
    byte[] alertSigningKey;
#_protected
    int bip32HeaderPub;
#_protected
    int bip32HeaderPriv;

    ;;; Used to check majorities for block version upgrade. ;;
#_protected
    int majorityEnforceBlockUpgrade;
#_protected
    int majorityRejectBlockOutdated;
#_protected
    int majorityWindow;

    ;;;
     ; See getId().  This may be null for old deserialized wallets.  In that case we derive it heuristically
     ; by looking at the port number.
     ;;
#_protected
    String id;

    ;;;
     ; The depth of blocks required for a coinbase transaction to be spendable.
     ;;
#_protected
    int spendableCoinbaseDepth;
#_protected
    int subsidyDecreaseBlockCount;

#_protected
    int[] acceptableAddressCodes;
#_protected
    String[] dnsSeeds;
#_protected
    int[] addrSeeds;
#_protected
    Map<Integer, Sha256Hash> checkpoints = new HashMap<>();
#_protected
    transient MessageSerializer defaultSerializer;

#_protected
    NetworkParameters()
    (§
        alertSigningKey = SATOSHI_KEY;
        genesisBlock = createGenesis(this);
    )

#_private
#_static
    Block createGenesis(NetworkParameters n)
    (§
        Block genesisBlock = new Block(n, Block.BLOCK_VERSION_GENESIS);
        Transaction t = new Transaction(n);
        try
        (§
            ;; A script containing the difficulty bits and the following message: "The Times 03/Jan/2009 Chancellor on brink of second bailout for banks".
            byte[] bytes = Utils.HEX.decode
                    ("04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73");
            t.addInput(new TransactionInput(n, t, bytes));
            ByteArrayOutputStream scriptPubKeyBytes = new ByteArrayOutputStream();
            Script.writeBytes(scriptPubKeyBytes, Utils.HEX.decode
                    ("04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f"));
            scriptPubKeyBytes.write(ScriptOpCodes.OP_CHECKSIG);
            t.addOutput(new TransactionOutput(n, t, FIFTY_COINS, scriptPubKeyBytes.toByteArray()));
        )
        catch (Exception e)
        (§
            throw new RuntimeException(e); ;; Cannot happen.
        )
        genesisBlock.addTransaction(t);
        return genesisBlock;
    )

#_public
#_static
#_final
    int TARGET_TIMESPAN = 14 * 24 * 60 * 60; ;; 2 weeks per difficulty cycle, on average.
#_public
#_static
#_final
    int TARGET_SPACING = 10 * 60; ;; 10 minutes per block.
#_public
#_static
#_final
    int INTERVAL = TARGET_TIMESPAN / TARGET_SPACING;

    ;;;
     ; Blocks with a timestamp after this should enforce BIP 16, aka "Pay to script hash".  This BIP changed
     ; the network rules in a soft-forking manner, that is, blocks that don't follow the rules are accepted
     ; but not mined upon and thus will be quickly re-orged out as long as the majority are enforcing the rule.
     ;;
#_public
#_static
#_final
    int BIP16_ENFORCE_TIME = 1333238400;

    ;;;
     ; The maximum number of coins to be generated.
     ;;
#_public
#_static
#_final
    long MAX_COINS = 21000000;

    ;;;
     ; The maximum money to be generated.
     ;;
#_public
#_static
#_final
    Coin MAX_MONEY = COIN.multiply(MAX_COINS);

    ;;;
     ; A Java package style string acting as unique ID for these parameters.
     ;;
#_public
    String getId()
    (§
        return id;
    )

#_public
#_abstract
    String getPaymentProtocolId();

#_override
#_public
    boolean equals(Object o)
    (§
        if (this == o)
            return true;
        if (o == nil || getClass() != o.getClass())
            return false;
        return getId().equals(((NetworkParameters)o).getId());
    )

#_override
#_public
    int hashCode()
    (§
        return Objects.hashCode(getId());
    )

    ;;; Returns the network parameters for the given string ID or NULL if not recognized. ;;
#_nilable
#_public
#_static
    NetworkParameters fromID(String id)
    (§
        if (id.equals(ID_MAINNET))
            return MainNetParams.get();
        if (id.equals(ID_TESTNET))
            return TestNet3Params.get();
        if (id.equals(ID_UNITTESTNET))
            return UnitTestParams.get();
        return nil;
    )

    ;;; Returns the network parameters for the given string paymentProtocolID or NULL if not recognized. ;;
#_nilable
#_public
#_static
    NetworkParameters fromPmtProtocolID(String pmtProtocolId)
    (§
        if (pmtProtocolId.equals(PAYMENT_PROTOCOL_ID_MAINNET))
            return MainNetParams.get();
        if (pmtProtocolId.equals(PAYMENT_PROTOCOL_ID_TESTNET))
            return TestNet3Params.get();
        if (pmtProtocolId.equals(PAYMENT_PROTOCOL_ID_UNIT_TESTS))
            return UnitTestParams.get();
        return nil;
    )

#_public
    int getSpendableCoinbaseDepth()
    (§
        return spendableCoinbaseDepth;
    )

    ;;;
     ; Throws an exception if the block's difficulty is not correct.
     ;
     ; @throws VerificationException if the block's difficulty is not correct.
     ;;
#_public
#_abstract
    void checkDifficultyTransitions(StoredBlock storedPrev, Block next, final BlockStore blockStore)
        throws VerificationException, BlockStoreException;

    ;;;
     ; Returns true if the block height is either not a checkpoint, or is a checkpoint and the hash matches.
     ;;
#_public
    boolean passesCheckpoint(int height, Sha256Hash hash)
    (§
        Sha256Hash checkpointHash = checkpoints.get(height);
        return (checkpointHash == nil || checkpointHash.equals(hash));
    )

    ;;;
     ; Returns true if the given height has a recorded checkpoint.
     ;;
#_public
    boolean isCheckpoint(int height)
    (§
        Sha256Hash checkpointHash = checkpoints.get(height);
        return (checkpointHash != nil);
    )

#_public
    int getSubsidyDecreaseBlockCount()
    (§
        return subsidyDecreaseBlockCount;
    )

    ;;; Returns DNS names that when resolved, give IP addresses of active peers. ;;
#_public
    String[] getDnsSeeds()
    (§
        return dnsSeeds;
    )

    ;;; Returns IP address of active peers. ;;
#_public
    int[] getAddrSeeds()
    (§
        return addrSeeds;
    )

    ;;;
     ; <p>Genesis block for this chain.</p>
     ;
     ; <p>The first block in every chain is a well known constant shared between all Bitcoin implemenetations.
     ; For a block to be valid, it must be eventually possible to work backwards to the genesis block by following
     ; the prevBlockHash pointers in the block headers.</p>
     ;
     ; <p>The genesis blocks for both test and main networks contain the timestamp of when they were created,
     ; and a message in the coinbase transaction.  It says,
     ; <i>"The Times 03/Jan/2009 Chancellor on brink of second bailout for banks"</i>.</p>
     ;;
#_public
    Block getGenesisBlock()
    (§
        return genesisBlock;
    )

    ;;; Default TCP port on which to connect to nodes. ;;
#_public
    int getPort()
    (§
        return port;
    )

    ;;; The header bytes that identify the start of a packet on this network. ;;
#_public
    long getPacketMagic()
    (§
        return packetMagic;
    )

    ;;;
     ; First byte of a base58 encoded address.  See {@link org.bitcoinj.core.Address}.
     ; This is the same as acceptableAddressCodes[0] and is the one used for "normal" addresses.
     ; Other types of address may be encountered with version codes found in the acceptableAddressCodes array.
     ;;
#_public
    int getAddressHeader()
    (§
        return addressHeader;
    )

    ;;;
     ; First byte of a base58 encoded P2SH address.  P2SH addresses are defined as part of BIP0013.
     ;;
#_public
    int getP2SHHeader()
    (§
        return p2shHeader;
    )

    ;;;
     ; How much time in seconds is supposed to pass between "interval" blocks.  If the actual elapsed time is
     ; significantly different from this value, the network difficulty formula will produce a different value.
     ; Both test and main Bitcoin networks use 2 weeks (1209600 seconds).
     ;;
#_public
    int getTargetTimespan()
    (§
        return targetTimespan;
    )

    ;;;
     ; The version codes that prefix addresses which are acceptable on this network.  Although Satoshi intended these
     ; to be used for "versioning", in fact they are today used to discriminate what kind of data is contained in the
     ; address and to prevent accidentally sending coins across chains which would destroy them.
     ;;
#_public
    int[] getAcceptableAddressCodes()
    (§
        return acceptableAddressCodes;
    )

    ;;;
     ; If we are running in testnet-in-a-box mode, we allow connections to nodes with 0 non-genesis blocks.
     ;;
#_public
    boolean allowEmptyPeerChain()
    (§
        return true;
    )

    ;;; How many blocks pass between difficulty adjustment periods.  Bitcoin standardises this to be 2016. ;;
#_public
    int getInterval()
    (§
        return interval;
    )

    ;;; Maximum target represents the easiest allowable proof of work. ;;
#_public
    BigInteger getMaxTarget()
    (§
        return maxTarget;
    )

    ;;;
     ; The key used to sign {@link org.bitcoinj.core.AlertMessage}s.
     ; You can use {@link org.bitcoinj.core.ECKey#verify(byte[], byte[], byte[])} to verify signatures using it.
     ;;
#_public
    byte[] getAlertSigningKey()
    (§
        return alertSigningKey;
    )

    ;;; Returns the 4 byte header for BIP32 (HD) wallet - public key part. ;;
#_public
    int getBip32HeaderPub()
    (§
        return bip32HeaderPub;
    )

    ;;; Returns the 4 byte header for BIP32 (HD) wallet - private key part. ;;
#_public
    int getBip32HeaderPriv()
    (§
        return bip32HeaderPriv;
    )

    ;;;
     ; Returns the number of coins that will be produced in total, on this network.
     ; Where not applicable, a very large number of coins is returned
     ; instead (i.e. the main coin issue for Dogecoin).
     ;;
#_public
#_abstract
    Coin getMaxMoney();

    ;;;
     ; Any standard (i.e. pay-to-address) output smaller than this value will
     ; most likely be rejected by the network.
     ;;
#_public
#_abstract
    Coin getMinNonDustOutput();

    ;;;
     ; The monetary object for this currency.
     ;;
#_public
#_abstract
    MonetaryFormat getMonetaryFormat();

    ;;;
     ; Scheme part for URIs, for example "bitcoin".
     ;;
#_public
#_abstract
    String getUriScheme();

    ;;;
     ; Returns whether this network has a maximum number of coins (finite supply) or not.
     ; Always returns true for Bitcoin, but exists to be overriden for other networks.
     ;;
#_public
#_abstract
    boolean hasMaxMoney();

    ;;;
     ; Return the default serializer for this network.  This is a shared serializer.
     ;;
#_public
#_final
    MessageSerializer getDefaultSerializer()
    (§
        ;; Construct a default serializer if we don't have one.
        if (this.defaultSerializer == nil)
        (§
            ;; Don't grab a lock unless we absolutely need it.
#_synchronized
            (this)
            (§
                ;; Now we have a lock, double check there's still no serializer and create one if so.
                if (this.defaultSerializer == nil)
                (§
                    ;; As the serializers are intended to be immutable, creating
                    ;; two due to a race condition should not be a problem, however
                    ;; to be safe we ensure only one exists for each network.
                    this.defaultSerializer = getSerializer(false);
                )
            )
        )
        return defaultSerializer;
    )

    ;;;
     ; Construct and return a custom serializer.
     ;;
#_public
#_abstract
    BitcoinSerializer getSerializer(boolean parseRetain);

    ;;;
     ; The number of blocks in the last {@link getMajorityWindow()} blocks
     ; at which to trigger a notice to the user to upgrade their client, where
     ; the client does not understand those blocks.
     ;;
#_public
    int getMajorityEnforceBlockUpgrade()
    (§
        return majorityEnforceBlockUpgrade;
    )

    ;;;
     ; The number of blocks in the last {@link getMajorityWindow()} blocks
     ; at which to enforce the requirement that all new blocks are of the
     ; newer type (i.e. outdated blocks are rejected).
     ;;
#_public
    int getMajorityRejectBlockOutdated()
    (§
        return majorityRejectBlockOutdated;
    )

    ;;;
     ; The sampling window from which the version numbers of blocks are taken
     ; in order to determine if a new block version is now the majority.
     ;;
#_public
    int getMajorityWindow()
    (§
        return majorityWindow;
    )

    ;;;
     ; The flags indicating which block validation tests should be applied to
     ; the given block.  Enables support for alternative blockchains which enable
     ; tests based on different criteria.
     ;
     ; @param block Block to determine flags for.
     ; @param height Height of the block, if known, null otherwise.  Returned
     ; tests should be a safe subset if block height is unknown.
     ;;
#_public
    EnumSet<Block.VerifyFlag> getBlockVerificationFlags(final Block block, final VersionTally tally, final Integer height)
    (§
#_final
        EnumSet<Block.VerifyFlag> flags = EnumSet.noneOf(Block.VerifyFlag.class);

        if (block.isBIP34())
        (§
#_final
            Integer count = tally.getCountAtOrAbove(Block.BLOCK_VERSION_BIP34);
            if (count != nil && getMajorityEnforceBlockUpgrade() <= count)
                flags.add(Block.VerifyFlag.HEIGHT_IN_COINBASE);
        )

        return flags;
    )

    ;;;
     ; The flags indicating which script validation tests should be applied to
     ; the given transaction.  Enables support for alternative blockchains which enable
     ; tests based on different criteria.
     ;
     ; @param block Block the transaction belongs to.
     ; @param transaction to determine flags for.
     ; @param height Height of the block, if known, null otherwise.  Returned
     ; tests should be a safe subset if block height is unknown.
     ;;
#_public
    EnumSet<Script.VerifyFlag> getTransactionVerificationFlags(final Block block, final Transaction transaction, final VersionTally tally, final Integer height)
    (§
#_final
        EnumSet<Script.VerifyFlag> verifyFlags = EnumSet.noneOf(Script.VerifyFlag.class);
        if (NetworkParameters.BIP16_ENFORCE_TIME <= block.getTimeSeconds())
            verifyFlags.add(Script.VerifyFlag.P2SH);

        ;; Start enforcing CHECKLOCKTIMEVERIFY (BIP65) for block.nVersion=4 blocks,
        ;; when 75% of the network has been upgraded:
        if (Block.BLOCK_VERSION_BIP65 <= block.getVersion() && this.getMajorityEnforceBlockUpgrade() < tally.getCountAtOrAbove(Block.BLOCK_VERSION_BIP65))
            verifyFlags.add(Script.VerifyFlag.CHECKLOCKTIMEVERIFY);

        return verifyFlags;
    )

#_public
#_abstract
    int getProtocolVersionNum(final ProtocolVersion version);

#_public
#_static
    enum ProtocolVersion
    (§
        MINIMUM(70000),
        PONG(60001),
        BLOOM_FILTER(70000),
        CURRENT(70001);

#_private
#_final
        int bitcoinProtocol;

        ProtocolVersion(final int bitcoinProtocol)
        (§
            this.bitcoinProtocol = bitcoinProtocol;
        )

#_public
        int getBitcoinProtocolVersion()
        (§
            return bitcoinProtocol;
        )
    )
)

(ns org.bitcoinj.core #_"NotFoundMessage"
    (:import [java.util ArrayList List]))

;;;
 ; <p>Sent by a peer when a getdata request doesn't find the requested data in the mempool.  It has the same format
 ; as an inventory message and lists the hashes of the missing items.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
class NotFoundMessage extends InventoryMessage
(§
#_public
#_static
    int MIN_PROTOCOL_VERSION = 70001;

#_public
    NotFoundMessage(NetworkParameters params)
    (§
        super(params);
    )

#_public
    NotFoundMessage(NetworkParameters params, byte[] payloadBytes)
        throws ProtocolException
    (§
        super(params, payloadBytes);
    )

#_public
    NotFoundMessage(NetworkParameters params, List<InventoryItem> items)
    (§
        super(params);
        this.items = new ArrayList<>(items);
    )
)

(ns org.bitcoinj.core #_"PartialMerkleTree"
    (:import [java.io IOException OutputStream]
             [java.util ArrayList Arrays List])
    (:import [com.google.common.base Objects])
    (:import #_static #_[org.bitcoinj.core.Utils *]))

;;;
 ; <p>A data structure that contains proofs of block inclusion for one or more transactions, in an efficient manner.</p>
 ;
 ; <p>The encoding works as follows: we traverse the tree in depth-first order, storing a bit for each traversed node,
 ; signifying whether the node is the parent of at least one matched leaf txid (or a matched txid itself).  In case we
 ; are at the leaf level, or this bit is 0, its merkle node hash is stored, and its children are not explored further.
 ; Otherwise, no hash is stored, but we recurse into both (or the only) child branch.  During decoding, the same
 ; depth-first traversal is performed, consuming bits and hashes as they were written during encoding.</p>
 ;
 ; <p>The serialization is fixed and provides a hard guarantee about the encoded size,
 ; <tt>SIZE &lt;= 10 + ceil(32.25 * N)</tt> where N represents the number of leaf nodes of the partial tree.
 ; N itself is bounded by:</p>
 ;
 ; N &lt;= total_transactions<br>
 ; N &lt;= 1 + matched_transactions * tree_height
 ;
 ; <p><pre>The serialization format:
 ;  - uint32     total_transactions (4 bytes)
 ;  - varint     number of hashes (1-3 bytes)
 ;  - uint256[]  hashes in depth-first order (&lt;= 32*N bytes)
 ;  - varint     number of bytes of flag bits (1-3 bytes)
 ;  - byte[]     flag bits, packed per 8 in a byte, least significant bit first (&lt;= 2*N-1 bits)
 ; The size constraints follow from this.</pre></p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
class PartialMerkleTree extends Message
(§
    ;; the total number of transactions in the block
#_private
    int transactionCount;

    ;; node-is-parent-of-matched-txid bits
#_private
    byte[] matchedChildBits;

    ;; txids and internal hashes
#_private
    List<Sha256Hash> hashes;

#_public
    PartialMerkleTree(NetworkParameters params, byte[] payloadBytes, int offset)
        throws ProtocolException
    (§
        super(params, payloadBytes, offset);
    )

    ;;;
     ; Constructs a new PMT with the given bit set (little endian) and the raw list of hashes including internal hashes,
     ; taking ownership of the list.
     ;;
#_public
    PartialMerkleTree(NetworkParameters params, byte[] bits, List<Sha256Hash> hashes, int origTxCount)
    (§
        super(params);

        this.matchedChildBits = bits;
        this.hashes = hashes;
        this.transactionCount = origTxCount;
    )

    ;;;
     ; Calculates a PMT given the list of leaf hashes and which leaves need to be included.  The relevant interior hashes
     ; are calculated and a new PMT returned.
     ;;
#_public
#_static
    PartialMerkleTree buildFromLeaves(NetworkParameters params, byte[] includeBits, List<Sha256Hash> allLeafHashes)
    (§
        ;; Calculate height of the tree.
        int height = 0;
        while (1 < getTreeWidth(allLeafHashes.size(), height))
            height++;
        List<Boolean> bitList = new ArrayList<>();
        List<Sha256Hash> hashes = new ArrayList<>();
        traverseAndBuild(height, 0, allLeafHashes, includeBits, bitList, hashes);
        byte[] bits = new byte[(int)Math.ceil(bitList.size() / 8.0)];
        for (int i = 0; i < bitList.size(); i++)
            if (bitList.get(i))
                Utils.setBitLE(bits, i);
        return new PartialMerkleTree(params, bits, hashes, allLeafHashes.size());
    )

#_override
#_public
    void bitcoinSerializeToStream(OutputStream stream)
        throws IOException
    (§
        uint32ToByteStreamLE(transactionCount, stream);

        stream.write(new VarInt(hashes.size()).encode());
        for (Sha256Hash hash : hashes)
            stream.write(hash.getReversedBytes());

        stream.write(new VarInt(matchedChildBits.length).encode());
        stream.write(matchedChildBits);
    )

#_override
#_protected
    void parse()
        throws ProtocolException
    (§
        transactionCount = (int)readUint32();

        int nHashes = (int)readVarInt();
        hashes = new ArrayList<>(nHashes);
        for (int i = 0; i < nHashes; i++)
            hashes.add(readHash());

        int nFlagBytes = (int)readVarInt();
        matchedChildBits = readBytes(nFlagBytes);

        length = cursor - offset;
    )

    ;; Based on CPartialMerkleTree::TraverseAndBuild in Bitcoin Core.
#_private
#_static
    void traverseAndBuild(int height, int pos, List<Sha256Hash> allLeafHashes, byte[] includeBits, List<Boolean> matchedChildBits, List<Sha256Hash> resultHashes)
    (§
        boolean parentOfMatch = false;
        ;; Is this node a parent of at least one matched hash?
        for (int p = pos << height; p < (pos + 1) << height && p < allLeafHashes.size(); p++)
        (§
            if (Utils.checkBitLE(includeBits, p))
            (§
                parentOfMatch = true;
                break;
            )
        )
        ;; Store as a flag bit.
        matchedChildBits.add(parentOfMatch);
        if (height == 0 || !parentOfMatch)
        (§
            ;; If at height 0, or nothing interesting below, store hash and stop.
            resultHashes.add(calcHash(height, pos, allLeafHashes));
        )
        else
        (§
            ;; Otherwise descend into the subtrees.
            int h = height - 1;
            int p = pos * 2;
            traverseAndBuild(h, p, allLeafHashes, includeBits, matchedChildBits, resultHashes);
            if (p + 1 < getTreeWidth(allLeafHashes.size(), h))
                traverseAndBuild(h, p + 1, allLeafHashes, includeBits, matchedChildBits, resultHashes);
        )
    )

#_private
#_static
    Sha256Hash calcHash(int height, int pos, List<Sha256Hash> hashes)
    (§
        ;; Hash at height 0 is just the regular tx hash itself.
        if (height == 0)
            return hashes.get(pos);

        int h = height - 1;
        int p = pos * 2;
        Sha256Hash left = calcHash(h, p, hashes);
        ;; Calculate right hash if not beyond the end of the array - copy left hash otherwise.
        Sha256Hash right = (p + 1 < getTreeWidth(hashes.size(), h)) ? calcHash(h, p + 1, hashes) : left;

        return combineLeftRight(left.getBytes(), right.getBytes());
    )

    ;; Helper function to efficiently calculate the number of nodes at given height in the merkle tree.
#_private
#_static
    int getTreeWidth(int transactionCount, int height)
    (§
        return (transactionCount + (1 << height) - 1) >> height;
    )

#_private
#_static
    class ValuesUsed
    (§
#_public
        int bitsUsed = 0, hashesUsed = 0;
    )

    ;; Recursive function that traverses tree nodes, consuming the bits and hashes produced by TraverseAndBuild.
    ;; It returns the hash of the respective node.
#_private
    Sha256Hash recursiveExtractHashes(int height, int pos, ValuesUsed used, List<Sha256Hash> matchedHashes)
        throws VerificationException
    (§
        ;; overflowed bits array - failure
        if (matchedChildBits.length * 8 <= used.bitsUsed)
            throw new VerificationException("PartialMerkleTree overflowed its bits array");

        boolean parentOfMatch = checkBitLE(matchedChildBits, used.bitsUsed++);

        ;; if at height 0, or nothing interesting below, use stored hash and do not descend
        if (height == 0 || !parentOfMatch)
        (§
            ;; overflowed hash array - failure
            if (hashes.size() <= used.hashesUsed)
                throw new VerificationException("PartialMerkleTree overflowed its hash array");

            Sha256Hash hash = hashes.get(used.hashesUsed++);
            ;; in case of height 0, we have a matched txid
            if (height == 0 && parentOfMatch)
                matchedHashes.add(hash);

            return hash;
        )
        else
        (§
            ;; otherwise, descend into the subtrees to extract matched txids and hashes
            byte[] left = recursiveExtractHashes(height - 1, pos * 2, used, matchedHashes).getBytes(), right;
            if (pos * 2 + 1 < getTreeWidth(transactionCount, height - 1))
            (§
                right = recursiveExtractHashes(height - 1, pos * 2 + 1, used, matchedHashes).getBytes();
                if (Arrays.equals(right, left))
                    throw new VerificationException("Invalid merkle tree with duplicated left/right branches");
            )
            else
            (§
                right = left;
            )
            ;; and combine them before returning
            return combineLeftRight(left, right);
        )
    )

#_private
#_static
    Sha256Hash combineLeftRight(byte[] left, byte[] right)
    (§
        return Sha256Hash.wrapReversed(Sha256Hash.hashTwice(reverseBytes(left), 0, 32, reverseBytes(right), 0, 32));
    )

    ;;;
     ; Extracts tx hashes that are in this merkle tree and returns the merkle root of this tree.
     ;
     ; The returned root should be checked against the merkle root contained in the block header for security.
     ;
     ; @param matchedHashesOut A list which will contain the matched txn (will be cleared).
     ; @return the merkle root of this merkle tree.
     ; @throws ProtocolException if this partial merkle tree is invalid.
     ;;
#_public
    Sha256Hash getTxnHashAndMerkleRoot(List<Sha256Hash> matchedHashesOut)
        throws VerificationException
    (§
        matchedHashesOut.clear();

        ;; an empty set will not work
        if (transactionCount == 0)
            throw new VerificationException("Got a CPartialMerkleTree with 0 transactions");
        ;; check for excessively high numbers of transactions
        if (Block.MAX_BLOCK_SIZE / 60 < transactionCount) ;; 60 is the lower bound for the size of a serialized CTransaction
            throw new VerificationException("Got a CPartialMerkleTree with more transactions than is possible");
        ;; there can never be more hashes provided than one for every txid
        if (transactionCount < hashes.size())
            throw new VerificationException("Got a CPartialMerkleTree with more hashes than transactions");
        ;; there must be at least one bit per node in the partial tree, and at least one node per hash
        if (matchedChildBits.length * 8 < hashes.size())
            throw new VerificationException("Got a CPartialMerkleTree with fewer matched bits than hashes");

        ;; calculate height of tree
        int height = 0;
        while (1 < getTreeWidth(transactionCount, height))
            height++;
        ;; traverse the partial tree
        ValuesUsed used = new ValuesUsed();
        Sha256Hash merkleRoot = recursiveExtractHashes(height, 0, used, matchedHashesOut);
        ;; verify that all bits were consumed (except for the padding caused by serializing it as a byte sequence)
        ;; verify that all hashes were consumed
        if ((used.bitsUsed + 7) / 8 != matchedChildBits.length || used.hashesUsed != hashes.size())
            throw new VerificationException("Got a CPartialMerkleTree that didn't need all the data it provided");

        return merkleRoot;
    )

#_public
    int getTransactionCount()
    (§
        return transactionCount;
    )

#_override
#_public
    boolean equals(Object o)
    (§
        if (this == o)
            return true;
        if (o == nil || getClass() != o.getClass())
            return false;
        PartialMerkleTree other = (PartialMerkleTree)o;
        return (transactionCount == other.transactionCount && hashes.equals(other.hashes) && Arrays.equals(matchedChildBits, other.matchedChildBits));
    )

#_override
#_public
    int hashCode()
    (§
        return Objects.hashCode(transactionCount, hashes, Arrays.hashCode(matchedChildBits));
    )

#_override
#_public
    String toString()
    (§
        return "PartialMerkleTree{" +
                "transactionCount=" + transactionCount +
                ", matchedChildBits=" + Arrays.toString(matchedChildBits) +
                ", hashes=" + hashes +
                '}';
    )
)

(ns org.bitcoinj.core #_"Peer"
    (:import #_[java.util *]
             [java.util.concurrent CopyOnWriteArrayList CopyOnWriteArraySet Executor]
             [java.util.concurrent.atomic AtomicInteger]
             [java.util.concurrent.locks ReentrantLock])
    (:import [com.google.common.base * Objects]
             [com.google.common.collect Lists]
             [com.google.common.util.concurrent FutureCallback Futures ListenableFuture SettableFuture]
             [net.jcip.annotations GuardedBy]
             [org.slf4j Logger LoggerFactory])
  #_(:require #_[org.bitcoinj.core.listeners *]
             [org.bitcoinj.net StreamConnection]
             [org.bitcoinj.store BlockStore BlockStoreException]
             [org.bitcoinj.utils ListenerRegistration Threading]
             [org.bitcoinj.wallet Wallet]))

;;;
 ; <p>A Peer handles the high level communication with a Bitcoin node, extending a {@link PeerSocketHandler} which
 ; handles low-level message (de)serialization.</p>
 ;
 ; <p>Note that timeouts are handled by the extended
 ; {@link org.bitcoinj.net.AbstractTimeoutHandler} and timeout is automatically disabled (using
 ; {@link org.bitcoinj.net.AbstractTimeoutHandler#setTimeoutEnabled(boolean)}) once the version
 ; handshake completes.</p>
 ;;
#_public
class Peer extends PeerSocketHandler
(§
#_private
#_static
#_final
    Logger log = LoggerFactory.getLogger(Peer.class);

#_protected
#_final
    ReentrantLock lock = Threading.lock("peer");

#_private
#_final
    NetworkParameters params;
#_private
#_final
    AbstractBlockChain blockChain;
#_private
#_final
    Context context;

#_private
#_final
    CopyOnWriteArrayList<ListenerRegistration<BlocksDownloadedEventListener>> blocksDownloadedEventListeners = new CopyOnWriteArrayList<>();
#_private
#_final
    CopyOnWriteArrayList<ListenerRegistration<ChainDownloadStartedEventListener>> chainDownloadStartedEventListeners = new CopyOnWriteArrayList<>();
#_private
#_final
    CopyOnWriteArrayList<ListenerRegistration<PeerConnectedEventListener>> connectedEventListeners = new CopyOnWriteArrayList<>();
#_private
#_final
    CopyOnWriteArrayList<ListenerRegistration<PeerDisconnectedEventListener>> disconnectedEventListeners = new CopyOnWriteArrayList<>();
#_private
#_final
    CopyOnWriteArrayList<ListenerRegistration<GetDataEventListener>> getDataEventListeners = new CopyOnWriteArrayList<>();
#_private
#_final
    CopyOnWriteArrayList<ListenerRegistration<PreMessageReceivedEventListener>> preMessageReceivedEventListeners = new CopyOnWriteArrayList<>();
#_private
#_final
    CopyOnWriteArrayList<ListenerRegistration<OnTransactionBroadcastListener>> onTransactionEventListeners = new CopyOnWriteArrayList<>();

    ;; Whether to try and download blocks and transactions from this peer.  Set to false by PeerGroup if not the
    ;; primary peer.  This is to avoid redundant work and concurrency problems with downloading the same chain
    ;; in parallel.
#_private
#_volatile
    boolean vDownloadData;
    ;; The version data to announce to the other side of the connections we make: useful for setting our "user agent"
    ;; equivalent and other things.
#_private
#_final
    VersionMessage versionMessage;
    ;; Maximum depth up to which pending transaction dependencies are downloaded, or 0 for disabled.
#_private
#_volatile
    int vDownloadTxDependencyDepth;
    ;; How many block messages the peer has announced to us.  Peers only announce blocks that attach to their best chain
    ;; so we can use this to calculate the height of the peers chain, by adding it to the initial height in the version
    ;; message.  This method can go wrong if the peer re-orgs onto a shorter (but harder) chain, however, this is rare.
#_private
#_final
    AtomicInteger blocksAnnounced = new AtomicInteger();
    ;; Each wallet added to the peer will be notified of downloaded transaction data.
#_private
#_final
    CopyOnWriteArrayList<Wallet> wallets;
    ;; A time before which we only download block headers, after that point we download block bodies.
#_guarded-by("lock")
#_private
    long fastCatchupTimeSecs;
    ;; Whether we are currently downloading headers only or block bodies.  Starts at true.  If the fast catchup time is
    ;; set AND our best block is before that date, switch to false until block headers beyond that point have been
    ;; received at which point it gets set to true again.  This isn't relevant unless vDownloadData is true.
#_guarded-by("lock")
#_private
    boolean downloadBlockBodies = true;
    ;; Whether to request filtered blocks instead of full blocks if the protocol version allows for them.
#_guarded-by("lock")
#_private
    boolean useFilteredBlocks = false;
    ;; The current Bloom filter set on the connection, used to tell the remote peer what transactions to send us.
#_private
#_volatile
    BloomFilter vBloomFilter;
    ;; The last filtered block we received, we're waiting to fill it out with transactions.
#_private
    FilteredBlock currentFilteredBlock = nil;
    ;; How many filtered blocks have been received during the lifetime of this connection.  Used to decide when to
    ;; refresh the server-side side filter by sending a new one (it degrades over time as false positives are added
    ;; on the remote side, see BIP 37 for a discussion of this).
    ;; TODO: Is this still needed?  It should not be since the auto FP tracking logic was added.
#_private
    int filteredBlocksReceived;
    ;; If non-null, we should discard incoming filtered blocks because we ran out of keys and are awaiting a new filter
    ;; to be calculated by the PeerGroup.  The discarded block hashes should be added here so we can re-request them
    ;; once we've recalculated and resent a new filter.
#_guarded-by("lock")
#_nilable
#_private
    List<Sha256Hash> awaitingFreshFilter;
    ;; How frequently to refresh the filter.  This should become dynamic in future and calculated depending on the
    ;; actual false positive rate.  For now a good value was determined empirically around January 2013.
#_private
#_static
#_final
    int RESEND_BLOOM_FILTER_BLOCK_COUNT = 25000;
    ;; Keeps track of things we requested internally with getdata but didn't receive yet, so we can avoid re-requests.
    ;; It's not quite the same as getDataFutures, as this is used only for getdatas done as part of downloading
    ;; the chain and so is lighter weight (we just keep a bunch of hashes not futures).
    ;;
    ;; It is important to avoid a nasty edge case where we can end up with parallel chain downloads proceeding
    ;; simultaneously if we were to receive a newly solved block whilst parts of the chain are streaming to us.
#_private
#_final
    HashSet<Sha256Hash> pendingBlockDownloads = new HashSet<>();
    ;; Keep references to TransactionConfidence objects for transactions that were announced by a remote peer, but
    ;; which we haven't downloaded yet.  These objects are de-duplicated by the TxConfidenceTable class.
    ;; Once the tx is downloaded (by some peer), the Transaction object that is created will have a reference to
    ;; the confidence object held inside it, and it's then up to the event listeners that receive the Transaction
    ;; to keep it pinned to the root set if they care about this data.
#_suppress("MismatchedQueryAndUpdateOfCollection")
#_private
#_final
    HashSet<TransactionConfidence> pendingTxDownloads = new HashSet<>();
    ;; The lowest version number we're willing to accept.  Lower than this will result in an immediate disconnect.
#_private
#_volatile
    int vMinProtocolVersion;
    ;; When an API user explicitly requests a block or transaction from a peer, the InventoryItem is put here
    ;; whilst waiting for the response.  Is not used for downloads Peer generates itself.
#_private
#_static
    class GetDataRequest
    (§
#_final
        Sha256Hash hash;
#_final
        SettableFuture future;

#_public
        GetDataRequest(Sha256Hash hash, SettableFuture future)
        (§
            this.hash = hash;
            this.future = future;
        )
    )
    ;; TODO: The types/locking should be rationalised a bit.
#_private
#_final
    CopyOnWriteArrayList<GetDataRequest> getDataFutures;
#_guarded-by("getAddrFutures")
#_private
#_final
    LinkedList<SettableFuture<AddressMessage>> getAddrFutures;

#_private
#_static
#_final
    int PING_MOVING_AVERAGE_WINDOW = 20;

    ;; Outstanding pings against this peer and how long the last one took to complete.
#_private
#_final
    ReentrantLock lastPingTimesLock = new ReentrantLock();
#_guarded-by("lastPingTimesLock")
#_private
    long[] lastPingTimes;
#_private
#_final
    CopyOnWriteArrayList<PendingPing> pendingPings;

#_private
#_volatile
    VersionMessage vPeerVersionMessage;

    ;; A settable future which completes (with this) when the connection is open.
#_private
#_final
    SettableFuture<Peer> connectionOpenFuture = SettableFuture.create();
#_private
#_final
    SettableFuture<Peer> outgoingVersionHandshakeFuture = SettableFuture.create();
#_private
#_final
    SettableFuture<Peer> incomingVersionHandshakeFuture = SettableFuture.create();
#_private
#_final
    ListenableFuture<Peer> versionHandshakeFuture = Futures.transform(
            Futures.allAsList(outgoingVersionHandshakeFuture, incomingVersionHandshakeFuture),
            new Function<List<Peer>, Peer>()
            (§
#_override
#_nilable
#_public
                Peer apply(#_nilable List<Peer> peers)
                (§
                    Preconditions.checkNotNull(peers);
                    Preconditions.checkState(peers.size() == 2 && peers.get(0) == peers.get(1));
                    return peers.get(0);
                )
            ));

    ;;;
     ; <p>Construct a peer that reads/writes from the given block chain.</p>
     ;
     ; <p>Note that this does <b>NOT</b> make a connection to the given remoteAddress, it only creates a handler
     ; for a connection.  If you want to create a one-off connection, create a Peer and pass it to
     ; {@link org.bitcoinj.net.NioClientManager#openConnection(java.net.SocketAddress, StreamConnection)}
     ; or
     ; {@link org.bitcoinj.net.NioClient#NioClient(java.net.SocketAddress, StreamConnection, int)}.</p>
     ;
     ; <p>The remoteAddress provided should match the remote address of the peer which is being connected to,
     ; and is used to keep track of which peers relayed transactions and offer more descriptive logging.</p>
     ;;
#_public
    Peer(NetworkParameters params, VersionMessage ver, #_nilable AbstractBlockChain chain, PeerAddress remoteAddress)
    (§
        this(params, ver, remoteAddress, chain);
    )

    ;;;
     ; <p>Construct a peer that reads/writes from the given block chain.  Transactions stored in a {@link org.bitcoinj.core.TxConfidenceTable}
     ; will have their confidence levels updated when a peer announces it, to reflect the greater likelyhood that
     ; the transaction is valid.</p>
     ;
     ; <p>Note that this does <b>NOT</b> make a connection to the given remoteAddress, it only creates a handler
     ; for a connection.  If you want to create a one-off connection, create a Peer and pass it to
     ; {@link org.bitcoinj.net.NioClientManager#openConnection(java.net.SocketAddress, StreamConnection)}
     ; or
     ; {@link org.bitcoinj.net.NioClient#NioClient(java.net.SocketAddress, StreamConnection, int)}.</p>
     ;
     ; <p>The remoteAddress provided should match the remote address of the peer which is being connected to,
     ; and is used to keep track of which peers relayed transactions and offer more descriptive logging.</p>
     ;;
#_public
    Peer(NetworkParameters params, VersionMessage ver, PeerAddress remoteAddress, #_nilable AbstractBlockChain chain)
    (§
        this(params, ver, remoteAddress, chain, Integer.MAX_VALUE);
    )

    ;;;
     ; <p>Construct a peer that reads/writes from the given block chain.  Transactions stored in a {@link org.bitcoinj.core.TxConfidenceTable}
     ; will have their confidence levels updated when a peer announces it, to reflect the greater likelyhood that
     ; the transaction is valid.</p>
     ;
     ; <p>Note that this does <b>NOT</b> make a connection to the given remoteAddress, it only creates a handler
     ; for a connection.  If you want to create a one-off connection, create a Peer and pass it to
     ; {@link org.bitcoinj.net.NioClientManager#openConnection(java.net.SocketAddress, StreamConnection)}
     ; or
     ; {@link org.bitcoinj.net.NioClient#NioClient(java.net.SocketAddress, StreamConnection, int)}.</p>
     ;
     ; <p>The remoteAddress provided should match the remote address of the peer which is being connected to,
     ; and is used to keep track of which peers relayed transactions and offer more descriptive logging.</p>
     ;;
#_public
    Peer(NetworkParameters params, VersionMessage ver, PeerAddress remoteAddress, #_nilable AbstractBlockChain chain, int downloadTxDependencyDepth)
    (§
        super(params, remoteAddress);

        this.params = Preconditions.checkNotNull(params);
        this.versionMessage = Preconditions.checkNotNull(ver);
        this.vDownloadTxDependencyDepth = (chain != nil) ? downloadTxDependencyDepth : 0;
        this.blockChain = chain; ;; Allowed to be nil.
        this.vDownloadData = (chain != nil);
        this.getDataFutures = new CopyOnWriteArrayList<>();
        this.getAddrFutures = new LinkedList<>();
        this.fastCatchupTimeSecs = params.getGenesisBlock().getTimeSeconds();
        this.pendingPings = new CopyOnWriteArrayList<>();
        this.vMinProtocolVersion = params.getProtocolVersionNum(NetworkParameters.ProtocolVersion.PONG);
        this.wallets = new CopyOnWriteArrayList<>();
        this.context = Context.get();

        this.versionHandshakeFuture.addListener(new Runnable()
        (§
#_override
#_public
            void run()
            (§
                versionHandshakeComplete();
            )
        ), Threading.SAME_THREAD);
    )

    ;;;
     ; <p>Construct a peer that reads/writes from the given chain.  Automatically creates a VersionMessage for you from
     ; the given software name/version strings, which should be something like "MySimpleTool", "1.0" and which will tell
     ; the remote node to relay transaction inv messages before it has received a filter.</p>
     ;
     ; <p>Note that this does <b>NOT</b> make a connection to the given remoteAddress, it only creates a handler
     ; for a connection. If you want to create a one-off connection, create a Peer and pass it to
     ; {@link org.bitcoinj.net.NioClientManager#openConnection(java.net.SocketAddress, StreamConnection)}
     ; or
     ; {@link org.bitcoinj.net.NioClient#NioClient(java.net.SocketAddress, StreamConnection, int)}.</p>
     ;
     ; <p>The remoteAddress provided should match the remote address of the peer which is being connected to,
     ; and is used to keep track of which peers relayed transactions and offer more descriptive logging.</p>
     ;;
#_public
    Peer(NetworkParameters params, AbstractBlockChain blockChain, PeerAddress peerAddress, String thisSoftwareName, String thisSoftwareVersion)
    (§
        this(params, new VersionMessage(params, blockChain.getBestChainHeight()), blockChain, peerAddress);
        this.versionMessage.appendToSubVer(thisSoftwareName, thisSoftwareVersion, nil);
    )

    ;;; Registers a listener that is invoked when new blocks are downloaded. ;;
#_public
    void addBlocksDownloadedEventListener(BlocksDownloadedEventListener listener)
    (§
        addBlocksDownloadedEventListener(Threading.USER_THREAD, listener);
    )

    ;;; Registers a listener that is invoked when new blocks are downloaded. ;;
#_public
    void addBlocksDownloadedEventListener(Executor executor, BlocksDownloadedEventListener listener)
    (§
        blocksDownloadedEventListeners.add(new ListenerRegistration(listener, executor));
    )

    ;;; Registers a listener that is invoked when a blockchain downloaded starts. ;;
#_public
    void addChainDownloadStartedEventListener(ChainDownloadStartedEventListener listener)
    (§
        addChainDownloadStartedEventListener(Threading.USER_THREAD, listener);
    )

    ;;; Registers a listener that is invoked when a blockchain downloaded starts. ;;
#_public
    void addChainDownloadStartedEventListener(Executor executor, ChainDownloadStartedEventListener listener)
    (§
        chainDownloadStartedEventListeners.add(new ListenerRegistration(listener, executor));
    )

    ;;; Registers a listener that is invoked when a peer is connected. ;;
#_public
    void addConnectedEventListener(PeerConnectedEventListener listener)
    (§
        addConnectedEventListener(Threading.USER_THREAD, listener);
    )

    ;;; Registers a listener that is invoked when a peer is connected. ;;
#_public
    void addConnectedEventListener(Executor executor, PeerConnectedEventListener listener)
    (§
        connectedEventListeners.add(new ListenerRegistration(listener, executor));
    )

    ;;; Registers a listener that is invoked when a peer is disconnected. ;;
#_public
    void addDisconnectedEventListener(PeerDisconnectedEventListener listener)
    (§
        addDisconnectedEventListener(Threading.USER_THREAD, listener);
    )

    ;;; Registers a listener that is invoked when a peer is disconnected. ;;
#_public
    void addDisconnectedEventListener(Executor executor, PeerDisconnectedEventListener listener)
    (§
        disconnectedEventListeners.add(new ListenerRegistration(listener, executor));
    )

    ;;; Registers a listener that is called when messages are received. ;;
#_public
    void addGetDataEventListener(GetDataEventListener listener)
    (§
        addGetDataEventListener(Threading.USER_THREAD, listener);
    )

    ;;; Registers a listener that is called when messages are received. ;;
#_public
    void addGetDataEventListener(Executor executor, GetDataEventListener listener)
    (§
        getDataEventListeners.add(new ListenerRegistration<>(listener, executor));
    )

    ;;; Registers a listener that is called when a transaction is broadcast across the network. ;;
#_public
    void addOnTransactionBroadcastListener(OnTransactionBroadcastListener listener)
    (§
        addOnTransactionBroadcastListener(Threading.USER_THREAD, listener);
    )

    ;;; Registers a listener that is called when a transaction is broadcast across the network. ;;
#_public
    void addOnTransactionBroadcastListener(Executor executor, OnTransactionBroadcastListener listener)
    (§
        onTransactionEventListeners.add(new ListenerRegistration<>(listener, executor));
    )

    ;;; Registers a listener that is called immediately before a message is received. ;;
#_public
    void addPreMessageReceivedEventListener(PreMessageReceivedEventListener listener)
    (§
        addPreMessageReceivedEventListener(Threading.USER_THREAD, listener);
    )

    ;;; Registers a listener that is called immediately before a message is received. ;;
#_public
    void addPreMessageReceivedEventListener(Executor executor, PreMessageReceivedEventListener listener)
    (§
        preMessageReceivedEventListeners.add(new ListenerRegistration<>(listener, executor));
    )

#_public
    boolean removeBlocksDownloadedEventListener(BlocksDownloadedEventListener listener)
    (§
        return ListenerRegistration.removeFromList(listener, blocksDownloadedEventListeners);
    )

#_public
    boolean removeChainDownloadStartedEventListener(ChainDownloadStartedEventListener listener)
    (§
        return ListenerRegistration.removeFromList(listener, chainDownloadStartedEventListeners);
    )

#_public
    boolean removeConnectedEventListener(PeerConnectedEventListener listener)
    (§
        return ListenerRegistration.removeFromList(listener, connectedEventListeners);
    )

#_public
    boolean removeDisconnectedEventListener(PeerDisconnectedEventListener listener)
    (§
        return ListenerRegistration.removeFromList(listener, disconnectedEventListeners);
    )

#_public
    boolean removeGetDataEventListener(GetDataEventListener listener)
    (§
        return ListenerRegistration.removeFromList(listener, getDataEventListeners);
    )

#_public
    boolean removeOnTransactionBroadcastListener(OnTransactionBroadcastListener listener)
    (§
        return ListenerRegistration.removeFromList(listener, onTransactionEventListeners);
    )

#_public
    boolean removePreMessageReceivedEventListener(PreMessageReceivedEventListener listener)
    (§
        return ListenerRegistration.removeFromList(listener, preMessageReceivedEventListeners);
    )

#_override
#_public
    String toString()
    (§
        PeerAddress addr = getAddress();
        ;; if null, it's a user-provided NetworkConnection object
        return (addr == nil) ? "Peer()" : addr.toString();
    )

#_override
#_protected
    void timeoutOccurred()
    (§
        super.timeoutOccurred();

        if (!connectionOpenFuture.isDone())
            ;; Invoke the event handlers to tell listeners e.g. PeerGroup that we never managed to connect.
            connectionClosed();
    )

#_override
#_public
    void connectionClosed()
    (§
        for (final ListenerRegistration<PeerDisconnectedEventListener> registration : disconnectedEventListeners)
        (§
            registration.executor.execute(new Runnable()
            (§
#_override
#_public
                void run()
                (§
                    registration.listener.onPeerDisconnected(Peer.this, 0);
                )
            ));
        )
    )

#_override
#_public
    void connectionOpened()
    (§
        ;; Announce ourselves.  This has to come first to connect to clients beyond v0.3.20.2 which wait to hear
        ;; from us until they send their version message back.
        PeerAddress address = getAddress();
        log.info("Announcing to {} as: {}", (address == nil) ? "Peer" : address.toSocketAddress(), versionMessage.subVer);
        sendMessage(versionMessage);
        connectionOpenFuture.set(this);
        ;; When connecting, the remote peer sends us a version message with various bits of
        ;; useful data in it.  We need to know the peer protocol version before we can talk to it.
    )

    ;;;
     ; Provides a ListenableFuture that can be used to wait for the socket to connect.  A socket connection does not
     ; mean that protocol handshake has occurred.
     ;;
#_public
    ListenableFuture<Peer> getConnectionOpenFuture()
    (§
        return connectionOpenFuture;
    )

#_public
    ListenableFuture<Peer> getVersionHandshakeFuture()
    (§
        return versionHandshakeFuture;
    )

#_override
#_protected
    void processMessage(Message m)
        throws Exception
    (§
        ;; Allow event listeners to filter the message stream.  Listeners are allowed to drop messages by returning null.
        for (ListenerRegistration<PreMessageReceivedEventListener> registration : preMessageReceivedEventListeners)
        (§
            ;; Skip any listeners that are supposed to run in another thread as we don't want to block waiting for it,
            ;; which might cause circular deadlock.
            if (registration.executor == Threading.SAME_THREAD)
            (§
                m = registration.listener.onPreMessageReceived(this, m);
                if (m == nil)
                    break;
            )
        )
        if (m == nil)
            return;

        ;; If we are in the middle of receiving transactions as part of a filtered block push from the remote node,
        ;; and we receive something that's not a transaction, then we're done.
        if (currentFilteredBlock != nil && !(m instanceof Transaction))
        (§
            endFilteredBlock(currentFilteredBlock);
            currentFilteredBlock = nil;
        )

        ;; No further communication is possible until version handshake is complete.
        if (!(m instanceof VersionMessage || m instanceof VersionAck || (versionHandshakeFuture.isDone() && !versionHandshakeFuture.isCancelled())))
            throw new ProtocolException("Received " + m.getClass().getSimpleName() + " before version handshake is complete.");

        if (m instanceof Ping)
        (§
            processPing((Ping)m);
        )
        else if (m instanceof Pong)
        (§
            processPong((Pong)m);
        )
        else if (m instanceof NotFoundMessage)
        (§
            ;; This is sent to us when we did a getdata on some transactions that aren't in the peers memory pool.
            ;; Because NotFoundMessage is a subclass of InventoryMessage, the test for it must come before the next.
            processNotFoundMessage((NotFoundMessage)m);
        )
        else if (m instanceof InventoryMessage)
        (§
            processInv((InventoryMessage)m);
        )
        else if (m instanceof Block)
        (§
            processBlock((Block)m);
        )
        else if (m instanceof FilteredBlock)
        (§
            startFilteredBlock((FilteredBlock)m);
        )
        else if (m instanceof Transaction)
        (§
            processTransaction((Transaction)m);
        )
        else if (m instanceof GetDataMessage)
        (§
            processGetData((GetDataMessage)m);
        )
        else if (m instanceof AddressMessage)
        (§
            ;; We don't care about addresses of the network right now.  But in future,
            ;; we should save them in the wallet so we don't put too much load on the seed nodes and can
            ;; properly explore the network.
            processAddressMessage((AddressMessage)m);
        )
        else if (m instanceof HeadersMessage)
        (§
            processHeaders((HeadersMessage)m);
        )
        else if (m instanceof AlertMessage)
        (§
            processAlert((AlertMessage)m);
        )
        else if (m instanceof VersionMessage)
        (§
            processVersionMessage((VersionMessage)m);
        )
        else if (m instanceof VersionAck)
        (§
            processVersionAck((VersionAck)m);
        )
        else if (m instanceof RejectMessage)
        (§
            log.error("{} {}: Received {}", this, getPeerVersionMessage().subVer, m);
        )
        else
        (§
            log.warn("{}: Received unhandled message: {}", this, m);
        )
    )

#_private
    void processAddressMessage(AddressMessage m)
    (§
        SettableFuture<AddressMessage> future;
#_synchronized
        (getAddrFutures)
        (§
            future = getAddrFutures.poll();
            if (future == nil) ;; Not an addr message we are waiting for.
                return;
        )
        future.set(m);
    )

#_private
    void processVersionMessage(VersionMessage m)
        throws ProtocolException
    (§
        if (vPeerVersionMessage != nil)
            throw new ProtocolException("Got two version messages from peer");

        vPeerVersionMessage = m;
        ;; Switch to the new protocol version.
        long peerTime = vPeerVersionMessage.time * 1000;
        log.info("{}: Got version={}, subVer='{}', services=0x{}, time={}, blocks={}",
                this,
                vPeerVersionMessage.clientVersion,
                vPeerVersionMessage.subVer,
                vPeerVersionMessage.localServices,
                String.format(Locale.US, "%tF %tT", peerTime, peerTime),
                vPeerVersionMessage.bestHeight);
        ;; bitcoinj is a client mode implementation.  That means there's not much point in us talking to other client
        ;; mode nodes because we can't download the data from them we need to find/verify transactions.  Some bogus
        ;; implementations claim to have a block chain in their services field but then report a height of zero, filter
        ;; them out here.
        if (!vPeerVersionMessage.hasBlockChain() || (!params.allowEmptyPeerChain() && vPeerVersionMessage.bestHeight == 0))
        (§
            ;; Shut down the channel gracefully.
            log.info("{}: Peer does not have a copy of the block chain.", this);
            close();
            return;
        )

        if (vPeerVersionMessage.bestHeight < 0)
            ;; In this case, it's a protocol violation.
            throw new ProtocolException("Peer reports invalid best height: " + vPeerVersionMessage.bestHeight);
        ;; Now it's our turn ...
        ;; Send an ACK message stating we accept the peers protocol version.
        sendMessage(new VersionAck());
        log.debug("{}: Incoming version handshake complete.", this);
        incomingVersionHandshakeFuture.set(this);
    )

#_private
    void processVersionAck(VersionAck m)
        throws ProtocolException
    (§
        if (vPeerVersionMessage == nil)
            throw new ProtocolException("got a version ack before version");

        if (outgoingVersionHandshakeFuture.isDone())
            throw new ProtocolException("got more than one version ack");

        log.debug("{}: Outgoing version handshake complete.", this);
        outgoingVersionHandshakeFuture.set(this);
    )

#_private
    void versionHandshakeComplete()
    (§
        log.debug("{}: Handshake complete.", this);
        setTimeoutEnabled(false);
        for (final ListenerRegistration<PeerConnectedEventListener> registration : connectedEventListeners)
        (§
            registration.executor.execute(new Runnable()
            (§
#_override
#_public
                void run()
                (§
                    registration.listener.onPeerConnected(Peer.this, 1);
                )
            ));
        )
        ;; We check min version after onPeerConnected as channel.close() will
        ;; call onPeerDisconnected, and we should probably call onPeerConnected first.
#_final
        int version = vMinProtocolVersion;
        if (vPeerVersionMessage.clientVersion < version)
        (§
            log.warn("Connected to a peer speaking protocol version {} but need {}, closing", vPeerVersionMessage.clientVersion, version);
            close();
        )
    )

#_protected
    void startFilteredBlock(FilteredBlock m)
    (§
        ;; Filtered blocks come before the data that they refer to, so stash it here and then fill it out as
        ;; messages stream in.  We'll call endFilteredBlock when a non-tx message arrives (e.g. another
        ;; FilteredBlock) or when a tx that isn't needed by that block is found.  A ping message is sent after
        ;; a getblocks, to force the non-tx message path.
        currentFilteredBlock = m;
        ;; Potentially refresh the server side filter.  Because the remote node adds hits back into the filter
        ;; to save round-tripping back through us, the filter degrades over time as false positives get added,
        ;; triggering yet more false positives.  We refresh it every so often to get the FP rate back down.
        filteredBlocksReceived++;
        if (filteredBlocksReceived % RESEND_BLOOM_FILTER_BLOCK_COUNT == RESEND_BLOOM_FILTER_BLOCK_COUNT - 1)
            sendMessage(vBloomFilter);
    )

#_protected
    void processNotFoundMessage(NotFoundMessage m)
    (§
        ;; This is received when we previously did a getdata but the peer couldn't find what we requested in it's
        ;; memory pool.  Typically, because we are downloading dependencies of a relevant transaction and reached
        ;; the bottom of the dependency tree (where the unconfirmed transactions connect to transactions that are
        ;; in the chain).
        ;;
        ;; We go through and cancel the pending getdata futures for the items we were told weren't found.
        for (GetDataRequest req : getDataFutures)
            for (InventoryItem item : m.getItems())
                if (item.hash.equals(req.hash))
                (§
                    log.info("{}: Bottomed out dep tree at {}", this, req.hash);
                    req.future.cancel(true);
                    getDataFutures.remove(req);
                    break;
                )
    )

#_protected
    void processAlert(AlertMessage m)
    (§
        try
        (§
            if (m.isSignatureValid())
                log.info("Received alert from peer {}: {}", this, m.getStatusBar());
            else
                log.warn("Received alert with invalid signature from peer {}: {}", this, m.getStatusBar());
        )
        catch (Throwable t)
        (§
            ;; Signature checking can FAIL on Android platforms before Gingerbread apparently due to bugs in their
            ;; BigInteger implementations!  See https://github.com/bitcoinj/bitcoinj/issues/526 for discussion.
            ;; As alerts are just optional and not that useful, we just swallow the error here.
            log.error("Failed to check signature: bug in platform libraries?", t);
        )
    )

#_protected
    void processHeaders(HeadersMessage m)
        throws ProtocolException
    (§
        ;; Runs in network loop thread for this peer.
        ;;
        ;; This method can run if a peer just randomly sends us a "headers" message (should never happen), or more
        ;; likely when we've requested them as part of chain download using fast catchup.  We need to add each block to
        ;; the chain if it pre-dates the fast catchup time.  If we go past it, we can stop processing the headers and
        ;; request the full blocks from that point on instead.
        boolean downloadBlockBodies;
        long fastCatchupTimeSecs;

        lock.lock();
        try
        (§
            if (blockChain == nil)
            (§
                ;; Can happen if we are receiving unrequested data, or due to programmer error.
                log.warn("Received headers when Peer is not configured with a chain.");
                return;
            )
            fastCatchupTimeSecs = this.fastCatchupTimeSecs;
            downloadBlockBodies = this.downloadBlockBodies;
        )
        finally
        (§
            lock.unlock();
        )

        try
        (§
            Preconditions.checkState(!downloadBlockBodies, toString());

            for (int i = 0; i < m.getBlockHeaders().size(); i++)
            (§
                Block header = m.getBlockHeaders().get(i);
                ;; Process headers until we pass the fast catchup time, or are about to catch up with the head
                ;; of the chain - always process the last block as a full/filtered block to kick us out of the
                ;; fast catchup mode (in which we ignore new blocks).
                boolean passedTime = (fastCatchupTimeSecs <= header.getTimeSeconds());
                boolean reachedTop = (vPeerVersionMessage.bestHeight <= blockChain.getBestChainHeight());
                if (!passedTime && !reachedTop)
                (§
                    if (!vDownloadData)
                    (§
                        ;; Not download peer anymore, some other peer probably became better.
                        log.info("Lost download peer status, throwing away downloaded headers.");
                        return;
                    )
                    if (blockChain.add(header))
                    (§
                        ;; The block was successfully linked into the chain. Notify the user of our progress.
                        invokeOnBlocksDownloaded(header, nil);
                    )
                    else
                    (§
                        ;; This block is unconnected - we don't know how to get from it back to the genesis block yet.
                        ;; That must mean that the peer is buggy or malicious because we specifically requested for
                        ;; headers that are part of the best chain.
                        throw new ProtocolException("Got unconnected header from peer: " + header.getHashAsString());
                    )
                )
                else
                (§
                    lock.lock();
                    try
                    (§
                        log.info("Passed the fast catchup time ({}) at height {}, discarding {} headers and requesting full blocks",
                            Utils.dateTimeFormat(fastCatchupTimeSecs * 1000), blockChain.getBestChainHeight() + 1, m.getBlockHeaders().size() - i);
                        this.downloadBlockBodies = true;
                        ;; Prevent this request being seen as a duplicate.
                        this.lastGetBlocksBegin = Sha256Hash.ZERO_HASH;
                        blockChainDownloadLocked(Sha256Hash.ZERO_HASH);
                    )
                    finally
                    (§
                        lock.unlock();
                    )
                    return;
                )
            )
            ;; We added all headers in the message to the chain.
            ;; Request some more if we got up to the limit, otherwise we are at the end of the chain.
            if (HeadersMessage.MAX_HEADERS <= m.getBlockHeaders().size())
            (§
                lock.lock();
                try
                (§
                    blockChainDownloadLocked(Sha256Hash.ZERO_HASH);
                )
                finally
                (§
                    lock.unlock();
                )
            )
        )
        catch (VerificationException e)
        (§
            log.warn("Block header verification failed", e);
        )
        catch (PrunedException e)
        (§
            ;; Unreachable when in SPV mode.
            throw new RuntimeException(e);
        )
    )

#_protected
    void processGetData(GetDataMessage getdata)
    (§
        log.info("{}: Received getdata message: {}", getAddress(), getdata.toString());
        ArrayList<Message> items = new ArrayList<>();
        for (ListenerRegistration<GetDataEventListener> registration : getDataEventListeners)
        (§
            if (registration.executor != Threading.SAME_THREAD)
                continue;
            List<Message> listenerItems = registration.listener.getData(this, getdata);
            if (listenerItems == nil)
                continue;
            items.addAll(listenerItems);
        )
        if (!items.isEmpty())
        (§
            log.info("{}: Sending {} items gathered from listeners to peer", getAddress(), items.size());
            for (Message item : items)
                sendMessage(item);
        )
    )

#_protected
    void processTransaction(final Transaction tx)
        throws VerificationException
    (§
        ;; Check a few basic syntax issues to ensure the received TX isn't nonsense.
        tx.verify();
        lock.lock();
        try
        (§
            log.debug("{}: Received tx {}", getAddress(), tx.getHashAsString());
            ;; Label the transaction as coming in from the P2P network (as opposed to being created by us, direct import,
            ;; etc).  This helps the wallet decide how to risk analyze it later.
            ;;
            ;; Additionally, by invoking tx.getConfidence(), this tx now pins the confidence data into the heap, meaning
            ;; we can stop holding a reference to the confidence object ourselves.  It's up to event listeners on the
            ;; Peer to stash the tx object somewhere if they want to keep receiving updates about network propagation
            ;; and so on.
            TransactionConfidence confidence = tx.getConfidence();
            confidence.setSource(TransactionConfidence.Source.NETWORK);
            pendingTxDownloads.remove(confidence);
            if (maybeHandleRequestedData(tx))
                return;

            if (currentFilteredBlock != nil)
            (§
                if (!currentFilteredBlock.provideTransaction(tx))
                (§
                    ;; Got a tx that didn't fit into the filtered block, so we must have received everything.
                    endFilteredBlock(currentFilteredBlock);
                    currentFilteredBlock = nil;
                )
                ;; Don't tell wallets or listeners about this tx as they'll learn about it when the filtered block is
                ;; fully downloaded instead.
                return;
            )

            ;; It's a broadcast transaction.  Tell all wallets about this tx so they can check if it's relevant or not.
            for (final Wallet wallet : wallets)
            (§
                try
                (§
                    if (wallet.isPendingTransactionRelevant(tx))
                    (§
                        if (0 < vDownloadTxDependencyDepth)
                        (§
                            ;; This transaction seems interesting to us, so let's download its dependencies.  This has
                            ;; several purposes: we can check that the sender isn't attacking us by engaging in protocol
                            ;; abuse games, like depending on a time-locked transaction that will never confirm, or
                            ;; building huge chains of unconfirmed transactions (again - so they don't confirm and the
                            ;; money can be taken back with a Finney attack).  Knowing the dependencies also lets us
                            ;; store them in a serialized wallet so we always have enough data to re-announce to the
                            ;; network and get the payment into the chain, in case the sender goes away and the network
                            ;; starts to forget.
                            ;;
                            ;; TODO: Not all the above things are implemented.
                            ;;
                            ;; Note that downloading of dependencies can end up walking around 15 minutes back even
                            ;; through transactions that have confirmed, as getdata on the remote peer also checks
                            ;; relay memory not only the mempool.  Unfortunately we have no way to know that here.
                            ;; In practice it should not matter much.
                            Futures.addCallback(downloadDependencies(tx), new FutureCallback<List<Transaction>>()
                            (§
#_override
#_public
                                void onSuccess(List<Transaction> dependencies)
                                (§
                                    try
                                    (§
                                        log.info("{}: Dependency download complete!", getAddress());
                                        wallet.receivePending(tx, dependencies);
                                    )
                                    catch (VerificationException e)
                                    (§
                                        log.error("{}: Wallet failed to process pending transaction {}", getAddress(), tx.getHash());
                                        log.error("Error was: ", e);
                                        ;; Not much more we can do at this point.
                                    )
                                )

#_override
#_public
                                void onFailure(Throwable throwable)
                                (§
                                    log.error("Could not download dependencies of tx {}", tx.getHashAsString());
                                    log.error("Error was: ", throwable);
                                    ;; Not much more we can do at this point.
                                )
                            ));
                        )
                        else
                        (§
                            wallet.receivePending(tx, nil);
                        )
                    )
                )
                catch (VerificationException e)
                (§
                    log.error("Wallet failed to verify tx", e);
                    ;; Carry on, listeners may still want to know.
                )
            )
        )
        finally
        (§
            lock.unlock();
        )
        ;; Tell all listeners about this tx so they can decide whether to keep it or not.  If no listener keeps a
        ;; reference around then the memory pool will forget about it after a while too because it uses weak references.
        for (final ListenerRegistration<OnTransactionBroadcastListener> registration : onTransactionEventListeners)
        (§
            registration.executor.execute(new Runnable()
            (§
#_override
#_public
                void run()
                (§
                    registration.listener.onTransaction(Peer.this, tx);
                )
            ));
        )
    )

    ;;;
     ; <p>Returns a future that wraps a list of all transactions that the given transaction depends on, recursively.
     ; Only transactions in peers memory pools are included; the recursion stops at transactions that are in the
     ; current best chain.  So it doesn't make much sense to provide a tx that was already in the best chain and
     ; a precondition checks this.</p>
     ;
     ; <p>For example, if tx has 2 inputs that connect to transactions A and B, and transaction B is unconfirmed and
     ; has one input connecting to transaction C that is unconfirmed, and transaction C connects to transaction D
     ; that is in the chain, then this method will return either {B, C} or {C, B}.  No ordering is guaranteed.</p>
     ;
     ; <p>This method is useful for apps that want to learn about how long an unconfirmed transaction might take
     ; to confirm, by checking for unexpectedly time locked transactions, unusually deep dependency trees or fee-paying
     ; transactions that depend on unconfirmed free transactions.</p>
     ;
     ; <p>Note that dependencies downloaded this way will not trigger the onTransaction method of event listeners.</p>
     ;;
#_public
    ListenableFuture<List<Transaction>> downloadDependencies(Transaction tx)
    (§
        TransactionConfidence.ConfidenceType txConfidence = tx.getConfidence().getConfidenceType();
        Preconditions.checkArgument(txConfidence != TransactionConfidence.ConfidenceType.BUILDING);
        log.info("{}: Downloading dependencies of {}", getAddress(), tx.getHashAsString());
#_final
        LinkedList<Transaction> results = new LinkedList<>();
        ;; future will be invoked when the entire dependency tree has been walked and the results compiled.
#_final
        ListenableFuture<Object> future = downloadDependenciesInternal(vDownloadTxDependencyDepth, 0, tx, new Object(), results);
#_final
        SettableFuture<List<Transaction>> resultFuture = SettableFuture.create();
        Futures.addCallback(future, new FutureCallback<Object>()
        (§
#_override
#_public
            void onSuccess(Object ignored)
            (§
                resultFuture.set(results);
            )

#_override
#_public
            void onFailure(Throwable throwable)
            (§
                resultFuture.setException(throwable);
            )
        ));
        return resultFuture;
    )

    ;; The marker object in the future returned is the same as the parameter.  It is arbitrary and can be anything.
#_protected
    ListenableFuture<Object> downloadDependenciesInternal(final int maxDepth, final int depth, final Transaction tx, final Object marker, final List<Transaction> results)
    (§
#_final
        SettableFuture<Object> resultFuture = SettableFuture.create();
#_final
        Sha256Hash rootTxHash = tx.getHash();
        ;; We want to recursively grab its dependencies.  This is so listeners can learn important information like
        ;; whether a transaction is dependent on a timelocked transaction or has an unexpectedly deep dependency tree
        ;; or depends on a no-fee transaction.

        ;; We may end up requesting transactions that we've already downloaded and thrown away here.
        Set<Sha256Hash> needToRequest = new CopyOnWriteArraySet<>();
        for (TransactionInput input : tx.getInputs())
        (§
            ;; There may be multiple inputs that connect to the same transaction.
            needToRequest.add(input.getOutpoint().getHash());
        )

        lock.lock();
        try
        (§
            ;; Build the request for the missing dependencies.
            List<ListenableFuture<Transaction>> futures = Lists.newArrayList();
            GetDataMessage getdata = new GetDataMessage(params);

            if (1 < needToRequest.size())
                log.info("{}: Requesting {} transactions for depth {} dep resolution", getAddress(), needToRequest.size(), depth + 1);

            for (Sha256Hash hash : needToRequest)
            (§
                getdata.addTransaction(hash);
                GetDataRequest req = new GetDataRequest(hash, SettableFuture.create());
                futures.add(req.future);
                getDataFutures.add(req);
            )

            ListenableFuture<List<Transaction>> successful = Futures.successfulAsList(futures);
            Futures.addCallback(successful, new FutureCallback<List<Transaction>>()
            (§
#_override
#_public
                void onSuccess(List<Transaction> transactions)
                (§
                    ;; Once all transactions either were received, or we know there are no more to come, ...
                    ;; Note that transactions will contain "null" for any positions that weren't successful.
                    List<ListenableFuture<Object>> childFutures = Lists.newLinkedList();
                    for (Transaction tx : transactions)
                    (§
                        if (tx == nil)
                            continue;
                        log.info("{}: Downloaded dependency of {}: {}", getAddress(), rootTxHash, tx.getHashAsString());
                        results.add(tx);
                        ;; Now recurse into the dependencies of this transaction too.
                        if (depth + 1 < maxDepth)
                            childFutures.add(downloadDependenciesInternal(maxDepth, depth + 1, tx, marker, results));
                    )
                    if (childFutures.size() == 0)
                    (§
                        ;; Short-circuit: we're at the bottom of this part of the tree.
                        resultFuture.set(marker);
                    )
                    else
                    (§
                        ;; There are some children to download.  Wait until it's done (and their children, and their
                        ;; children, ...) to inform the caller that we're finished.
                        Futures.addCallback(Futures.successfulAsList(childFutures), new FutureCallback<List<Object>>()
                        (§
#_override
#_public
                            void onSuccess(List<Object> objects)
                            (§
                                resultFuture.set(marker);
                            )

#_override
#_public
                            void onFailure(Throwable throwable)
                            (§
                                resultFuture.setException(throwable);
                            )
                        ));
                    )
                )

#_override
#_public
                void onFailure(Throwable throwable)
                (§
                    resultFuture.setException(throwable);
                )
            ));

            ;; Start the operation.
            sendMessage(getdata);
        )
        catch (Exception e)
        (§
            log.error("{}: Couldn't send getdata in downloadDependencies({})", this, tx.getHash(), e);
            resultFuture.setException(e);
        )
        finally
        (§
            lock.unlock();
        )

        return resultFuture;
    )

#_protected
    void processBlock(Block m)
    (§
        if (log.isDebugEnabled())
            log.debug("{}: Received broadcast block {}", getAddress(), m.getHashAsString());

        ;; Was this block requested by getBlock()?
        if (maybeHandleRequestedData(m))
            return;

        if (blockChain == nil)
        (§
            log.debug("Received block but was not configured with an AbstractBlockChain");
            return;
        )

        ;; Did we lose download peer status after requesting block data?
        if (!vDownloadData)
        (§
            log.debug("{}: Received block we did not ask for: {}", getAddress(), m.getHashAsString());
            return;
        )

        pendingBlockDownloads.remove(m.getHash());

        try
        (§
            ;; Otherwise it's a block sent to us because the peer thought we needed it, so add it to the block chain.
            if (blockChain.add(m))
            (§
                ;; The block was successfully linked into the chain.  Notify the user of our progress.
                invokeOnBlocksDownloaded(m, nil);
            )
            else
            (§
                ;; This block is an orphan - we don't know how to get from it back to the genesis block yet.  That
                ;; must mean that there are blocks we are missing, so do another getblocks with a new block locator
                ;; to ask the peer to send them to us.  This can happen during the initial block chain download where
                ;; the peer will only send us 500 at a time and then sends us the head block expecting us to request
                ;; the others.
                ;;
                ;; We must do two things here:
                ;; (1) Request from current top of chain to the oldest ancestor of the received block in the orphan set.
                ;; (2) Filter out duplicate getblock requests (done in blockChainDownloadLocked).
                ;;
                ;; The reason for (1) is that otherwise if new blocks were solved during the middle of chain download
                ;; we'd do a blockChainDownloadLocked() on the new best chain head, which would cause us to try and grab the
                ;; chain twice (or more!) on the same connection!  The block chain would filter out the duplicates but
                ;; only at a huge speed penalty.  By finding the orphan root we ensure every getblocks looks the same
                ;; no matter how many blocks are solved, and therefore that the (2) duplicate filtering can work.
                ;;
                ;; We only do this if we are not currently downloading headers.  If we are then we don't want to kick
                ;; off a request for lots more headers in parallel.
                lock.lock();
                try
                (§
                    if (downloadBlockBodies)
                    (§
#_final
                        Block orphanRoot = Preconditions.checkNotNull(blockChain.getOrphanRoot(m.getHash()));
                        blockChainDownloadLocked(orphanRoot.getHash());
                    )
                    else
                    (§
                        log.info("Did not start chain download on solved block due to in-flight header download.");
                    )
                )
                finally
                (§
                    lock.unlock();
                )
            )
        )
        catch (VerificationException e)
        (§
            ;; We don't want verification failures to kill the thread.
            log.warn("{}: Block verification failed", getAddress(), e);
        )
        catch (PrunedException e)
        (§
            ;; Unreachable when in SPV mode.
            throw new RuntimeException(e);
        )
    )

    ;; TODO: Fix this duplication.
#_protected
    void endFilteredBlock(FilteredBlock m)
    (§
        if (log.isDebugEnabled())
            log.debug("{}: Received broadcast filtered block {}", getAddress(), m.getHash().toString());

        if (!vDownloadData)
        (§
            log.debug("{}: Received block we did not ask for: {}", getAddress(), m.getHash().toString());
            return;
        )

        if (blockChain == nil)
        (§
            log.debug("Received filtered block but was not configured with an AbstractBlockChain");
            return;
        )

        ;; Note that we currently do nothing about peers which maliciously do not include transactions which
        ;; actually match our filter or which simply do not send us all the transactions we need: it can be fixed
        ;; by cross-checking peers against each other.
        pendingBlockDownloads.remove(m.getBlockHeader().getHash());

        try
        (§
            ;; It's a block sent to us because the peer thought we needed it, so maybe add it to the block chain.
            ;; The FilteredBlock m here contains a list of hashes, and may contain Transaction objects for a subset
            ;; of the hashes (those that were sent to us by the remote peer).  Any hashes that haven't had a tx
            ;; provided in processTransaction are ones that were announced to us previously via an 'inv' so the
            ;; assumption is we have already downloaded them and either put them in the wallet, or threw them away
            ;; for being false positives.
            ;;
            ;; TODO: Fix the following protocol race.
            ;; It is possible for this code to go wrong such that we miss a confirmation.  If the remote peer announces
            ;; a relevant transaction via an 'inv' and then it immediately announces the block that confirms
            ;; the tx before we had a chance to download it+its dependencies and provide them to the wallet, then we
            ;; will add the block to the chain here without the tx being in the wallet and thus it will miss its
            ;; confirmation and become stuck forever.  The fix is to notice that there's a pending getdata for a tx
            ;; that appeared in this block and delay processing until it arrived ... it's complicated by the fact that
            ;; the data may be requested by a different peer to this one.

            ;; Ask each wallet attached to the peer/blockchain if this block exhausts the list of data items
            ;; (keys/addresses) that were used to calculate the previous filter.  If so, then it's possible this block
            ;; is only partial.  Check for discarding first so we don't check for exhaustion on blocks we already know
            ;; we're going to discard, otherwise redundant filters might end up being queued and calculated.
            lock.lock();
            try
            (§
                if (awaitingFreshFilter != nil)
                (§
                    log.info("Discarding block {} because we're still waiting for a fresh filter", m.getHash());
                    ;; We must record the hashes of blocks we discard because you cannot do getblocks twice on the same
                    ;; range of blocks and get an inv both times, due to the codepath in Bitcoin Core hitting
                    ;; CPeer::PushInventory() which checks CPeer::setInventoryKnown and thus deduplicates.
                    awaitingFreshFilter.add(m.getHash());
                    return; ;; Chain download process is restarted via a call to setBloomFilter.
                )

                if (checkForFilterExhaustion(m))
                (§
                    ;; Yes, so we must abandon the attempt to process this block and any further blocks we receive,
                    ;; then wait for the Bloom filter to be recalculated, sent to this peer and for the peer to acknowledge
                    ;; that the new filter is now in use (which we have to simulate with a ping/pong), and then we can
                    ;; safely restart the chain download with the new filter that contains a new set of lookahead keys.
                    log.info("Bloom filter exhausted whilst processing block {}, discarding", m.getHash());
                    awaitingFreshFilter = new LinkedList<>();
                    awaitingFreshFilter.add(m.getHash());
                    awaitingFreshFilter.addAll(blockChain.drainOrphanBlocks());
                    return; ;; Chain download process is restarted via a call to setBloomFilter.
                )
            )
            finally
            (§
                lock.unlock();
            )

            if (blockChain.add(m))
            (§
                ;; The block was successfully linked into the chain.  Notify the user of our progress.
                invokeOnBlocksDownloaded(m.getBlockHeader(), m);
            )
            else
            (§
                ;; This block is an orphan - we don't know how to get from it back to the genesis block yet.  That
                ;; must mean that there are blocks we are missing, so do another getblocks with a new block locator
                ;; to ask the peer to send them to us.  This can happen during the initial block chain download where
                ;; the peer will only send us 500 at a time and then sends us the head block expecting us to request
                ;; the others.
                ;;
                ;; We must do two things here:
                ;; (1) Request from current top of chain to the oldest ancestor of the received block in the orphan set.
                ;; (2) Filter out duplicate getblock requests (done in blockChainDownloadLocked).
                ;;
                ;; The reason for (1) is that otherwise if new blocks were solved during the middle of chain download
                ;; we'd do a blockChainDownloadLocked() on the new best chain head, which would cause us to try and grab the
                ;; chain twice (or more!) on the same connection!  The block chain would filter out the duplicates but
                ;; only at a huge speed penalty.  By finding the orphan root we ensure every getblocks looks the same
                ;; no matter how many blocks are solved, and therefore that the (2) duplicate filtering can work.
                lock.lock();
                try
                (§
#_final
                    Block orphanRoot = Preconditions.checkNotNull(blockChain.getOrphanRoot(m.getHash()));
                    blockChainDownloadLocked(orphanRoot.getHash());
                )
                finally
                (§
                    lock.unlock();
                )
            )
        )
        catch (VerificationException e)
        (§
            ;; We don't want verification failures to kill the thread.
            log.warn("{}: FilteredBlock verification failed", getAddress(), e);
        )
        catch (PrunedException e)
        (§
            ;; We pruned away some of the data we need to properly handle this block.  We need to request the needed
            ;; data from the remote peer and fix things.  Or just give up.
            ;; TODO: Request e.getHash() and submit it to the block store before any other blocks.
            throw new RuntimeException(e);
        )
    )

#_private
    boolean checkForFilterExhaustion(FilteredBlock m)
    (§
        boolean exhausted = false;
        for (Wallet wallet : wallets)
            exhausted |= wallet.checkForFilterExhaustion(m);
        return exhausted;
    )

#_private
    boolean maybeHandleRequestedData(Message m)
    (§
        boolean found = false;
        Sha256Hash hash = m.getHash();
        for (GetDataRequest req : getDataFutures)
        (§
            if (hash.equals(req.hash))
            (§
                req.future.set(m);
                getDataFutures.remove(req);
                found = true;
                ;; Keep going in case there are more.
            )
        )
        return found;
    )

#_private
    void invokeOnBlocksDownloaded(final Block block, #_nilable final FilteredBlock fb)
    (§
        ;; It is possible for the peer block height difference to be negative when blocks have been solved and broadcast
        ;; since the time we first connected to the peer.  However, it's weird and unexpected to receive a callback
        ;; with negative "blocks left" in this case, so we clamp to zero so the API user doesn't have to think about it.
#_final
        int blocksLeft = Math.max(0, (int)vPeerVersionMessage.bestHeight - Preconditions.checkNotNull(blockChain).getBestChainHeight());
        for (final ListenerRegistration<BlocksDownloadedEventListener> registration : blocksDownloadedEventListeners)
        (§
            registration.executor.execute(new Runnable()
            (§
#_override
#_public
                void run()
                (§
                    registration.listener.onBlocksDownloaded(Peer.this, block, fb, blocksLeft);
                )
            ));
        )
    )

#_protected
    void processInv(InventoryMessage inv)
    (§
        List<InventoryItem> items = inv.getItems();

        ;; Separate out the blocks and transactions, we'll handle them differently.
        List<InventoryItem> transactions = new LinkedList<>();
        List<InventoryItem> blocks = new LinkedList<>();

        for (InventoryItem item : items)
        (§
            switch (item.type)
            (§
                case Transaction:
                    transactions.add(item);
                    break;
                case Block:
                    blocks.add(item);
                    break;
                default:
                    throw new IllegalStateException("Not implemented: " + item.type);
            )
        )

#_final
        boolean downloadData = this.vDownloadData;

        if (transactions.size() == 0 && blocks.size() == 1)
        (§
            ;; Single block announcement.  If we're downloading the chain this is just a tickle to make us continue
            ;; (the block chain download protocol is very implicit and not well thought out).  If we're not downloading
            ;; the chain then this probably means a new block was solved and the peer believes it connects to the best
            ;; chain, so count it.  This way getBestChainHeight() can be accurate.
            if (downloadData && blockChain != nil)
            (§
                if (!blockChain.isOrphan(blocks.get(0).hash))
                (§
                    blocksAnnounced.incrementAndGet();
                )
            )
            else
            (§
                blocksAnnounced.incrementAndGet();
            )
        )

        GetDataMessage getdata = new GetDataMessage(params);

        Iterator<InventoryItem> it = transactions.iterator();
        while (it.hasNext())
        (§
            InventoryItem item = it.next();
            ;; Only download the transaction if we are the first peer that saw it be advertised.  Other peers will also
            ;; see it be advertised in inv packets asynchronously, they co-ordinate via the memory pool.  We could
            ;; potentially download transactions faster by always asking every peer for a tx when advertised, as remote
            ;; peers run at different speeds.  However to conserve bandwidth on mobile devices we try to only download a
            ;; transaction once.  This means we can miss broadcasts if the peer disconnects between sending us an inv and
            ;; sending us the transaction: currently we'll never try to re-fetch after a timeout.
            ;;
            ;; The line below can trigger confidence listeners.
            TransactionConfidence conf = context.getConfidenceTable().seen(item.hash, this.getAddress());
            if (1 < conf.numBroadcastPeers())
            (§
                ;; Some other peer already announced this so don't download.
                it.remove();
            )
            else if (conf.getSource().equals(TransactionConfidence.Source.SELF))
            (§
                ;; We created this transaction ourselves, so don't download.
                it.remove();
            )
            else
            (§
                log.debug("{}: getdata on tx {}", getAddress(), item.hash);
                getdata.addItem(item);
                ;; Register with the garbage collector that we care about the confidence data for a while.
                pendingTxDownloads.add(conf);
            )
        )

        ;; If we are requesting filteredblocks, we have to send a ping after the getdata so that we have a clear
        ;; end to the final FilteredBlock's transactions (in the form of a pong) sent to us.
        boolean pingAfterGetData = false;

        lock.lock();
        try
        (§
            if (0 < blocks.size() && downloadData && blockChain != nil)
            (§
                ;; Ideally, we'd only ask for the data here if we actually needed it.  However that can imply a lot of
                ;; disk IO to figure out what we've got.  Normally peers will not send us inv for things we already have
                ;; so we just re-request it here, and if we get duplicates the block chain / wallet will filter them out.
                for (InventoryItem item : blocks)
                (§
                    if (blockChain.isOrphan(item.hash) && downloadBlockBodies)
                    (§
                        ;; If an orphan was re-advertised, ask for more blocks unless we are not currently downloading
                        ;; full block data because we have a getheaders outstanding.
#_final
                        Block orphanRoot = Preconditions.checkNotNull(blockChain.getOrphanRoot(item.hash));
                        blockChainDownloadLocked(orphanRoot.getHash());
                    )
                    else
                    (§
                        ;; Don't re-request blocks we already requested.  Normally this should not happen.  However there is
                        ;; an edge case: if a block is solved and we complete the inv<->getdata<->block<->getblocks cycle
                        ;; whilst other parts of the chain are streaming in, then the new getblocks request won't match the
                        ;; previous one: whilst the stopHash is the same (because we use the orphan root), the start hash
                        ;; will be different and so the getblocks req won't be dropped as a duplicate.  We'll end up
                        ;; requesting a subset of what we already requested, which can lead to parallel chain downloads
                        ;; and other nastyness.  So we just do a quick removal of redundant getdatas here too.
                        ;;
                        ;; Note that as of June 2012 Bitcoin Core won't actually ever interleave blocks pushed as
                        ;; part of chain download with newly announced blocks, so it should always be taken care of by
                        ;; the duplicate check in blockChainDownloadLocked().  But Bitcoin Core may change in future so
                        ;; it's better to be safe here.
                        if (!pendingBlockDownloads.contains(item.hash))
                        (§
                            if (vPeerVersionMessage.isBloomFilteringSupported() && useFilteredBlocks)
                            (§
                                getdata.addFilteredBlock(item.hash);
                                pingAfterGetData = true;
                            )
                            else
                            (§
                                getdata.addItem(item);
                            )
                            pendingBlockDownloads.add(item.hash);
                        )
                    )
                )
                ;; If we're downloading the chain, doing a getdata on the last block we were told about will cause the
                ;; peer to advertize the head block to us in a single-item inv.  When we download THAT, it will be an
                ;; orphan block, meaning we'll re-enter blockChainDownloadLocked() to trigger another getblocks between the
                ;; current best block we have and the orphan block.  If more blocks arrive in the meantime they'll also
                ;; become orphan.
            )
        )
        finally
        (§
            lock.unlock();
        )

        if (!getdata.getItems().isEmpty())
        (§
            ;; This will cause us to receive a bunch of block or tx messages.
            sendMessage(getdata);
        )

        if (pingAfterGetData)
            sendMessage(new Ping((long)(Math.random() * Long.MAX_VALUE)));
    )

    ;;;
     ; Asks the connected peer for the block of the given hash, and returns a future representing the answer.
     ; If you want the block right away and don't mind waiting for it, just call .get() on the result.  Your thread
     ; will block until the peer answers.
     ;;
#_suppress("unchecked")
    ;; The 'unchecked conversion' warning being suppressed here comes from the sendSingleGetData() formally returning
    ;; ListenableFuture instead of ListenableFuture<Block>.  This is okay as sendSingleGetData() actually returns
    ;; ListenableFuture<Block> in this context.  Note that sendSingleGetData() is also used for Transactions.
#_public
    ListenableFuture<Block> getBlock(Sha256Hash blockHash)
    (§
        ;; This does not need to be locked.
        log.info("Request to fetch block {}", blockHash);
        GetDataMessage getdata = new GetDataMessage(params);
        getdata.addBlock(blockHash);
        return sendSingleGetData(getdata);
    )

    ;;;
     ; Asks the connected peer for the given transaction from its memory pool.  Transactions in the chain cannot be
     ; retrieved this way because peers don't have a transaction ID to transaction-pos-on-disk index, and besides,
     ; in future many peers will delete old transaction data they don't need.
     ;;
#_suppress("unchecked")
    ;; The 'unchecked conversion' warning being suppressed here comes from the sendSingleGetData() formally returning
    ;; ListenableFuture instead of ListenableFuture<Transaction>.  This is okay as sendSingleGetData() actually returns
    ;; ListenableFuture<Transaction> in this context.  Note that sendSingleGetData() is also used for Blocks.
#_public
    ListenableFuture<Transaction> getPeerMempoolTransaction(Sha256Hash hash)
    (§
        ;; This does not need to be locked.
        log.info("Request to fetch peer mempool tx  {}", hash);
        GetDataMessage getdata = new GetDataMessage(params);
        getdata.addTransaction(hash);
        return sendSingleGetData(getdata);
    )

    ;;; Sends a getdata with a single item in it. ;;
#_private
    ListenableFuture sendSingleGetData(GetDataMessage getdata)
    (§
        ;; This does not need to be locked.
        Preconditions.checkArgument(getdata.getItems().size() == 1);
        GetDataRequest req = new GetDataRequest(getdata.getItems().get(0).hash, SettableFuture.create());
        getDataFutures.add(req);
        sendMessage(getdata);
        return req.future;
    )

    ;;; Sends a getaddr request to the peer and returns a future that completes with the answer once the peer has replied. ;;
#_public
    ListenableFuture<AddressMessage> getAddr()
    (§
        SettableFuture<AddressMessage> future = SettableFuture.create();
#_synchronized
        (getAddrFutures)
        (§
            getAddrFutures.add(future);
        )
        sendMessage(new GetAddrMessage(params));
        return future;
    )

    ;;;
     ; When downloading the block chain, the bodies will be skipped for blocks created before the given date.
     ; Any transactions relevant to the wallet will therefore not be found, but if you know your wallet has no such
     ; transactions it doesn't matter and can save a lot of bandwidth and processing time.  Note that the times of blocks
     ; isn't known until their headers are available and they are requested in chunks, so some headers may be downloaded
     ; twice using this scheme, but this optimization can still be a large win for newly created wallets.
     ;
     ; @param secondsSinceEpoch Time in seconds since the epoch or 0 to reset to always downloading block bodies.
     ;;
#_public
    void setDownloadParameters(long secondsSinceEpoch, boolean useFilteredBlocks)
    (§
        lock.lock();
        try
        (§
            if (secondsSinceEpoch == 0)
            (§
                fastCatchupTimeSecs = params.getGenesisBlock().getTimeSeconds();
                downloadBlockBodies = true;
            )
            else
            (§
                fastCatchupTimeSecs = secondsSinceEpoch;
                ;; If the given time is before the current chains head block time, then this has no effect (we already
                ;; downloaded everything we need).
                if (blockChain != nil && blockChain.getChainHead().getHeader().getTimeSeconds() < fastCatchupTimeSecs)
                    downloadBlockBodies = false;
            )
            this.useFilteredBlocks = useFilteredBlocks;
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Links the given wallet to this peer.  If you have multiple peers, you should use a {@link PeerGroup} to manage
     ; them and use the {@link PeerGroup#addWallet(Wallet)} method instead of registering the wallet with each peer
     ; independently, otherwise the wallet will receive duplicate notifications.
     ;;
#_public
    void addWallet(Wallet wallet)
    (§
        wallets.add(wallet);
    )

    ;;; Unlinks the given wallet from peer.  See {@link Peer#addWallet(Wallet)}. ;;
#_public
    void removeWallet(Wallet wallet)
    (§
        wallets.remove(wallet);
    )

    ;; Keep track of the last request we made to the peer in blockChainDownloadLocked so we can avoid redundant and harmful
    ;; getblocks requests.
#_guarded-by("lock")
#_private
    Sha256Hash lastGetBlocksBegin, lastGetBlocksEnd;

#_guarded-by("lock")
#_private
    void blockChainDownloadLocked(Sha256Hash toHash)
    (§
        Preconditions.checkState(lock.isHeldByCurrentThread());

        ;; The block chain download process is a bit complicated.  Basically, we start with one or more blocks in a
        ;; chain that we have from a previous session.  We want to catch up to the head of the chain BUT we don't know
        ;; where that chain is up to or even if the top block we have is even still in the chain - we
        ;; might have got ourselves onto a fork that was later resolved by the network.
        ;;
        ;; To solve this, we send the peer a block locator which is just a list of block hashes.  It contains the
        ;; blocks we know about, but not all of them, just enough of them so the peer can figure out if we did end up
        ;; on a fork and if so, what the earliest still valid block we know about is likely to be.
        ;;
        ;; Once it has decided which blocks we need, it will send us an inv with up to 500 block messages.  We may
        ;; have some of them already if we already have a block chain and just need to catch up.  Once we request the
        ;; last block, if there are still more to come it sends us an "inv" containing only the hash of the head
        ;; block.
        ;;
        ;; That causes us to download the head block but then we find (in processBlock) that we can't connect
        ;; it to the chain yet because we don't have the intermediate blocks.  So we rerun this function building a
        ;; new block locator describing where we're up to.
        ;;
        ;; The getblocks with the new locator gets us another inv with another bunch of blocks.  We download them once
        ;; again.  This time when the peer sends us an inv with the head block, we already have it so we won't download
        ;; it again - but we recognize this case as special and call back into blockChainDownloadLocked to continue the
        ;; process.
        ;;
        ;; So this is a complicated process but it has the advantage that we can download a chain of enormous length
        ;; in a relatively stateless manner and with constant memory usage.
        ;;
        ;; All this is made more complicated by the desire to skip downloading the bodies of blocks that pre-date the
        ;; 'fast catchup time', which is usually set to the creation date of the earliest key in the wallet.  Because
        ;; we know there are no transactions using our keys before that date, we need only the headers.  To do that we
        ;; use the "getheaders" command.  Once we find we've gone past the target date, we throw away the downloaded
        ;; headers and then request the blocks from that point onwards.  "getheaders" does not send us an inv, it just
        ;; sends us the data we requested in a "headers" message.

        ;; TODO: Block locators should be abstracted out rather than special cased here.
        List<Sha256Hash> blockLocator = new ArrayList<>(51);

        ;; For now, we don't do the exponential thinning as suggested here:
        ;;
        ;;   https://en.bitcoin.it/wiki/Protocol_specification#getblocks
        ;;
        ;; This is because it requires scanning all the block chain headers, which is very slow.  Instead we add the
        ;; top 100 block headers.  If there is a re-org deeper than that, we'll end up downloading the entire chain.
        ;; We must always put the genesis block as the first entry.

        BlockStore store = Preconditions.checkNotNull(blockChain).getBlockStore();
        StoredBlock chainHead = blockChain.getChainHead();
        Sha256Hash chainHeadHash = chainHead.getHeader().getHash();

        ;; Did we already make this request?  If so, don't do it again.
        if (Objects.equal(lastGetBlocksBegin, chainHeadHash) && Objects.equal(lastGetBlocksEnd, toHash))
        (§
            log.info("blockChainDownloadLocked({}): ignoring duplicated request: {}", toHash, chainHeadHash);
            for (Sha256Hash hash : pendingBlockDownloads)
                log.info("Pending block download: {}", hash);
            log.info(Throwables.getStackTraceAsString(new Throwable()));
            return;
        )

        if (log.isDebugEnabled())
            log.debug("{}: blockChainDownloadLocked({}) current head = {}", this, toHash, chainHead.getHeader().getHashAsString());

        StoredBlock cursor = chainHead;
        for (int i = 100; cursor != nil && 0 < i; i--)
        (§
            blockLocator.add(cursor.getHeader().getHash());
            try
            (§
                cursor = cursor.getPrev(store);
            )
            catch (BlockStoreException e)
            (§
                log.error("Failed to walk the block chain whilst constructing a locator");
                throw new RuntimeException(e);
            )
        )

        ;; Only add the locator if we didn't already do so.  If the chain is < 50 blocks we already reached it.
        if (cursor != nil)
            blockLocator.add(params.getGenesisBlock().getHash());

        ;; Record that we requested this range of blocks so we can filter out duplicate requests in the event
        ;; of a block being solved during chain download.
        lastGetBlocksBegin = chainHeadHash;
        lastGetBlocksEnd = toHash;

        if (downloadBlockBodies)
        (§
            GetBlocksMessage message = new GetBlocksMessage(params, blockLocator, toHash);
            sendMessage(message);
        )
        else
        (§
            ;; Downloading headers for a while instead of full blocks.
            GetHeadersMessage message = new GetHeadersMessage(params, blockLocator, toHash);
            sendMessage(message);
        )
    )

    ;;;
     ; Starts an asynchronous download of the block chain.  The chain download is deemed to be complete once we've
     ; downloaded the same number of blocks that the peer advertised having in its version handshake message.
     ;;
#_public
    void startBlockChainDownload()
    (§
        setDownloadData(true);
        ;; TODO: Peer might still have blocks that we don't have, and even have a heavier
        ;; chain even if the chain block count is lower.
#_final
        int blocksLeft = getPeerBlockHeightDifference();
        if (0 <= blocksLeft)
        (§
            for (final ListenerRegistration<ChainDownloadStartedEventListener> registration : chainDownloadStartedEventListeners)
            (§
                registration.executor.execute(new Runnable()
                (§
#_override
#_public
                    void run()
                    (§
                        registration.listener.onChainDownloadStarted(Peer.this, blocksLeft);
                    )
                ));
            )
            ;; When we just want as many blocks as possible, we can set the target hash to zero.
            lock.lock();
            try
            (§
                blockChainDownloadLocked(Sha256Hash.ZERO_HASH);
            )
            finally
            (§
                lock.unlock();
            )
        )
    )

#_private
    class PendingPing
    (§
        ;; The future that will be invoked when the pong is heard back.
#_public
        SettableFuture<Long> future;
        ;; The random nonce that lets us tell apart overlapping pings/pongs.
#_public
#_final
        long nonce;
        ;; Measurement of the time elapsed.
#_public
#_final
        long startTimeMsec;

#_public
        PendingPing(long nonce)
        (§
            future = SettableFuture.create();
            this.nonce = nonce;
            startTimeMsec = Utils.currentTimeMillis();
        )

#_public
        void complete()
        (§
            if (!future.isDone())
            (§
                Long elapsed = Utils.currentTimeMillis() - startTimeMsec;
                Peer.this.addPingTimeData(elapsed);
                log.debug("{}: ping time is {} msec", Peer.this.toString(), elapsed);
                future.set(elapsed);
            )
        )
    )

    ;;; Adds a ping time sample to the averaging window. ;;
#_private
    void addPingTimeData(long sample)
    (§
        lastPingTimesLock.lock();
        try
        (§
            if (lastPingTimes == nil)
            (§
                lastPingTimes = new long[PING_MOVING_AVERAGE_WINDOW];
                ;; Initialize the averaging window to the first sample.
                Arrays.fill(lastPingTimes, sample);
            )
            else
            (§
                ;; Shift all elements backwards by one.
                System.arraycopy(lastPingTimes, 1, lastPingTimes, 0, lastPingTimes.length - 1);
                ;; And append the new sample to the end.
                lastPingTimes[lastPingTimes.length - 1] = sample;
            )
        )
        finally
        (§
            lastPingTimesLock.unlock();
        )
    )

    ;;;
     ; Sends the peer a ping message and returns a future that will be invoked when the pong is received back.
     ; The future provides a number which is the number of milliseconds elapsed between the ping and the pong.
     ; Once the pong is received the value returned by {@link org.bitcoinj.core.Peer#getLastPingTime()} is
     ; updated.
     ; @throws ProtocolException if the peer version is too low to support measurable pings.
     ;;
#_public
    ListenableFuture<Long> ping()
        throws ProtocolException
    (§
        return ping((long)(Math.random() * Long.MAX_VALUE));
    )

#_protected
    ListenableFuture<Long> ping(long nonce)
        throws ProtocolException
    (§
#_final
        VersionMessage ver = vPeerVersionMessage;
        if (!ver.isPingPongSupported())
            throw new ProtocolException("Peer version is too low for measurable pings: " + ver);

        PendingPing pendingPing = new PendingPing(nonce);
        pendingPings.add(pendingPing);
        sendMessage(new Ping(pendingPing.nonce));

        return pendingPing.future;
    )

    ;;;
     ; Returns the elapsed time of the last ping/pong cycle.  If {@link org.bitcoinj.core.Peer#ping()} has
     ; never been called or we did not hear back the "pong" message yet, returns {@link Long#MAX_VALUE}.
     ;;
#_public
    long getLastPingTime()
    (§
        lastPingTimesLock.lock();
        try
        (§
            return (lastPingTimes != nil) ? lastPingTimes[lastPingTimes.length - 1] : Long.MAX_VALUE;
        )
        finally
        (§
            lastPingTimesLock.unlock();
        )
    )

    ;;;
     ; Returns a moving average of the last N ping/pong cycles.  If {@link org.bitcoinj.core.Peer#ping()} has never
     ; been called or we did not hear back the "pong" message yet, returns {@link Long#MAX_VALUE}.  The moving average
     ; window is 5 buckets.
     ;;
#_public
    long getPingTime()
    (§
        lastPingTimesLock.lock();
        try
        (§
            if (lastPingTimes == nil)
                return Long.MAX_VALUE;
            long sum = 0;
            for (long i : lastPingTimes)
                sum += i;
            return (long)((double)sum / lastPingTimes.length);
        )
        finally
        (§
            lastPingTimesLock.unlock();
        )
    )

#_private
    void processPing(Ping m)
    (§
        if (m.hasNonce())
            sendMessage(new Pong(m.getNonce()));
    )

#_protected
    void processPong(Pong m)
    (§
        ;; Iterates over a snapshot of the list, so we can run unlocked here.
        for (PendingPing ping : pendingPings)
        (§
            if (m.getNonce() == ping.nonce)
            (§
                pendingPings.remove(ping);
                ;; This line may trigger an event listener that re-runs ping().
                ping.complete();
                return;
            )
        )
    )

    ;;;
     ; Returns the difference between our best chain height and the peers, which can either be positive if we are
     ; behind the peer, or negative if the peer is ahead of us.
     ;;
#_public
    int getPeerBlockHeightDifference()
    (§
        Preconditions.checkNotNull(blockChain, "No block chain configured");

        ;; Chain will overflow signed int blocks in ~41,000 years.
        int chainHeight = (int)getBestHeight();
        ;; chainHeight should not be zero/negative because we shouldn't have given the user a Peer that is to another
        ;; client-mode node, nor should it be unconnected.  If that happens it means the user overrode us somewhere or
        ;; there is a bug in the peer management code.
        Preconditions.checkState(params.allowEmptyPeerChain() || 0 < chainHeight, "Connected to peer with zero/negative chain height", chainHeight);
        return chainHeight - blockChain.getBestChainHeight();
    )

#_private
    boolean isNotFoundMessageSupported()
    (§
        return (NotFoundMessage.MIN_PROTOCOL_VERSION <= vPeerVersionMessage.clientVersion);
    )

    ;;;
     ; Returns true if this peer will try and download things it is sent in "inv" messages.
     ; Normally you only need one peer to be downloading data.  Defaults to true.
     ;;
#_public
    boolean isDownloadData()
    (§
        return vDownloadData;
    )

    ;;;
     ; If set to false, the peer won't try and fetch blocks and transactions it hears about.  Normally, only one
     ; peer should download missing blocks.  Defaults to true.  Changing this value from false to true may trigger
     ; a request to the remote peer for the contents of its memory pool, if Bloom filtering is active.
     ;;
#_public
    void setDownloadData(boolean downloadData)
    (§
        this.vDownloadData = downloadData;
    )

    ;;; Returns version data announced by the remote peer. ;;
#_public
    VersionMessage getPeerVersionMessage()
    (§
        return vPeerVersionMessage;
    )

    ;;; Returns version data we announce to our remote peers. ;;
#_public
    VersionMessage getVersionMessage()
    (§
        return versionMessage;
    )

    ;;;
     ; @return the height of the best chain as claimed by peer: sum of its ver announcement and blocks announced since.
     ;;
#_public
    long getBestHeight()
    (§
        return vPeerVersionMessage.bestHeight + blocksAnnounced.get();
    )

    ;;;
     ; The minimum P2P protocol version that is accepted.  If the peer speaks a protocol version lower than this, it
     ; will be disconnected.
     ; @return true if the peer was disconnected as a result.
     ;;
#_public
    boolean setMinProtocolVersion(int minProtocolVersion)
    (§
        this.vMinProtocolVersion = minProtocolVersion;

        VersionMessage ver = getPeerVersionMessage();
        if (ver != nil && ver.clientVersion < minProtocolVersion)
        (§
            log.warn("{}: Disconnecting due to new min protocol version {}, got: {}", this, minProtocolVersion, ver.clientVersion);
            close();
            return true;
        )

        return false;
    )

    ;;;
     ; <p>Sets a Bloom filter on this connection.  This will cause the given {@link BloomFilter} object to be sent
     ; to the remote peer and if either a memory pool has been set using the constructor or the
     ; vDownloadData property is true, a {@link MemoryPoolMessage} is sent as well to trigger downloading of any
     ; pending transactions that may be relevant.</p>
     ;
     ; <p>The Peer does not automatically request filters from any wallets added using {@link Peer#addWallet(Wallet)}.
     ; This is to allow callers to avoid redundantly recalculating the same filter repeatedly when using multiple peers
     ; and multiple wallets together.</p>
     ;
     ; <p>Therefore, you should not use this method if your app uses a {@link PeerGroup}.  It is called for you.</p>
     ;
     ; <p>If the remote peer doesn't support Bloom filtering, then this call is ignored.  Once set you presently cannot
     ; unset a filter, though the underlying p2p protocol does support it.</p>
     ;;
#_public
    void setBloomFilter(BloomFilter filter)
    (§
        setBloomFilter(filter, true);
    )

    ;;;
     ; <p>Sets a Bloom filter on this connection.  This will cause the given {@link BloomFilter} object to be sent
     ; to the remote peer and if requested, a {@link MemoryPoolMessage} is sent as well to trigger downloading of any
     ; pending transactions that may be relevant.</p>
     ;
     ; <p>The Peer does not automatically request filters from any wallets added using {@link Peer#addWallet(Wallet)}.
     ; This is to allow callers to avoid redundantly recalculating the same filter repeatedly when using multiple peers
     ; and multiple wallets together.</p>
     ;
     ; <p>Therefore, you should not use this method if your app uses a {@link PeerGroup}.  It is called for you.</p>
     ;
     ; <p>If the remote peer doesn't support Bloom filtering, then this call is ignored.  Once set you presently cannot
     ; unset a filter, though the underlying p2p protocol does support it.</p>
     ;;
#_public
    void setBloomFilter(BloomFilter filter, boolean andQueryMemPool)
    (§
        Preconditions.checkNotNull(filter, "Clearing filters is not currently supported");

#_final
        VersionMessage ver = vPeerVersionMessage;
        if (ver != nil && ver.isBloomFilteringSupported())
        (§
            vBloomFilter = filter;
            log.debug("{}: Sending Bloom filter{}", this, andQueryMemPool ? " and querying mempool" : "");
            sendMessage(filter);
            if (andQueryMemPool)
                sendMessage(new MemoryPoolMessage());
            maybeRestartChainDownload();
        )
    )

#_private
    void maybeRestartChainDownload()
    (§
        lock.lock();
        try
        (§
            if (awaitingFreshFilter == nil)
                return;

            if (!vDownloadData)
            (§
                ;; This branch should be harmless but I want to know how often it happens in reality.
                log.warn("Lost download peer status whilst awaiting fresh filter.");
                return;
            )

            ;; Ping/pong to wait for blocks that are still being streamed to us to finish being downloaded and discarded.
            ping().addListener(new Runnable()
            (§
#_override
#_public
                void run()
                (§
                    lock.lock();
                    Preconditions.checkNotNull(awaitingFreshFilter);
                    GetDataMessage getdata = new GetDataMessage(params);
                    for (Sha256Hash hash : awaitingFreshFilter)
                        getdata.addFilteredBlock(hash);
                    awaitingFreshFilter = nil;
                    lock.unlock();

                    log.info("Restarting chain download");
                    sendMessage(getdata);
                    ;; TODO: This bizarre ping-after-getdata hack probably isn't necessary.
                    ;; It's to ensure we know when the end of a filtered block stream of txns is, but we should just be
                    ;; able to match txns with the merkleblock.  Ask Matt why it's written this way.
                    sendMessage(new Ping((long)(Math.random() * Long.MAX_VALUE)));
                )
            ), Threading.SAME_THREAD);
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Returns the last {@link BloomFilter} set by {@link Peer#setBloomFilter(BloomFilter)}.  Bloom filters tell
     ; the remote node what transactions to send us, in a compact manner.
     ;;
#_public
    BloomFilter getBloomFilter()
    (§
        return vBloomFilter;
    )

    ;;;
     ; Returns true if this peer will use getdata/notfound messages to walk backwards through transaction dependencies
     ; before handing the transaction off to the wallet.  The wallet can do risk analysis on pending/recent transactions
     ; to try and discover if a pending tx might be at risk of double spending.
     ;;
#_public
    boolean isDownloadTxDependencies()
    (§
        return (0 < vDownloadTxDependencyDepth);
    )

    ;;;
     ; Sets if this peer will use getdata/notfound messages to walk backwards through transaction dependencies
     ; before handing the transaction off to the wallet.  The wallet can do risk analysis on pending/recent transactions
     ; to try and discover if a pending tx might be at risk of double spending.
     ;;
#_public
    void setDownloadTxDependencies(boolean enable)
    (§
        vDownloadTxDependencyDepth = enable ? Integer.MAX_VALUE : 0;
    )

    ;;;
     ; Sets if this peer will use getdata/notfound messages to walk backwards through transaction dependencies
     ; before handing the transaction off to the wallet.  The wallet can do risk analysis on pending/recent transactions
     ; to try and discover if a pending tx might be at risk of double spending.
     ;;
#_public
    void setDownloadTxDependencies(int depth)
    (§
        vDownloadTxDependencyDepth = depth;
    )
)

(ns org.bitcoinj.core #_"PeerAddress"
    (:import [java.io IOException OutputStream]
             [java.math BigInteger]
             [java.net InetAddress InetSocketAddress UnknownHostException])
    (:import [com.google.common.base Objects Preconditions]
             [com.google.common.net InetAddresses])
    (:import #_static #_[org.bitcoinj.core.Utils uint32ToByteStreamLE]
             #_static #_[org.bitcoinj.core.Utils uint64ToByteStreamLE]
             [org.bitcoinj.params MainNetParams]))

;;;
 ; <p>A PeerAddress holds an IP address and port number representing the network location of
 ; a peer in the Bitcoin P2P network.  It exists primarily for serialization purposes.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
class PeerAddress extends ChildMessage
(§
#_static
#_final
    int MESSAGE_SIZE = 30;

#_private
    InetAddress addr;
#_private
    String hostname; ;; Used for .onion addresses.
#_private
    int port;
#_private
    BigInteger services;
#_private
    long time;

    ;;;
     ; Construct a peer address from a serialized payload.
     ;;
#_public
    PeerAddress(NetworkParameters params, byte[] payload, int offset, int protocolVersion)
        throws ProtocolException
    (§
        super(params, payload, offset, protocolVersion);
    )

    ;;;
     ; Construct a peer address from a serialized payload.
     ; @param params NetworkParameters object.
     ; @param payload Bitcoin protocol formatted byte array containing message content.
     ; @param offset The location of the first payload byte within the array.
     ; @param protocolVersion Bitcoin protocol version.
     ; @param serializer The serializer to use for this message.
     ; @throws ProtocolException
     ;;
#_public
    PeerAddress(NetworkParameters params, byte[] payload, int offset, int protocolVersion, Message parent, MessageSerializer serializer)
        throws ProtocolException
    (§
        super(params, payload, offset, protocolVersion, parent, serializer, UNKNOWN_LENGTH);
    )

    ;;;
     ; Construct a peer address from a memorized or hardcoded address.
     ;;
#_public
    PeerAddress(NetworkParameters params, InetAddress addr, int port, int protocolVersion, BigInteger services)
    (§
        super(params);

        this.addr = Preconditions.checkNotNull(addr);
        this.port = port;
        this.protocolVersion = protocolVersion;
        this.services = services;

        length = (31402 < protocolVersion) ? MESSAGE_SIZE : MESSAGE_SIZE - 4;
    )

    ;;;
     ; Constructs a peer address from the given IP address and port.  Version number is default for the given parameters.
     ;;
#_public
    PeerAddress(NetworkParameters params, InetAddress addr, int port)
    (§
        this(params, addr, port, params.getProtocolVersionNum(NetworkParameters.ProtocolVersion.CURRENT), BigInteger.ZERO);
    )

    ;;;
     ; Constructs a peer address from the given IP address.  Port and version number are default for the given parameters.
     ;;
#_public
    PeerAddress(NetworkParameters params, InetAddress addr)
    (§
        this(params, addr, params.getPort());
    )

    ;;;
     ; Constructs a peer address from an {@link InetSocketAddress}.  An InetSocketAddress can take in as parameters an
     ; InetAddress or a String hostname.  If you want to connect to a .onion, set the hostname to the .onion address.
     ;;
#_public
    PeerAddress(NetworkParameters params, InetSocketAddress addr)
    (§
        this(params, addr.getAddress(), addr.getPort());
    )

    ;;;
     ; Constructs a peer address from a stringified hostname+port.  Use this if you want to connect to a Tor .onion address.
     ;;
#_public
    PeerAddress(NetworkParameters params, String hostname, int port)
    (§
        super(params);

        this.hostname = hostname;
        this.port = port;
        this.protocolVersion = params.getProtocolVersionNum(NetworkParameters.ProtocolVersion.CURRENT);
        this.services = BigInteger.ZERO;
    )

#_public
#_static
    PeerAddress localhost(NetworkParameters params)
    (§
        return new PeerAddress(params, InetAddresses.forString("127.0.0.1"), params.getPort());
    )

#_override
#_protected
    void bitcoinSerializeToStream(OutputStream stream)
        throws IOException
    (§
        if (31402 <= protocolVersion)
        (§
            ;; TODO: This appears to be dynamic because the client only ever sends out it's own address
            ;; so assumes itself to be up.  For a fuller implementation this needs to be dynamic only if
            ;; the address refers to this client.
            int secs = (int)Utils.currentTimeSeconds();
            uint32ToByteStreamLE(secs, stream);
        )
        uint64ToByteStreamLE(services, stream); ;; nServices.
        ;; Java does not provide any utility to map an IPv4 address into IPv6 space, so we have to do it by hand.
        byte[] ipBytes = addr.getAddress();
        if (ipBytes.length == 4)
        (§
            byte[] v6addr = new byte[16];
            System.arraycopy(ipBytes, 0, v6addr, 12, 4);
            v6addr[10] = (byte)0xff;
            v6addr[11] = (byte)0xff;
            ipBytes = v6addr;
        )
        stream.write(ipBytes);
        ;; And write out the port.  Unlike the rest of the protocol, address and port is in big endian byte order.
        stream.write((byte)(0xff & port >> 8));
        stream.write((byte)(0xff & port));
    )

#_override
#_protected
    void parse()
        throws ProtocolException
    (§
        ;; Format of a serialized address:
        ;;   uint32 timestamp
        ;;   uint64 services (flags determining what the node can do)
        ;;   16 bytes ip address
        ;;   2 bytes port num
        time = (31402 < protocolVersion) ? readUint32() : -1;
        services = readUint64();
        byte[] addrBytes = readBytes(16);
        try
        (§
            addr = InetAddress.getByAddress(addrBytes);
        )
        catch (UnknownHostException e)
        (§
            throw new RuntimeException(e); ;; Cannot happen.
        )
        port = ((0xff & payload[cursor++]) << 8) | (0xff & payload[cursor++]);
        ;; The 4 byte difference is the uint32 timestamp that was introduced in version 31402.
        length = (31402 < protocolVersion) ? MESSAGE_SIZE : MESSAGE_SIZE - 4;
    )

#_public
    String getHostname()
    (§
        return hostname;
    )

#_public
    InetAddress getAddr()
    (§
        return addr;
    )

#_public
    InetSocketAddress getSocketAddress()
    (§
        return new InetSocketAddress(getAddr(), getPort());
    )

#_public
    int getPort()
    (§
        return port;
    )

#_public
    BigInteger getServices()
    (§
        return services;
    )

#_public
    long getTime()
    (§
        return time;
    )

#_override
#_public
    String toString()
    (§
        return (hostname != nil) ? "[" + hostname + "]:" + port : "[" + addr.getHostAddress() + "]:" + port;
    )

#_override
#_public
    boolean equals(Object o)
    (§
        if (this == o)
            return true;
        if (o == nil || getClass() != o.getClass())
            return false;
        PeerAddress other = (PeerAddress)o;
        return (other.addr.equals(addr) && other.port == port && other.time == time && other.services.equals(services));
    )

#_override
#_public
    int hashCode()
    (§
        return Objects.hashCode(addr, port, time, services);
    )

#_public
    InetSocketAddress toSocketAddress()
    (§
        ;; Reconstruct the InetSocketAddress properly.
        return (hostname != nil) ? InetSocketAddress.createUnresolved(hostname, port) : new InetSocketAddress(addr, port);
    )
)

(ns org.bitcoinj.core #_"PeerException"
)

;;;
 ; Thrown when a problem occurs in communicating with a peer, and we should retry.
 ;;
#_public
class PeerException extends Exception
(§
#_public
    PeerException(String msg)
    (§
        super(msg);
    )

#_public
    PeerException(Exception e)
    (§
        super(e);
    )

#_public
    PeerException(String msg, Exception e)
    (§
        super(msg, e);
    )
)

(ns org.bitcoinj.core #_"PeerFilterProvider"
)

;;;
 ; An interface which provides the information required to properly filter data downloaded from Peers.
 ; Note that an implementer is responsible for calling {@link PeerGroup#recalculateFastCatchupAndFilter(org.bitcoinj.core.PeerGroup.FilterRecalculateMode)}
 ; whenever a change occurs which effects the data provided via this interface.
 ;;
#_public
interface PeerFilterProvider
(§
    ;;;
     ; Returns the earliest timestamp (seconds since epoch) for which full/bloom-filtered blocks must be downloaded.
     ; Blocks with timestamps before this time will only have headers downloaded.  0 requires that all blocks be
     ; downloaded, and thus this should default to {@link System#currentTimeMillis()}/1000.
     ;;
    long getEarliestKeyCreationTime();

    ;;;
     ; Called on all registered filter providers before getBloomFilterElementCount and getBloomFilter are called.
     ; Once called, the provider should ensure that the items it will want to insert into the filter don't change.
     ; The reason is that all providers will have their element counts queried, and then a filter big enough for
     ; all of them will be specified.  So the provider must use consistent state.  There is guaranteed to be
     ; a matching call to endBloomFilterCalculation that can be used to e.g. unlock a lock.
     ;;
    void beginBloomFilterCalculation();

    ;;;
     ; Gets the number of elements that will be added to a bloom filter returned by
     ; {@link PeerFilterProvider#getBloomFilter(int, double, long)}.
     ;;
    int getBloomFilterElementCount();

    ;;;
     ; Gets a bloom filter that contains all the necessary elements for the listener to receive relevant transactions.
     ; Default value should be an empty bloom filter with the given size, falsePositiveRate, and nTweak.
     ;;
    BloomFilter getBloomFilter(int size, double falsePositiveRate, long nTweak);

    void endBloomFilterCalculation();
)

(ns org.bitcoinj.core #_"PeerGroup"
    (:import #_[java.io *]
             #_[java.net *]
             #_[java.util *]
             #_[java.util.concurrent *]
             #_[java.util.concurrent.locks *])
    (:import #_[com.google.common.annotations *]
             #_[com.google.common.base *]
             #_[com.google.common.collect *]
             #_[com.google.common.net *]
             #_[com.google.common.primitives *]
             #_[com.google.common.util.concurrent *]
             #_[net.jcip.annotations *]
             #_[org.slf4j *])
  #_(:require #_[org.bitcoinj.core.listeners *]
             #_[org.bitcoinj.net *]
             #_[org.bitcoinj.net.discovery *]
             #_[org.bitcoinj.script *]
             [org.bitcoinj.utils * Threading]
             [org.bitcoinj.wallet Wallet]
             [org.bitcoinj.wallet.listeners KeyChainEventListener WalletCoinsReceivedEventListener]))

;;;
 ; <p>Runs a set of connections to the P2P network, brings up connections to replace disconnected nodes and manages
 ; the interaction between them all.  Most applications will want to use one of these.</p>
 ;
 ; <p>PeerGroup tries to maintain a constant number of connections to a set of distinct peers.
 ; Each peer runs a network listener in its own thread.  When a connection is lost, a new peer
 ; will be tried after a delay as long as the number of connections less than the maximum.</p>
 ;
 ; <p>Connections are made to addresses from a provided list.  When that list is exhausted,
 ; we start again from the head of the list.</p>
 ;
 ; <p>The PeerGroup can broadcast a transaction to the currently connected set of peers.  It can
 ; also handle download of the blockchain from peers, restarting the process when peers die.</p>
 ;
 ; <p>A PeerGroup won't do anything until you call the {@link PeerGroup#start()} method
 ; which will block until peer discovery is completed and some outbound connections
 ; have been initiated (it will return before handshaking is done, however).
 ; You should call {@link PeerGroup#stop()} when finished.  Note that not all methods
 ; of PeerGroup are safe to call from a UI thread as some may do network IO,
 ; but starting and stopping the service should be fine.</p>
 ;;
#_public
class PeerGroup implements TransactionBroadcaster
(§
#_private
#_static
#_final
    Logger log = LoggerFactory.getLogger(PeerGroup.class);

    ;; All members in this class should be marked with final, volatile, @GuardedBy or a mix as appropriate to define
    ;; their thread safety semantics.  Volatile requires a Hungarian-style v prefix.

    ;; By default we don't require any services because any peer will do.
#_private
    long requiredServices = 0;

    ;;;
     ; The default number of connections to the p2p network the library will try to build.  This is set to 12 empirically.
     ; It used to be 4, but because we divide the connection pool in two for broadcasting transactions, that meant we
     ; were only sending transactions to two peers and sometimes this wasn't reliable enough: transactions wouldn't
     ; get through.
     ;;
#_public
#_static
#_final
    int DEFAULT_CONNECTIONS = 12;
#_private
#_volatile
    int vMaxPeersToDiscoverCount = 100;
#_private
#_static
#_final
    long DEFAULT_PEER_DISCOVERY_TIMEOUT_MILLIS = 5000;
#_private
#_volatile
    long vPeerDiscoveryTimeoutMillis = DEFAULT_PEER_DISCOVERY_TIMEOUT_MILLIS;

#_protected
#_final
    ReentrantLock lock = Threading.lock("peergroup");

#_protected
#_final
    NetworkParameters params;
#_nilable
#_protected
#_final
    AbstractBlockChain chain;

    ;; This executor is used to queue up jobs: it's used when we don't want to use locks for mutual exclusion,
    ;; typically because the job might call in to user provided code that needs/wants the freedom to use the API
    ;; however it wants, or because a job needs to be ordered relative to other jobs like that.
#_protected
#_final
    ListeningScheduledExecutorService executor;

    ;; Whether the peer group is currently running.  Once shut down it cannot be restarted.
#_private
#_volatile
    boolean vRunning;
    ;; Whether the peer group has been started or not.  An unstarted PG does not try to access the network.
#_private
#_volatile
    boolean vUsedUp;

    ;; Addresses to try to connect to, excluding active peers.
#_guarded-by("lock")
#_private
#_final
    PriorityQueue<PeerAddress> inactives;
#_guarded-by("lock")
#_private
#_final
    Map<PeerAddress, ExponentialBackoff> backoffMap;

    ;; Currently active peers.  This is an ordered list rather than a set to make unit tests predictable.
#_private
#_final
    CopyOnWriteArrayList<Peer> peers;
    ;; Currently connecting peers.
#_private
#_final
    CopyOnWriteArrayList<Peer> pendingPeers;
#_private
#_final
    ClientConnectionManager channels;

    ;; The peer that has been selected for the purposes of downloading announced data.
#_guarded-by("lock")
#_private
    Peer downloadPeer;
    ;; Callback for events related to chain download.
#_nilable
#_guarded-by("lock")
#_private
    PeerDataEventListener downloadListener;

#_private
#_final
    CopyOnWriteArrayList<ListenerRegistration<BlocksDownloadedEventListener>> peersBlocksDownloadedEventListeners = new CopyOnWriteArrayList<>();
#_private
#_final
    CopyOnWriteArrayList<ListenerRegistration<ChainDownloadStartedEventListener>> peersChainDownloadStartedEventListeners = new CopyOnWriteArrayList<>();
    ;;; Callbacks for events related to peers connecting. ;;
#_protected
#_final
    CopyOnWriteArrayList<ListenerRegistration<PeerConnectedEventListener>> peerConnectedEventListeners = new CopyOnWriteArrayList<>();
    ;;; Callbacks for events related to peer connection/disconnection. ;;
#_protected
#_final
    CopyOnWriteArrayList<ListenerRegistration<PeerDiscoveredEventListener>> peerDiscoveredEventListeners = new CopyOnWriteArrayList<>();
    ;;; Callbacks for events related to peers disconnecting. ;;
#_protected
#_final
    CopyOnWriteArrayList<ListenerRegistration<PeerDisconnectedEventListener>> peerDisconnectedEventListeners = new CopyOnWriteArrayList<>();
    ;;; Callbacks for events related to peer data being received. ;;
#_private
#_final
    CopyOnWriteArrayList<ListenerRegistration<GetDataEventListener>> peerGetDataEventListeners = new CopyOnWriteArrayList<>();
#_private
#_final
    CopyOnWriteArrayList<ListenerRegistration<PreMessageReceivedEventListener>> peersPreMessageReceivedEventListeners = new CopyOnWriteArrayList<>();
#_protected
#_final
    CopyOnWriteArrayList<ListenerRegistration<OnTransactionBroadcastListener>> peersTransactionBroadastEventListeners = new CopyOnWriteArrayList<>();

    ;; Peer discovery sources, will be polled occasionally if there aren't enough inactives.
#_private
#_final
    CopyOnWriteArraySet<PeerDiscovery> peerDiscoverers;
    ;; The version message to use for new connections.
#_guarded-by("lock")
#_private
    VersionMessage versionMessage;
    ;; Maximum depth up to which pending transaction dependencies are downloaded, or 0 for disabled.
#_guarded-by("lock")
#_private
    int downloadTxDependencyDepth;
    ;; How many connections we want to have open at the current time.  If we lose connections, we'll try opening more
    ;; until we reach this count.
#_guarded-by("lock")
#_private
    int maxConnections;
    ;; Minimum protocol version we will allow ourselves to connect to: require Bloom filtering.
#_private
#_volatile
    int vMinRequiredProtocolVersion;

    ;;; How many milliseconds to wait after receiving a pong before sending another ping. ;;
#_public
#_static
#_final
    long DEFAULT_PING_INTERVAL_MSEC = 2000;
#_guarded-by("lock")
#_private
    long pingIntervalMsec = DEFAULT_PING_INTERVAL_MSEC;

#_guarded-by("lock")
#_private
    boolean useLocalhostPeerWhenPossible = true;
#_guarded-by("lock")
#_private
    boolean ipv6Unreachable = false;

#_guarded-by("lock")
#_private
    long fastCatchupTimeSecs;
#_private
#_final
    CopyOnWriteArrayList<Wallet> wallets;
#_private
#_final
    CopyOnWriteArrayList<PeerFilterProvider> peerFilterProviders;

    ;; This event listener is added to every peer.  It's here so when we announce transactions via an "inv",
    ;; every peer can fetch them.
#_private
#_final
    PeerListener peerListener = new PeerListener();

#_private
    int minBroadcastConnections = 0;

#_private
#_final
    KeyChainEventListener walletKeyEventListener = new KeyChainEventListener()
    (§
#_override
#_public
        void onKeysAdded(List<ECKey> keys)
        (§
            recalculateFastCatchupAndFilter(FilterRecalculateMode.SEND_IF_CHANGED);
        )
    );

#_private
#_final
    WalletCoinsReceivedEventListener walletCoinsReceivedEventListener = new WalletCoinsReceivedEventListener()
    (§
#_override
#_public
        void onCoinsReceived(Wallet wallet, Transaction tx, Coin prevBalance, Coin newBalance)
        (§
            ;; We received a relevant transaction.  We MAY need to recalculate and resend the Bloom filter, but only
            ;; if we have received a transaction that includes a relevant pay-to-pubkey output.
            ;;
            ;; The reason is that pay-to-pubkey outputs, when spent, will not repeat any data we can predict in their
            ;; inputs.  So a remote peer will update the Bloom filter for us when such an output is seen matching the
            ;; existing filter, so that it includes the tx hash in which the pay-to-pubkey output was observed.  Thus
            ;; the spending transaction will always match (due to the outpoint structure).
            ;;
            ;; Unfortunately, whilst this is required for correct sync of the chain in blocks, there are two edge cases.
            ;;
            ;; (1) If a wallet receives a relevant, confirmed p2pubkey output that was not broadcast across the network,
            ;; for example in a coinbase transaction, then the node that's serving us the chain will update its filter
            ;; but the rest will not.  If another transaction then spends it, the other nodes won't match/relay it.
            ;;
            ;; (2) If we receive a p2pubkey output broadcast across the network, all currently connected nodes will see
            ;; it and update their filter themselves, but any newly connected nodes will receive the last filter we
            ;; calculated, which would not include this transaction.
            ;;
            ;; For this reason we check if the transaction contained any relevant pay to pubkeys and force a recalc
            ;; and possibly retransmit if so.  The recalculation process will end up including the tx hash into the
            ;; filter.  In case (1), we need to retransmit the filter to the connected peers.  In case (2), we don't
            ;; and shouldn't, we should just recalculate and cache the new filter for next time.

            for (TransactionOutput output : tx.getOutputs())
            (§
                if (output.getScriptPubKey().isSentToRawPubKey() && output.isMine(wallet))
                (§
                    if (tx.getConfidence().getConfidenceType() == TransactionConfidence.ConfidenceType.BUILDING)
                        recalculateFastCatchupAndFilter(FilterRecalculateMode.SEND_IF_CHANGED);
                    else
                        recalculateFastCatchupAndFilter(FilterRecalculateMode.DONT_SEND);
                    return;
                )
            )
        )
    );

    ;; Exponential backoff for peers starts at 1 second and maxes at 10 minutes.
#_private
#_final
    ExponentialBackoff.Params peerBackoffParams = new ExponentialBackoff.Params(1000, 1.5f, 10 * 60 * 1000);
    ;; Tracks failures globally in case of a network failure.
#_guarded-by("lock")
#_private
    ExponentialBackoff groupBackoff = new ExponentialBackoff(new ExponentialBackoff.Params(1000, 1.5f, 10 * 1000));

    ;; This is a synchronized set, so it locks on itself.  We use it to prevent TransactionBroadcast objects from
    ;; being garbage collected if nothing in the apps code holds on to them transitively.  See the discussion
    ;; in broadcastTransaction.
#_private
#_final
    Set<TransactionBroadcast> runningBroadcasts;

#_private
    class PeerListener implements GetDataEventListener, BlocksDownloadedEventListener
    (§
#_public
        PeerListener()
        (§
        )

#_override
#_public
        List<Message> getData(Peer peer, GetDataMessage m)
        (§
            return handleGetData(m);
        )

#_override
#_public
        void onBlocksDownloaded(Peer peer, Block block, #_nilable FilteredBlock filteredBlock, int blocksLeft)
        (§
            if (chain != nil)
            (§
#_final
                double rate = chain.getFalsePositiveRate();
#_final
                double target = bloomFilterMerger.getBloomFilterFPRate() * MAX_FP_RATE_INCREASE;
                if (target < rate)
                (§
                    ;; TODO: Avoid hitting this path if the remote peer didn't acknowledge applying a new filter yet.
                    if (log.isDebugEnabled())
                        log.debug("Force update Bloom filter due to high false positive rate ({} vs {})", rate, target);

                    recalculateFastCatchupAndFilter(FilterRecalculateMode.FORCE_SEND_FOR_REFRESH);
                )
            )
        )
    )

#_private
    class PeerStartupListener implements PeerConnectedEventListener, PeerDisconnectedEventListener
    (§
#_override
#_public
        void onPeerConnected(Peer peer, int peerCount)
        (§
            handleNewPeer(peer);
        )

#_override
#_public
        void onPeerDisconnected(Peer peer, int peerCount)
        (§
            ;; The channel will be automatically removed from channels.
            handlePeerDeath(peer, nil);
        )
    )

#_private
#_final
    PeerStartupListener startupListener = new PeerStartupListener();

    ;;;
     ; The default Bloom filter false positive rate, which is selected to be extremely low such that you hardly ever
     ; download false positives.  This provides maximum performance.  Although this default can be overridden to push
     ; the FP rate higher, due to <a href="https://groups.google.com/forum/#!msg/bitcoinj/Ys13qkTwcNg/9qxnhwnkeoIJ">
     ; various complexities</a> there are still ways a remote peer can deanonymize the users wallet.  This is why the
     ; FP rate is chosen for performance rather than privacy.  If a future version of bitcoinj fixes the known
     ; de-anonymization attacks this FP rate may rise again (or more likely, become expressed as a bandwidth allowance).
     ;;
#_public
#_static
#_final
    double DEFAULT_BLOOM_FILTER_FP_RATE = 0.00001;
    ;;; Maximum increase in FP rate before forced refresh of the bloom filter. ;;
#_public
#_static
#_final
    double MAX_FP_RATE_INCREASE = 10.0f;
    ;; An object that calculates bloom filters given a list of filter providers, whilst tracking some state useful
    ;; for privacy purposes.
#_private
#_final
    FilterMerger bloomFilterMerger;

    ;;; The default timeout between when a connection attempt begins and version message exchange completes. ;;
#_public
#_static
#_final
    int DEFAULT_CONNECT_TIMEOUT_MILLIS = 5000;
#_private
#_volatile
    int vConnectTimeoutMillis = DEFAULT_CONNECT_TIMEOUT_MILLIS;

    ;;; Whether bloom filter support is enabled when using a non FullPrunedBlockchain. ;;
#_private
#_volatile
    boolean vBloomFilteringEnabled = true;

    ;;; See {@link #PeerGroup(Context)}. ;;
#_public
    PeerGroup(NetworkParameters params)
    (§
        this(params, nil);
    )

    ;;;
     ; Creates a PeerGroup with the given context.  No chain is provided so this node will report its chain height
     ; as zero to other peers.  This constructor is useful if you just want to explore the network but aren't interested
     ; in downloading block data.
     ;;
#_public
    PeerGroup(Context context)
    (§
        this(context, nil);
    )

    ;;; See {@link #PeerGroup(Context, AbstractBlockChain)}. ;;
#_public
    PeerGroup(NetworkParameters params, #_nilable AbstractBlockChain chain)
    (§
        this(Context.getOrCreate(params), chain, new NioClientManager());
    )

    ;;;
     ; Creates a PeerGroup for the given context and chain.  Blocks will be passed to the chain as they are broadcast
     ; and downloaded.  This is probably the constructor you want to use.
     ;;
#_public
    PeerGroup(Context context, #_nilable AbstractBlockChain chain)
    (§
        this(context, chain, new NioClientManager());
    )

    ;;; See {@link #PeerGroup(Context, AbstractBlockChain, ClientConnectionManager)}. ;;
#_public
    PeerGroup(NetworkParameters params, #_nilable AbstractBlockChain chain, ClientConnectionManager connectionManager)
    (§
        this(Context.getOrCreate(params), chain, connectionManager);
    )

    ;;;
     ; Creates a new PeerGroup allowing you to specify the {@link ClientConnectionManager} which is used to create new
     ; connections and keep track of existing ones.
     ;;
#_private
    PeerGroup(Context context, #_nilable AbstractBlockChain chain, ClientConnectionManager connectionManager)
    (§
        Preconditions.checkNotNull(context);

        this.params = context.getParams();
        this.chain = chain;
        fastCatchupTimeSecs = params.getGenesisBlock().getTimeSeconds();
        wallets = new CopyOnWriteArrayList<>();
        peerFilterProviders = new CopyOnWriteArrayList<>();

        executor = createPrivateExecutor();

        ;; This default sentinel value will be overridden by one of two actions:
        ;;   - adding a peer discovery source sets it to the default.
        ;;   - using connectTo() will increment it by one.
        maxConnections = 0;

        int height = (chain != nil) ? chain.getBestChainHeight() : 0;
        versionMessage = new VersionMessage(params, height);
        ;; We never request that the remote node wait for a bloom filter yet, as we have no wallets.
        versionMessage.relayTxesBeforeFilter = true;

        downloadTxDependencyDepth = Integer.MAX_VALUE;

        inactives = new PriorityQueue<>(1, new Comparator<PeerAddress>()
        (§
#_suppress("FieldAccessNotGuarded") ;; Only called when inactives is accessed, and lock is held then.
#_override
#_public
            int compare(PeerAddress a, PeerAddress b)
            (§
                Preconditions.checkState(lock.isHeldByCurrentThread());

                int result = backoffMap.get(a).compareTo(backoffMap.get(b));
                ;; Sort by port if otherwise equals - for testing.
                if (result == 0)
                    result = Ints.compare(a.getPort(), b.getPort());
                return result;
            )
        ));
        backoffMap = new HashMap<>();
        peers = new CopyOnWriteArrayList<>();
        pendingPeers = new CopyOnWriteArrayList<>();
        channels = connectionManager;
        peerDiscoverers = new CopyOnWriteArraySet<>();
        runningBroadcasts = Collections.synchronizedSet(new HashSet<TransactionBroadcast>());
        bloomFilterMerger = new FilterMerger(DEFAULT_BLOOM_FILTER_FP_RATE);
        vMinRequiredProtocolVersion = params.getProtocolVersionNum(NetworkParameters.ProtocolVersion.BLOOM_FILTER);
    )

#_private
    CountDownLatch executorStartupLatch = new CountDownLatch(1);

#_protected
    ListeningScheduledExecutorService createPrivateExecutor()
    (§
        ListeningScheduledExecutorService result = MoreExecutors.listeningDecorator(
                new ScheduledThreadPoolExecutor(1, new ContextPropagatingThreadFactory("PeerGroup Thread"))
        );
        ;; Hack: jam the executor so jobs just queue up until the user calls start() on us.  For example, adding a wallet
        ;; results in a bloom filter recalc being queued, but we don't want to do that until we're actually started.
        result.execute(new Runnable()
        (§
#_override
#_public
            void run()
            (§
                Uninterruptibles.awaitUninterruptibly(executorStartupLatch);
            )
        ));
        return result;
    )

    ;;;
     ; This is how many milliseconds we wait for peer discoveries to return their results.
     ;;
#_public
    void setPeerDiscoveryTimeoutMillis(long peerDiscoveryTimeoutMillis)
    (§
        this.vPeerDiscoveryTimeoutMillis = peerDiscoveryTimeoutMillis;
    )

    ;;;
     ; Adjusts the desired number of connections that we will create to peers.  Note that if there are already peers
     ; open and the new value is lower than the current number of peers, those connections will be terminated.
     ; Likewise if there aren't enough current connections to meet the new requested max size, some will be added.
     ;;
#_public
    void setMaxConnections(int maxConnections)
    (§
        lock.lock();
        try
        (§
            this.maxConnections = maxConnections;
            if (!isRunning())
                return;
        )
        finally
        (§
            lock.unlock();
        )

        ;; We may now have too many or too few open connections.  Add more or drop some to get to the right amount.
        int adjustment = maxConnections - channels.getConnectedClientCount();
        if (0 < adjustment)
            triggerConnections();

        if (adjustment < 0)
            channels.closeConnections(-adjustment);
    )

    ;;;
     ; Configure download of pending transaction dependencies.  A change of values only takes effect for newly connected peers.
     ;;
#_public
    void setDownloadTxDependencies(int depth)
    (§
        lock.lock();
        try
        (§
            this.downloadTxDependencyDepth = depth;
        )
        finally
        (§
            lock.unlock();
        )
    )

#_private
    Runnable triggerConnectionsJob = new Runnable()
    (§
#_private
        boolean firstRun = true;
#_private
#_final
#_static
        long MIN_PEER_DISCOVERY_INTERVAL = 1000L;

#_override
#_public
        void run()
        (§
            try
            (§
                go();
            )
            catch (Throwable e)
            (§
                log.error("Exception when trying to build connections", e); ;; The executor swallows exceptions :(
            )
        )

#_public
        void go()
        (§
            if (!vRunning)
                return;

            boolean doDiscovery = false;
            long now = Utils.currentTimeMillis();
            lock.lock();
            try
            (§
                ;; First run: try and use a local node if there is one, for the additional security it can provide.
                ;; But, not on Android as there are none for this platform: it could only be a malicious app trying
                ;; to hijack our traffic.
                if (!Utils.isAndroidRuntime() && useLocalhostPeerWhenPossible && maybeCheckForLocalhostPeer() && firstRun)
                (§
                    log.info("Localhost peer detected, trying to use it instead of P2P discovery");
                    maxConnections = 0;
                    connectToLocalHost();
                    return;
                )

                boolean havePeerWeCanTry = (!inactives.isEmpty() && backoffMap.get(inactives.peek()).getRetryTime() <= now);
                doDiscovery = !havePeerWeCanTry;
            )
            finally
            (§
                firstRun = false;
                lock.unlock();
            )

            ;; Don't hold the lock across discovery as this process can be very slow.
            boolean discoverySuccess = false;
            if (doDiscovery)
            (§
                try
                (§
                    discoverySuccess = (0 < discoverPeers());
                )
                catch (PeerDiscoveryException e)
                (§
                    log.error("Peer discovery failure", e);
                )
            )

            long retryTime;
            PeerAddress addrToTry;
            lock.lock();
            try
            (§
                if (doDiscovery)
                (§
                    ;; Require that we have enough connections, to consider this a success,
                    ;; or we just constantly test for new peers.
                    if (discoverySuccess && getMaxConnections() <= countConnectedAndPendingPeers())
                        groupBackoff.trackSuccess();
                    else
                        groupBackoff.trackFailure();
                )
                ;; Inactives is sorted by backoffMap time.
                if (inactives.isEmpty())
                (§
                    if (countConnectedAndPendingPeers() < getMaxConnections())
                    (§
                        long interval = Math.max(groupBackoff.getRetryTime() - now, MIN_PEER_DISCOVERY_INTERVAL);
                        log.info("Peer discovery didn't provide us any more peers, will try again in " + interval + "ms.");
                        executor.schedule(this, interval, TimeUnit.MILLISECONDS);
                    )
                    else
                    (§
                        ;; We have enough peers and discovery provided no more, so just settle down.
                        ;; Most likely we were given a fixed set of addresses in some test scenario.
                    )
                    return;
                )
                else
                (§
                    do
                    (§
                        addrToTry = inactives.poll();
                    )
                    while (ipv6Unreachable && addrToTry.getAddr() instanceof Inet6Address);
                    retryTime = backoffMap.get(addrToTry).getRetryTime();
                )
                retryTime = Math.max(retryTime, groupBackoff.getRetryTime());
                if (now < retryTime)
                (§
                    long delay = retryTime - now;
                    log.info("Waiting {} msec before next connect attempt {}", delay, (addrToTry == nil) ? "" : "to " + addrToTry);
                    inactives.add(addrToTry);
                    executor.schedule(this, delay, TimeUnit.MILLISECONDS);
                    return;
                )
                connectTo(addrToTry, false, vConnectTimeoutMillis);
            )
            finally
            (§
                lock.unlock();
            )
            if (countConnectedAndPendingPeers() < getMaxConnections())
            (§
                executor.execute(this); ;; Try next peer immediately.
            )
        )
    );

#_private
    void triggerConnections()
    (§
        ;; Run on a background thread due to the need to potentially retry and back off in the background.
        if (!executor.isShutdown())
            executor.execute(triggerConnectionsJob);
    )

    ;;; The maximum number of connections that we will create to peers. ;;
#_public
    int getMaxConnections()
    (§
        lock.lock();
        try
        (§
            return maxConnections;
        )
        finally
        (§
            lock.unlock();
        )
    )

#_private
    List<Message> handleGetData(GetDataMessage m)
    (§
        ;; Scans the wallets and memory pool for transactions in the getdata message and returns them.
        ;; Runs on peer threads.
        lock.lock();
        try
        (§
            LinkedList<Message> transactions = new LinkedList<>();
            LinkedList<InventoryItem> items = new LinkedList<>(m.getItems());
            Iterator<InventoryItem> it = items.iterator();
            while (it.hasNext())
            (§
                InventoryItem item = it.next();
                ;; Check the wallets.
                for (Wallet w : wallets)
                (§
                    Transaction tx = w.getTransaction(item.hash);
                    if (tx != nil)
                    (§
                        transactions.add(tx);
                        it.remove();
                        break;
                    )
                )
            )
            return transactions;
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Sets the {@link VersionMessage} that will be announced on newly created connections.  A version message is
     ; primarily interesting because it lets you customize the "subVer" field which is used a bit like the User-Agent
     ; field from HTTP.  It means your client tells the other side what it is, see
     ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0014.mediawiki">BIP 14</a>.
     ;
     ; The VersionMessage you provide is copied and the best chain height/time filled in for each new connection,
     ; therefore you don't have to worry about setting that.  The provided object is really more of a template.
     ;;
#_public
    void setVersionMessage(VersionMessage ver)
    (§
        lock.lock();
        try
        (§
            versionMessage = ver;
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Returns the version message provided by setVersionMessage or a default if none was given.
     ;;
#_public
    VersionMessage getVersionMessage()
    (§
        lock.lock();
        try
        (§
            return versionMessage;
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Sets information that identifies this software to remote nodes.  This is a convenience wrapper for creating
     ; a new {@link VersionMessage}, calling {@link VersionMessage#appendToSubVer(String, String, String)} on it,
     ; and then calling {@link PeerGroup#setVersionMessage(VersionMessage)} on the result of that.  See the docs for
     ; {@link VersionMessage#appendToSubVer(String, String, String)} for information on what the fields should contain.
     ;;
#_public
    void setUserAgent(String name, String version, #_nilable String comments)
    (§
        ;; TODO: Check that height is needed here (it wasnt, but it should be, no?)
        int height = (chain != nil) ? chain.getBestChainHeight() : 0;
        VersionMessage ver = new VersionMessage(params, height);
        ver.relayTxesBeforeFilter = false;
        updateVersionMessageRelayTxesBeforeFilter(ver);
        ver.appendToSubVer(name, version, comments);
        setVersionMessage(ver);
    )

    ;; Updates the relayTxesBeforeFilter flag of ver.
#_private
    void updateVersionMessageRelayTxesBeforeFilter(VersionMessage ver)
    (§
        ;; We will provide the remote node with a bloom filter (i.e. they shouldn't relay yet)
        ;; if chain == null || !chain.shouldVerifyTransactions() and a wallet is added and bloom filters are enabled.
        ;; Note that the default here means that no tx invs will be received if no wallet is ever added.
        lock.lock();
        try
        (§
            boolean spvMode = (chain != nil && !chain.shouldVerifyTransactions());
            boolean willSendFilter = (spvMode && 0 < peerFilterProviders.size() && vBloomFilteringEnabled);
            ver.relayTxesBeforeFilter = !willSendFilter;
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Sets information that identifies this software to remote nodes.  This is a convenience wrapper for creating
     ; a new {@link VersionMessage}, calling {@link VersionMessage#appendToSubVer(String, String, String)} on it,
     ; and then calling {@link PeerGroup#setVersionMessage(VersionMessage)} on the result of that.  See the docs for
     ; {@link VersionMessage#appendToSubVer(String, String, String)} for information on what the fields should contain.
     ;;
#_public
    void setUserAgent(String name, String version)
    (§
        setUserAgent(name, version, nil);
    )

    ;;; See {@link Peer#addBlocksDownloadedEventListener(BlocksDownloadedEventListener)}. ;;
#_public
    void addBlocksDownloadedEventListener(BlocksDownloadedEventListener listener)
    (§
        addBlocksDownloadedEventListener(Threading.USER_THREAD, listener);
    )

    ;;;
     ; <p>Adds a listener that will be notified on the given executor when
     ; blocks are downloaded by the download peer.</p>
     ; @see Peer#addBlocksDownloadedEventListener(Executor, BlocksDownloadedEventListener)
     ;;
#_public
    void addBlocksDownloadedEventListener(Executor executor, BlocksDownloadedEventListener listener)
    (§
        peersBlocksDownloadedEventListeners.add(new ListenerRegistration<>(Preconditions.checkNotNull(listener), executor));
        for (Peer peer : getConnectedPeers())
            peer.addBlocksDownloadedEventListener(executor, listener);
        for (Peer peer : getPendingPeers())
            peer.addBlocksDownloadedEventListener(executor, listener);
    )

    ;;; See {@link Peer#addBlocksDownloadedEventListener(BlocksDownloadedEventListener)}. ;;
#_public
    void addChainDownloadStartedEventListener(ChainDownloadStartedEventListener listener)
    (§
        addChainDownloadStartedEventListener(Threading.USER_THREAD, listener);
    )

    ;;;
     ; <p>Adds a listener that will be notified on the given executor when
     ; chain download starts.</p>
     ;;
#_public
    void addChainDownloadStartedEventListener(Executor executor, ChainDownloadStartedEventListener listener)
    (§
        peersChainDownloadStartedEventListeners.add(new ListenerRegistration<>(Preconditions.checkNotNull(listener), executor));
        for (Peer peer : getConnectedPeers())
            peer.addChainDownloadStartedEventListener(executor, listener);
        for (Peer peer : getPendingPeers())
            peer.addChainDownloadStartedEventListener(executor, listener);
    )

    ;;; See {@link Peer#addConnectedEventListener(PeerConnectedEventListener)}. ;;
#_public
    void addConnectedEventListener(PeerConnectedEventListener listener)
    (§
        addConnectedEventListener(Threading.USER_THREAD, listener);
    )

    ;;;
     ; <p>Adds a listener that will be notified on the given executor when
     ; new peers are connected to.</p>
     ;;
#_public
    void addConnectedEventListener(Executor executor, PeerConnectedEventListener listener)
    (§
        peerConnectedEventListeners.add(new ListenerRegistration<>(Preconditions.checkNotNull(listener), executor));
        for (Peer peer : getConnectedPeers())
            peer.addConnectedEventListener(executor, listener);
        for (Peer peer : getPendingPeers())
            peer.addConnectedEventListener(executor, listener);
    )

    ;;; See {@link Peer#addDisconnectedEventListener(PeerDisconnectedEventListener)}. ;;
#_public
    void addDisconnectedEventListener(PeerDisconnectedEventListener listener)
    (§
        addDisconnectedEventListener(Threading.USER_THREAD, listener);
    )

    ;;;
     ; <p>Adds a listener that will be notified on the given executor when
     ; peers are disconnected from.</p>
     ;;
#_public
    void addDisconnectedEventListener(Executor executor, PeerDisconnectedEventListener listener)
    (§
        peerDisconnectedEventListeners.add(new ListenerRegistration<>(Preconditions.checkNotNull(listener), executor));
        for (Peer peer : getConnectedPeers())
            peer.addDisconnectedEventListener(executor, listener);
        for (Peer peer : getPendingPeers())
            peer.addDisconnectedEventListener(executor, listener);
    )

    ;;; See {@link Peer#addDiscoveredEventListener(PeerDiscoveredEventListener)}. ;;
#_public
    void addDiscoveredEventListener(PeerDiscoveredEventListener listener)
    (§
        addDiscoveredEventListener(Threading.USER_THREAD, listener);
    )

    ;;;
     ; <p>Adds a listener that will be notified on the given executor when new
     ; peers are discovered.</p>
     ;;
#_public
    void addDiscoveredEventListener(Executor executor, PeerDiscoveredEventListener listener)
    (§
        peerDiscoveredEventListeners.add(new ListenerRegistration<>(Preconditions.checkNotNull(listener), executor));
    )

    ;;; See {@link Peer#addGetDataEventListener(GetDataEventListener)}. ;;
#_public
    void addGetDataEventListener(GetDataEventListener listener)
    (§
        addGetDataEventListener(Threading.USER_THREAD, listener);
    )

    ;;; See {@link Peer#addGetDataEventListener(Executor, GetDataEventListener)}. ;;
#_public
    void addGetDataEventListener(final Executor executor, final GetDataEventListener listener)
    (§
        peerGetDataEventListeners.add(new ListenerRegistration<>(Preconditions.checkNotNull(listener), executor));
        for (Peer peer : getConnectedPeers())
            peer.addGetDataEventListener(executor, listener);
        for (Peer peer : getPendingPeers())
            peer.addGetDataEventListener(executor, listener);
    )

    ;;; See {@link Peer#addOnTransactionBroadcastListener(OnTransactionBroadcastListener)}. ;;
#_public
    void addOnTransactionBroadcastListener(OnTransactionBroadcastListener listener)
    (§
        addOnTransactionBroadcastListener(Threading.USER_THREAD, listener);
    )

    ;;; See {@link Peer#addOnTransactionBroadcastListener(OnTransactionBroadcastListener)}. ;;
#_public
    void addOnTransactionBroadcastListener(Executor executor, OnTransactionBroadcastListener listener)
    (§
        peersTransactionBroadastEventListeners.add(new ListenerRegistration<>(Preconditions.checkNotNull(listener), executor));
        for (Peer peer : getConnectedPeers())
            peer.addOnTransactionBroadcastListener(executor, listener);
        for (Peer peer : getPendingPeers())
            peer.addOnTransactionBroadcastListener(executor, listener);
    )

    ;;; See {@link Peer#addPreMessageReceivedEventListener(PreMessageReceivedEventListener)}. ;;
#_public
    void addPreMessageReceivedEventListener(PreMessageReceivedEventListener listener)
    (§
        addPreMessageReceivedEventListener(Threading.USER_THREAD, listener);
    )

    ;;; See {@link Peer#addPreMessageReceivedEventListener(Executor, PreMessageReceivedEventListener)}. ;;
#_public
    void addPreMessageReceivedEventListener(Executor executor, PreMessageReceivedEventListener listener)
    (§
        peersPreMessageReceivedEventListeners.add(new ListenerRegistration<>(Preconditions.checkNotNull(listener), executor));
        for (Peer peer : getConnectedPeers())
            peer.addPreMessageReceivedEventListener(executor, listener);
        for (Peer peer : getPendingPeers())
            peer.addPreMessageReceivedEventListener(executor, listener);
    )

#_public
    boolean removeBlocksDownloadedEventListener(BlocksDownloadedEventListener listener)
    (§
        boolean result = ListenerRegistration.removeFromList(listener, peersBlocksDownloadedEventListeners);
        for (Peer peer : getConnectedPeers())
            peer.removeBlocksDownloadedEventListener(listener);
        for (Peer peer : getPendingPeers())
            peer.removeBlocksDownloadedEventListener(listener);
        return result;
    )

#_public
    boolean removeChainDownloadStartedEventListener(ChainDownloadStartedEventListener listener)
    (§
        boolean result = ListenerRegistration.removeFromList(listener, peersChainDownloadStartedEventListeners);
        for (Peer peer : getConnectedPeers())
            peer.removeChainDownloadStartedEventListener(listener);
        for (Peer peer : getPendingPeers())
            peer.removeChainDownloadStartedEventListener(listener);
        return result;
    )

    ;;; The given event listener will no longer be called with events. ;;
#_public
    boolean removeConnectedEventListener(PeerConnectedEventListener listener)
    (§
        boolean result = ListenerRegistration.removeFromList(listener, peerConnectedEventListeners);
        for (Peer peer : getConnectedPeers())
            peer.removeConnectedEventListener(listener);
        for (Peer peer : getPendingPeers())
            peer.removeConnectedEventListener(listener);
        return result;
    )

    ;;; The given event listener will no longer be called with events. ;;
#_public
    boolean removeDisconnectedEventListener(PeerDisconnectedEventListener listener)
    (§
        boolean result = ListenerRegistration.removeFromList(listener, peerDisconnectedEventListeners);
        for (Peer peer : getConnectedPeers())
            peer.removeDisconnectedEventListener(listener);
        for (Peer peer : getPendingPeers())
            peer.removeDisconnectedEventListener(listener);
        return result;
    )

    ;;; The given event listener will no longer be called with events. ;;
#_public
    boolean removeDiscoveredEventListener(PeerDiscoveredEventListener listener)
    (§
        boolean result = ListenerRegistration.removeFromList(listener, peerDiscoveredEventListeners);
        return result;
    )

    ;;; The given event listener will no longer be called with events. ;;
#_public
    boolean removeGetDataEventListener(GetDataEventListener listener)
    (§
        boolean result = ListenerRegistration.removeFromList(listener, peerGetDataEventListeners);
        for (Peer peer : getConnectedPeers())
            peer.removeGetDataEventListener(listener);
        for (Peer peer : getPendingPeers())
            peer.removeGetDataEventListener(listener);
        return result;
    )

    ;;; The given event listener will no longer be called with events. ;;
#_public
    boolean removeOnTransactionBroadcastListener(OnTransactionBroadcastListener listener)
    (§
        boolean result = ListenerRegistration.removeFromList(listener, peersTransactionBroadastEventListeners);
        for (Peer peer : getConnectedPeers())
            peer.removeOnTransactionBroadcastListener(listener);
        for (Peer peer : getPendingPeers())
            peer.removeOnTransactionBroadcastListener(listener);
        return result;
    )

#_public
    boolean removePreMessageReceivedEventListener(PreMessageReceivedEventListener listener)
    (§
        boolean result = ListenerRegistration.removeFromList(listener, peersPreMessageReceivedEventListeners);
        for (Peer peer : getConnectedPeers())
            peer.removePreMessageReceivedEventListener(listener);
        for (Peer peer : getPendingPeers())
            peer.removePreMessageReceivedEventListener(listener);
        return result;
    )

    ;;;
     ; Returns a newly allocated list containing the currently connected peers.
     ; If all you care about is the count, use numConnectedPeers().
     ;;
#_public
    List<Peer> getConnectedPeers()
    (§
        lock.lock();
        try
        (§
            return new ArrayList<>(peers);
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Returns a list containing Peers that did not complete connection yet.
     ;;
#_public
    List<Peer> getPendingPeers()
    (§
        lock.lock();
        try
        (§
            return new ArrayList<>(pendingPeers);
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Add an address to the list of potential peers to connect to.  It won't necessarily be used unless there's a need
     ; to build new connections to reach the max connection count.
     ;
     ; @param peerAddress IP/port to use.
     ;;
#_public
    void addAddress(PeerAddress peerAddress)
    (§
        int newMax;
        lock.lock();
        try
        (§
            addInactive(peerAddress);
            newMax = getMaxConnections() + 1;
        )
        finally
        (§
            lock.unlock();
        )
        setMaxConnections(newMax);
    )

#_private
    void addInactive(PeerAddress peerAddress)
    (§
        lock.lock();
        try
        (§
            ;; Deduplicate.
            if (backoffMap.containsKey(peerAddress))
                return;
            backoffMap.put(peerAddress, new ExponentialBackoff(peerBackoffParams));
            inactives.offer(peerAddress);
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Convenience for connecting only to peers that can serve specific services.
     ; It will configure suitable peer discoveries.
     ; @param requiredServices Required services as a bitmask, e.g. {@link VersionMessage#NODE_NETWORK}.
     ;;
#_public
    void setRequiredServices(long requiredServices)
    (§
        lock.lock();
        try
        (§
            this.requiredServices = requiredServices;
            peerDiscoverers.clear();
            addPeerDiscovery(MultiplexingDiscovery.forServices(params, requiredServices));
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;; Convenience method for addAddress(new PeerAddress(address, params.port)). ;;
#_public
    void addAddress(InetAddress address)
    (§
        addAddress(new PeerAddress(params, address, params.getPort()));
    )

    ;;;
     ; Add addresses from a discovery source to the list of potential peers to connect to.
     ; If max connections has not been configured, or set to zero, then it's set to the default at this point.
     ;;
#_public
    void addPeerDiscovery(PeerDiscovery peerDiscovery)
    (§
        lock.lock();
        try
        (§
            if (getMaxConnections() == 0)
                setMaxConnections(DEFAULT_CONNECTIONS);
            peerDiscoverers.add(peerDiscovery);
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;; Returns number of discovered peers. ;;
#_protected
    int discoverPeers()
        throws PeerDiscoveryException
    (§
        ;; Don't hold the lock whilst doing peer discovery: it can take a long time and cause high API latency.
        Preconditions.checkState(!lock.isHeldByCurrentThread());

        int maxPeersToDiscoverCount = this.vMaxPeersToDiscoverCount;
        long peerDiscoveryTimeoutMillis = this.vPeerDiscoveryTimeoutMillis;
#_final
        Stopwatch watch = Stopwatch.createStarted();
#_final
        List<PeerAddress> addressList = Lists.newLinkedList();

        for (PeerDiscovery peerDiscovery : peerDiscoverers) ;; COW
        (§
            InetSocketAddress[] addresses = peerDiscovery.getPeers(requiredServices, peerDiscoveryTimeoutMillis, TimeUnit.MILLISECONDS);
            for (InetSocketAddress address : addresses)
                addressList.add(new PeerAddress(params, address));
            if (maxPeersToDiscoverCount <= addressList.size())
                break;
        )

        if (!addressList.isEmpty())
        (§
            for (PeerAddress address : addressList)
                addInactive(address);

#_final
            ImmutableSet<PeerAddress> peersDiscoveredSet = ImmutableSet.copyOf(addressList);
            for (final ListenerRegistration<PeerDiscoveredEventListener> registration : peerDiscoveredEventListeners) ;; COW
            (§
                registration.executor.execute(new Runnable()
                (§
#_override
#_public
                    void run()
                    (§
                        registration.listener.onPeersDiscovered(peersDiscoveredSet);
                    )
                ));
            )
        )
        watch.stop();
        log.info("Peer discovery took {} and returned {} items", watch, addressList.size());
        return addressList.size();
    )

#_testing
    void waitForJobQueue()
    (§
        Futures.getUnchecked(executor.submit(Runnables.doNothing()));
    )

#_private
    int countConnectedAndPendingPeers()
    (§
        lock.lock();
        try
        (§
            return peers.size() + pendingPeers.size();
        )
        finally
        (§
            lock.unlock();
        )
    )

#_private
    enum LocalhostCheckState
    (§
        NOT_TRIED,
        FOUND,
        FOUND_AND_CONNECTED,
        NOT_THERE
    )
#_private
    LocalhostCheckState localhostCheckState = LocalhostCheckState.NOT_TRIED;

#_private
    boolean maybeCheckForLocalhostPeer()
    (§
        Preconditions.checkState(lock.isHeldByCurrentThread());

        if (localhostCheckState == LocalhostCheckState.NOT_TRIED)
        (§
            ;; Do a fast blocking connect to see if anything is listening.
            Socket socket = nil;
            try
            (§
                socket = new Socket();
                socket.connect(new InetSocketAddress(InetAddresses.forString("127.0.0.1"), params.getPort()), vConnectTimeoutMillis);
                localhostCheckState = LocalhostCheckState.FOUND;
                return true;
            )
            catch (IOException e)
            (§
                log.info("Localhost peer not detected.");
                localhostCheckState = LocalhostCheckState.NOT_THERE;
            )
            finally
            (§
                if (socket != nil)
                (§
                    try
                    (§
                        socket.close();
                    )
                    catch (IOException _)
                    (§
                        ;; Ignore.
                    )
                )
            )
        )
        return false;
    )

    ;;;
     ; Starts the PeerGroup and begins network activity.
     ; @return A future that completes when first connection activity has been triggered (note: not first connection made).
     ;;
#_public
    ListenableFuture startAsync()
    (§
        ;; This is run in a background thread by the Service implementation.
        if (chain == nil)
        (§
            ;; Just try to help catch what might be a programming error.
            log.warn("Starting up with no attached block chain. Did you forget to pass one to the constructor?");
        )
        Preconditions.checkState(!vUsedUp, "Cannot start a peer group twice");

        vRunning = true;
        vUsedUp = true;
        executorStartupLatch.countDown();

        ;; We do blocking waits during startup, so run on the executor thread.
        return executor.submit(new Runnable()
        (§
#_override
#_public
            void run()
            (§
                try
                (§
                    log.info("Starting ...");
                    channels.startAsync();
                    channels.awaitRunning();
                    triggerConnections();
                    setupPinging();
                )
                catch (Throwable e)
                (§
                    log.error("Exception when starting up", e); ;; The executor swallows exceptions :(
                )
            )
        ));
    )

    ;;; Does a blocking startup. ;;
#_public
    void start()
    (§
        Futures.getUnchecked(startAsync());
    )

    ;;; Can just use start() for a blocking start here instead of startAsync/awaitRunning: PeerGroup is no longer a Guava service. ;;
#_deprecated
#_public
    void awaitRunning()
    (§
        waitForJobQueue();
    )

#_public
    ListenableFuture stopAsync()
    (§
        Preconditions.checkState(vRunning);
        vRunning = false;
        ListenableFuture future = executor.submit(new Runnable()
        (§
#_override
#_public
            void run()
            (§
                try
                (§
                    log.info("Stopping ...");
                    ;; Blocking close of all sockets.
                    channels.stopAsync();
                    channels.awaitTerminated();
                    for (PeerDiscovery peerDiscovery : peerDiscoverers)
                    (§
                        peerDiscovery.shutdown();
                    )
                    vRunning = false;
                    log.info("Stopped.");
                )
                catch (Throwable e)
                (§
                    log.error("Exception when shutting down", e); ;; The executor swallows exceptions :(
                )
            )
        ));
        executor.shutdown();
        return future;
    )

    ;;; Does a blocking stop. ;;
#_public
    void stop()
    (§
        try
        (§
            stopAsync();
            log.info("Awaiting PeerGroup shutdown ...");
            executor.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS);
        )
        catch (InterruptedException e)
        (§
            throw new RuntimeException(e);
        )
    )

    ;;; Can just use stop() here instead of stopAsync/awaitTerminated: PeerGroup is no longer a Guava service. ;;
#_deprecated
#_public
    void awaitTerminated()
    (§
        try
        (§
            executor.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS);
        )
        catch (InterruptedException e)
        (§
            throw new RuntimeException(e);
        )
    )

    ;;;
     ; <p>Link the given wallet to this PeerGroup.  This is used for three purposes:</p>
     ;
     ; <ol>
     ;   <li>So the wallet receives broadcast transactions.</li>
     ;   <li>Announcing pending transactions that didn't get into the chain yet to our peers.</li>
     ;   <li>Set the fast catchup time using {@link PeerGroup#setFastCatchupTimeSecs(long)} to optimize chain download.</li>
     ; </ol>
     ;
     ; <p>Note that this should be done before chain download commences because if you add a wallet with keys earlier
     ; than the current chain head, the relevant parts of the chain won't be redownloaded for you.</p>
     ;
     ; <p>The Wallet will have an event listener registered on it, so to avoid leaks remember to use
     ; {@link PeerGroup#removeWallet(Wallet)} on it if you wish to keep the Wallet but lose the PeerGroup.</p>
     ;;
#_public
    void addWallet(Wallet wallet)
    (§
        lock.lock();
        try
        (§
            Preconditions.checkNotNull(wallet);
            Preconditions.checkState(!wallets.contains(wallet));
            wallets.add(wallet);
            wallet.setTransactionBroadcaster(this);
            wallet.addCoinsReceivedEventListener(Threading.SAME_THREAD, walletCoinsReceivedEventListener);
            wallet.addKeyChainEventListener(Threading.SAME_THREAD, walletKeyEventListener);
            addPeerFilterProvider(wallet);
            for (Peer peer : peers)
                peer.addWallet(wallet);
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; <p>Link the given PeerFilterProvider to this PeerGroup.
     ; DO NOT use this for Wallets, use {@link PeerGroup#addWallet(Wallet)} instead.</p>
     ;
     ; <p>Note that this should be done before chain download commences because if you add a listener with keys earlier
     ; than the current chain head, the relevant parts of the chain won't be redownloaded for you.</p>
     ;
     ; <p>This method invokes {@link PeerGroup#recalculateFastCatchupAndFilter(FilterRecalculateMode)}.
     ; The return value of this method is the <code>ListenableFuture</code> returned by that invocation.</p>
     ;
     ; @return a future that completes once each <code>Peer</code> in this group has had its <code>BloomFilter</code> (re)set.
     ;;
#_public
    ListenableFuture<BloomFilter> addPeerFilterProvider(PeerFilterProvider provider)
    (§
        lock.lock();
        try
        (§
            Preconditions.checkNotNull(provider);
            Preconditions.checkState(!peerFilterProviders.contains(provider));
            ;; Insert provider at the start.  This avoids various concurrency problems that could occur because we need
            ;; all providers to be in a consistent, unchanging state whilst the filter is built.  Providers can give
            ;; this guarantee by taking a lock in their begin method, but if we add to the end of the list here, it
            ;; means we establish a lock ordering a > b > c if that's the order the providers were added in.  Given that
            ;; the main wallet will usually be first, this establishes an ordering wallet > other-provider, which means
            ;; other-provider can then not call into the wallet itself.  Other providers installed by the API user should
            ;; come first so the expected ordering is preserved.  This can also manifest itself in providers that use
            ;; synchronous RPCs into an actor instead of locking, but the same issue applies.
            peerFilterProviders.add(0, provider);

            ;; Don't bother downloading block bodies before the oldest keys in all our wallets.  Make sure we recalculate
            ;; if a key is added.  Of course, by then we may have downloaded the chain already.  Ideally adding keys would
            ;; automatically rewind the block chain and redownload the blocks to find transactions relevant to those keys,
            ;; all transparently and in the background.  But we are a long way from that yet.
            ListenableFuture<BloomFilter> future = recalculateFastCatchupAndFilter(FilterRecalculateMode.SEND_IF_CHANGED);
            updateVersionMessageRelayTxesBeforeFilter(getVersionMessage());
            return future;
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Opposite of {@link #addPeerFilterProvider(PeerFilterProvider)}.  Again, don't use this for wallets.  Does not
     ; trigger recalculation of the filter.
     ;;
#_public
    void removePeerFilterProvider(PeerFilterProvider provider)
    (§
        lock.lock();
        try
        (§
            Preconditions.checkNotNull(provider);
            Preconditions.checkArgument(peerFilterProviders.remove(provider));
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Unlinks the given wallet so it no longer receives broadcast transactions or has its transactions announced.
     ;;
#_public
    void removeWallet(Wallet wallet)
    (§
        wallets.remove(Preconditions.checkNotNull(wallet));
        peerFilterProviders.remove(wallet);
        wallet.removeCoinsReceivedEventListener(walletCoinsReceivedEventListener);
        wallet.removeKeyChainEventListener(walletKeyEventListener);
        wallet.setTransactionBroadcaster(nil);
        for (Peer peer : peers)
            peer.removeWallet(wallet);
    )

#_public
    enum FilterRecalculateMode
    (§
        SEND_IF_CHANGED,
        FORCE_SEND_FOR_REFRESH,
        DONT_SEND
    )

#_private
#_final
    Map<FilterRecalculateMode, SettableFuture<BloomFilter>> inFlightRecalculations = Maps.newHashMap();

    ;;;
     ; Recalculates the bloom filter given to peers as well as the timestamp after which full blocks are downloaded
     ; (instead of only headers).  Note that calls made one after another may return the same future, if the request
     ; wasn't processed yet (i.e. calls are deduplicated).
     ;
     ; @param mode In what situations to send the filter to connected peers.
     ; @return A future that completes once the filter has been calculated (note: this does not mean acknowledged by remote peers).
     ;;
#_public
    ListenableFuture<BloomFilter> recalculateFastCatchupAndFilter(final FilterRecalculateMode mode)
    (§
#_final
        SettableFuture<BloomFilter> future = SettableFuture.create();
#_synchronized
        (inFlightRecalculations)
        (§
            if (inFlightRecalculations.get(mode) != nil)
                return inFlightRecalculations.get(mode);

            inFlightRecalculations.put(mode, future);
        )
        Runnable command = new Runnable()
        (§
#_override
#_public
            void run()
            (§
                try
                (§
                    go();
                )
                catch (Throwable e)
                (§
                    log.error("Exception when trying to recalculate Bloom filter", e); ;; The executor swallows exceptions :(
                )
            )

#_public
            void go()
            (§
                Preconditions.checkState(!lock.isHeldByCurrentThread());
                ;; Fully verifying mode doesn't use this optimization (it can't as it needs to see all transactions).
                if ((chain != nil && chain.shouldVerifyTransactions()) || !vBloomFilteringEnabled)
                    return;

                ;; We only ever call bloomFilterMerger.calculate on jobQueue, so we cannot be calculating two filters at once.
                FilterMerger.Result result = bloomFilterMerger.calculate(ImmutableList.copyOf(peerFilterProviders)); ;; COW
                boolean send;
                switch (mode)
                (§
                    case SEND_IF_CHANGED:
                        send = result.changed;
                        break;
                    case DONT_SEND:
                        send = false;
                        break;
                    case FORCE_SEND_FOR_REFRESH:
                        send = true;
                        break;
                    default:
                        throw new UnsupportedOperationException();
                )
                if (send)
                (§
                    for (Peer peer : peers) ;; COW
                    (§
                        ;; Only query the mempool if this recalculation request is not in order to lower the observed FP
                        ;; rate.  There's no point querying the mempool when doing this because the FP rate can only go
                        ;; down, and we will have seen all the relevant txns before: it's pointless to ask for them again.
                        peer.setBloomFilter(result.filter, mode != FilterRecalculateMode.FORCE_SEND_FOR_REFRESH);
                    )
                    ;; Reset the false positive estimate so that we don't send a flood of filter updates
                    ;; if the estimate temporarily overshoots our threshold.
                    if (chain != nil)
                        chain.resetFalsePositiveEstimate();
                )
                ;; Do this last so that bloomFilter is already set when it gets called.
                setFastCatchupTimeSecs(result.earliestKeyTimeSecs);
#_synchronized
                (inFlightRecalculations)
                (§
                    inFlightRecalculations.put(mode, nil);
                )
                future.set(result.filter);
            )
        );
        try
        (§
            executor.execute(command);
        )
        catch (RejectedExecutionException _)
        (§
            ;; Can happen during shutdown.
        )
        return future;
    )

    ;;;
     ; <p>Sets the false positive rate of bloom filters given to peers.  The default is {@link #DEFAULT_BLOOM_FILTER_FP_RATE}.</p>
     ;
     ; <p>Be careful regenerating the bloom filter too often, as it decreases anonymity because remote nodes can
     ; compare transactions against both the new and old filters to significantly decrease the false positive rate.</p>
     ;
     ; <p>See the docs for {@link BloomFilter#BloomFilter(int, double, long, BloomFilter.BloomUpdate)} for a brief
     ; explanation of anonymity when using bloom filters.</p>
     ;;
#_public
    void setBloomFilterFalsePositiveRate(double bloomFilterFPRate)
    (§
        lock.lock();
        try
        (§
            bloomFilterMerger.setBloomFilterFPRate(bloomFilterFPRate);
            recalculateFastCatchupAndFilter(FilterRecalculateMode.SEND_IF_CHANGED);
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Returns the number of currently connected peers.  To be informed when this count changes, register a
     ; {@link org.bitcoinj.core.listeners.PeerConnectedEventListener}/{@link org.bitcoinj.core.listeners.PeerDisconnectedEventListener}
     ; and use the onPeerConnected/onPeerDisconnected methods.
     ;;
#_public
    int numConnectedPeers()
    (§
        return peers.size();
    )

    ;;;
     ; Connect to a peer by creating a channel to the destination address.  This should not be
     ; used normally - let the PeerGroup manage connections through {@link #start()}.
     ;
     ; @param address Destination IP and port.
     ; @return The newly created Peer object or null if the peer could not be connected.
     ;         Use {@link org.bitcoinj.core.Peer#getConnectionOpenFuture()} if you
     ;         want a future which completes when the connection is open.
     ;;
#_nilable
#_public
    Peer connectTo(InetSocketAddress address)
    (§
        lock.lock();
        try
        (§
            PeerAddress peerAddress = new PeerAddress(params, address);
            backoffMap.put(peerAddress, new ExponentialBackoff(peerBackoffParams));
            return connectTo(peerAddress, true, vConnectTimeoutMillis);
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Helper for forcing a connection to localhost.  Useful when using test mode.  Returns the peer object.
     ;;
#_nilable
#_public
    Peer connectToLocalHost()
    (§
        lock.lock();
        try
        (§
#_final
            PeerAddress localhost = PeerAddress.localhost(params);
            backoffMap.put(localhost, new ExponentialBackoff(peerBackoffParams));
            return connectTo(localhost, true, vConnectTimeoutMillis);
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Creates a version message to send, constructs a Peer object and attempts to connect it.
     ; Returns the peer on success or null on failure.
     ; @param address Remote network address.
     ; @param incrementMaxConnections Whether to consider this connection an attempt to fill our quota, or something explicitly requested.
     ; @return Peer or null.
     ;;
#_nilable
#_guarded-by("lock")
#_protected
    Peer connectTo(PeerAddress address, boolean incrementMaxConnections, int connectTimeoutMillis)
    (§
        Preconditions.checkState(lock.isHeldByCurrentThread());
        VersionMessage ver = getVersionMessage().duplicate();
        ver.bestHeight = (chain != nil) ? chain.getBestChainHeight() : 0;
        ver.time = Utils.currentTimeSeconds();

        Peer peer = createPeer(address, ver);
        peer.addConnectedEventListener(Threading.SAME_THREAD, startupListener);
        peer.addDisconnectedEventListener(Threading.SAME_THREAD, startupListener);
        peer.setMinProtocolVersion(vMinRequiredProtocolVersion);
        pendingPeers.add(peer);

        try
        (§
            log.info("Attempting connection to {}     ({} connected, {} pending, {} max)", address, peers.size(), pendingPeers.size(), maxConnections);
            ListenableFuture<SocketAddress> future = channels.openConnection(address.toSocketAddress(), peer);
            if (future.isDone())
                Uninterruptibles.getUninterruptibly(future);
        )
        catch (ExecutionException e)
        (§
            Throwable cause = Throwables.getRootCause(e);
            log.warn("Failed to connect to " + address + ": " + cause.getMessage());
            handlePeerDeath(peer, cause);
            return nil;
        )
        peer.setSocketTimeout(connectTimeoutMillis);
        ;; When the channel has connected and version negotiated successfully, handleNewPeer will end up being called
        ;; on a worker thread.
        if (incrementMaxConnections)
        (§
            ;; We don't use setMaxConnections here as that would trigger a recursive attempt to establish a new
            ;; outbound connection.
            maxConnections++;
        )
        return peer;
    )

    ;;; You can override this to customise the creation of {@link Peer} objects. ;;
#_guarded-by("lock")
#_protected
    Peer createPeer(PeerAddress address, VersionMessage ver)
    (§
        return new Peer(params, ver, address, chain, downloadTxDependencyDepth);
    )

    ;;;
     ; Sets the timeout between when a connection attempt to a peer begins and when the version message exchange completes.
     ; This does not apply to currently pending peers.
     ;;
#_public
    void setConnectTimeoutMillis(int connectTimeoutMillis)
    (§
        this.vConnectTimeoutMillis = connectTimeoutMillis;
    )

    ;;;
     ; <p>Start downloading the blockchain from the first available peer.</p>
     ;
     ; <p>If no peers are currently connected, the download will be started once a peer starts.  If the peer dies,
     ; the download will resume with another peer.</p>
     ;
     ; @param listener A listener for chain download events, may not be null.
     ;;
#_public
    void startBlockChainDownload(PeerDataEventListener listener)
    (§
        lock.lock();
        try
        (§
            if (downloadPeer != nil)
            (§
                if (this.downloadListener != nil)
                    removeDataEventListenerFromPeer(downloadPeer, this.downloadListener);
                if (listener != nil)
                    addDataEventListenerToPeer(Threading.USER_THREAD, downloadPeer, listener);
            )
            this.downloadListener = listener;
            ;; TODO: Be more nuanced about which peer to download from.  We can also try
            ;; downloading from multiple peers and handle the case when a new peer comes along
            ;; with a longer chain after we thought we were done.
            if (!peers.isEmpty())
                startBlockChainDownloadFromPeer(peers.iterator().next()); ;; Will add the new download listener.
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Register a data event listener against a single peer (i.e. for blockchain download).
     ; Handling registration/deregistration on peer death/add is outside the scope of these methods.
     ;;
#_private
#_static
    void addDataEventListenerToPeer(Executor executor, Peer peer, PeerDataEventListener downloadListener)
    (§
        peer.addBlocksDownloadedEventListener(executor, downloadListener);
        peer.addChainDownloadStartedEventListener(executor, downloadListener);
        peer.addGetDataEventListener(executor, downloadListener);
        peer.addPreMessageReceivedEventListener(executor, downloadListener);
    )

    ;;;
     ; Remove a registered data event listener against a single peer (i.e. for blockchain download).
     ; Handling registration/deregistration on peer death/add is outside the scope of these methods.
     ;;
#_private
#_static
    void removeDataEventListenerFromPeer(Peer peer, PeerDataEventListener listener)
    (§
        peer.removeBlocksDownloadedEventListener(listener);
        peer.removeChainDownloadStartedEventListener(listener);
        peer.removeGetDataEventListener(listener);
        peer.removePreMessageReceivedEventListener(listener);
    )

    ;;;
     ; Download the blockchain from peers.  Convenience that uses a {@link DownloadProgressTracker} for you.
     ;
     ; This method waits until the download is complete.  "Complete" is defined as downloading
     ; from at least one peer all the blocks that are in that peer's inventory.
     ;;
#_public
    void downloadBlockChain()
    (§
        DownloadProgressTracker listener = new DownloadProgressTracker();
        startBlockChainDownload(listener);
        try
        (§
            listener.await();
        )
        catch (InterruptedException e)
        (§
            throw new RuntimeException(e);
        )
    )

#_protected
    void handleNewPeer(final Peer peer)
    (§
        int newSize = -1;
        lock.lock();
        try
        (§
            groupBackoff.trackSuccess();
            backoffMap.get(peer.getAddress()).trackSuccess();

            ;; Sets up the newly connected peer so it can do everything it needs to.
            pendingPeers.remove(peer);
            peers.add(peer);
            newSize = peers.size();
            log.info("{}: New peer      ({} connected, {} pending, {} max)", peer, newSize, pendingPeers.size(), maxConnections);
            ;; Give the peer a filter that can be used to probabilistically drop transactions that
            ;; aren't relevant to our wallet.  We may still receive some false positives, which is
            ;; OK because it helps improve wallet privacy.  Old nodes will just ignore the message.
            if (bloomFilterMerger.getLastFilter() != nil)
                peer.setBloomFilter(bloomFilterMerger.getLastFilter());
            peer.setDownloadData(false);
            ;; TODO: The peer should calculate the fast catchup time from the added wallets here.
            for (Wallet wallet : wallets)
                peer.addWallet(wallet);
            if (downloadPeer == nil)
            (§
                ;; Kick off chain download if we aren't already doing it.
                setDownloadPeer(selectDownloadPeer(peers));
                boolean shouldDownloadChain = (downloadListener != nil && chain != nil);
                if (shouldDownloadChain)
                    startBlockChainDownloadFromPeer(downloadPeer);
            )
            ;; Make sure the peer knows how to upload transactions that are requested from us.
            peer.addBlocksDownloadedEventListener(Threading.SAME_THREAD, peerListener);
            peer.addGetDataEventListener(Threading.SAME_THREAD, peerListener);

            ;; And set up event listeners for clients.  This will allow them to find out about new transactions and blocks.
            for (ListenerRegistration<BlocksDownloadedEventListener> registration : peersBlocksDownloadedEventListeners)
                peer.addBlocksDownloadedEventListener(registration.executor, registration.listener);
            for (ListenerRegistration<ChainDownloadStartedEventListener> registration : peersChainDownloadStartedEventListeners)
                peer.addChainDownloadStartedEventListener(registration.executor, registration.listener);
            for (ListenerRegistration<PeerConnectedEventListener> registration : peerConnectedEventListeners)
                peer.addConnectedEventListener(registration.executor, registration.listener);

            ;; We intentionally do not add disconnect listeners to peers.
            for (ListenerRegistration<GetDataEventListener> registration : peerGetDataEventListeners)
                peer.addGetDataEventListener(registration.executor, registration.listener);
            for (ListenerRegistration<OnTransactionBroadcastListener> registration : peersTransactionBroadastEventListeners)
                peer.addOnTransactionBroadcastListener(registration.executor, registration.listener);
            for (ListenerRegistration<PreMessageReceivedEventListener> registration : peersPreMessageReceivedEventListeners)
                peer.addPreMessageReceivedEventListener(registration.executor, registration.listener);
        )
        finally
        (§
            lock.unlock();
        )

#_final
        int fNewSize = newSize;
        for (final ListenerRegistration<PeerConnectedEventListener> registration : peerConnectedEventListeners)
        (§
            registration.executor.execute(new Runnable()
            (§
#_override
#_public
                void run()
                (§
                    registration.listener.onPeerConnected(peer, fNewSize);
                )
            ));
        )
    )

#_nilable
#_private
#_volatile
    ListenableScheduledFuture<?> vPingTask;

#_suppress("NonAtomicOperationOnVolatileField")
#_private
    void setupPinging()
    (§
        if (getPingIntervalMsec() <= 0)
            return; ;; Disabled.

        vPingTask = executor.scheduleAtFixedRate(new Runnable()
        (§
#_override
#_public
            void run()
            (§
                try
                (§
                    if (getPingIntervalMsec() <= 0)
                    (§
                        ListenableScheduledFuture<?> task = vPingTask;
                        if (task != nil)
                        (§
                            task.cancel(false);
                            vPingTask = nil;
                        )
                        return; ;; Disabled.
                    )
                    for (Peer peer : getConnectedPeers())
                    (§
                        if (peer.getPeerVersionMessage().clientVersion < params.getProtocolVersionNum(NetworkParameters.ProtocolVersion.PONG))
                            continue;
                        peer.ping();
                    )
                )
                catch (Throwable e)
                (§
                    log.error("Exception in ping loop", e); ;; The executor swallows exceptions :(
                )
            )
        ), getPingIntervalMsec(), getPingIntervalMsec(), TimeUnit.MILLISECONDS);
    )

#_private
    void setDownloadPeer(#_nilable Peer peer)
    (§
        lock.lock();
        try
        (§
            if (downloadPeer == peer)
                return;
            if (downloadPeer != nil)
            (§
                log.info("Unsetting download peer: {}", downloadPeer);
                if (downloadListener != nil)
                    removeDataEventListenerFromPeer(downloadPeer, downloadListener);
                downloadPeer.setDownloadData(false);
            )
            downloadPeer = peer;
            if (downloadPeer != nil)
            (§
                log.info("Setting download peer: {}", downloadPeer);
                if (downloadListener != nil)
                    addDataEventListenerToPeer(Threading.SAME_THREAD, peer, downloadListener);
                downloadPeer.setDownloadData(true);
                if (chain != nil)
                    downloadPeer.setDownloadParameters(fastCatchupTimeSecs, bloomFilterMerger.getLastFilter() != nil);
            )
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Tells the PeerGroup to download only block headers before a certain time and bodies after that.
     ; Call this before starting block chain download.
     ; Do not use a time > NOW - 1 block, as it will break some block download logic.
     ;;
#_public
    void setFastCatchupTimeSecs(long secondsSinceEpoch)
    (§
        lock.lock();
        try
        (§
            Preconditions.checkState(chain == nil || !chain.shouldVerifyTransactions(), "Fast catchup is incompatible with fully verifying");

            fastCatchupTimeSecs = secondsSinceEpoch;
            if (downloadPeer != nil)
                downloadPeer.setDownloadParameters(secondsSinceEpoch, bloomFilterMerger.getLastFilter() != nil);
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Returns the current fast catchup time.  The contents of blocks before this time won't be downloaded as they
     ; cannot contain any interesting transactions.  If you use {@link PeerGroup#addWallet(Wallet)} this just returns
     ; the min of the wallets earliest key times.
     ; @return a time in seconds since the epoch.
     ;;
#_public
    long getFastCatchupTimeSecs()
    (§
        lock.lock();
        try
        (§
            return fastCatchupTimeSecs;
        )
        finally
        (§
            lock.unlock();
        )
    )

#_protected
    void handlePeerDeath(final Peer peer, #_nilable Throwable exception)
    (§
        ;; Peer deaths can occur during startup if a connect attempt after peer discovery aborts immediately.
        if (!isRunning())
            return;

        int numPeers;
        int numConnectedPeers = 0;
        lock.lock();
        try
        (§
            pendingPeers.remove(peer);
            peers.remove(peer);

            PeerAddress address = peer.getAddress();

            log.info("{}: Peer died      ({} connected, {} pending, {} max)", address, peers.size(), pendingPeers.size(), maxConnections);
            if (peer == downloadPeer)
            (§
                log.info("Download peer died. Picking a new one.");
                setDownloadPeer(nil);
                ;; Pick a new one and possibly tell it to download the chain.
#_final
                Peer newDownloadPeer = selectDownloadPeer(peers);
                if (newDownloadPeer != nil)
                (§
                    setDownloadPeer(newDownloadPeer);
                    if (downloadListener != nil)
                        startBlockChainDownloadFromPeer(newDownloadPeer);
                )
            )
            numPeers = peers.size() + pendingPeers.size();
            numConnectedPeers = peers.size();

            groupBackoff.trackFailure();

            if (exception instanceof NoRouteToHostException)
            (§
                if (address.getAddr() instanceof Inet6Address && !ipv6Unreachable)
                (§
                    ipv6Unreachable = true;
                    log.warn("IPv6 peer connect failed due to routing failure, ignoring IPv6 addresses from now on");
                )
            )
            else
            (§
                backoffMap.get(address).trackFailure();
                ;; Put back on inactive list.
                inactives.offer(address);
            )

            if (numPeers < getMaxConnections())
                triggerConnections();
        )
        finally
        (§
            lock.unlock();
        )

        peer.removeBlocksDownloadedEventListener(peerListener);
        peer.removeGetDataEventListener(peerListener);
        for (Wallet wallet : wallets)
            peer.removeWallet(wallet);

#_final
        int fNumConnectedPeers = numConnectedPeers;

        for (ListenerRegistration<BlocksDownloadedEventListener> registration: peersBlocksDownloadedEventListeners)
            peer.removeBlocksDownloadedEventListener(registration.listener);
        for (ListenerRegistration<ChainDownloadStartedEventListener> registration: peersChainDownloadStartedEventListeners)
            peer.removeChainDownloadStartedEventListener(registration.listener);
        for (ListenerRegistration<GetDataEventListener> registration: peerGetDataEventListeners)
            peer.removeGetDataEventListener(registration.listener);
        for (ListenerRegistration<PreMessageReceivedEventListener> registration: peersPreMessageReceivedEventListeners)
            peer.removePreMessageReceivedEventListener(registration.listener);
        for (ListenerRegistration<OnTransactionBroadcastListener> registration : peersTransactionBroadastEventListeners)
            peer.removeOnTransactionBroadcastListener(registration.listener);

        for (final ListenerRegistration<PeerDisconnectedEventListener> registration : peerDisconnectedEventListeners)
        (§
            registration.executor.execute(new Runnable()
            (§
#_override
#_public
                void run()
                (§
                    registration.listener.onPeerDisconnected(peer, fNumConnectedPeers);
                )
            ));
            peer.removeDisconnectedEventListener(registration.listener);
        )
    )

#_guarded-by("lock")
#_private
    int stallPeriodSeconds = 10;
#_guarded-by("lock")
#_private
    int stallMinSpeedBytesSec = Block.HEADER_SIZE * 20;

    ;;;
     ; Configures the stall speed: the speed at which a peer is considered to be serving us the block chain
     ; unacceptably slowly.  Once a peer has served us data slower than the given data rate for the given
     ; number of seconds, it is considered stalled and will be disconnected, forcing the chain download to continue
     ; from a different peer.  The defaults are chosen conservatively, but if you are running on a platform that is
     ; CPU constrained or on a very slow network e.g. EDGE, the default settings may need adjustment to
     ; avoid false stalls.
     ;
     ; @param periodSecs How many seconds the download speed must be below blocksPerSec, defaults to 10.
     ; @param bytesPerSecond Download speed (only blocks/txns count) must be consistently below this for a stall, defaults to the bandwidth required for 20 block headers per second.
     ;;
#_public
    void setStallThreshold(int periodSecs, int bytesPerSecond)
    (§
        lock.lock();
        try
        (§
            stallPeriodSeconds = periodSecs;
            stallMinSpeedBytesSec = bytesPerSecond;
        )
        finally
        (§
            lock.unlock();
        )
    )

#_private
    class ChainDownloadSpeedCalculator implements BlocksDownloadedEventListener, Runnable
    (§
#_private
        int blocksInLastSecond, txnsInLastSecond, origTxnsInLastSecond;
#_private
        long bytesInLastSecond;

        ;; If we take more stalls than this, we assume we're on some kind of terminally slow network and the
        ;; stall threshold just isn't set properly.  We give up on stall disconnects after that.
#_private
        int maxStalls = 3;

        ;; How many seconds the peer has until we start measuring its speed.
#_private
        int warmupSeconds = -1;

        ;; Used to calculate a moving average.
#_private
        long[] samples;
#_private
        int cursor;

#_private
        boolean syncDone;

#_override
#_public
#_synchronized
        void onBlocksDownloaded(Peer peer, Block block, #_nilable FilteredBlock filteredBlock, int blocksLeft)
        (§
            blocksInLastSecond++;
            bytesInLastSecond += Block.HEADER_SIZE;
            List<Transaction> blockTransactions = block.getTransactions();
            ;; This whole area of the type hierarchy is a mess.
            int txCount = (blockTransactions != nil ? countAndMeasureSize(blockTransactions) : 0) +
                          (filteredBlock != nil ? countAndMeasureSize(filteredBlock.getAssociatedTransactions().values()) : 0);
            txnsInLastSecond = txnsInLastSecond + txCount;
            if (filteredBlock != nil)
                origTxnsInLastSecond += filteredBlock.getTransactionCount();
        )

#_private
        int countAndMeasureSize(Collection<Transaction> transactions)
        (§
            for (Transaction transaction : transactions)
                bytesInLastSecond += transaction.getMessageSize();
            return transactions.size();
        )

#_override
#_public
        void run()
        (§
            try
            (§
                calculate();
            )
            catch (Throwable e)
            (§
                log.error("Error in speed calculator", e);
            )
        )

#_private
        void calculate()
        (§
            int minSpeedBytesPerSec;
            int period;

            lock.lock();
            try
            (§
                minSpeedBytesPerSec = stallMinSpeedBytesSec;
                period = stallPeriodSeconds;
            )
            finally
            (§
                lock.unlock();
            )

#_synchronized
            (this)
            (§
                if (samples == nil || samples.length != period)
                (§
                    samples = new long[period];
                    ;; *2 because otherwise a single low sample could cause an immediate disconnect which is too harsh.
                    Arrays.fill(samples, minSpeedBytesPerSec * 2);
                    warmupSeconds = 15;
                )

                boolean behindPeers = (chain != nil && chain.getBestChainHeight() < getMostCommonChainHeight());
                if (!behindPeers)
                    syncDone = true;
                if (!syncDone)
                (§
                    if (warmupSeconds < 0)
                    (§
                        ;; Calculate the moving average.
                        samples[cursor++] = bytesInLastSecond;
                        if (cursor == samples.length)
                            cursor = 0;
                        long average = 0;
                        for (long sample : samples)
                            average += sample;
                        average /= samples.length;

                        log.info(String.format(Locale.US,
                                "%d blocks/sec, %d tx/sec, %d pre-filtered tx/sec, avg/last %.2f/%.2f kilobytes per sec (stall threshold <%.2f KB/sec for %d seconds)",
                                blocksInLastSecond, txnsInLastSecond, origTxnsInLastSecond, average / 1024.0, bytesInLastSecond / 1024.0,
                                minSpeedBytesPerSec / 1024.0, samples.length));

                        if (average < minSpeedBytesPerSec && 0 < maxStalls)
                        (§
                            maxStalls--;
                            if (maxStalls == 0)
                            (§
                                ;; We could consider starting to drop the Bloom filtering FP rate at this point, because
                                ;; we tried a bunch of peers and no matter what we don't seem to be able to go any faster.
                                ;; This implies we're bandwidth bottlenecked and might want to start using bandwidth
                                ;; more effectively.  Of course if there's a MITM that is deliberately throttling us,
                                ;; this is a good way to make us take away all the FPs from our Bloom filters ... but
                                ;; as they don't give us a whole lot of privacy either way that's not inherently a big
                                ;; deal.
                                log.warn("This network seems to be slower than the requested stall threshold - won't do stall disconnects any more.");
                            )
                            else
                            (§
                                Peer peer = getDownloadPeer();
                                log.warn(String.format(Locale.US,
                                        "Chain download stalled: received %.2f KB/sec for %d seconds, require average of %.2f KB/sec, disconnecting %s",
                                        average / 1024.0, samples.length, minSpeedBytesPerSec / 1024.0, peer));
                                peer.close();
                                ;; Reset the sample buffer and give the next peer time to get going.
                                samples = nil;
                                warmupSeconds = period;
                            )
                        )
                    )
                    else
                    (§
                        warmupSeconds--;
                        if (0 < bytesInLastSecond)
                            log.info(String.format(Locale.US, "%d blocks/sec, %d tx/sec, %d pre-filtered tx/sec, last %.2f kilobytes per sec",
                                    blocksInLastSecond, txnsInLastSecond, origTxnsInLastSecond, bytesInLastSecond / 1024.0));
                    )
                )
                blocksInLastSecond = 0;
                txnsInLastSecond = 0;
                origTxnsInLastSecond = 0;
                bytesInLastSecond = 0;
            )
        )
    )
#_nilable
#_private
    ChainDownloadSpeedCalculator chainDownloadSpeedCalculator;

#_private
    void startBlockChainDownloadFromPeer(Peer peer)
    (§
        lock.lock();
        try
        (§
            setDownloadPeer(peer);

            if (chainDownloadSpeedCalculator == nil)
            (§
                ;; Every second, run the calculator which will log how fast we are downloading the chain.
                chainDownloadSpeedCalculator = new ChainDownloadSpeedCalculator();
                executor.scheduleAtFixedRate(chainDownloadSpeedCalculator, 1, 1, TimeUnit.SECONDS);
            )
            peer.addBlocksDownloadedEventListener(Threading.SAME_THREAD, chainDownloadSpeedCalculator);

            ;; startBlockChainDownload will setDownloadData(true) on itself automatically.
            peer.startBlockChainDownload();
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Returns a future that is triggered when the number of connected peers is equal to the given number of peers.
     ; By using this with {@link org.bitcoinj.core.PeerGroup#getMaxConnections()} you can wait until the
     ; network is fully online.  To block immediately, just call get() on the result.  Just calls
     ; {@link #waitForPeersOfVersion(int, long)} with zero as the protocol version.
     ;
     ; @param numPeers How many peers to wait for.
     ; @return a future that will be triggered when the number of connected peers >= numPeers.
     ;;
#_public
    ListenableFuture<List<Peer>> waitForPeers(final int numPeers)
    (§
        return waitForPeersOfVersion(numPeers, 0);
    )

    ;;;
     ; Returns a future that is triggered when there are at least the requested number of connected peers that support
     ; the given protocol version or higher.  To block immediately, just call get() on the result.
     ;
     ; @param numPeers How many peers to wait for.
     ; @param protocolVersion The protocol version the awaited peers must implement (or better).
     ; @return a future that will be triggered when the number of connected peers implementing protocolVersion or higher >= numPeers.
     ;;
#_public
    ListenableFuture<List<Peer>> waitForPeersOfVersion(final int numPeers, final long protocolVersion)
    (§
        List<Peer> foundPeers = findPeersOfAtLeastVersion(protocolVersion);
        if (numPeers <= foundPeers.size())
            return Futures.immediateFuture(foundPeers);

#_final
        SettableFuture<List<Peer>> future = SettableFuture.create();
        addConnectedEventListener(new PeerConnectedEventListener()
        (§
#_override
#_public
            void onPeerConnected(Peer peer, int peerCount)
            (§
#_final
                List<Peer> peers = findPeersOfAtLeastVersion(protocolVersion);
                if (numPeers <= peers.size())
                (§
                    future.set(peers);
                    removeConnectedEventListener(this);
                )
            )
        ));
        return future;
    )

    ;;;
     ; Returns an array list of peers that implement the given protocol version or better.
     ;;
#_public
    List<Peer> findPeersOfAtLeastVersion(long protocolVersion)
    (§
        lock.lock();
        try
        (§
            ArrayList<Peer> results = new ArrayList<Peer>(peers.size());
            for (Peer peer : peers)
                if (peer.getPeerVersionMessage().clientVersion >= protocolVersion)
                    results.add(peer);
            return results;
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Returns a future that is triggered when there are at least the requested number of connected peers that support
     ; the given protocol version or higher.  To block immediately, just call get() on the result.
     ;
     ; @param numPeers How many peers to wait for.
     ; @param mask An integer representing a bit mask that will be ANDed with the peers advertised service masks.
     ; @return a future that will be triggered when the number of connected peers implementing protocolVersion or higher >= numPeers.
     ;;
#_public
    ListenableFuture<List<Peer>> waitForPeersWithServiceMask(final int numPeers, final int mask)
    (§
        lock.lock();
        try
        (§
            List<Peer> foundPeers = findPeersWithServiceMask(mask);
            if (numPeers <= foundPeers.size())
                return Futures.immediateFuture(foundPeers);

#_final
            SettableFuture<List<Peer>> future = SettableFuture.create();
            addConnectedEventListener(new PeerConnectedEventListener()
            (§
#_override
#_public
                void onPeerConnected(Peer peer, int peerCount)
                (§
#_final
                    List<Peer> peers = findPeersWithServiceMask(mask);
                    if (numPeers <= peers.size())
                    (§
                        future.set(peers);
                        removeConnectedEventListener(this);
                    )
                )
            ));
            return future;
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Returns an array list of peers that match the requested service bit mask.
     ;;
#_public
    List<Peer> findPeersWithServiceMask(int mask)
    (§
        lock.lock();
        try
        (§
            ArrayList<Peer> results = new ArrayList<Peer>(peers.size());
            for (Peer peer : peers)
                if ((peer.getPeerVersionMessage().localServices & mask) == mask)
                    results.add(peer);
            return results;
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Returns the number of connections that are required before transactions will be broadcast.  If there aren't
     ; enough, {@link PeerGroup#broadcastTransaction(Transaction)} will wait until the minimum number is reached so
     ; propagation across the network can be observed.  If no value has been set using
     ; {@link PeerGroup#setMinBroadcastConnections(int)} a default of 80% of whatever
     ; {@link org.bitcoinj.core.PeerGroup#getMaxConnections()} returns is used.
     ;;
#_public
    int getMinBroadcastConnections()
    (§
        lock.lock();
        try
        (§
            if (minBroadcastConnections == 0)
            (§
                int max = getMaxConnections();
                if (max <= 1)
                    return max;
                else
                    return (int)Math.round(getMaxConnections() * 0.8);
            )
            return minBroadcastConnections;
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; See {@link org.bitcoinj.core.PeerGroup#getMinBroadcastConnections()}.
     ;;
#_public
    void setMinBroadcastConnections(int value)
    (§
        lock.lock();
        try
        (§
            minBroadcastConnections = value;
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Calls {@link PeerGroup#broadcastTransaction(Transaction, int)} with getMinBroadcastConnections() as the number
     ; of connections to wait for before commencing broadcast.
     ;;
#_override
#_public
    TransactionBroadcast broadcastTransaction(final Transaction tx)
    (§
        return broadcastTransaction(tx, Math.max(1, getMinBroadcastConnections()));
    )

    ;;;
     ; <p>Given a transaction, sends it un-announced to one peer and then waits for it to be received back from
     ; other peers.  Once all connected peers have announced the transaction, the future available via the
     ; {@link org.bitcoinj.core.TransactionBroadcast#future()} method will be completed.  If anything goes
     ; wrong the exception will be thrown when get() is called, or you can receive it via a callback on the
     ; {@link ListenableFuture}.  This method returns immediately, so if you want it to block just call get() on the
     ; result.</p>
     ;
     ; <p>Note that if the PeerGroup is limited to only one connection (discovery is not activated) then the future
     ; will complete as soon as the transaction was successfully written to that peer.</p>
     ;
     ; <p>The transaction won't be sent until there are at least minConnections active connections available.
     ; A good choice for proportion would be between 0.5 and 0.8 but if you want faster transmission during initial
     ; bringup of the peer group you can lower it.</p>
     ;
     ; <p>The returned {@link org.bitcoinj.core.TransactionBroadcast} object can be used to get progress feedback,
     ; which is calculated by watching the transaction propagate across the network and be announced by peers.</p>
     ;;
#_public
    TransactionBroadcast broadcastTransaction(final Transaction tx, final int minConnections)
    (§
        ;; If we don't have a record of where this tx came from already, set it to be ourselves so Peer doesn't end up
        ;; redownloading it from the network redundantly.
        if (tx.getConfidence().getSource().equals(TransactionConfidence.Source.UNKNOWN))
        (§
            log.info("Transaction source unknown, setting to SELF: {}", tx.getHashAsString());
            tx.getConfidence().setSource(TransactionConfidence.Source.SELF);
        )
#_final
        TransactionBroadcast broadcast = new TransactionBroadcast(this, tx);
        broadcast.setMinConnections(minConnections);
        ;; Send the TX to the wallet once we have a successful broadcast.
        Futures.addCallback(broadcast.future(), new FutureCallback<Transaction>()
        (§
#_override
#_public
            void onSuccess(Transaction transaction)
            (§
                runningBroadcasts.remove(broadcast);
                ;; OK, now tell the wallet about the transaction.  If the wallet created the transaction,
                ;; then it already knows and will ignore this.  If it's a transaction we received from
                ;; somebody else via a side channel and are now broadcasting, this will put it into the
                ;; wallet now we know it's valid.
                for (Wallet wallet : wallets)
                (§
                    ;; Assumption here is there are no dependencies of the created transaction.
                    ;;
                    ;; We may end up with two threads trying to do this in parallel - the wallet will
                    ;; ignore whichever one loses the race.
                    try
                    (§
                        wallet.receivePending(transaction, nil);
                    )
                    catch (VerificationException e)
                    (§
                        throw new RuntimeException(e); ;; Cannot fail to verify a tx we created ourselves.
                    )
                )
            )

#_override
#_public
            void onFailure(Throwable throwable)
            (§
                ;; This can happen if we get a reject message from a peer.
                runningBroadcasts.remove(broadcast);
            )
        ));
        ;; Keep a reference to the TransactionBroadcast object.  This is important because otherwise, the entire tree
        ;; of objects we just created would become garbage if the user doesn't hold on to the returned future, and
        ;; eventually be collected.  This in turn could result in the transaction not being committed to the wallet
        ;; at all.
        runningBroadcasts.add(broadcast);
        broadcast.broadcast();
        return broadcast;
    )

    ;;;
     ; Returns the period between pings for an individual peer.  Setting this lower means more accurate and timely
     ; ping times are available via {@link org.bitcoinj.core.Peer#getLastPingTime()} but it increases load on the
     ; remote node.  It defaults to {@link PeerGroup#DEFAULT_PING_INTERVAL_MSEC}.
     ;;
#_public
    long getPingIntervalMsec()
    (§
        lock.lock();
        try
        (§
            return pingIntervalMsec;
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Sets the period between pings for an individual peer.  Setting this lower means more accurate and timely
     ; ping times are available via {@link org.bitcoinj.core.Peer#getLastPingTime()} but it increases load on the
     ; remote node.  It defaults to {@link PeerGroup#DEFAULT_PING_INTERVAL_MSEC}.
     ; Setting the value to be <= 0 disables pinging entirely, although you can still request one yourself
     ; using {@link org.bitcoinj.core.Peer#ping()}.
     ;;
#_public
    void setPingIntervalMsec(long pingIntervalMsec)
    (§
        lock.lock();
        try
        (§
            this.pingIntervalMsec = pingIntervalMsec;
            ListenableScheduledFuture<?> task = vPingTask;
            if (task != nil)
                task.cancel(false);
            setupPinging();
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; If a peer is connected to that claims to speak a protocol version lower than the given version, it will
     ; be disconnected and another one will be tried instead.
     ;;
#_public
    void setMinRequiredProtocolVersion(int minRequiredProtocolVersion)
    (§
        this.vMinRequiredProtocolVersion = minRequiredProtocolVersion;
    )

    ;;; The minimum protocol version required: defaults to the version required for Bloom filtering. ;;
#_public
    int getMinRequiredProtocolVersion()
    (§
        return vMinRequiredProtocolVersion;
    )

    ;;;
     ; Returns our peers most commonly reported chain height.  If multiple heights are tied, the highest is returned.
     ; If no peers are connected, returns zero.
     ;;
#_public
    int getMostCommonChainHeight()
    (§
        lock.lock();
        try
        (§
            return getMostCommonChainHeight(this.peers);
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Returns most commonly reported chain height from the given list of {@link Peer}s.
     ; If multiple heights are tied, the highest is returned.  If no peers are connected, returns zero.
     ;;
#_public
#_static
    int getMostCommonChainHeight(final List<Peer> peers)
    (§
        if (peers.isEmpty())
            return 0;

        List<Integer> heights = new ArrayList<>(peers.size());
        for (Peer peer : peers)
            heights.add((int)peer.getBestHeight());
        return Utils.maxOfMostFreq(heights);
    )

    ;;;
     ; Given a list of Peers, return a Peer to be used as the download peer.  If you don't want PeerGroup to manage
     ; download peer statuses for you, just override this and always return null.
     ;;
#_nilable
#_protected
    Peer selectDownloadPeer(List<Peer> peers)
    (§
        ;; Characteristics to select for in order of importance:
        ;;  - Chain height is reasonable (majority of nodes).
        ;;  - High enough protocol version for the features we want (but we'll settle for less).
        ;;  - Randomly, to try and spread the load.
        if (peers.isEmpty())
            return nil;

        ;; Make sure we don't select a peer that is behind/synchronizing itself.
        int mostCommonChainHeight = getMostCommonChainHeight(peers);
        List<Peer> candidates = new ArrayList<>();
        for (Peer peer : peers)
            if (peer.getBestHeight() == mostCommonChainHeight)
                candidates.add(peer);

        ;; Of the candidates, find the peers that meet the minimum protocol version we want to target.  We could select
        ;; the highest version we've seen on the assumption that newer versions are always better but we don't want to
        ;; zap peers if they upgrade early.  If we can't find any peers that have our preferred protocol version or
        ;; better then we'll settle for the highest we found instead.
        int highestVersion = 0, preferredVersion = 0;

        ;; if/when PREFERRED_VERSION is not equal to vMinRequiredProtocolVersion, reenable the last test in PeerGroupTest.downloadPeerSelection
#_final
        int PREFERRED_VERSION = params.getProtocolVersionNum(NetworkParameters.ProtocolVersion.BLOOM_FILTER);
        for (Peer peer : candidates)
        (§
            highestVersion = Math.max(peer.getPeerVersionMessage().clientVersion, highestVersion);
            preferredVersion = Math.min(highestVersion, PREFERRED_VERSION);
        )
        ArrayList<Peer> candidates2 = new ArrayList<>(candidates.size());
        for (Peer peer : candidates)
        (§
            if (preferredVersion <= peer.getPeerVersionMessage().clientVersion)
                candidates2.add(peer);
        )
        int index = (int)(Math.random() * candidates2.size());
        return candidates2.get(index);
    )

    ;;;
     ; Returns the currently selected download peer.  Bear in mind that it may have changed as soon as this method
     ; returns.  Can return null if no peer was selected.
     ;;
#_public
    Peer getDownloadPeer()
    (§
        lock.lock();
        try
        (§
            return downloadPeer;
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Returns the maximum number of {@link Peer}s to discover.  This maximum is checked after
     ; each {@link PeerDiscovery} so this max number can be surpassed.
     ; @return the maximum number of peers to discover.
     ;;
#_public
    int getMaxPeersToDiscoverCount()
    (§
        return vMaxPeersToDiscoverCount;
    )

    ;;;
     ; Sets the maximum number of {@link Peer}s to discover.  This maximum is checked after
     ; each {@link PeerDiscovery} so this max number can be surpassed.
     ; @param maxPeersToDiscoverCount the maximum number of peers to discover.
     ;;
#_public
    void setMaxPeersToDiscoverCount(int maxPeersToDiscoverCount)
    (§
        this.vMaxPeersToDiscoverCount = maxPeersToDiscoverCount;
    )

    ;;; See {@link #setUseLocalhostPeerWhenPossible(boolean)}. ;;
#_public
    boolean getUseLocalhostPeerWhenPossible()
    (§
        lock.lock();
        try
        (§
            return useLocalhostPeerWhenPossible;
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; When true (the default), PeerGroup will attempt to connect to a Bitcoin node running on localhost before
     ; attempting to use the P2P network.  If successful, only localhost will be used.  This makes for a simple
     ; and easy way for a user to upgrade a bitcoinj based app running in SPV mode to fully validating security.
     ;;
#_public
    void setUseLocalhostPeerWhenPossible(boolean useLocalhostPeerWhenPossible)
    (§
        lock.lock();
        try
        (§
            this.useLocalhostPeerWhenPossible = useLocalhostPeerWhenPossible;
        )
        finally
        (§
            lock.unlock();
        )
    )

#_public
    boolean isRunning()
    (§
        return vRunning;
    )

    ;;;
     ; Can be used to disable Bloom filtering entirely, even in SPV mode.  You are very unlikely to need this, it is
     ; an optimisation for rare cases when full validation is not required but it's still more efficient to download
     ; full blocks than filtered blocks.
     ;;
#_public
    void setBloomFilteringEnabled(boolean bloomFilteringEnabled)
    (§
        this.vBloomFilteringEnabled = bloomFilteringEnabled;
    )

    ;;; Returns whether the Bloom filtering protocol optimisation is in use: defaults to true. ;;
#_public
    boolean isBloomFilteringEnabled()
    (§
        return vBloomFilteringEnabled;
    )
)

(ns org.bitcoinj.core #_"PeerSocketHandler"
    (:import [java.io ByteArrayOutputStream IOException]
             [java.net ConnectException InetSocketAddress]
             [java.nio BufferUnderflowException ByteBuffer]
             [java.nio.channels NotYetConnectedException]
             [java.util.concurrent.locks Lock])
    (:import [com.google.common.annotations VisibleForTesting]
             [com.google.common.base Preconditions]
             [org.slf4j Logger LoggerFactory])
  #_(:require [org.bitcoinj.net AbstractTimeoutHandler MessageWriteTarget StreamConnection]
             [org.bitcoinj.utils Threading]))

;;;
 ; Handles high-level message (de)serialization for peers, acting as the bridge between the
 ; {@link org.bitcoinj.net} classes and {@link Peer}.
 ;;
#_public
#_abstract
class PeerSocketHandler extends AbstractTimeoutHandler implements StreamConnection
(§
#_private
#_static
#_final
    Logger log = LoggerFactory.getLogger(PeerSocketHandler.class);

#_private
#_final
    MessageSerializer serializer;
#_protected
    PeerAddress peerAddress;
    ;; If we close() before we know our writeTarget, set this to true to call writeTarget.closeConnection() right away.
#_private
    boolean closePending;
    ;; writeTarget will be thread-safe, and may call into PeerGroup, which calls us, so we should call it unlocked.
#_testing
#_protected
    MessageWriteTarget writeTarget;

    ;; The ByteBuffers passed to us from the writeTarget are static in size, and usually smaller than some messages we
    ;; will receive.  For SPV clients, this should be rare (i.e. we're mostly dealing with small transactions), but for
    ;; messages which are larger than the read buffer, we have to keep a temporary buffer with its bytes.
#_private
    byte[] largeReadBuffer;
#_private
    int largeReadBufferPos;
#_private
    BitcoinSerializer.BitcoinPacketHeader header;

#_private
    Lock lock = Threading.lock("PeerSocketHandler");

#_public
    PeerSocketHandler(NetworkParameters params, InetSocketAddress remoteIp)
    (§
        Preconditions.checkNotNull(params);
        serializer = params.getDefaultSerializer();
        this.peerAddress = new PeerAddress(params, remoteIp);
    )

#_public
    PeerSocketHandler(NetworkParameters params, PeerAddress peerAddress)
    (§
        Preconditions.checkNotNull(params);
        serializer = params.getDefaultSerializer();
        this.peerAddress = Preconditions.checkNotNull(peerAddress);
    )

    ;;;
     ; Sends the given message to the peer.  Due to the asynchronousness of network programming, there is no guarantee
     ; the peer will have received it.  Throws NotYetConnectedException if we are not yet connected to the remote peer.
     ; TODO: Maybe use something other than the unchecked NotYetConnectedException here.
     ;;
#_public
    void sendMessage(Message message)
        throws NotYetConnectedException
    (§
        lock.lock();
        try
        (§
            if (writeTarget == nil)
                throw new NotYetConnectedException();
        )
        finally
        (§
            lock.unlock();
        )
        ;; TODO: Some round-tripping could be avoided here.
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        try
        (§
            serializer.serialize(message, out);
            writeTarget.writeBytes(out.toByteArray());
        )
        catch (IOException e)
        (§
            exceptionCaught(e);
        )
    )

    ;;;
     ; Closes the connection to the peer if one exists, or immediately closes the connection as soon as it opens.
     ;;
#_public
    void close()
    (§
        lock.lock();
        try
        (§
            if (writeTarget == nil)
            (§
                closePending = true;
                return;
            )
        )
        finally
        (§
            lock.unlock();
        )
        writeTarget.closeConnection();
    )

#_override
#_protected
    void timeoutOccurred()
    (§
        log.info("{}: Timed out", getAddress());
        close();
    )

    ;;;
     ; Called every time a message is received from the network.
     ;;
#_protected
#_abstract
    void processMessage(Message m)
        throws Exception;

#_override
#_public
    int receiveBytes(ByteBuffer buff)
    (§
        Preconditions.checkArgument(buff.position() == 0 && BitcoinSerializer.BitcoinPacketHeader.HEADER_LENGTH + 4 <= buff.capacity());
        try
        (§
            ;; Repeatedly try to deserialize messages until we hit a BufferUnderflowException.
            boolean firstMessage = true;
            while (true)
            (§
                ;; If we are in the middle of reading a message, try to fill that one first, before we expect another.
                if (largeReadBuffer != nil)
                (§
                    ;; This can only happen in the first iteration.
                    Preconditions.checkState(firstMessage);
                    ;; Read new bytes into the largeReadBuffer.
                    int bytesToGet = Math.min(buff.remaining(), largeReadBuffer.length - largeReadBufferPos);
                    buff.get(largeReadBuffer, largeReadBufferPos, bytesToGet);
                    largeReadBufferPos += bytesToGet;
                    ;; Check the largeReadBuffer's status.
                    if (largeReadBufferPos == largeReadBuffer.length)
                    (§
                        ;; ...processing a message if one is available.
                        processMessage(serializer.deserializePayload(header, ByteBuffer.wrap(largeReadBuffer)));
                        largeReadBuffer = nil;
                        header = nil;
                        firstMessage = false;
                    )
                    else ;; ...or just returning if we don't have enough bytes yet.
                        return buff.position();
                )
                ;; Now try to deserialize any messages left in buff.
                Message message;
                int preSerializePosition = buff.position();
                try
                (§
                    message = serializer.deserialize(buff);
                )
                catch (BufferUnderflowException e)
                (§
                    ;; If we went through the whole buffer without a full message, we need to use the largeReadBuffer.
                    if (firstMessage && buff.limit() == buff.capacity())
                    (§
                        ;; ...so reposition the buffer to 0 and read the next message header.
                        buff.position(0);
                        try
                        (§
                            serializer.seekPastMagicBytes(buff);
                            header = serializer.deserializeHeader(buff);
                            ;; Initialize the largeReadBuffer with the next message's size and fill it with any bytes left in buff.
                            largeReadBuffer = new byte[header.size];
                            largeReadBufferPos = buff.remaining();
                            buff.get(largeReadBuffer, 0, largeReadBufferPos);
                        )
                        catch (BufferUnderflowException e1)
                        (§
                            ;; If we went through a whole buffer's worth of bytes without getting a header, give up.
                            ;; In cases where the buff is just really small, we could create a second largeReadBuffer
                            ;; that we use to deserialize the magic+header, but that is rather complicated when the buff
                            ;; should probably be at least that big anyway (for efficiency).
                            throw new ProtocolException("No magic bytes+header after reading " + buff.capacity() + " bytes");
                        )
                    )
                    else
                    (§
                        ;; Reposition the buffer to its original position, which saves us from skipping messages by
                        ;; seeking past part of the magic bytes before all of them are in the buffer.
                        buff.position(preSerializePosition);
                    )
                    return buff.position();
                )
                ;; Process our freshly deserialized message.
                processMessage(message);
                firstMessage = false;
            )
        )
        catch (Exception e)
        (§
            exceptionCaught(e);
            ;; Returning -1 also throws an IllegalStateException upstream and kills the connection.
            return -1;
        )
    )

    ;;;
     ; Sets the {@link MessageWriteTarget} used to write messages to the peer.  This should almost never be called,
     ; it is called automatically by {@link org.bitcoinj.net.NioClient} or
     ; {@link org.bitcoinj.net.NioClientManager} once the socket finishes initialization.
     ;;
#_override
#_public
    void setWriteTarget(MessageWriteTarget writeTarget)
    (§
        Preconditions.checkArgument(writeTarget != nil);

        lock.lock();
        boolean closeNow = false;
        try
        (§
            Preconditions.checkArgument(this.writeTarget == nil);

            closeNow = closePending;
            this.writeTarget = writeTarget;
        )
        finally
        (§
            lock.unlock();
        )
        if (closeNow)
            writeTarget.closeConnection();
    )

#_override
#_public
    int getMaxMessageSize()
    (§
        return Message.MAX_SIZE;
    )

    ;;;
     ; @return the IP address and port of peer.
     ;;
#_public
    PeerAddress getAddress()
    (§
        return peerAddress;
    )

    ;;; Catch any exceptions, logging them and then closing the channel. ;;
#_private
    void exceptionCaught(Exception e)
    (§
        PeerAddress addr = getAddress();
        String s = (addr == nil) ? "?" : addr.toString();
        if (e instanceof ConnectException || e instanceof IOException)
        (§
            ;; Short message for network errors
            log.info(s + " - " + e.getMessage());
        )
        else
        (§
            log.warn(s + " - ", e);
            Thread.UncaughtExceptionHandler handler = Threading.uncaughtExceptionHandler;
            if (handler != nil)
                handler.uncaughtException(Thread.currentThread(), e);
        )

        close();
    )
)

(ns org.bitcoinj.core #_"Ping"
    (:import [java.io IOException OutputStream]))

;;;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
class Ping extends Message
(§
#_private
    long nonce;
#_private
    boolean hasNonce;

#_public
    Ping(NetworkParameters params, byte[] payloadBytes)
        throws ProtocolException
    (§
        super(params, payloadBytes, 0);
    )

    ;;;
     ; Create a Ping with a nonce value.
     ; Only use this if the remote node has a protocol version > 60000.
     ;;
#_public
    Ping(long nonce)
    (§
        this.nonce = nonce;
        this.hasNonce = true;
    )

    ;;;
     ; Create a Ping without a nonce value.
     ; Only use this if the remote node has a protocol version <= 60000.
     ;;
#_public
    Ping()
    (§
        this.hasNonce = false;
    )

#_override
#_public
    void bitcoinSerializeToStream(OutputStream stream)
        throws IOException
    (§
        if (hasNonce)
            Utils.int64ToByteStreamLE(nonce, stream);
    )

#_override
#_protected
    void parse()
        throws ProtocolException
    (§
        try
        (§
            nonce = readInt64();
            hasNonce = true;
        )
        catch(ProtocolException e)
        (§
            hasNonce = false;
        )
        length = hasNonce ? 8 : 0;
    )

#_public
    boolean hasNonce()
    (§
        return hasNonce;
    )

#_public
    long getNonce()
    (§
        return nonce;
    )
)

(ns org.bitcoinj.core #_"Pong"
    (:import [java.io IOException OutputStream]))

;;;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
class Pong extends Message
(§
#_private
    long nonce;

#_public
    Pong(NetworkParameters params, byte[] payloadBytes)
        throws ProtocolException
    (§
        super(params, payloadBytes, 0);
    )

    ;;;
     ; Create a Pong with a nonce value.
     ; Only use this if the remote node has a protocol version > 60000.
     ;;
#_public
    Pong(long nonce)
    (§
        this.nonce = nonce;
    )

#_override
#_protected
    void parse()
        throws ProtocolException
    (§
        nonce = readInt64();
        length = 8;
    )

#_override
#_public
    void bitcoinSerializeToStream(OutputStream stream)
        throws IOException
    (§
        Utils.int64ToByteStreamLE(nonce, stream);
    )

    ;;; Returns the nonce sent by the remote peer. ;;
#_public
    long getNonce()
    (§
        return nonce;
    )
)

(ns org.bitcoinj.core #_"ProtocolException"
)

#_public
class ProtocolException extends VerificationException
(§
#_public
    ProtocolException(String msg)
    (§
        super(msg);
    )

#_public
    ProtocolException(Exception e)
    (§
        super(e);
    )

#_public
    ProtocolException(String msg, Exception e)
    (§
        super(msg, e);
    )
)

(ns org.bitcoinj.core #_"PrunedException"
)

;; TODO: Rename PrunedException to something like RequiredDataWasPrunedException.

;;;
 ; PrunedException is thrown in cases where a fully verifying node has deleted (pruned) old block data that turned
 ; out to be necessary for handling a re-org.  Normally this should never happen unless you're playing with the testnet
 ; as the pruning parameters should be set very conservatively, such that an absolutely enormous re-org would be
 ; required to trigger it.
 ;;
#_public
class PrunedException extends Exception
(§
#_private
    Sha256Hash hash;

#_public
    PrunedException(Sha256Hash hash)
    (§
        super(hash.toString());

        this.hash = hash;
    )

#_public
    Sha256Hash getHash()
    (§
        return hash;
    )
)

(ns org.bitcoinj.core #_"RejectMessage"
    (:import [java.io IOException OutputStream]
             [java.util Locale])
    (:import [com.google.common.base Objects]))

;;;
 ; <p>A message sent by nodes when a message we sent was rejected (i.e. a transaction had too little fee/was invalid/etc).</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
class RejectMessage extends Message
(§
#_private
    String message, reason;

#_public
    enum RejectCode
    (§
        ;;; The message was not able to be parsed. ;;
        MALFORMED((byte)0x01),
        ;;; The message described an invalid object. ;;
        INVALID((byte)0x10),
        ;;; The message was obsolete or described an object which is obsolete (e.g. unsupported, old version, v1 block). ;;
        OBSOLETE((byte)0x11),
        ;;;
         ; The message was relayed multiple times or described an object which is in conflict with another.
         ; This message can describe errors in protocol implementation or the presence of an attempt to DOUBLE SPEND.
         ;;
        DUPLICATE((byte)0x12),
        ;;;
         ; The message described an object was not standard and was thus not accepted.
         ; Bitcoin Core has a concept of standard transaction forms, which describe scripts and encodings which
         ; it is willing to relay further.  Other transactions are neither relayed nor mined, though they are considered
         ; valid if they appear in a block.
         ;;
        NONSTANDARD((byte)0x40),
        ;;;
         ; This refers to a specific form of NONSTANDARD transactions, which have an output smaller than some constant
         ; defining them as dust (this is no longer used).
         ;;
        DUST((byte)0x41),
        ;;; The messages described an object which did not have sufficient fee to be relayed further. ;;
        INSUFFICIENTFEE((byte)0x42),
        ;;; The message described a block which was invalid according to hard-coded checkpoint blocks. ;;
        CHECKPOINT((byte)0x43),
        OTHER((byte)0xff);

        byte code;

        RejectCode(byte code)
        (§
            this.code = code;
        )

#_static
        RejectCode fromCode(byte code)
        (§
            for (RejectCode rejectCode : RejectCode.values())
                if (rejectCode.code == code)
                    return rejectCode;

            return OTHER;
        )
    )

#_private
    RejectCode code;
#_private
    Sha256Hash messageHash;

#_public
    RejectMessage(NetworkParameters params, byte[] payload)
        throws ProtocolException
    (§
        super(params, payload, 0);
    )

    ;;; Constructs a reject message that fingers the object with the given hash as rejected for the given reason. ;;
#_public
    RejectMessage(NetworkParameters params, RejectCode code, Sha256Hash hash, String message, String reason)
        throws ProtocolException
    (§
        super(params);

        this.code = code;
        this.messageHash = hash;
        this.message = message;
        this.reason = reason;
    )

#_override
#_protected
    void parse()
        throws ProtocolException
    (§
        message = readStr();
        code = RejectCode.fromCode(readBytes(1)[0]);
        reason = readStr();
        if (message.equals("block") || message.equals("tx"))
            messageHash = readHash();
        length = cursor - offset;
    )

#_override
#_public
    void bitcoinSerializeToStream(OutputStream stream)
        throws IOException
    (§
        byte[] messageBytes = message.getBytes("UTF-8");
        stream.write(new VarInt(messageBytes.length).encode());
        stream.write(messageBytes);
        stream.write(code.code);
        byte[] reasonBytes = reason.getBytes("UTF-8");
        stream.write(new VarInt(reasonBytes.length).encode());
        stream.write(reasonBytes);
        if ("block".equals(message) || "tx".equals(message))
            stream.write(messageHash.getReversedBytes());
    )

    ;;;
     ; Provides the type of message which was rejected by the peer.
     ; Note that this is ENTIRELY UNTRUSTED and should be sanity-checked before it is printed or processed.
     ;;
#_public
    String getRejectedMessage()
    (§
        return message;
    )

    ;;;
     ; Provides the hash of the rejected object (if getRejectedMessage() is either "tx" or "block"), otherwise null.
     ;;
#_public
    Sha256Hash getRejectedObjectHash()
    (§
        return messageHash;
    )

    ;;;
     ; The reason code given for why the peer rejected the message.
     ;;
#_public
    RejectCode getReasonCode()
    (§
        return code;
    )

    ;;;
     ; The reason message given for rejection.
     ; Note that this is ENTIRELY UNTRUSTED and should be sanity-checked before it is printed or processed.
     ;;
#_public
    String getReasonString()
    (§
        return reason;
    )

    ;;;
     ; A String representation of the relevant details of this reject message.
     ; Be aware that the value returned by this method includes the value returned by
     ; {@link #getReasonString() getReasonString}, which is taken from the reject message unchecked.
     ; Through malice or otherwise, it might contain control characters or other harmful content.
     ;;
#_override
#_public
    String toString()
    (§
        Sha256Hash hash = getRejectedObjectHash();
        return String.format(Locale.US, "Reject: %s %s for reason '%s' (%d)", getRejectedMessage(), (hash != nil) ? hash : "", getReasonString(), getReasonCode().code);
    )

#_override
#_public
    boolean equals(Object o)
    (§
        if (this == o)
            return true;
        if (o == nil || getClass() != o.getClass())
            return false;
        RejectMessage other = (RejectMessage)o;
        return (message.equals(other.message) && code.equals(other.code) && reason.equals(other.reason) && messageHash.equals(other.messageHash));
    )

#_override
#_public
    int hashCode()
    (§
        return Objects.hashCode(message, code, reason, messageHash);
    )
)

(ns org.bitcoinj.core #_"RejectedTransactionException"
)

;;;
 ; This exception is used by the TransactionBroadcast class to indicate that a broadcast
 ; Transaction has been rejected by the network, for example because it violates a
 ; protocol rule.  Note that not all invalid transactions generate a reject message, and
 ; some peers may never do so.
 ;;
#_public
class RejectedTransactionException extends Exception
(§
#_private
    Transaction tx;
#_private
    RejectMessage rejectMessage;

#_public
    RejectedTransactionException(Transaction tx, RejectMessage rejectMessage)
    (§
        super(rejectMessage.toString());

        this.tx = tx;
        this.rejectMessage = rejectMessage;
    )

    ;;; Return the original Transaction object whose broadcast was rejected. ;;
#_public
    Transaction getTransaction() { return tx; }

    ;;; Return the RejectMessage object representing the broadcast rejection. ;;
#_public
    RejectMessage getRejectMessage() { return rejectMessage; }
)

(ns org.bitcoinj.core #_"ScriptException"
  #_(:require [org.bitcoinj.script ScriptError]))

#_public
class ScriptException extends VerificationException
(§
#_private
#_final
    ScriptError err;

#_public
    ScriptException(ScriptError err, String msg)
    (§
        super(msg);
        this.err = err;
    )

#_public
    ScriptException(ScriptError err, String msg, Exception e)
    (§
        super(msg, e);
        this.err = err;
    )

#_public
    ScriptError getError()
    (§
        return err;
    )
)

(ns org.bitcoinj.core #_"Sha256Hash"
    (:import [java.io File FileInputStream IOException Serializable]
             [java.math BigInteger]
             [java.security MessageDigest NoSuchAlgorithmException]
             [java.util Arrays])
    (:import [com.google.common.base Preconditions]
             [com.google.common.io ByteStreams]
             #_[com.google.common.primitives *]))

;;;
 ; A Sha256Hash just wraps a byte[] so that equals and hashcode work correctly,
 ; allowing it to be used as keys in a map.
 ; It also checks that the length is correct and provides a bit more type safety.
 ;;
#_public
class Sha256Hash implements Serializable, Comparable<Sha256Hash>
(§
#_public
#_static
#_final
    int LENGTH = 32; ;; bytes
#_public
#_static
#_final
    Sha256Hash ZERO_HASH = wrap(new byte[LENGTH]);

#_private
#_final
    byte[] bytes;

    ;;;
     ; Use {@link #wrap(byte[])} instead.
     ;;
#_protected
    Sha256Hash(byte[] rawHashBytes)
    (§
        Preconditions.checkArgument(rawHashBytes.length == LENGTH);
        this.bytes = rawHashBytes;
    )

    ;;;
     ; Creates a new instance that wraps the given hash value.
     ;
     ; @param rawHashBytes The raw hash bytes to wrap.
     ; @return a new instance.
     ; @throws IllegalArgumentException if the given array length is not exactly 32.
     ;;
#_public
#_static
    Sha256Hash wrap(byte[] rawHashBytes)
    (§
        return new Sha256Hash(rawHashBytes);
    )

    ;;;
     ; Creates a new instance that wraps the given hash value (represented as a hex string).
     ;
     ; @param hexString A hash value represented as a hex string.
     ; @return a new instance.
     ; @throws IllegalArgumentException if the given string is not a valid hex string, or if it does not represent exactly 32 bytes.
     ;;
#_public
#_static
    Sha256Hash wrap(String hexString)
    (§
        return wrap(Utils.HEX.decode(hexString));
    )

    ;;;
     ; Creates a new instance that wraps the given hash value, but with byte order reversed.
     ;
     ; @param rawHashBytes The raw hash bytes to wrap.
     ; @return a new instance.
     ; @throws IllegalArgumentException if the given array length is not exactly 32.
     ;;
#_public
#_static
    Sha256Hash wrapReversed(byte[] rawHashBytes)
    (§
        return wrap(Utils.reverseBytes(rawHashBytes));
    )

    ;;;
     ; Creates a new instance containing the calculated (one-time) hash of the given bytes.
     ;
     ; @param contents The bytes on which the hash value is calculated.
     ; @return a new instance containing the calculated (one-time) hash.
     ;;
#_public
#_static
    Sha256Hash of(byte[] contents)
    (§
        return wrap(hash(contents));
    )

    ;;;
     ; Creates a new instance containing the hash of the calculated hash of the given bytes.
     ;
     ; @param contents The bytes on which the hash value is calculated.
     ; @return a new instance containing the calculated (two-time) hash.
     ;;
#_public
#_static
    Sha256Hash twiceOf(byte[] contents)
    (§
        return wrap(hashTwice(contents));
    )

    ;;;
     ; Creates a new instance containing the calculated (one-time) hash of the given file's contents.
     ;
     ; The file contents are read fully into memory, so this method should only be used with small files.
     ;
     ; @param file The file on which the hash value is calculated.
     ; @return a new instance containing the calculated (one-time) hash.
     ; @throws IOException if an error occurs while reading the file.
     ;;
#_public
#_static
    Sha256Hash of(File file)
        throws IOException
    (§
        FileInputStream in = new FileInputStream(file);
        try
        (§
            return of(ByteStreams.toByteArray(in));
        )
        finally
        (§
            in.close();
        )
    )

    ;;;
     ; Returns a new SHA-256 MessageDigest instance.
     ;
     ; This is a convenience method which wraps the checked
     ; exception that can never occur with a RuntimeException.
     ;
     ; @return a new SHA-256 MessageDigest instance.
     ;;
#_public
#_static
    MessageDigest newDigest()
    (§
        try
        (§
            return MessageDigest.getInstance("SHA-256");
        )
        catch (NoSuchAlgorithmException e)
        (§
            throw new RuntimeException(e); ;; Can't happen.
        )
    )

    ;;;
     ; Calculates the SHA-256 hash of the given bytes.
     ;
     ; @param input The bytes to hash.
     ; @return the hash (in big-endian order).
     ;;
#_public
#_static
    byte[] hash(byte[] input)
    (§
        return hash(input, 0, input.length);
    )

    ;;;
     ; Calculates the SHA-256 hash of the given byte range.
     ;
     ; @param input The array containing the bytes to hash.
     ; @param offset The offset within the array of the bytes to hash.
     ; @param length The number of bytes to hash.
     ; @return the hash (in big-endian order).
     ;;
#_public
#_static
    byte[] hash(byte[] input, int offset, int length)
    (§
        MessageDigest digest = newDigest();
        digest.update(input, offset, length);
        return digest.digest();
    )

    ;;;
     ; Calculates the SHA-256 hash of the given bytes,
     ; and then hashes the resulting hash again.
     ;
     ; @param input The bytes to hash.
     ; @return the double-hash (in big-endian order).
     ;;
#_public
#_static
    byte[] hashTwice(byte[] input)
    (§
        return hashTwice(input, 0, input.length);
    )

    ;;;
     ; Calculates the SHA-256 hash of the given byte range,
     ; and then hashes the resulting hash again.
     ;
     ; @param input The array containing the bytes to hash.
     ; @param offset The offset within the array of the bytes to hash.
     ; @param length The number of bytes to hash.
     ; @return the double-hash (in big-endian order).
     ;;
#_public
#_static
    byte[] hashTwice(byte[] input, int offset, int length)
    (§
        MessageDigest digest = newDigest();
        digest.update(input, offset, length);
        return digest.digest(digest.digest());
    )

    ;;;
     ; Calculates the hash of hash on the given byte ranges.  This is equivalent to
     ; concatenating the two ranges and then passing the result to {@link #hashTwice(byte[])}.
     ;;
#_public
#_static
    byte[] hashTwice(byte[] input1, int offset1, int length1, byte[] input2, int offset2, int length2)
    (§
        MessageDigest digest = newDigest();
        digest.update(input1, offset1, length1);
        digest.update(input2, offset2, length2);
        return digest.digest(digest.digest());
    )

#_override
#_public
    boolean equals(Object o)
    (§
        if (this == o)
            return true;
        if (o == nil || getClass() != o.getClass())
            return false;
        return Arrays.equals(bytes, ((Sha256Hash)o).bytes);
    )

    ;;;
     ; Returns the last four bytes of the wrapped hash.  This should be unique enough to be a suitable hash code
     ; even for blocks, where the goal is to try and get the first bytes to be zeros (i.e. the value as a big integer
     ; lower than the target value).
     ;;
#_override
#_public
    int hashCode()
    (§
        ;; Use the last 4 bytes, not the first 4 which are often zeros in Bitcoin.
        return Ints.fromBytes(bytes[LENGTH - 4], bytes[LENGTH - 3], bytes[LENGTH - 2], bytes[LENGTH - 1]);
    )

#_override
#_public
    String toString()
    (§
        return Utils.HEX.encode(bytes);
    )

    ;;;
     ; Returns the bytes interpreted as a positive integer.
     ;;
#_public
    BigInteger toBigInteger()
    (§
        return new BigInteger(1, bytes);
    )

    ;;;
     ; Returns the internal byte array, without defensively copying.  Therefore do NOT modify the returned array.
     ;;
#_public
    byte[] getBytes()
    (§
        return bytes;
    )

    ;;;
     ; Returns a reversed copy of the internal byte array.
     ;;
#_public
    byte[] getReversedBytes()
    (§
        return Utils.reverseBytes(bytes);
    )

#_override
#_public
    int compareTo(final Sha256Hash other)
    (§
        for (int i = LENGTH - 1; 0 <= i; i--)
        (§
#_final
            int thisByte = this.bytes[i] & 0xff;
#_final
            int otherByte = other.bytes[i] & 0xff;
            if (thisByte > otherByte)
                return 1;
            if (thisByte < otherByte)
                return -1;
        )
        return 0;
    )
)

(ns org.bitcoinj.core #_"StoredBlock"
    (:import [java.math BigInteger]
             [java.nio ByteBuffer]
             [java.util Locale])
    (:import [com.google.common.base Objects Preconditions])
  #_(:require [org.bitcoinj.store BlockStore BlockStoreException]))

;;;
 ; Wraps a {@link Block} object with extra data that can be derived from the block chain but is slow or inconvenient
 ; to calculate.  By storing it alongside the block header we reduce the amount of work required significantly.
 ; Recalculation is slow because the fields are cumulative - to find the chainWork you have to iterate over every
 ; block in the chain back to the genesis block, which involves lots of seeking/loading etc.  So we just keep a
 ; running total: it's a disk space vs cpu/io tradeoff.
 ;
 ; StoredBlocks are put inside a {@link BlockStore} which saves them to memory or disk.
 ;;
#_public
class StoredBlock
(§
    ;; A BigInteger representing the total amount of work done so far on this chain.  As of May 2011 it takes
    ;; 8 bytes to represent this field, so 12 bytes should be plenty for now.
#_public
#_static
#_final
    int CHAIN_WORK_BYTES = 12;
#_public
#_static
#_final
    byte[] EMPTY_BYTES = new byte[CHAIN_WORK_BYTES];
#_public
#_static
#_final
    int COMPACT_SERIALIZED_SIZE = Block.HEADER_SIZE + CHAIN_WORK_BYTES + 4; ;; for height

#_private
    Block header;
#_private
    BigInteger chainWork;
#_private
    int height;

#_public
    StoredBlock(Block header, BigInteger chainWork, int height)
    (§
        this.header = header;
        this.chainWork = chainWork;
        this.height = height;
    )

    ;;;
     ; The block header this object wraps.  The referenced block object must not have any transactions in it.
     ;;
#_public
    Block getHeader()
    (§
        return header;
    )

    ;;;
     ; The total sum of work done in this block, and all the blocks below it in the chain.  Work is a measure of
     ; how many tries are needed to solve a block.  If the target is set to cover 10% of the total hash value space,
     ; then the work represented by a block is 10.
     ;;
#_public
    BigInteger getChainWork()
    (§
        return chainWork;
    )

    ;;;
     ; Position in the chain for this block.  The genesis block has a height of zero.
     ;;
#_public
    int getHeight()
    (§
        return height;
    )

    ;;; Returns true if this objects chainWork is higher than the others. ;;
#_public
    boolean moreWorkThan(StoredBlock other)
    (§
        return (0 < chainWork.compareTo(other.chainWork));
    )

#_override
#_public
    boolean equals(Object o)
    (§
        if (this == o)
            return true;
        if (o == nil || getClass() != o.getClass())
            return false;
        StoredBlock other = (StoredBlock)o;
        return (header.equals(other.header) && chainWork.equals(other.chainWork) && height == other.height);
    )

#_override
#_public
    int hashCode()
    (§
        return Objects.hashCode(header, chainWork, height);
    )

    ;;;
     ; Creates a new StoredBlock, calculating the additional fields by adding to the values in this block.
     ;;
#_public
    StoredBlock build(Block block)
        throws VerificationException
    (§
        ;; Stored blocks track total work done in this chain, because the canonical chain is the one that represents
        ;; the largest amount of work done not the tallest.
        BigInteger chainWork = this.chainWork.add(block.getWork());
        int height = this.height + 1;
        return new StoredBlock(block, chainWork, height);
    )

    ;;;
     ; Given a block store, looks up the previous block in this chain.  Convenience method for doing
     ; <tt>store.get(this.getHeader().getPrevBlockHash())</tt>.
     ;
     ; @return the previous block in the chain or null if it was not found in the store.
     ;;
#_public
    StoredBlock getPrev(BlockStore store)
        throws BlockStoreException
    (§
        return store.get(getHeader().getPrevBlockHash());
    )

    ;;; Serializes the stored block to a custom packed format.  Used by {@link CheckpointManager}. ;;
#_public
    void serializeCompact(ByteBuffer buffer)
    (§
        byte[] chainWorkBytes = getChainWork().toByteArray();
        Preconditions.checkState(chainWorkBytes.length <= CHAIN_WORK_BYTES, "Ran out of space to store chain work!");
        if (chainWorkBytes.length < CHAIN_WORK_BYTES)
        (§
            ;; Pad to the right size.
            buffer.put(EMPTY_BYTES, 0, CHAIN_WORK_BYTES - chainWorkBytes.length);
        )
        buffer.put(chainWorkBytes);
        buffer.putInt(getHeight());
        ;; Using unsafeBitcoinSerialize here can give us direct access to the same bytes we read off the wire,
        ;; avoiding serialization round-trips.
        byte[] bytes = getHeader().unsafeBitcoinSerialize();
        buffer.put(bytes, 0, Block.HEADER_SIZE); ;; Trim the trailing 00 byte (zero transactions).
    )

    ;;; De-serializes the stored block from a custom packed format.  Used by {@link CheckpointManager}. ;;
#_public
#_static
    StoredBlock deserializeCompact(NetworkParameters params, ByteBuffer buffer)
        throws ProtocolException
    (§
        byte[] chainWorkBytes = new byte[StoredBlock.CHAIN_WORK_BYTES];
        buffer.get(chainWorkBytes);
        BigInteger chainWork = new BigInteger(1, chainWorkBytes);
        int height = buffer.getInt(); ;; +4 bytes
        byte[] header = new byte[Block.HEADER_SIZE + 1]; ;; Extra byte for the 00 transactions length.
        buffer.get(header, 0, Block.HEADER_SIZE);
        return new StoredBlock(params.getDefaultSerializer().makeBlock(header), chainWork, height);
    )

#_override
#_public
    String toString()
    (§
        return String.format(Locale.US, "Block %s at height %d: %s", getHeader().getHashAsString(), getHeight(), getHeader().toString());
    )
)

(ns org.bitcoinj.core #_"StoredUndoableBlock"
    (:import [java.util List]))

;;;
 ; Contains minimal data neccessary to disconnect/connect the transactions
 ; in the stored block at will.  Can either store the full set of
 ; transactions (if the inputs for the block have not been tested to work)
 ; or the set of transaction outputs created/destroyed when the block is
 ; connected.
 ;;
#_public
class StoredUndoableBlock
(§
    Sha256Hash blockHash;

    ;; Only one of either txOutChanges or transactions will be set.
#_private
    TransactionOutputChanges txOutChanges;
#_private
    List<Transaction> transactions;

#_public
    StoredUndoableBlock(Sha256Hash hash, TransactionOutputChanges txOutChanges)
    (§
        this.blockHash = hash;
        this.transactions = nil;
        this.txOutChanges = txOutChanges;
    )

#_public
    StoredUndoableBlock(Sha256Hash hash, List<Transaction> transactions)
    (§
        this.blockHash = hash;
        this.txOutChanges = nil;
        this.transactions = transactions;
    )

    ;;;
     ; Get the transaction output changes if they have been calculated, otherwise null.
     ; Only one of this and getTransactions() will return a non-null value.
     ;;
#_public
    TransactionOutputChanges getTxOutChanges()
    (§
        return txOutChanges;
    )

    ;;;
     ; Get the full list of transactions if it is stored, otherwise null.
     ; Only one of this and getTxOutChanges() will return a non-null value.
     ;;
#_public
    List<Transaction> getTransactions()
    (§
        return transactions;
    )

    ;;;
     ; Get the hash of the represented block.
     ;;
#_public
    Sha256Hash getHash()
    (§
        return blockHash;
    )

#_override
#_public
    int hashCode()
    (§
        return blockHash.hashCode();
    )

#_override
#_public
    boolean equals(Object o)
    (§
        if (this == o)
            return true;
        if (o == nil || getClass() != o.getClass())
            return false;
        return getHash().equals(((StoredUndoableBlock)o).getHash());
    )

#_override
#_public
    String toString()
    (§
        return "Undoable Block " + blockHash;
    )
)

(ns org.bitcoinj.core #_"Transaction"
    (:import #_[java.io *]
             [java.math BigInteger]
             #_[java.util *])
    (:import [com.google.common.base Preconditions Strings]
             [com.google.common.collect ImmutableMap]
             [com.google.common.primitives Ints Longs]
             [org.slf4j Logger LoggerFactory]
             [org.spongycastle.crypto.params KeyParameter])
  #_(:require [org.bitcoinj.core.TransactionConfidence ConfidenceType]
             #_static #_[org.bitcoinj.core.Utils *]
             [org.bitcoinj.crypto TransactionSignature]
             [org.bitcoinj.script Script ScriptBuilder ScriptError ScriptOpCodes]
             [org.bitcoinj.signers TransactionSigner]
             [org.bitcoinj.utils ExchangeRate]
             [org.bitcoinj.wallet Wallet]
             [org.bitcoinj.wallet.WalletTransaction Pool]))

;;;
 ; <p>A transaction represents the movement of coins from some addresses to some other addresses.  It can also represent
 ; the minting of new coins.  A Transaction object corresponds to the equivalent in the Bitcoin C++ implementation.</p>
 ;
 ; <p>Transactions are the fundamental atoms of Bitcoin and have many powerful features.  Read
 ; <a href="https://bitcoinj.github.io/working-with-transactions">"Working with transactions"</a> in the
 ; documentation to learn more about how to use this class.</p>
 ;
 ; <p>All Bitcoin transactions are at risk of being reversed, though the risk is much less than with traditional payment
 ; systems.  Transactions have <i>confidence levels</i>, which help you decide whether to trust a transaction or not.
 ; Whether to trust a transaction is something that needs to be decided on a case by case basis - a rule that makes
 ; sense for selling MP3s might not make sense for selling cars, or accepting payments from a family member.  If you
 ; are building a wallet, how to present confidence to your users is something to consider carefully.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
class Transaction extends ChildMessage
(§
    ;;;
     ; A comparator that can be used to sort transactions by their updateTime field.
     ; The ordering goes from most recent into the past.
     ;;
#_public
#_static
#_final
    Comparator<Transaction> SORT_TX_BY_UPDATE_TIME = new Comparator<Transaction>()
    (§
#_override
#_public
        int compare(final Transaction tx1, final Transaction tx2)
        (§
#_final
            long time1 = tx1.getUpdateTime().getTime();
#_final
            long time2 = tx2.getUpdateTime().getTime();
#_final
            int updateTimeComparison = -Longs.compare(time1, time2);
            ;; If time1 == time2, compare by tx hash to make comparator consistent with equals.
            return (updateTimeComparison != 0) ? updateTimeComparison : tx1.getHash().compareTo(tx2.getHash());
        )
    );

    ;;; A comparator that can be used to sort transactions by their chain height. ;;
#_public
#_static
#_final
    Comparator<Transaction> SORT_TX_BY_HEIGHT = new Comparator<Transaction>()
    (§
#_override
#_public
        int compare(final Transaction tx1, final Transaction tx2)
        (§
#_final
            TransactionConfidence confidence1 = tx1.getConfidence();
#_final
            int height1 = (confidence1.getConfidenceType() == ConfidenceType.BUILDING) ? confidence1.getAppearedAtChainHeight() : Block.BLOCK_HEIGHT_UNKNOWN;
#_final
            TransactionConfidence confidence2 = tx2.getConfidence();
#_final
            int height2 = (confidence2.getConfidenceType() == ConfidenceType.BUILDING) ? confidence2.getAppearedAtChainHeight() : Block.BLOCK_HEIGHT_UNKNOWN;
#_final
            int heightComparison = -Ints.compare(height1, height2);
            ;; If height1 == height2, compare by tx hash to make comparator consistent with equals.
            return (heightComparison != 0) ? heightComparison : tx1.getHash().compareTo(tx2.getHash());
        )
    );

#_private
#_static
#_final
    Logger log = LoggerFactory.getLogger(Transaction.class);

    ;;; Threshold for lockTime: below this value it is interpreted as block number, otherwise as timestamp. ;;
#_public
#_static
#_final
    int LOCKTIME_THRESHOLD = 500000000; ;; Tue Nov  5 00:53:20 1985 UTC
    ;;; Same, but as a BigInteger for CHECKLOCKTIMEVERIFY. ;;
#_public
#_static
#_final
    BigInteger LOCKTIME_THRESHOLD_BIG = BigInteger.valueOf(LOCKTIME_THRESHOLD);

    ;;; How many bytes a transaction can be before it won't be relayed anymore.  Currently 100kb. ;;
#_public
#_static
#_final
    int MAX_STANDARD_TX_SIZE = 100000;

    ;;;
     ; If feePerKb is lower than this, Bitcoin Core will treat it as if there were no fee.
     ;;
#_public
#_static
#_final
    Coin REFERENCE_DEFAULT_MIN_TX_FEE = Coin.valueOf(5000); ;; 0.05 mBTC

    ;;;
     ; If using this feePerKb, transactions will get confirmed within the next couple of blocks.
     ; This should be adjusted from time to time.  Last adjustment: February 2017.
     ;;
#_public
#_static
#_final
    Coin DEFAULT_TX_FEE = Coin.valueOf(100000); ;; 1 mBTC

    ;;;
     ; Any standard (i.e. pay-to-address) output smaller than this value (in satoshis) will most likely be rejected by the network.
     ; This is calculated by assuming a standard output will be 34 bytes, and then using the formula used in
     ; {@link TransactionOutput#getMinNonDustValue(Coin)}.
     ;;
#_public
#_static
#_final
    Coin MIN_NONDUST_OUTPUT = Coin.valueOf(2730); ;; satoshis

    ;; These are bitcoin serialized.
#_private
    long version;
#_private
    ArrayList<TransactionInput> inputs;
#_private
    ArrayList<TransactionOutput> outputs;

#_private
    long lockTime;

    ;; This is either the time the transaction was broadcast as measured from the local clock, or the time from the
    ;; block in which it was included.  Note that this can be changed by re-orgs so the wallet may update this field.
    ;; Old serialized transactions don't have this field, thus null is valid.  It is used for returning an ordered
    ;; list of transactions from a wallet, which is helpful for presenting to users.
#_private
    Date updatedAt;

    ;; This is an in memory helper only.
#_private
    Sha256Hash hash;

    ;; Data about how confirmed this tx is.  Serialized, may be null.
#_nilable
#_private
    TransactionConfidence confidence;

    ;; Records a map of which blocks the transaction has appeared in (keys) to an index within that block (values).
    ;; The "index" is not a real index, instead the values are only meaningful relative to each other.  For example,
    ;; consider two transactions that appear in the same block, t1 and t2, where t2 spends an output of t1.  Both
    ;; will have the same block hash as a key in their appearsInHashes, but the counter would be 1 and 2 respectively
    ;; regardless of where they actually appeared in the block.
    ;;
    ;; If this transaction is not stored in the wallet, appearsInHashes is null.
#_private
    Map<Sha256Hash, Integer> appearsInHashes;

    ;; Transactions can be encoded in a way that will use more bytes than is optimal
    ;; (due to VarInts having multiple encodings).
    ;; MAX_BLOCK_SIZE must be compared to the optimal encoding, not the actual encoding, so when parsing, we keep track
    ;; of the size of the ideal encoding in addition to the actual message size (which Message needs) so that Blocks
    ;; can properly keep track of optimal encoded size.
#_private
    int optimalEncodingMessageSize;

    ;;;
     ; This enum describes the underlying reason the transaction was created.  It's useful for rendering wallet GUIs
     ; more appropriately.
     ;;
#_public
    enum Purpose
    (§
        ;;; Used when the purpose of a transaction is genuinely unknown. ;;
        UNKNOWN,
        ;;; Transaction created to satisfy a user payment request. ;;
        USER_PAYMENT,
        ;;; Transaction automatically created and broadcast in order to reallocate money from old to new keys. ;;
        KEY_ROTATION,
        ;;; Transaction that uses up pledges to an assurance contract. ;;
        ASSURANCE_CONTRACT_CLAIM,
        ;;; Transaction that makes a pledge to an assurance contract. ;;
        ASSURANCE_CONTRACT_PLEDGE,
        ;;; Send-to-self transaction that exists just to create an output of the right size we can pledge. ;;
        ASSURANCE_CONTRACT_STUB,
        ;;; Raise fee, e.g. child-pays-for-parent. ;;
        RAISE_FEE
        ;; In future: de/refragmentation, privacy boosting/mixing, etc.
        ;; When adding a value, it also needs to be added to wallet.proto, WalletProtobufSerialize.makeTxProto()
        ;; and WalletProtobufSerializer.readTransaction()!
    )

#_private
    Purpose purpose = Purpose.UNKNOWN;

    ;;;
     ; This field can be used by applications to record the exchange rate that was valid when the transaction happened.
     ; It's optional.
     ;;
#_nilable
#_private
    ExchangeRate exchangeRate;

    ;;;
     ; This field can be used to record the memo of the payment request that initiated the transaction.
     ; It's optional.
     ;;
#_nilable
#_private
    String memo;

    ;; Below flags apply in the context of BIP 68.
     ; If this flag set, CTxIn::nSequence is NOT interpreted as a relative lock-time.
     ;;
#_public
#_static
#_final
    long SEQUENCE_LOCKTIME_DISABLE_FLAG = 1L << 31;

    ;; If CTxIn::nSequence encodes a relative lock-time and this flag
     ; is set, the relative lock-time has units of 512 seconds,
     ; otherwise it specifies blocks with a granularity of 1.
     ;;
#_public
#_static
#_final
    long SEQUENCE_LOCKTIME_TYPE_FLAG = 1L << 22;

    ;; If CTxIn::nSequence encodes a relative lock-time, this mask is
     ; applied to extract that lock-time from the sequence field.
     ;;
#_public
#_static
#_final
    long SEQUENCE_LOCKTIME_MASK = 0x0000ffff;

#_public
    Transaction(NetworkParameters params)
    (§
        super(params);

        version = 1;
        inputs = new ArrayList<>();
        outputs = new ArrayList<>();
        ;; We don't initialize appearsIn deliberately as it's only useful for transactions stored in the wallet.
        length = 8; ;; 8 for std fields
    )

    ;;;
     ; Creates a transaction from the given serialized bytes, e.g. from a block or a tx network message.
     ;;
#_public
    Transaction(NetworkParameters params, byte[] payloadBytes)
        throws ProtocolException
    (§
        super(params, payloadBytes, 0);
    )

    ;;;
     ; Creates a transaction by reading payload starting from offset bytes in.  Length of a transaction is fixed.
     ;;
#_public
    Transaction(NetworkParameters params, byte[] payload, int offset)
        throws ProtocolException
    (§
        super(params, payload, offset);
        ;; inputs/outputs will be created in parse()
    )

    ;;;
     ; Creates a transaction by reading payload starting from offset bytes in.  Length of a transaction is fixed.
     ; @param params NetworkParameters object.
     ; @param payload Bitcoin protocol formatted byte array containing message content.
     ; @param offset The location of the first payload byte within the array.
     ; @param parseRetain Whether to retain the backing byte array for quick reserialization.
     ; If true and the backing byte array is invalidated due to modification of a field, then
     ; the cached bytes may be repopulated and retained if the message is serialized again in the future.
     ; @param length The length of message if known.  Usually this is provided when deserializing of the wire
     ; as the length will be provided as part of the header.  Set to Message.UNKNOWN_LENGTH, if not known.
     ; @throws ProtocolException
     ;;
#_public
    Transaction(NetworkParameters params, byte[] payload, int offset, #_nilable Message parent, MessageSerializer setSerializer, int length)
        throws ProtocolException
    (§
        super(params, payload, offset, parent, setSerializer, length);
    )

    ;;;
     ; Creates a transaction by reading payload.  Length of a transaction is fixed.
     ;;
#_public
    Transaction(NetworkParameters params, byte[] payload, #_nilable Message parent, MessageSerializer setSerializer, int length)
        throws ProtocolException
    (§
        super(params, payload, 0, parent, setSerializer, length);
    )

    ;;;
     ; Returns the transaction hash as you see them in the block explorer.
     ;;
#_override
#_public
    Sha256Hash getHash()
    (§
        if (hash == nil)
            hash = Sha256Hash.wrapReversed(Sha256Hash.hashTwice(unsafeBitcoinSerialize()));
        return hash;
    )

    ;;;
     ; Used by BitcoinSerializer.  The serializer has to calculate a hash for checksumming so to
     ; avoid wasting the considerable effort a set method is provided so the serializer can set it.
     ;
     ; No verification is performed on this hash.
     ;;
    void setHash(Sha256Hash hash)
    (§
        this.hash = hash;
    )

#_public
    String getHashAsString()
    (§
        return getHash().toString();
    )

    ;;;
     ; Gets the sum of the inputs, regardless of who owns them.
     ;;
#_public
    Coin getInputSum()
    (§
        Coin inputTotal = Coin.ZERO;

        for (TransactionInput input: inputs)
        (§
            Coin inputValue = input.getValue();
            if (inputValue != nil)
                inputTotal = inputTotal.add(inputValue);
        )

        return inputTotal;
    )

    ;;;
     ; Calculates the sum of the outputs that are sending coins to a key in the wallet.
     ;;
#_public
    Coin getValueSentToMe(TransactionBag transactionBag)
    (§
        ;; This is tested in WalletTest.
        Coin v = Coin.ZERO;
        for (TransactionOutput o : outputs)
            if (o.isMine(transactionBag))
                v = v.add(o.getValue());
        return v;
    )

    ;;;
     ; Returns a map of block [hashes] which contain the transaction mapped to relativity counters, or null if this
     ; transaction doesn't have that data because it's not stored in the wallet or because it has never appeared in a
     ; block.
     ;;
#_nilable
#_public
    Map<Sha256Hash, Integer> getAppearsInHashes()
    (§
        return (appearsInHashes != nil) ? ImmutableMap.copyOf(appearsInHashes) : nil;
    )

    ;;;
     ; Convenience wrapper around getConfidence().getConfidenceType().
     ; @return true if this transaction hasn't been seen in any block yet.
     ;;
#_public
    boolean isPending()
    (§
        return (getConfidence().getConfidenceType() == TransactionConfidence.ConfidenceType.PENDING);
    )

    ;;;
     ; <p>Puts the given block in the internal set of blocks in which this transaction appears.  This is
     ; used by the wallet to ensure transactions that appear on side chains are recorded properly even though
     ; the block stores do not save the transaction data at all.</p>
     ;
     ; <p>If there is a re-org this will be called once for each block that was previously seen, to update which block
     ; is the best chain.  The best chain block is guaranteed to be called last. So this must be idempotent.</p>
     ;
     ; <p>Sets updatedAt to be the earliest valid block time where this tx was seen.</p>
     ;
     ; @param block     The {@link StoredBlock} in which the transaction has appeared.
     ; @param bestChain Whether to set the updatedAt timestamp from the block header (only if not already set).
     ; @param relativityOffset A number that disambiguates the order of transactions within a block.
     ;;
#_public
    void setBlockAppearance(StoredBlock block, boolean bestChain, int relativityOffset)
    (§
        long blockTime = block.getHeader().getTimeSeconds() * 1000;
        if (bestChain && (updatedAt == nil || updatedAt.getTime() == 0 || blockTime < updatedAt.getTime()))
            updatedAt = new Date(blockTime);

        addBlockAppearance(block.getHeader().getHash(), relativityOffset);

        if (bestChain)
        (§
            TransactionConfidence transactionConfidence = getConfidence();
            ;; This sets type to BUILDING and depth to one.
            transactionConfidence.setAppearedAtChainHeight(block.getHeight());
        )
    )

#_public
    void addBlockAppearance(final Sha256Hash blockHash, int relativityOffset)
    (§
        ;; TODO: This could be a lot more memory efficient as we'll typically only store one element.
        if (appearsInHashes == nil)
            appearsInHashes = new TreeMap<>();

        appearsInHashes.put(blockHash, relativityOffset);
    )

    ;;;
     ; Calculates the sum of the inputs that are spending coins with keys in the wallet.  This requires the
     ; transactions sending coins to those keys to be in the wallet.  This method will not attempt to download
     ; the blocks containing the input transactions if the key is in the wallet but the transactions are not.
     ;
     ; @return sum of the inputs that are spending coins with keys in the wallet.
     ;;
#_public
    Coin getValueSentFromMe(TransactionBag wallet)
        throws ScriptException
    (§
        ;; This is tested in WalletTest.
        Coin v = Coin.ZERO;
        for (TransactionInput input : inputs)
        (§
            ;; This input is taking value from a transaction in our wallet.  To discover the value,
            ;; we must find the connected transaction.
            TransactionOutput connected = input.getConnectedOutput(wallet.getTransactionPool(Pool.UNSPENT));
            if (connected == nil)
                connected = input.getConnectedOutput(wallet.getTransactionPool(Pool.SPENT));
            if (connected == nil)
                connected = input.getConnectedOutput(wallet.getTransactionPool(Pool.PENDING));

            ;; The connected output may be the change to the sender of a previous input sent to this wallet.
            ;; In this case we ignore it.
            if (connected != nil && connected.isMine(wallet))
                v = v.add(connected.getValue());
        )
        return v;
    )

    ;;;
     ; Gets the sum of the outputs of the transaction.  If the outputs are less than the inputs, it does not count the fee.
     ; @return the sum of the outputs regardless of who owns them.
     ;;
#_public
    Coin getOutputSum()
    (§
        Coin totalOut = Coin.ZERO;

        for (TransactionOutput output: outputs)
            totalOut = totalOut.add(output.getValue());

        return totalOut;
    )

#_nilable
#_private
    Coin cachedValue;
#_nilable
#_private
    TransactionBag cachedForBag;

    ;;;
     ; Returns the difference of {@link Transaction#getValueSentToMe(TransactionBag)} and {@link Transaction#getValueSentFromMe(TransactionBag)}.
     ;;
#_public
    Coin getValue(TransactionBag wallet)
        throws ScriptException
    (§
        ;; FIXME: TEMP PERF HACK FOR ANDROID - this crap can go away once we have a real payments API.
        boolean isAndroid = Utils.isAndroidRuntime();
        if (isAndroid && cachedValue != nil && cachedForBag == wallet)
            return cachedValue;

        Coin result = getValueSentToMe(wallet).subtract(getValueSentFromMe(wallet));
        if (isAndroid)
        (§
            cachedValue = result;
            cachedForBag = wallet;
        )
        return result;
    )

    ;;;
     ; The transaction fee is the difference of the value of all inputs and the value of all outputs.
     ; Currently, the fee can only be determined for transactions created by us.
     ;
     ; @return fee, or null if it cannot be determined.
     ;;
#_public
    Coin getFee()
    (§
        Coin fee = Coin.ZERO;
        if (inputs.isEmpty() || outputs.isEmpty()) ;; Incomplete transaction.
            return nil;

        for (TransactionInput input : inputs)
        (§
            if (input.getValue() == nil)
                return nil;
            fee = fee.add(input.getValue());
        )
        for (TransactionOutput output : outputs)
        (§
            fee = fee.subtract(output.getValue());
        )
        return fee;
    )

    ;;;
     ; Returns true if any of the outputs is marked as spent.
     ;;
#_public
    boolean isAnyOutputSpent()
    (§
        for (TransactionOutput output : outputs)
            if (!output.isAvailableForSpending())
                return true;

        return false;
    )

    ;;;
     ; Returns false if this transaction has at least one output that is owned by the given wallet and unspent,
     ; true otherwise.
     ;;
#_public
    boolean isEveryOwnedOutputSpent(TransactionBag transactionBag)
    (§
        for (TransactionOutput output : outputs)
            if (output.isAvailableForSpending() && output.isMine(transactionBag))
                return false;

        return true;
    )

    ;;;
     ; Returns the earliest time at which the transaction was seen (broadcast or included into the chain),
     ; or the epoch if that information isn't available.
     ;;
#_public
    Date getUpdateTime()
    (§
        ;; Older wallets did not store this field.  Set to the epoch.
        if (updatedAt == nil)
            updatedAt = new Date(0);
        return updatedAt;
    )

#_public
    void setUpdateTime(Date updatedAt)
    (§
        this.updatedAt = updatedAt;
    )

    ;;;
     ; These constants are a part of a scriptSig signature on the inputs.  They define the details of how a
     ; transaction can be redeemed, specifically, they control how the hash of the transaction is calculated.
     ;;
#_public
    enum SigHash
    (§
        ALL(1),
        NONE(2),
        SINGLE(3),
        ANYONECANPAY(0x80), ;; Caution: Using this type in isolation is non-standard.  Treated similar to ANYONECANPAY_ALL.
        ANYONECANPAY_ALL(0x81),
        ANYONECANPAY_NONE(0x82),
        ANYONECANPAY_SINGLE(0x83),
        UNSET(0); ;; Caution: Using this type in isolation is non-standard.  Treated similar to ALL.

#_public
#_final
        int value;

        ;;;
         ; @param value
         ;;
#_private
        SigHash(final int value)
        (§
            this.value = value;
        )

        ;;;
         ; @return the value as a byte.
         ;;
#_public
        byte byteValue()
        (§
            return (byte)this.value;
        )
    )

#_override
#_protected
    void unCache()
    (§
        super.unCache();
        hash = nil;
    )

#_protected
#_static
    int calcLength(byte[] buf, int offset)
    (§
        ;; jump past version (uint32)
        int cursor = offset + 4;

        VarInt varint = new VarInt(buf, cursor);
        long txInCount = varint.value;
        cursor += varint.getOriginalSizeInBytes();

        for (int i = 0; i < txInCount; i++)
        (§
            ;; 36 = length of previous_outpoint
            cursor += 36;
            varint = new VarInt(buf, cursor);
            long scriptLen = varint.value;
            ;; 4 = length of sequence field (unint32)
            cursor += scriptLen + 4 + varint.getOriginalSizeInBytes();
        )

        varint = new VarInt(buf, cursor);
        long txOutCount = varint.value;
        cursor += varint.getOriginalSizeInBytes();

        for (int i = 0; i < txOutCount; i++)
        (§
            ;; 8 = length of tx value field (uint64)
            cursor += 8;
            varint = new VarInt(buf, cursor);
            long scriptLen = varint.value;
            cursor += scriptLen + varint.getOriginalSizeInBytes();
        )
        ;; 4 = length of lock_time field (uint32)
        return cursor - offset + 4;
    )

#_override
#_protected
    void parse()
        throws ProtocolException
    (§
        cursor = offset;

        version = readUint32();
        optimalEncodingMessageSize = 4;

        ;; First come the inputs.
        long numInputs = readVarInt();
        optimalEncodingMessageSize += VarInt.sizeOf(numInputs);
        inputs = new ArrayList<>((int)numInputs);
        for (long i = 0; i < numInputs; i++)
        (§
            TransactionInput input = new TransactionInput(params, this, payload, cursor, serializer);
            inputs.add(input);
            long scriptLen = readVarInt(TransactionOutPoint.MESSAGE_LENGTH);
            optimalEncodingMessageSize += TransactionOutPoint.MESSAGE_LENGTH + VarInt.sizeOf(scriptLen) + scriptLen + 4;
            cursor += scriptLen + 4;
        )
        ;; Now the outputs.
        long numOutputs = readVarInt();
        optimalEncodingMessageSize += VarInt.sizeOf(numOutputs);
        outputs = new ArrayList<>((int)numOutputs);
        for (long i = 0; i < numOutputs; i++)
        (§
            TransactionOutput output = new TransactionOutput(params, this, payload, cursor, serializer);
            outputs.add(output);
            long scriptLen = readVarInt(8);
            optimalEncodingMessageSize += 8 + VarInt.sizeOf(scriptLen) + scriptLen;
            cursor += scriptLen;
        )
        lockTime = readUint32();
        optimalEncodingMessageSize += 4;
        length = cursor - offset;
    )

#_public
    int getOptimalEncodingMessageSize()
    (§
        if (optimalEncodingMessageSize != 0)
            return optimalEncodingMessageSize;

        optimalEncodingMessageSize = getMessageSize();
        return optimalEncodingMessageSize;
    )

    ;;;
     ; The priority (coin age) calculation doesn't use the regular message size, but rather one adjusted downwards
     ; for the number of inputs.  The goal is to incentivise cleaning up the UTXO set with free transactions, if one
     ; can do so.
     ;;
#_public
    int getMessageSizeForPriorityCalc()
    (§
        int size = getMessageSize();
        for (TransactionInput input : inputs)
        (§
            ;; 41: min size of an input
            ;; 110: enough to cover a compressed pubkey p2sh redemption (somewhat arbitrary)
            int benefit = 41 + Math.min(110, input.getScriptSig().getProgram().length);
            if (benefit < size)
                size -= benefit;
        )
        return size;
    )

    ;;;
     ; A coinbase transaction is one that creates a new coin.  They are the first transaction in each block and their
     ; value is determined by a formula that all implementations of Bitcoin share.  In 2011 the value of a coinbase
     ; transaction is 50 coins, but in future it will be less.  A coinbase transaction is defined not only by its
     ; position in a block but by the data in the inputs.
     ;;
#_public
    boolean isCoinBase()
    (§
        return (inputs.size() == 1 && inputs.get(0).isCoinBase());
    )

    ;;;
     ; A transaction is mature if it is either a building coinbase tx that is as deep or deeper than the required coinbase depth, or a non-coinbase tx.
     ;;
#_public
    boolean isMature()
    (§
        if (!isCoinBase())
            return true;

        if (getConfidence().getConfidenceType() != ConfidenceType.BUILDING)
            return false;

        return (params.getSpendableCoinbaseDepth() <= getConfidence().getDepthInBlocks());
    )

#_override
#_public
    String toString()
    (§
        return toString(nil);
    )

    ;;;
     ; A human readable version of the transaction useful for debugging.  The format is not guaranteed to be stable.
     ; @param chain If provided, will be used to estimate lock times (if set).  Can be null.
     ;;
#_public
    String toString(#_nilable AbstractBlockChain chain)
    (§
        StringBuilder sb = new StringBuilder();
        sb.append("  ").append(getHashAsString()).append('\n');
        if (updatedAt != nil)
            sb.append("  updated: ").append(Utils.dateTimeFormat(updatedAt)).append('\n');
        if (version != 1)
            sb.append("  version ").append(version).append('\n');
        if (isTimeLocked())
        (§
            sb.append("  time locked until ");
            if (lockTime < LOCKTIME_THRESHOLD)
            (§
                sb.append("block ").append(lockTime);
                if (chain != nil)
                    sb.append(" (estimated to be reached at ").append(Utils.dateTimeFormat(chain.estimateBlockTime((int)lockTime))).append(')');
            )
            else
            (§
                sb.append(Utils.dateTimeFormat(lockTime * 1000));
            )
            sb.append('\n');
        )
        if (isOptInFullRBF())
        (§
            sb.append("  opts into full replace-by-fee\n");
        )
        if (isCoinBase())
        (§
            String script;
            String script2;
            try
            (§
                script = inputs.get(0).getScriptSig().toString();
                script2 = outputs.get(0).getScriptPubKey().toString();
            )
            catch (ScriptException _)
            (§
                script = "???";
                script2 = "???";
            )
            sb.append("     == COINBASE TXN (scriptSig ").append(script).append(")  (scriptPubKey ").append(script2).append(")\n");
            return sb.toString();
        )

        if (!inputs.isEmpty())
        (§
            for (TransactionInput in : inputs)
            (§
                sb.append("     in   ");

                try
                (§
                    String scriptSigStr = in.getScriptSig().toString();
                    sb.append(!Strings.isNullOrEmpty(scriptSigStr) ? scriptSigStr : "<no scriptSig>");
#_final
                    Coin value = in.getValue();
                    if (value != nil)
                        sb.append(" ").append(value.toFriendlyString());
                    sb.append("\n          outpoint:");
#_final
                    TransactionOutPoint outpoint = in.getOutpoint();
                    sb.append(outpoint.toString());
#_final
                    TransactionOutput connectedOutput = outpoint.getConnectedOutput();
                    if (connectedOutput != nil)
                    (§
                        Script scriptPubKey = connectedOutput.getScriptPubKey();
                        if (scriptPubKey.isSentToAddress() || scriptPubKey.isPayToScriptHash())
                            sb.append(" hash160:").append(Utils.HEX.encode(scriptPubKey.getPubKeyHash()));
                    )
                    if (in.hasSequence())
                    (§
                        sb.append("\n          sequence:").append(Long.toHexString(in.getSequenceNumber()));
                        if (in.isOptInFullRBF())
                            sb.append(", opts into full RBF");
                    )
                )
                catch (Exception e)
                (§
                    sb.append("[exception: ").append(e.getMessage()).append("]");
                )
                sb.append('\n');
            )
        )
        else
        (§
            sb.append("     INCOMPLETE: No inputs!\n");
        )

        for (TransactionOutput out : outputs)
        (§
            sb.append("     out  ");
            try
            (§
                String scriptPubKeyStr = out.getScriptPubKey().toString();
                sb.append(!Strings.isNullOrEmpty(scriptPubKeyStr) ? scriptPubKeyStr : "<no scriptPubKey>").append(" ").append(out.getValue().toFriendlyString());
                if (!out.isAvailableForSpending())
                    sb.append(" Spent");
#_final
                TransactionInput spentBy = out.getSpentBy();
                if (spentBy != nil)
                    sb.append(" by ").append(spentBy.getParentTransaction().getHashAsString());
            )
            catch (Exception e)
            (§
                sb.append("[exception: ").append(e.getMessage()).append("]");
            )
            sb.append('\n');
        )

#_final
        Coin fee = getFee();
        if (fee != nil)
        (§
#_final
            int size = unsafeBitcoinSerialize().length;
            sb.append("     fee  ").append(fee.multiply(1000).divide(size).toFriendlyString()).append("/kB, ").append(fee.toFriendlyString()).append(" for ").append(size).append(" bytes\n");
        )
        if (purpose != nil)
            sb.append("     prps ").append(purpose).append('\n');
        return sb.toString();
    )

    ;;;
     ; Removes all the inputs from this transaction.
     ; Note that this also invalidates the length attribute.
     ;;
#_public
    void clearInputs()
    (§
        unCache();
        for (TransactionInput input : inputs)
            input.setParent(nil);
        inputs.clear();
        ;; You wanted to reserialize, right?
        this.length = this.unsafeBitcoinSerialize().length;
    )

    ;;;
     ; Adds an input to this transaction that imports value from the given output.  Note that this input is <i>not</i>
     ; complete and after every input is added with {@link #addInput()} and every output is added with {@link #addOutput()},
     ; a {@link TransactionSigner} must be used to finalize the transaction and finish the inputs off.
     ; Otherwise it won't be accepted by the network.
     ; @return the newly created input.
     ;;
#_public
    TransactionInput addInput(TransactionOutput from)
    (§
        return addInput(new TransactionInput(params, this, from));
    )

    ;;;
     ; Adds an input directly, with no checking that it's valid.
     ; @return the new input.
     ;;
#_public
    TransactionInput addInput(TransactionInput input)
    (§
        unCache();
        input.setParent(this);
        inputs.add(input);
        adjustLength(inputs.size(), input.length);
        return input;
    )

    ;;;
     ; Creates and adds an input to this transaction, with no checking that it's valid.
     ; @return the newly created input.
     ;;
#_public
    TransactionInput addInput(Sha256Hash spendTxHash, long outputIndex, Script script)
    (§
        return addInput(new TransactionInput(params, this, script.getProgram(), new TransactionOutPoint(params, outputIndex, spendTxHash)));
    )

    ;;;
     ; Adds a new and fully signed input for the given parameters.  Note that this method is <b>not</b> thread safe
     ; and requires external synchronization.  Please refer to general documentation on Bitcoin scripting and contracts
     ; to understand the values of sigHash and anyoneCanPay: otherwise you can use the other form of this method
     ; that sets them to typical defaults.
     ;
     ; @throws ScriptException if the scriptPubKey is not a pay to address or pay to pubkey script.
     ;;
#_public
    TransactionInput addSignedInput(TransactionOutPoint prevOut, Script scriptPubKey, ECKey sigKey, SigHash sigHash, boolean anyoneCanPay)
        throws ScriptException
    (§
        ;; Verify the API user didn't try to do operations out of order.
        Preconditions.checkState(!outputs.isEmpty(), "Attempting to sign tx without outputs.");

        TransactionInput input = new TransactionInput(params, this, new byte[] {}, prevOut);
        addInput(input);
        Sha256Hash hash = hashForSignature(inputs.size() - 1, scriptPubKey, sigHash, anyoneCanPay);
        ECKey.ECDSASignature ecSig = sigKey.sign(hash);
        TransactionSignature txSig = new TransactionSignature(ecSig, sigHash, anyoneCanPay);
        if (scriptPubKey.isSentToRawPubKey())
            input.setScriptSig(ScriptBuilder.createInputScript(txSig));
        else if (scriptPubKey.isSentToAddress())
            input.setScriptSig(ScriptBuilder.createInputScript(txSig, sigKey));
        else
            throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "Don't know how to sign for this kind of scriptPubKey: " + scriptPubKey);
        return input;
    )

    ;;;
     ; Same as {@link #addSignedInput(TransactionOutPoint, org.bitcoinj.script.Script, ECKey, org.bitcoinj.core.Transaction.SigHash, boolean)},
     ; but defaults to {@link SigHash#ALL} and "false" for the anyoneCanPay flag.  This is normally what you want.
     ;;
#_public
    TransactionInput addSignedInput(TransactionOutPoint prevOut, Script scriptPubKey, ECKey sigKey)
        throws ScriptException
    (§
        return addSignedInput(prevOut, scriptPubKey, sigKey, SigHash.ALL, false);
    )

    ;;;
     ; Adds an input that points to the given output and contains a valid signature for it, calculated using the
     ; signing key.
     ;;
#_public
    TransactionInput addSignedInput(TransactionOutput output, ECKey signingKey)
    (§
        return addSignedInput(output.getOutPointFor(), output.getScriptPubKey(), signingKey);
    )

    ;;;
     ; Adds an input that points to the given output and contains a valid signature for it, calculated using the
     ; signing key.
     ;;
#_public
    TransactionInput addSignedInput(TransactionOutput output, ECKey signingKey, SigHash sigHash, boolean anyoneCanPay)
    (§
        return addSignedInput(output.getOutPointFor(), output.getScriptPubKey(), signingKey, sigHash, anyoneCanPay);
    )

    ;;;
     ; Removes all the outputs from this transaction.
     ; Note that this also invalidates the length attribute.
     ;;
#_public
    void clearOutputs()
    (§
        unCache();
        for (TransactionOutput output : outputs)
            output.setParent(nil);
        outputs.clear();
        ;; You wanted to reserialize, right?
        this.length = this.unsafeBitcoinSerialize().length;
    )

    ;;;
     ; Adds the given output to this transaction.  The output must be completely initialized.  Returns the given output.
     ;;
#_public
    TransactionOutput addOutput(TransactionOutput to)
    (§
        unCache();
        to.setParent(this);
        outputs.add(to);
        adjustLength(outputs.size(), to.length);
        return to;
    )

    ;;;
     ; Creates an output based on the given address and value, adds it to this transaction, and returns the new output.
     ;;
#_public
    TransactionOutput addOutput(Coin value, Address address)
    (§
        return addOutput(new TransactionOutput(params, this, value, address));
    )

    ;;;
     ; Creates an output that pays to the given pubkey directly (no address) with the given value, adds it to this
     ; transaction, and returns the new output.
     ;;
#_public
    TransactionOutput addOutput(Coin value, ECKey pubkey)
    (§
        return addOutput(new TransactionOutput(params, this, value, pubkey));
    )

    ;;;
     ; Creates an output that pays to the given script.  The address and key forms are specialisations of this method,
     ; you won't normally need to use it unless you're doing unusual things.
     ;;
#_public
    TransactionOutput addOutput(Coin value, Script script)
    (§
        return addOutput(new TransactionOutput(params, this, value, script.getProgram()));
    )

    ;;;
     ; Calculates a signature that is valid for being inserted into the input at the given position.  This is simply
     ; a wrapper around calling {@link Transaction#hashForSignature(int, byte[], org.bitcoinj.core.Transaction.SigHash, boolean)}
     ; followed by {@link ECKey#sign(Sha256Hash)} and then returning a new {@link TransactionSignature}.  The key
     ; must be usable for signing as-is: if the key is encrypted it must be decrypted first external to this method.
     ;
     ; @param inputIndex Which input to calculate the signature for, as an index.
     ; @param key The private key used to calculate the signature.
     ; @param redeemScript Byte-exact contents of the scriptPubKey that is being satisified, or the P2SH redeem script.
     ; @param hashType Signing mode, see the enum for documentation.
     ; @param anyoneCanPay Signing mode, see the SigHash enum for documentation.
     ; @return A newly calculated signature object that wraps the r, s and sighash components.
     ;;
#_public
    TransactionSignature calculateSignature(int inputIndex, ECKey key, byte[] redeemScript, SigHash hashType, boolean anyoneCanPay)
    (§
        Sha256Hash hash = hashForSignature(inputIndex, redeemScript, hashType, anyoneCanPay);
        return new TransactionSignature(key.sign(hash), hashType, anyoneCanPay);
    )

    ;;;
     ; Calculates a signature that is valid for being inserted into the input at the given position.  This is simply
     ; a wrapper around calling {@link Transaction#hashForSignature(int, byte[], org.bitcoinj.core.Transaction.SigHash, boolean)}
     ; followed by {@link ECKey#sign(Sha256Hash)} and then returning a new {@link TransactionSignature}.
     ;
     ; @param inputIndex Which input to calculate the signature for, as an index.
     ; @param key The private key used to calculate the signature.
     ; @param redeemScript The scriptPubKey that is being satisified, or the P2SH redeem script.
     ; @param hashType Signing mode, see the enum for documentation.
     ; @param anyoneCanPay Signing mode, see the SigHash enum for documentation.
     ; @return A newly calculated signature object that wraps the r, s and sighash components.
     ;;
#_public
    TransactionSignature calculateSignature(int inputIndex, ECKey key, Script redeemScript, SigHash hashType, boolean anyoneCanPay)
    (§
        Sha256Hash hash = hashForSignature(inputIndex, redeemScript.getProgram(), hashType, anyoneCanPay);
        return new TransactionSignature(key.sign(hash), hashType, anyoneCanPay);
    )

    ;;;
     ; Calculates a signature that is valid for being inserted into the input at the given position.  This is simply
     ; a wrapper around calling {@link Transaction#hashForSignature(int, byte[], org.bitcoinj.core.Transaction.SigHash, boolean)}
     ; followed by {@link ECKey#sign(Sha256Hash)} and then returning a new {@link TransactionSignature}.  The key
     ; must be usable for signing as-is: if the key is encrypted it must be decrypted first external to this method.
     ;
     ; @param inputIndex Which input to calculate the signature for, as an index.
     ; @param key The private key used to calculate the signature.
     ; @param aesKey The AES key to use for decryption of the private key.  If null then no decryption is required.
     ; @param redeemScript Byte-exact contents of the scriptPubKey that is being satisified, or the P2SH redeem script.
     ; @param hashType Signing mode, see the enum for documentation.
     ; @param anyoneCanPay Signing mode, see the SigHash enum for documentation.
     ; @return A newly calculated signature object that wraps the r, s and sighash components.
     ;;
#_public
    TransactionSignature calculateSignature(int inputIndex, ECKey key, #_nilable KeyParameter aesKey, byte[] redeemScript, SigHash hashType, boolean anyoneCanPay)
    (§
        Sha256Hash hash = hashForSignature(inputIndex, redeemScript, hashType, anyoneCanPay);
        return new TransactionSignature(key.sign(hash, aesKey), hashType, anyoneCanPay);
    )

    ;;;
     ; Calculates a signature that is valid for being inserted into the input at the given position.  This is simply
     ; a wrapper around calling {@link Transaction#hashForSignature(int, byte[], org.bitcoinj.core.Transaction.SigHash, boolean)}
     ; followed by {@link ECKey#sign(Sha256Hash)} and then returning a new {@link TransactionSignature}.
     ;
     ; @param inputIndex Which input to calculate the signature for, as an index.
     ; @param key The private key used to calculate the signature.
     ; @param aesKey The AES key to use for decryption of the private key.  If null then no decryption is required.
     ; @param redeemScript The scriptPubKey that is being satisified, or the P2SH redeem script.
     ; @param hashType Signing mode, see the enum for documentation.
     ; @param anyoneCanPay Signing mode, see the SigHash enum for documentation.
     ; @return A newly calculated signature object that wraps the r, s and sighash components.
     ;;
#_public
    TransactionSignature calculateSignature(int inputIndex, ECKey key, #_nilable KeyParameter aesKey, Script redeemScript, SigHash hashType, boolean anyoneCanPay)
    (§
        Sha256Hash hash = hashForSignature(inputIndex, redeemScript.getProgram(), hashType, anyoneCanPay);
        return new TransactionSignature(key.sign(hash, aesKey), hashType, anyoneCanPay);
    )

    ;;;
     ; <p>Calculates a signature hash, that is, a hash of a simplified form of the transaction.  How exactly the transaction
     ; is simplified is specified by the type and anyoneCanPay parameters.</p>
     ;
     ; <p>This is a low level API and when using the regular {@link Wallet} class you don't have to call this yourself.
     ; When working with more complex transaction types and contracts, it can be necessary.  When signing a P2SH output
     ; the redeemScript should be the script encoded into the scriptSig field, for normal transactions, it's the
     ; scriptPubKey of the output you're signing for.</p>
     ;
     ; @param inputIndex Input the signature is being calculated for.  Tx signatures are always relative to an input.
     ; @param redeemScript The bytes that should be in the given input during signing.
     ; @param type Should be SigHash.ALL.
     ; @param anyoneCanPay Should be false.
     ;;
#_public
    Sha256Hash hashForSignature(int inputIndex, byte[] redeemScript, SigHash type, boolean anyoneCanPay)
    (§
        byte sigHashType = (byte)TransactionSignature.calcSigHashValue(type, anyoneCanPay);
        return hashForSignature(inputIndex, redeemScript, sigHashType);
    )

    ;;;
     ; <p>Calculates a signature hash, that is, a hash of a simplified form of the transaction.  How exactly the transaction
     ; is simplified is specified by the type and anyoneCanPay parameters.</p>
     ;
     ; <p>This is a low level API and when using the regular {@link Wallet} class you don't have to call this yourself.
     ; When working with more complex transaction types and contracts, it can be necessary.  When signing a P2SH output
     ; the redeemScript should be the script encoded into the scriptSig field, for normal transactions, it's the
     ; scriptPubKey of the output you're signing for.</p>
     ;
     ; @param inputIndex Input the signature is being calculated for.  Tx signatures are always relative to an input.
     ; @param redeemScript The script that should be in the given input during signing.
     ; @param type Should be SigHash.ALL.
     ; @param anyoneCanPay Should be false.
     ;;
#_public
    Sha256Hash hashForSignature(int inputIndex, Script redeemScript, SigHash type, boolean anyoneCanPay)
    (§
        int sigHash = TransactionSignature.calcSigHashValue(type, anyoneCanPay);
        return hashForSignature(inputIndex, redeemScript.getProgram(), (byte)sigHash);
    )

    ;;;
     ; This is required for signatures which use a sigHashType which cannot be represented using SigHash and anyoneCanPay.
     ; See transaction c99c49da4c38af669dea436d3e73780dfdb6c1ecf9958baa52960e8baee30e73, which has sigHashType 0.
     ;;
#_public
    Sha256Hash hashForSignature(int inputIndex, byte[] connectedScript, byte sigHashType)
    (§
        ;; The SIGHASH flags are used in the design of contracts, please see this page for a further understanding of
        ;; the purposes of the code in this method:
        ;;
        ;;   https://en.bitcoin.it/wiki/Contracts

        try
        (§
            ;; Create a copy of this transaction to operate upon because we need make changes to the inputs and outputs.
            ;; It would not be thread-safe to change the attributes of the transaction object itself.
            Transaction tx = this.params.getDefaultSerializer().makeTransaction(this.bitcoinSerialize());

            ;; Clear input scripts in preparation for signing.  If we're signing a fresh transaction that step isn't very
            ;; helpful, but it doesn't add much cost relative to the actual EC math so we'll do it anyway.
            for (int i = 0; i < tx.inputs.size(); i++)
                tx.inputs.get(i).clearScriptBytes();

            ;; This step has no purpose beyond being synchronized with Bitcoin Core's bugs.  OP_CODESEPARATOR
            ;; is a legacy holdover from a previous, broken design of executing scripts that shipped in Bitcoin 0.1.
            ;; It was seriously flawed and would have let anyone take anyone elses money.  Later versions switched to
            ;; the design we use today where scripts are executed independently but share a stack.  This left the
            ;; OP_CODESEPARATOR instruction having no purpose as it was only meant to be used internally, not actually
            ;; ever put into scripts.  Deleting OP_CODESEPARATOR is a step that should never be required but if we don't
            ;; do it, we could split off the main chain.
            connectedScript = Script.removeAllInstancesOfOp(connectedScript, ScriptOpCodes.OP_CODESEPARATOR);

            ;; Set the input to the script of its output.  Bitcoin Core does this but the step has no obvious purpose as
            ;; the signature covers the hash of the prevout transaction which obviously includes the output script
            ;; already.  Perhaps it felt safer to him in some way, or is another leftover from how the code was written.
            TransactionInput input = tx.inputs.get(inputIndex);
            input.setScriptBytes(connectedScript);

            if ((sigHashType & 0x1f) == SigHash.NONE.value)
            (§
                ;; SIGHASH_NONE means no outputs are signed at all - the signature is effectively for a "blank cheque".
                tx.outputs = new ArrayList<>(0);
                ;; The signature isn't broken by new versions of the transaction issued by other parties.
                for (int i = 0; i < tx.inputs.size(); i++)
                    if (i != inputIndex)
                        tx.inputs.get(i).setSequenceNumber(0);
            )
            else if ((sigHashType & 0x1f) == SigHash.SINGLE.value)
            (§
                ;; SIGHASH_SINGLE means only sign the output at the same index as the input (i.e. my output).
                if (tx.outputs.size() <= inputIndex)
                (§
                    ;; The input index is beyond the number of outputs, it's a buggy signature made by a broken
                    ;; Bitcoin implementation.  Bitcoin Core also contains a bug in handling this case:
                    ;; any transaction output that is signed in this case will result in both the signed output
                    ;; and any future outputs to this public key being steal-able by anyone who has
                    ;; the resulting signature and the public key (both of which are part of the signed tx input).

                    ;; Bitcoin Core's bug is that SignatureHash was supposed to return a hash and on this codepath it
                    ;; actually returns the constant "1" to indicate an error, which is never checked for.  Oops.
                    return Sha256Hash.wrap("0100000000000000000000000000000000000000000000000000000000000000");
                )
                ;; In SIGHASH_SINGLE the outputs after the matching input index are deleted, and the outputs before
                ;; that position are "nulled out".  Unintuitively, the value in a "null" transaction is set to -1.
                tx.outputs = new ArrayList<>(tx.outputs.subList(0, inputIndex + 1));
                for (int i = 0; i < inputIndex; i++)
                    tx.outputs.set(i, new TransactionOutput(tx.params, tx, Coin.NEGATIVE_SATOSHI, new byte[] {}));
                ;; The signature isn't broken by new versions of the transaction issued by other parties.
                for (int i = 0; i < tx.inputs.size(); i++)
                    if (i != inputIndex)
                        tx.inputs.get(i).setSequenceNumber(0);
            )

            if ((sigHashType & SigHash.ANYONECANPAY.value) == SigHash.ANYONECANPAY.value)
            (§
                ;; SIGHASH_ANYONECANPAY means the signature in the input is not broken by changes/additions/removals
                ;; of other inputs.  For example, this is useful for building assurance contracts.
                tx.inputs = new ArrayList<TransactionInput>();
                tx.inputs.add(input);
            )

            ByteArrayOutputStream bos = new UnsafeByteArrayOutputStream((tx.length == UNKNOWN_LENGTH) ? 256 : tx.length + 4);
            tx.bitcoinSerialize(bos);
            ;; We also have to write a hash type (sigHashType is actually an unsigned char).
            uint32ToByteStreamLE(0x000000ff & sigHashType, bos);
            ;; Note that this is NOT reversed to ensure it will be signed correctly.  If it were to be printed out
            ;; however then we would expect that it is IS reversed.
            Sha256Hash hash = Sha256Hash.twiceOf(bos.toByteArray());
            bos.close();

            return hash;
        )
        catch (IOException e)
        (§
            throw new RuntimeException(e); ;; Cannot happen.
        )
    )

#_override
#_protected
    void bitcoinSerializeToStream(OutputStream stream)
        throws IOException
    (§
        uint32ToByteStreamLE(version, stream);
        stream.write(new VarInt(inputs.size()).encode());
        for (TransactionInput in : inputs)
            in.bitcoinSerialize(stream);
        stream.write(new VarInt(outputs.size()).encode());
        for (TransactionOutput out : outputs)
            out.bitcoinSerialize(stream);
        uint32ToByteStreamLE(lockTime, stream);
    )

    ;;;
     ; Transactions can have an associated lock time, specified either as a block height or in seconds since the
     ; UNIX epoch.  A transaction is not allowed to be confirmed by miners until the lock time is reached, and
     ; since Bitcoin 0.8+ a transaction that did not end its lock period (non final) is considered to be non
     ; standard and won't be relayed or included in the memory pool either.
     ;;
#_public
    long getLockTime()
    (§
        return lockTime;
    )

    ;;;
     ; Transactions can have an associated lock time, specified either as a block height or in seconds since the
     ; UNIX epoch.  A transaction is not allowed to be confirmed by miners until the lock time is reached, and
     ; since Bitcoin 0.8+ a transaction that did not end its lock period (non final) is considered to be non
     ; standard and won't be relayed or included in the memory pool either.
     ;;
#_public
    void setLockTime(long lockTime)
    (§
        unCache();
        boolean seqNumSet = false;
        for (TransactionInput input : inputs)
        (§
            if (input.getSequenceNumber() != TransactionInput.NO_SEQUENCE)
            (§
                seqNumSet = true;
                break;
            )
        )
        if (lockTime != 0 && (!seqNumSet || inputs.isEmpty()))
        (§
            ;; At least one input must have a non-default sequence number for lock times to have any effect.
            ;; For instance one of them can be set to zero to make this feature work.
            log.warn("You are setting the lock time on a transaction but none of the inputs have non-default sequence numbers. This will not do what you expect!");
        )
        this.lockTime = lockTime;
    )

#_public
    long getVersion()
    (§
        return version;
    )

#_public
    void setVersion(int version)
    (§
        this.version = version;
        unCache();
    )

    ;;; Returns an unmodifiable view of all inputs. ;;
#_public
    List<TransactionInput> getInputs()
    (§
        return Collections.unmodifiableList(inputs);
    )

    ;;; Returns an unmodifiable view of all outputs. ;;
#_public
    List<TransactionOutput> getOutputs()
    (§
        return Collections.unmodifiableList(outputs);
    )

    ;;;
     ; <p>Returns the list of transacion outputs, whether spent or unspent, that match a wallet by address or that are
     ; watched by a wallet, i.e. transaction outputs whose script's address is controlled by the wallet and transaction
     ; outputs whose script is watched by the wallet.</p>
     ;
     ; @param transactionBag The wallet that controls addresses and watches scripts.
     ; @return linked list of outputs relevant to the wallet in this transaction.
     ;;
#_public
    List<TransactionOutput> getWalletOutputs(TransactionBag transactionBag)
    (§
        List<TransactionOutput> walletOutputs = new LinkedList<>();

        for (TransactionOutput o : outputs)
            if (o.isMine(transactionBag))
                walletOutputs.add(o);

        return walletOutputs;
    )

    ;;; Randomly re-orders the transaction outputs: good for privacy. ;;
#_public
    void shuffleOutputs()
    (§
        Collections.shuffle(outputs);
    )

    ;;; Same as getInputs().get(index). ;;
#_public
    TransactionInput getInput(long index)
    (§
        return inputs.get((int)index);
    )

    ;;; Same as getOutputs().get(index). ;;
#_public
    TransactionOutput getOutput(long index)
    (§
        return outputs.get((int)index);
    )

    ;;;
     ; Returns the confidence object for this transaction from the {@link org.bitcoinj.core.TxConfidenceTable}
     ; referenced by the implicit {@link Context}.
     ;;
#_public
    TransactionConfidence getConfidence()
    (§
        return getConfidence(Context.get());
    )

    ;;;
     ; Returns the confidence object for this transaction from the {@link org.bitcoinj.core.TxConfidenceTable}
     ; referenced by the given {@link Context}.
     ;;
#_public
    TransactionConfidence getConfidence(Context context)
    (§
        return getConfidence(context.getConfidenceTable());
    )

    ;;;
     ; Returns the confidence object for this transaction from the {@link org.bitcoinj.core.TxConfidenceTable}.
     ;;
#_public
    TransactionConfidence getConfidence(TxConfidenceTable table)
    (§
        if (confidence == nil)
            confidence = table.getOrCreate(getHash());
        return confidence;
    )

    ;;; Check if the transaction has a known confidence. ;;
#_public
    boolean hasConfidence()
    (§
        return (getConfidence().getConfidenceType() != TransactionConfidence.ConfidenceType.UNKNOWN);
    )

#_override
#_public
    boolean equals(Object o)
    (§
        if (this == o)
            return true;
        if (o == nil || getClass() != o.getClass())
            return false;
        return getHash().equals(((Transaction)o).getHash());
    )

#_override
#_public
    int hashCode()
    (§
        return getHash().hashCode();
    )

    ;;;
     ; Gets the count of regular SigOps in this transactions.
     ;;
#_public
    int getSigOpCount()
        throws ScriptException
    (§
        int sigOps = 0;
        for (TransactionInput input : inputs)
            sigOps += Script.getSigOpCount(input.getScriptBytes());
        for (TransactionOutput output : outputs)
            sigOps += Script.getSigOpCount(output.getScriptBytes());
        return sigOps;
    )

    ;;;
     ; Check block height is in coinbase input script, for use after BIP 34
     ; enforcement is enabled.
     ;;
#_public
    void checkCoinBaseHeight(final int height)
        throws VerificationException
    (§
        Preconditions.checkArgument(Block.BLOCK_HEIGHT_GENESIS <= height);
        Preconditions.checkState(isCoinBase());

        ;; Check block height is in coinbase input script.
#_final
        TransactionInput in = this.getInputs().get(0);
#_final
        ScriptBuilder builder = new ScriptBuilder();
        builder.number(height);
#_final
        byte[] expected = builder.build().getProgram();
#_final
        byte[] actual = in.getScriptBytes();
        if (actual.length < expected.length)
            throw new VerificationException.CoinbaseHeightMismatch("Block height mismatch in coinbase.");

        for (int scriptIdx = 0; scriptIdx < expected.length; scriptIdx++)
            if (actual[scriptIdx] != expected[scriptIdx])
                throw new VerificationException.CoinbaseHeightMismatch("Block height mismatch in coinbase.");
    )

    ;;;
     ; <p>Checks the transaction contents for sanity, in ways that can be done in a standalone manner.
     ; Does <b>not</b> perform all checks on a transaction such as whether the inputs are already spent.
     ; Specifically this method verifies:</p>
     ;
     ; <ul>
     ;     <li>That there is at least one input and output.</li>
     ;     <li>That the serialized size is not larger than the max block size.</li>
     ;     <li>That no outputs have negative value.</li>
     ;     <li>That the outputs do not sum to larger than the max allowed quantity of coin in the system.</li>
     ;     <li>If the tx is a coinbase tx, the coinbase scriptSig size is within range.  Otherwise that
     ;     there are no coinbase inputs in the tx.</li>
     ; </ul>
     ;
     ; @throws VerificationException
     ;;
#_public
    void verify()
        throws VerificationException
    (§
        if (inputs.size() == 0 || outputs.size() == 0)
            throw new VerificationException.EmptyInputsOrOutputs();
        if (Block.MAX_BLOCK_SIZE < this.getMessageSize())
            throw new VerificationException.LargerThanMaxBlockSize();

        Coin valueOut = Coin.ZERO;
        HashSet<TransactionOutPoint> outpoints = new HashSet<>();
        for (TransactionInput input : inputs)
        (§
            if (outpoints.contains(input.getOutpoint()))
                throw new VerificationException.DuplicatedOutPoint();
            outpoints.add(input.getOutpoint());
        )
        try
        (§
            for (TransactionOutput output : outputs)
            (§
                if (output.getValue().signum() < 0) ;; getValue() can throw IllegalStateException
                    throw new VerificationException.NegativeValueOutput();

                valueOut = valueOut.add(output.getValue());
                if (params.hasMaxMoney() && 0 < valueOut.compareTo(params.getMaxMoney()))
                    throw new IllegalArgumentException();
            )
        )
        catch (IllegalStateException _)
        (§
            throw new VerificationException.ExcessiveValue();
        )
        catch (IllegalArgumentException _)
        (§
            throw new VerificationException.ExcessiveValue();
        )

        if (isCoinBase())
        (§
            int n = inputs.get(0).getScriptBytes().length;
            if (n < 2 || 100 < n)
                throw new VerificationException.CoinbaseScriptSizeOutOfRange();
        )
        else
        (§
            for (TransactionInput input : inputs)
                if (input.isCoinBase())
                    throw new VerificationException.UnexpectedCoinbaseInput();
        )
    )

    ;;;
     ; <p>A transaction is time locked if at least one of its inputs is non-final and it has a lock time.</p>
     ;
     ; <p>To check if this transaction is final at a given height and time, see {@link Transaction#isFinal(int, long)}.</p>
     ;;
#_public
    boolean isTimeLocked()
    (§
        if (getLockTime() == 0)
            return false;
        for (TransactionInput input : getInputs())
            if (input.hasSequence())
                return true;
        return false;
    )

    ;;;
     ; Returns whether this transaction will opt into the
     ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki">full replace-by-fee</a> semantics.
     ;;
#_public
    boolean isOptInFullRBF()
    (§
        for (TransactionInput input : getInputs())
            if (input.isOptInFullRBF())
                return true;
        return false;
    )

    ;;;
     ; <p>Returns true if this transaction is considered finalized and can be placed in a block.  Non-finalized
     ; transactions won't be included by miners and can be replaced with newer versions using sequence numbers.
     ; This is useful in certain types of <a href="http://en.bitcoin.it/wiki/Contracts">contracts</a>, such as
     ; micropayment channels.</p>
     ;
     ; <p>Note that currently the replacement feature is disabled in Bitcoin Core and will need to be
     ; re-activated before this functionality is useful.</p>
     ;;
#_public
    boolean isFinal(int height, long blockTimeSeconds)
    (§
        long time = getLockTime();
        return (time < (time < LOCKTIME_THRESHOLD ? height : blockTimeSeconds) || !isTimeLocked());
    )

    ;;;
     ; Returns either the lock time as a date, if it was specified in seconds, or an estimate based on the time in
     ; the current head block if it was specified as a block time.
     ;;
#_public
    Date estimateLockTime(AbstractBlockChain chain)
    (§
        return (lockTime < LOCKTIME_THRESHOLD) ? chain.estimateBlockTime((int)getLockTime()) : new Date(getLockTime() * 1000);
    )

    ;;;
     ; Returns the purpose for which this transaction was created.  See the javadoc for {@link Purpose} for more
     ; information on the point of this field and what it can be.
     ;;
#_public
    Purpose getPurpose()
    (§
        return purpose;
    )

    ;;;
     ; Marks the transaction as being created for the given purpose.  See the javadoc for {@link Purpose} for more
     ; information on the point of this field and what it can be.
     ;;
#_public
    void setPurpose(Purpose purpose)
    (§
        this.purpose = purpose;
    )

    ;;;
     ; Getter for {@link #exchangeRate}.
     ;;
#_nilable
#_public
    ExchangeRate getExchangeRate()
    (§
        return exchangeRate;
    )

    ;;;
     ; Setter for {@link #exchangeRate}.
     ;;
#_public
    void setExchangeRate(ExchangeRate exchangeRate)
    (§
        this.exchangeRate = exchangeRate;
    )

    ;;;
     ; Returns the transaction {@link #memo}.
     ;;
#_public
    String getMemo()
    (§
        return memo;
    )

    ;;;
     ; Set the transaction {@link #memo}.  It can be used to record the memo of the payment request that initiated the
     ; transaction.
     ;;
#_public
    void setMemo(String memo)
    (§
        this.memo = memo;
    )
)

(ns org.bitcoinj.core #_"TransactionBag"
    (:import [java.util Map])
  #_(:require [org.bitcoinj.script Script]
             [org.bitcoinj.wallet WalletTransaction]))

;;;
 ; This interface is used to abstract the {@link org.bitcoinj.wallet.Wallet} and the {@link org.bitcoinj.core.Transaction}.
 ;;
#_public
interface TransactionBag
(§
    ;;; Returns true if this wallet contains a public key which hashes to the given hash. ;;
    boolean isPubKeyHashMine(byte[] pubkeyHash);

    ;;; Returns true if this wallet contains a keypair with the given public key. ;;
    boolean isPubKeyMine(byte[] pubkey);

    ;;; Returns true if this wallet knows the script corresponding to the given hash. ;;
    boolean isPayToScriptHashMine(byte[] payToScriptHash);

    ;;; Returns transactions from a specific pool. ;;
    Map<Sha256Hash, Transaction> getTransactionPool(WalletTransaction.Pool pool);
)

(ns org.bitcoinj.core #_"TransactionBroadcast"
    (:import #_[java.util *]
             #_[java.util.concurrent *])
    (:import #_[com.google.common.annotations *]
             #_[com.google.common.base *]
             #_[com.google.common.util.concurrent *]
             #_[org.slf4j *])
  #_(:require [org.bitcoinj.core.listeners PreMessageReceivedEventListener]
             #_[org.bitcoinj.utils *]
             [org.bitcoinj.wallet Wallet]))

;;;
 ; Represents a single transaction broadcast that we are performing.  A broadcast occurs after a new transaction is created
 ; (typically by a {@link Wallet}) and needs to be sent to the network.  A broadcast can succeed or fail.  A success is
 ; defined as seeing the transaction be announced by peers via inv messages, thus indicating their acceptance.  A failure
 ; is defined as not reaching acceptance within a timeout period, or getting an explicit reject message from a peer
 ; indicating that the transaction was not acceptable.
 ;;
#_public
class TransactionBroadcast
(§
#_private
#_static
#_final
    Logger log = LoggerFactory.getLogger(TransactionBroadcast.class);

#_private
#_final
    SettableFuture<Transaction> future = SettableFuture.create();
#_private
#_final
    PeerGroup peerGroup;
#_private
#_final
    Transaction tx;
#_private
    int minConnections;
#_private
    int numWaitingFor;

    ;;; Used for shuffling the peers before broadcast: unit tests can replace this to make themselves deterministic. ;;
#_testing
#_public
#_static
    Random random = new Random();

    ;; Tracks which nodes sent us a reject message about this broadcast, if any.  Useful for debugging.
#_private
    Map<Peer, RejectMessage> rejects = Collections.synchronizedMap(new HashMap<Peer, RejectMessage>());

    TransactionBroadcast(PeerGroup peerGroup, Transaction tx)
    (§
        this.peerGroup = peerGroup;
        this.tx = tx;
        this.minConnections = Math.max(1, peerGroup.getMinBroadcastConnections());
    )

    ;; Only for mock broadcasts.
#_private
    TransactionBroadcast(Transaction tx)
    (§
        this.peerGroup = nil;
        this.tx = tx;
    )

#_testing
#_public
#_static
    TransactionBroadcast createMockBroadcast(Transaction tx, final SettableFuture<Transaction> future)
    (§
        return new TransactionBroadcast(tx)
        (§
#_override
#_public
            ListenableFuture<Transaction> broadcast()
            (§
                return future;
            )

#_override
#_public
            ListenableFuture<Transaction> future()
            (§
                return future;
            )
        );
    )

#_public
    ListenableFuture<Transaction> future()
    (§
        return future;
    )

#_public
    void setMinConnections(int minConnections)
    (§
        this.minConnections = minConnections;
    )

#_private
    PreMessageReceivedEventListener rejectionListener = new PreMessageReceivedEventListener()
    (§
#_override
#_public
        Message onPreMessageReceived(Peer peer, Message m)
        (§
            if (m instanceof RejectMessage)
            (§
                RejectMessage rejectMessage = (RejectMessage)m;
                if (tx.getHash().equals(rejectMessage.getRejectedObjectHash()))
                (§
                    rejects.put(peer, rejectMessage);
                    int size = rejects.size();
                    long threshold = Math.round(numWaitingFor / 2.0);
                    if (threshold < size)
                    (§
                        log.warn("Threshold for considering broadcast rejected has been reached ({}/{})", size, threshold);
                        future.setException(new RejectedTransactionException(tx, rejectMessage));
                        peerGroup.removePreMessageReceivedEventListener(this);
                    )
                )
            )
            return m;
        )
    );

#_public
    ListenableFuture<Transaction> broadcast()
    (§
        peerGroup.addPreMessageReceivedEventListener(Threading.SAME_THREAD, rejectionListener);
        log.info("Waiting for {} peers required for broadcast, we have {} ...", minConnections, peerGroup.getConnectedPeers().size());
        peerGroup.waitForPeers(minConnections).addListener(new EnoughAvailablePeers(), Threading.SAME_THREAD);
        return future;
    )

#_private
    class EnoughAvailablePeers implements Runnable
    (§
#_override
#_public
        void run()
        (§
            ;; We now have enough connected peers to send the transaction.
            ;; This can be called immediately if we already have enough.  Otherwise it'll be called from a peer thread.

            ;; We will send the tx simultaneously to half the connected peers and wait to hear back from at least half
            ;; of the other half, i.e. with 4 peers connected we will send the tx to 2 randomly chosen peers, and then
            ;; wait for it to show up on one of the other two.  This will be taken as sign of network acceptance.  As can
            ;; be seen, 4 peers is probably too little - it doesn't taken many broken peers for tx propagation to have
            ;; a big effect.
            List<Peer> peers = peerGroup.getConnectedPeers(); ;; snapshots
            ;; Prepare to send the transaction by adding a listener that'll be called when confidence changes.
            ;; Only bother with this if we might actually hear back:
            if (1 < minConnections)
                tx.getConfidence().addEventListener(new ConfidenceChange());
            ;; Bitcoin Core sends an inv in this case and then lets the peer request the tx data.  We just
            ;; blast out the TX here for a couple of reasons.  Firstly it's simpler: in the case where we have
            ;; just a single connection we don't have to wait for getdata to be received and handled before
            ;; completing the future in the code immediately below.  Secondly, it's faster.  The reason the
            ;; Bitcoin Core sends an inv is privacy - it means you can't tell if the peer originated the
            ;; transaction or not.  However, we are not a fully validating node and this is advertised in
            ;; our version message, as SPV nodes cannot relay it doesn't give away any additional information
            ;; to skip the inv here - we wouldn't send invs anyway.
            int numConnected = peers.size();
            int numToBroadcastTo = (int)Math.max(1, Math.round(Math.ceil(peers.size() / 2.0)));
            numWaitingFor = (int)Math.ceil((peers.size() - numToBroadcastTo) / 2.0);
            Collections.shuffle(peers, random);
            peers = peers.subList(0, numToBroadcastTo);
            log.info("broadcastTransaction: We have {} peers, adding {} to the memory pool", numConnected, tx.getHashAsString());
            log.info("Sending to {} peers, will wait for {}, sending to: {}", numToBroadcastTo, numWaitingFor, Joiner.on(",").join(peers));
            for (Peer peer : peers)
            (§
                try
                (§
                    peer.sendMessage(tx);
                    ;; We don't record the peer as having seen the tx in the memory pool because we want to track only
                    ;; how many peers announced to us.
                )
                catch (Exception e)
                (§
                    log.error("Caught exception sending to {}", peer, e);
                )
            )
            ;; If we've been limited to talk to only one peer, we can't wait to hear back because the
            ;; remote peer won't tell us about transactions we just announced to it for obvious reasons.
            ;; So we just have to assume we're done, at that point.  This happens when we're not given
            ;; any peer discovery source and the user just calls connectTo() once.
            if (minConnections == 1)
            (§
                peerGroup.removePreMessageReceivedEventListener(rejectionListener);
                future.set(tx);
            )
        )
    )

#_private
    int numSeemPeers;
#_private
    boolean mined;

#_private
    class ConfidenceChange implements TransactionConfidence.Listener
    (§
#_override
#_public
        void onConfidenceChanged(TransactionConfidence conf, ChangeReason reason)
        (§
            ;; The number of peers that announced this tx has gone up.
            int numSeenPeers = conf.numBroadcastPeers() + rejects.size();
            boolean mined = (tx.getAppearsInHashes() != nil);
            log.info("broadcastTransaction: {}:  TX {} seen by {} peers{}", reason, tx.getHashAsString(), numSeenPeers, mined ? " and mined" : "");

            ;; Progress callback on the requested thread.
            invokeAndRecord(numSeenPeers, mined);

            if (numWaitingFor <= numSeenPeers || mined)
            (§
                ;; We've seen the min required number of peers announce the transaction, or it was included
                ;; in a block.  Normally we'd expect to see it fully propagate before it gets mined, but
                ;; it can be that a block is solved very soon after broadcast, and it's also possible that
                ;; due to version skew and changes in the relay rules our transaction is not going to
                ;; fully propagate yet can get mined anyway.
                ;;
                ;; Note that we can't wait for the current number of connected peers right now because we
                ;; could have added more peers after the broadcast took place, which means they won't
                ;; have seen the transaction.  In future when peers sync up their memory pools after they
                ;; connect we could come back and change this.
                ;;
                ;; We're done!  It's important that the PeerGroup lock is not held (by this thread) at this
                ;; point to avoid triggering inversions when the Future completes.
                log.info("broadcastTransaction: {} complete", tx.getHash());
                peerGroup.removePreMessageReceivedEventListener(rejectionListener);
                conf.removeEventListener(this);
                future.set(tx); ;; RE-ENTRANCY POINT
            )
        )
    )

#_private
    void invokeAndRecord(int numSeenPeers, boolean mined)
    (§
#_synchronized
        (this)
        (§
            this.numSeemPeers = numSeenPeers;
            this.mined = mined;
        )
        invokeProgressCallback(numSeenPeers, mined);
    )

#_private
    void invokeProgressCallback(int numSeenPeers, boolean mined)
    (§
#_final
        ProgressCallback callback;
        Executor executor;
#_synchronized
        (this)
        (§
            callback = this.callback;
            executor = this.progressCallbackExecutor;
        )
        if (callback != nil)
        (§
#_final
            double progress = Math.min(1.0, mined ? 1.0 : numSeenPeers / (double)numWaitingFor);
            Preconditions.checkState(0.0 <= progress && progress <= 1.0, progress);
            try
            (§
                if (executor == nil)
                    callback.onBroadcastProgress(progress);
                else
                    executor.execute(new Runnable()
                    (§
#_override
#_public
                        void run()
                        (§
                            callback.onBroadcastProgress(progress);
                        )
                    ));
            )
            catch (Throwable e)
            (§
                log.error("Exception during progress callback", e);
            )
        )
    )

    ;;; An interface for receiving progress information on the propagation of the tx, from 0.0 to 1.0 ;;
#_public
    interface ProgressCallback
    (§
        ;;;
         ; onBroadcastProgress will be invoked on the provided executor when the progress of the transaction
         ; broadcast has changed, because the transaction has been announced by another peer or because the transaction
         ; was found inside a mined block (in this case progress will go to 1.0 immediately).  Any exceptions thrown
         ; by this callback will be logged and ignored.
         ;;
        void onBroadcastProgress(double progress);
    )

#_nilable
#_private
    ProgressCallback callback;
#_nilable
#_private
    Executor progressCallbackExecutor;

    ;;;
     ; Sets the given callback for receiving progress values, which will run on the user thread.
     ; See {@link org.bitcoinj.utils.Threading} for details.  If the broadcast has already started then the callback will
     ; be invoked immediately with the current progress.
     ;;
#_public
    void setProgressCallback(ProgressCallback callback)
    (§
        setProgressCallback(callback, Threading.USER_THREAD);
    )

    ;;;
     ; Sets the given callback for receiving progress values, which will run on the given executor.  If the executor
     ; is null, then the callback will run on a network thread and may be invoked multiple times in parallel.  You
     ; probably want to provide your UI thread or Threading.USER_THREAD for the second parameter.  If the broadcast
     ; has already started, then the callback will be invoked immediately with the current progress.
     ;;
#_public
    void setProgressCallback(ProgressCallback callback, #_nilable Executor executor)
    (§
        boolean shouldInvoke;
        int num;
        boolean mined;
#_synchronized
        (this)
        (§
            this.callback = callback;
            this.progressCallbackExecutor = executor;
            num = this.numSeemPeers;
            mined = this.mined;
            shouldInvoke = (0 < numWaitingFor);
        )
        if (shouldInvoke)
            invokeProgressCallback(num, mined);
    )
)

(ns org.bitcoinj.core #_"TransactionBroadcaster"
)

;;;
 ; A general interface which declares the ability to broadcast transactions.
 ; This is implemented by {@link org.bitcoinj.core.PeerGroup}.
 ;;
#_public
interface TransactionBroadcaster
(§
    ;;; Broadcast the given transaction on the network. ;;
    TransactionBroadcast broadcastTransaction(final Transaction tx);
)

(ns org.bitcoinj.core #_"TransactionConfidence"
    (:import #_[java.util *]
             #_[java.util.concurrent *])
    (:import [com.google.common.base Preconditions]
             #_[com.google.common.collect *]
             #_[com.google.common.util.concurrent *])
  #_(:require #_[org.bitcoinj.utils *]
             [org.bitcoinj.wallet Wallet]))

;; TODO: Modify the getDepthInBlocks method to require the chain height to be specified, in preparation for ceasing to touch every tx on every block.

;;;
 ; <p>A TransactionConfidence object tracks data you can use to make a confidence decision about a transaction.
 ; It also contains some pre-canned rules for common scenarios: if you aren't really sure what level of confidence
 ; you need, these should prove useful.  You can get a confidence object using {@link Transaction#getConfidence()}.
 ; They cannot be constructed directly.</p>
 ;
 ; <p>Confidence in a transaction can come in multiple ways:</p>
 ;
 ; <ul>
 ; <li>Because you created it yourself and only you have the necessary keys.</li>
 ; <li>Receiving it from a fully validating peer you know is trustworthy, for instance, because it's run by yourself.</li>
 ; <li>Receiving it from a peer on the network you randomly chose.  If your network connection is not being
 ;     intercepted, you have a pretty good chance of connecting to a node that is following the rules.</li>
 ; <li>Receiving it from multiple peers on the network.  If your network connection is not being intercepted,
 ;     hearing about a transaction from multiple peers indicates the network has accepted the transaction and
 ;     thus miners likely have too (miners have the final say in whether a transaction becomes valid or not).</li>
 ; <li>Seeing the transaction appear appear in a block on the main chain.  Your confidence increases as the transaction
 ;     becomes further buried under work.  Work can be measured either in blocks (roughly, units of time), or
 ;     amount of work done.</li>
 ; </ul>
 ;
 ; <p>Alternatively, you may know that the transaction is "dead", that is, one or more of its inputs have
 ; been double spent and will never confirm unless there is another re-org.</p>
 ;
 ; <p>TransactionConfidence is updated via the {@link org.bitcoinj.core.TransactionConfidence#incrementDepthInBlocks()}
 ; method to ensure the block depth is up to date.</p>
 ; To make a copy that won't be changed, use {@link org.bitcoinj.core.TransactionConfidence#duplicate()}.
 ;;
#_public
class TransactionConfidence
(§
    ;;;
     ; The peers that have announced the transaction to us.  Network nodes don't have stable identities, so we use
     ; IP address as an approximation.  It's obviously vulnerable to being gamed if we allow arbitrary people to connect
     ; to us, so only peers we explicitly connected to should go here.
     ;;
#_private
    CopyOnWriteArrayList<PeerAddress> broadcastBy;
    ;;; The time the transaction was last announced to us. ;;
#_private
    Date lastBroadcastedAt;
    ;;; The Transaction that this confidence object is associated with. ;;
#_private
#_final
    Sha256Hash hash;
    ;; Lazily created listeners array.
#_private
    CopyOnWriteArrayList<ListenerRegistration<Listener>> listeners;

    ;; The depth of the transaction on the best chain in blocks.  An unconfirmed block has depth 0.
#_private
    int depth;

    ;;; Describes the state of the transaction in general terms.  Properties can be read to learn specifics. ;;
#_public
    enum ConfidenceType
    (§
        ;;; If BUILDING, then the transaction is included in the best chain and your confidence in it is increasing. ;;
        BUILDING(1),

        ;;;
         ; If PENDING, then the transaction is unconfirmed and should be included shortly, as long as it is being
         ; announced and is considered valid by the network.  A pending transaction will be announced if the containing
         ; wallet has been attached to a live {@link PeerGroup} using {@link PeerGroup#addWallet(Wallet)}.
         ; You can estimate how likely the transaction is to be included by connecting to a bunch of nodes then measuring
         ; how many announce it, using {@link org.bitcoinj.core.TransactionConfidence#numBroadcastPeers()}.
         ; Or if you saw it from a trusted peer, you can assume it's valid and will get mined sooner or later as well.
         ;;
        PENDING(2),

        ;;;
         ; If DEAD, then it means the transaction won't confirm unless there is another re-org,
         ; because some other transaction is spending one of its inputs.  Such transactions should be alerted to the user
         ; so they can take action, e.g. suspending shipment of goods if they are a merchant.
         ; It can also mean that a coinbase transaction has been made dead from it being moved onto a side chain.
         ;;
        DEAD(4),

        ;;;
         ; If IN_CONFLICT, then it means there is another transaction (or several other transactions) spending one
         ; (or several) of its inputs but nor this transaction nor the other/s transaction/s are included in the best chain.
         ; The other/s transaction/s should be IN_CONFLICT too.
         ; IN_CONFLICT can be thought as an intermediary state between a) PENDING and BUILDING or b) PENDING and DEAD.
         ; Another common name for this situation is "double spend".
         ;;
        IN_CONFLICT(5),

        ;;;
         ; If a transaction hasn't been broadcast yet, or there's no record of it, its confidence is UNKNOWN.
         ;;
        UNKNOWN(0);

#_private
        int value;

        ConfidenceType(int value)
        (§
            this.value = value;
        )

#_public
        int getValue()
        (§
            return value;
        )
    )

#_private
    ConfidenceType confidenceType = ConfidenceType.UNKNOWN;
#_private
    int appearedAtChainHeight = -1;
    ;; The transaction that double spent this one, if any.
#_private
    Transaction overridingTransaction;

    ;;;
     ; Information about where the transaction was first seen (network, sent direct from peer, created by ourselves).
     ; Useful for risk analyzing pending transactions.  Probably not that useful after a tx is included in the chain,
     ; unless re-org double spends start happening frequently.
     ;;
#_public
    enum Source
    (§
        ;;; We don't know where the transaction came from. ;;
        UNKNOWN,
        ;;; We got this transaction from a network peer. ;;
        NETWORK,
        ;;; This transaction was created by our own wallet, so we know it's not a double spend. ;;
        SELF
    )
#_private
    Source source = Source.UNKNOWN;

#_public
    TransactionConfidence(Sha256Hash hash)
    (§
        ;; Assume a default number of peers for our set.
        broadcastBy = new CopyOnWriteArrayList<>();
        listeners = new CopyOnWriteArrayList<>();
        this.hash = hash;
    )

    ;;;
     ; <p>A confidence listener is informed when the level of {@link TransactionConfidence} is updated by something, like
     ; for example a {@link Wallet}.  You can add listeners to update your user interface or manage your order tracking
     ; system when confidence levels pass a certain threshold.  <b>Note that confidence can go down as well as up.</b>
     ; For example, this can happen if somebody is doing a double-spend attack against you.  Whilst it's unlikely, your
     ; code should be able to handle that in order to be correct.</p>
     ;
     ; <p>During listener execution, it's safe to remove the current listener but not others.</p>
     ;;
#_public
    interface Listener
    (§
        ;;; An enum that describes why a transaction confidence listener is being invoked (i.e. the class of change). ;;
        enum ChangeReason
        (§
            ;;;
             ; Occurs when the type returned by {@link org.bitcoinj.core.TransactionConfidence#getConfidenceType()}
             ; has changed.  For example, if a PENDING transaction changes to BUILDING or DEAD, then this reason will
             ; be given.  It's a high level summary.
             ;;
            TYPE,

            ;;;
             ; Occurs when a transaction that is in the best known block chain gets buried by another block.  If you're
             ; waiting for a certain number of confirmations, this is the reason to watch out for.
             ;;
            DEPTH,

            ;;;
             ; Occurs when a pending transaction (not in the chain) was announced by another connected peers.  By
             ; watching the number of peers that announced a transaction go up, you can see whether it's being
             ; accepted by the network or not.  If all your peers announce, it's a pretty good bet the transaction
             ; is considered relayable and has thus reached the miners.
             ;;
            SEEN_PEERS
        )

        void onConfidenceChanged(TransactionConfidence confidence, ChangeReason reason);
    )

    ;; This is used to ensure that confidence objects which aren't referenced from anywhere but which have an event
    ;; listener set on them don't become eligible for garbage collection.  Otherwise the TxConfidenceTable, which only
    ;; has weak references to these objects, would not be enough to keep the event listeners working as transactions
    ;; propagate around the network - it cannot know directly if the API user is interested in the object, so it uses
    ;; heap reachability as a proxy for interest.
    ;;
    ;; We add ourselves to this set when a listener is added and remove ourselves when the listener list is empty.
#_private
#_static
#_final
    Set<TransactionConfidence> pinnedConfidenceObjects = Collections.synchronizedSet(new HashSet<TransactionConfidence>());

    ;;;
     ; <p>Adds an event listener that will be run when this confidence object is updated.  The listener will be locked
     ; and is likely to be invoked on a peer thread.</p>
     ;
     ; <p>Note that this is NOT called when every block arrives.  Instead it is called when the transaction
     ; transitions between confidence states, i.e. from not being seen in the chain to being seen (not necessarily in
     ; the best chain).  If you want to know when the transaction gets buried under another block, consider using
     ; a future from {@link #getDepthFuture(int)}.</p>
     ;;
#_public
    void addEventListener(Executor executor, Listener listener)
    (§
        Preconditions.checkNotNull(listener);

        listeners.addIfAbsent(new ListenerRegistration<>(listener, executor));
        pinnedConfidenceObjects.add(this);
    )

    ;;;
     ; <p>Adds an event listener that will be run when this confidence object is updated.  The listener will be locked
     ; and is likely to be invoked on a peer thread.</p>
     ;
     ; <p>Note that this is NOT called when every block arrives.  Instead it is called when the transaction
     ; transitions between confidence states, i.e. from not being seen in the chain to being seen (not necessarily in
     ; the best chain).  If you want to know when the transaction gets buried under another block, implement a
     ; {@link BlockChainListener}, attach it to a {@link BlockChain} and then use the getters on the
     ; confidence object to determine the new depth.</p>
     ;;
#_public
    void addEventListener(Listener listener)
    (§
        addEventListener(Threading.USER_THREAD, listener);
    )

#_public
    boolean removeEventListener(Listener listener)
    (§
        Preconditions.checkNotNull(listener);

        boolean removed = ListenerRegistration.removeFromList(listener, listeners);
        if (listeners.isEmpty())
            pinnedConfidenceObjects.remove(this);
        return removed;
    )

    ;;;
     ; Returns the chain height at which the transaction appeared if confidence type is BUILDING.
     ; @throws IllegalStateException if the confidence type is not BUILDING.
     ;;
#_public
#_synchronized
    int getAppearedAtChainHeight()
    (§
        if (getConfidenceType() != ConfidenceType.BUILDING)
            throw new IllegalStateException("Confidence type is " + getConfidenceType() + ", not BUILDING");
        return appearedAtChainHeight;
    )

    ;;;
     ; The chain height at which the transaction appeared, if it has been seen in the best chain.
     ; Automatically sets the current type to {@link ConfidenceType#BUILDING} and depth to one.
     ;;
#_public
#_synchronized
    void setAppearedAtChainHeight(int appearedAtChainHeight)
    (§
        if (appearedAtChainHeight < 0)
            throw new IllegalArgumentException("appearedAtChainHeight out of range");

        this.appearedAtChainHeight = appearedAtChainHeight;
        this.depth = 1;
        setConfidenceType(ConfidenceType.BUILDING);
    )

    ;;;
     ; Returns a general statement of the level of confidence you can have in this transaction.
     ;;
#_public
#_synchronized
    ConfidenceType getConfidenceType()
    (§
        return confidenceType;
    )

    ;;;
     ; Called by other objects in the system, like a {@link Wallet}, when new information about the confidence
     ; of a transaction becomes available.
     ;;
#_public
#_synchronized
    void setConfidenceType(ConfidenceType confidenceType)
    (§
        if (confidenceType == this.confidenceType)
            return;

        this.confidenceType = confidenceType;
        if (confidenceType != ConfidenceType.DEAD)
            overridingTransaction = nil;
        if (confidenceType == ConfidenceType.PENDING || confidenceType == ConfidenceType.IN_CONFLICT)
        (§
            depth = 0;
            appearedAtChainHeight = -1;
        )
    )

    ;;;
     ; Called by a {@link Peer} when a transaction is pending and announced by a peer.  The more peers announce
     ; the transaction, the more peers have validated it (assuming your internet connection is not being intercepted).
     ; If confidence is currently unknown, sets it to {@link ConfidenceType#PENDING}.  Does not run listeners.
     ;
     ; @param address IP address of the peer, used as a proxy for identity.
     ; @return true if marked, false if this address was already seen.
     ;;
#_public
    boolean markBroadcastBy(PeerAddress address)
    (§
        lastBroadcastedAt = Utils.now();
        if (!broadcastBy.addIfAbsent(address))
            return false; ;; Duplicate.

#_synchronized
        (this)
        (§
            if (getConfidenceType() == ConfidenceType.UNKNOWN)
                this.confidenceType = ConfidenceType.PENDING;
        )
        return true;
    )

    ;;;
     ; Returns how many peers have been passed to {@link TransactionConfidence#markBroadcastBy}.
     ;;
#_public
    int numBroadcastPeers()
    (§
        return broadcastBy.size();
    )

    ;;;
     ; Returns a snapshot of {@link PeerAddress}es that announced the transaction.
     ;;
#_public
    Set<PeerAddress> getBroadcastBy()
    (§
        ListIterator<PeerAddress> iterator = broadcastBy.listIterator();
        return Sets.newHashSet(iterator);
    )

    ;;; Returns true if the given address has been seen via markBroadcastBy(). ;;
#_public
    boolean wasBroadcastBy(PeerAddress address)
    (§
        return broadcastBy.contains(address);
    )

    ;;; Return the time the transaction was last announced to us. ;;
#_public
    Date getLastBroadcastedAt()
    (§
        return lastBroadcastedAt;
    )

    ;;; Set the time the transaction was last announced to us. ;;
#_public
    void setLastBroadcastedAt(Date lastBroadcastedAt)
    (§
        this.lastBroadcastedAt = lastBroadcastedAt;
    )

#_override
#_public
#_synchronized
    String toString()
    (§
        StringBuilder sb = new StringBuilder();
        int peers = numBroadcastPeers();
        if (0 < peers)
        (§
            sb.append("Seen by ").append(peers).append((1 < peers) ? " peers" : " peer");
            if (lastBroadcastedAt != nil)
                sb.append(" (most recently: ").append(Utils.dateTimeFormat(lastBroadcastedAt)).append(")");
            sb.append(". ");
        )
        switch (getConfidenceType())
        (§
            case UNKNOWN:
                sb.append("Unknown confidence level.");
                break;
            case DEAD:
                sb.append("Dead: overridden by double spend and will not confirm.");
                break;
            case PENDING:
                sb.append("Pending/unconfirmed.");
                break;
            case IN_CONFLICT:
                sb.append("In conflict.");
                break;
            case BUILDING:
                sb.append(String.format(Locale.US, "Appeared in best chain at height %d, depth %d.", getAppearedAtChainHeight(), getDepthInBlocks()));
                break;
        )
        if (source != Source.UNKNOWN)
            sb.append(" Source: ").append(source);
        return sb.toString();
    )

    ;;;
     ; Called by the wallet when the tx appears on the best chain and a new block is added to the top.
     ; Updates the internal counter that tracks how deeply buried the block is.
     ;
     ; @return the new depth
     ;;
#_public
#_synchronized
    int incrementDepthInBlocks()
    (§
        return ++this.depth;
    )

    ;;;
     ; <p>Depth in the chain is an approximation of how much time has elapsed since the transaction has been confirmed.
     ; On average there is supposed to be a new block every 10 minutes, but the actual rate may vary.  Bitcoin Core
     ; considers a transaction impractical to reverse after 6 blocks, but as of EOY 2011 network
     ; security is high enough that often only one block is considered enough even for high value transactions.
     ; For low value transactions like songs, or other cheap items, no blocks at all may be necessary.</p>
     ;
     ; <p>If the transaction appears in the top block, the depth is one.  If it's anything else (pending, dead, unknown)
     ; the depth is zero.</p>
     ;;
#_public
#_synchronized
    int getDepthInBlocks()
    (§
        return depth;
    )

    ;;
     ; Set the depth in blocks.  Having one block confirmation is a depth of one.
     ;;
#_public
#_synchronized
    void setDepthInBlocks(int depth)
    (§
        this.depth = depth;
    )

    ;;;
     ; Erases the set of broadcast/seen peers.  This cannot be called whilst the confidence is PENDING.  It is useful
     ; for saving memory and wallet space once a tx is buried so deep it doesn't seem likely to go pending again.
     ;;
#_public
    void clearBroadcastBy()
    (§
        Preconditions.checkState(getConfidenceType() != ConfidenceType.PENDING);
        broadcastBy.clear();
        lastBroadcastedAt = nil;
    )

    ;;;
     ; If this transaction has been overridden by a double spend (is dead), this call returns the overriding transaction.
     ; Note that this call <b>can return null</b> if you have migrated an old wallet, as pre-Jan 2012 wallets did not
     ; store this information.
     ;
     ; @return the transaction that double spent this one.
     ; @throws IllegalStateException if confidence type is not DEAD.
     ;;
#_public
#_synchronized
    Transaction getOverridingTransaction()
    (§
        if (getConfidenceType() != ConfidenceType.DEAD)
            throw new IllegalStateException("Confidence type is " + getConfidenceType() + ", not DEAD");
        return overridingTransaction;
    )

    ;;;
     ; Called when the transaction becomes newly dead, that is, we learn that one of its inputs has already been spent
     ; in such a way that the double-spending transaction takes precedence over this one.  It will not become valid now
     ; unless there is a re-org.  Automatically sets the confidence type to DEAD.  The overriding transaction may not
     ; directly double spend this one, but could also have double spent a dependency of this tx.
     ;;
#_public
#_synchronized
    void setOverridingTransaction(#_nilable Transaction overridingTransaction)
    (§
        this.overridingTransaction = overridingTransaction;
        setConfidenceType(ConfidenceType.DEAD);
    )

    ;;; Returns a copy of this object.  Event listeners are not duplicated. ;;
#_public
    TransactionConfidence duplicate()
    (§
        TransactionConfidence c = new TransactionConfidence(hash);
        c.broadcastBy.addAll(broadcastBy);
        c.lastBroadcastedAt = lastBroadcastedAt;
#_synchronized
        (this)
        (§
            c.confidenceType = confidenceType;
            c.overridingTransaction = overridingTransaction;
            c.appearedAtChainHeight = appearedAtChainHeight;
        )
        return c;
    )

    ;;;
     ; Call this after adjusting the confidence, for cases where listeners should be notified.  This has to be done
     ; explicitly rather than being done automatically because sometimes complex changes to transaction states can
     ; result in a series of confidence changes that are not really useful to see separately.  By invoking listeners
     ; explicitly, more precise control is available.  Note that this will run the listeners on the user code thread.
     ;;
#_public
    void queueListeners(final Listener.ChangeReason reason)
    (§
        for (final ListenerRegistration<Listener> registration : listeners)
        (§
            registration.executor.execute(new Runnable()
            (§
#_override
#_public
                void run()
                (§
                    registration.listener.onConfidenceChanged(TransactionConfidence.this, reason);
                )
            ));
        )
    )

    ;;;
     ; The source of a transaction tries to identify where it came from originally.  For instance, did we download it
     ; from the peer to peer network, or make it ourselves, or receive it via Bluetooth, or import it from another app,
     ; and so on.  This information is useful for {@link org.bitcoinj.wallet.CoinSelector} implementations to risk analyze
     ; transactions and decide when to spend them.
     ;;
#_public
#_synchronized
    Source getSource()
    (§
        return source;
    )

    ;;;
     ; The source of a transaction tries to identify where it came from originally.  For instance, did we download it
     ; from the peer to peer network, or make it ourselves, or receive it via Bluetooth, or import it from another app,
     ; and so on.  This information is useful for {@link org.bitcoinj.wallet.CoinSelector} implementations to risk analyze
     ; transactions and decide when to spend them.
     ;;
#_public
#_synchronized
    void setSource(Source source)
    (§
        this.source = source;
    )

    ;;;
     ; Returns a future that completes when the transaction has been confirmed by "depth" blocks.  For instance setting
     ; depth to one will wait until it appears in a block on the best chain, and zero will wait until it has been seen
     ; on the network.
     ;;
#_public
#_synchronized
    ListenableFuture<TransactionConfidence> getDepthFuture(final int depth, Executor executor)
    (§
#_final
        SettableFuture<TransactionConfidence> result = SettableFuture.create();
        if (depth <= getDepthInBlocks())
            result.set(this);

        addEventListener(executor, new Listener()
        (§
#_override
#_public
            void onConfidenceChanged(TransactionConfidence confidence, ChangeReason reason)
            (§
                if (depth <= getDepthInBlocks())
                (§
                    removeEventListener(this);
                    result.set(confidence);
                )
            )
        ));
        return result;
    )

#_public
#_synchronized
    ListenableFuture<TransactionConfidence> getDepthFuture(final int depth)
    (§
        return getDepthFuture(depth, Threading.USER_THREAD);
    )

#_public
    Sha256Hash getTransactionHash()
    (§
        return hash;
    )
)

(ns org.bitcoinj.core #_"TransactionInput"
    (:import [java.io IOException OutputStream]
             [java.lang.ref WeakReference]
             [java.util Arrays Map])
    (:import [com.google.common.base Joiner Objects Preconditions])
  #_(:require [org.bitcoinj.script Script ScriptError]
             [org.bitcoinj.wallet DefaultRiskAnalysis KeyBag RedeemData]))

;;;
 ; <p>A transfer of coins from one address to another creates a transaction in which the outputs
 ; can be claimed by the recipient in the input of another transaction.  You can imagine a
 ; transaction as being a module which is wired up to others, the inputs of one have to be wired
 ; to the outputs of another.  The exceptions are coinbase transactions, which create new coins.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
class TransactionInput extends ChildMessage
(§
    ;;; Magic sequence number that indicates there is no sequence number. ;;
#_public
#_static
#_final
    long NO_SEQUENCE = 0xffffffffL;
#_private
#_static
#_final
    byte[] EMPTY_ARRAY = new byte[0];
    ;; Magic outpoint index that indicates the input is in fact unconnected.
#_private
#_static
#_final
    long UNCONNECTED = 0xffffffffL;

    ;; Allows for altering transactions after they were broadcast.  Values below NO_SEQUENCE-1 mean it can be altered.
#_private
    long sequence;
    ;; Data needed to connect to the output of the transaction we're gathering coins from.
#_private
    TransactionOutPoint outpoint;
    ;; The "script bytes" might not actually be a script.  In coinbase transactions where new coins are minted there
    ;; is no input transaction, so instead the scriptBytes contains some extra stuff (like a rollover nonce) that we
    ;; don't care about much.  The bytes are turned into a Script object (cached below) on demand via a getter.
#_private
    byte[] scriptBytes;
    ;; The Script object obtained from parsing scriptBytes.  Only filled in on demand and if the transaction is not
    ;; coinbase.
#_private
    WeakReference<Script> scriptSig;
    ;;; Value of the output connected to the input, if known.  This field does not participate in equals()/hashCode(). ;;
#_nilable
#_private
    Coin value;

    ;;;
     ; Creates an input that connects to nothing - used only in creation of coinbase transactions.
     ;;
#_public
    TransactionInput(NetworkParameters params, #_nilable Transaction parentTransaction, byte[] scriptBytes)
    (§
        this(params, parentTransaction, scriptBytes, new TransactionOutPoint(params, UNCONNECTED, (Transaction) nil));
    )

#_public
    TransactionInput(NetworkParameters params, #_nilable Transaction parentTransaction, byte[] scriptBytes, TransactionOutPoint outpoint)
    (§
        this(params, parentTransaction, scriptBytes, outpoint, nil);
    )

#_public
    TransactionInput(NetworkParameters params, #_nilable Transaction parentTransaction, byte[] scriptBytes, TransactionOutPoint outpoint, #_nilable Coin value)
    (§
        super(params);

        this.scriptBytes = scriptBytes;
        this.outpoint = outpoint;
        this.sequence = NO_SEQUENCE;
        this.value = value;
        setParent(parentTransaction);
        length = 40 + (scriptBytes != nil ? VarInt.sizeOf(scriptBytes.length) + scriptBytes.length : 1);
    )

    ;;;
     ; Creates an UNSIGNED input that links to the given output.
     ;;
    TransactionInput(NetworkParameters params, Transaction parentTransaction, TransactionOutput output)
    (§
        super(params);

        long outputIndex = output.getIndex();
        if (output.getParentTransaction() != nil )
            outpoint = new TransactionOutPoint(params, outputIndex, output.getParentTransaction());
        else
            outpoint = new TransactionOutPoint(params, output);
        scriptBytes = EMPTY_ARRAY;
        sequence = NO_SEQUENCE;
        setParent(parentTransaction);
        this.value = output.getValue();
        length = 41;
    )

    ;;;
     ; Deserializes an input message.  This is usually part of a transaction message.
     ;;
#_public
    TransactionInput(NetworkParameters params, #_nilable Transaction parentTransaction, byte[] payload, int offset)
        throws ProtocolException
    (§
        super(params, payload, offset);

        setParent(parentTransaction);
        this.value = nil;
    )

    ;;;
     ; Deserializes an input message.  This is usually part of a transaction message.
     ; @param params NetworkParameters object.
     ; @param payload Bitcoin protocol formatted byte array containing message content.
     ; @param offset The location of the first payload byte within the array.
     ; @param serializer The serializer to use for this message.
     ; @throws ProtocolException
     ;;
#_public
    TransactionInput(NetworkParameters params, Transaction parentTransaction, byte[] payload, int offset, MessageSerializer serializer)
        throws ProtocolException
    (§
        super(params, payload, offset, parentTransaction, serializer, UNKNOWN_LENGTH);

        this.value = nil;
    )

#_override
#_protected
    void parse()
        throws ProtocolException
    (§
        outpoint = new TransactionOutPoint(params, payload, cursor, this, serializer);
        cursor += outpoint.getMessageSize();
        int scriptLen = (int)readVarInt();
        length = cursor - offset + scriptLen + 4;
        scriptBytes = readBytes(scriptLen);
        sequence = readUint32();
    )

#_override
#_protected
    void bitcoinSerializeToStream(OutputStream stream)
        throws IOException
    (§
        outpoint.bitcoinSerialize(stream);
        stream.write(new VarInt(scriptBytes.length).encode());
        stream.write(scriptBytes);
        Utils.uint32ToByteStreamLE(sequence, stream);
    )

    ;;;
     ; Coinbase transactions have special inputs with hashes of zero.  If this is such an input, returns true.
     ;;
#_public
    boolean isCoinBase()
    (§
        return outpoint.getHash().equals(Sha256Hash.ZERO_HASH) && (outpoint.getIndex() & 0xffffffffL) == 0xffffffffL; ;; -1 but all is serialized to the wire as unsigned int.
    )

    ;;;
     ; Returns the script that is fed to the referenced output (scriptPubKey) script in order to satisfy it: usually
     ; contains signatures and maybe keys, but can contain arbitrary data if the output script accepts it.
     ;;
#_public
    Script getScriptSig()
        throws ScriptException
    (§
        ;; Transactions that generate new coins don't actually have a script.
        ;; Instead this parameter is overloaded to be something totally different.
        Script script = (scriptSig != nil) ? scriptSig.get() : nil;
        if (script == nil)
        (§
            script = new Script(scriptBytes);
            scriptSig = new WeakReference<>(script);
        )
        return script;
    )

    ;;; Set the given program as the scriptSig that is supposed to satisfy the connected output script. ;;
#_public
    void setScriptSig(Script scriptSig)
    (§
        this.scriptSig = new WeakReference<>(Preconditions.checkNotNull(scriptSig));
        ;; TODO: This should all be cleaned up so we have a consistent internal representation.
        setScriptBytes(scriptSig.getProgram());
    )

    ;;;
     ; Convenience method that returns the from address of this input by parsing the scriptSig.  The concept of
     ; a "from address" is not well defined in Bitcoin and you should not assume that senders of a transaction can
     ; actually receive coins on the same address they used to sign (e.g. this is not true for shared wallets).
     ;;
#_deprecated
#_public
    Address getFromAddress()
        throws ScriptException
    (§
        if (isCoinBase())
            throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "This is a coinbase transaction which generates new coins. It does not have a from address.");

        return getScriptSig().getFromAddress(params);
    )

    ;;;
     ; Sequence numbers allow participants in a multi-party transaction signing protocol to create new versions of the
     ; transaction independently of each other.  Newer versions of a transaction can replace an existing version that's
     ; in nodes memory pools if the existing version is time locked.  See the Contracts page on the Bitcoin wiki for
     ; examples of how you can use this feature to build contract protocols.
     ;;
#_public
    long getSequenceNumber()
    (§
        return sequence;
    )

    ;;;
     ; Sequence numbers allow participants in a multi-party transaction signing protocol to create new versions of the
     ; transaction independently of each other.  Newer versions of a transaction can replace an existing version that's
     ; in nodes memory pools if the existing version is time locked.  See the Contracts page on the Bitcoin wiki for
     ; examples of how you can use this feature to build contract protocols.
     ;;
#_public
    void setSequenceNumber(long sequence)
    (§
        unCache();
        this.sequence = sequence;
    )

    ;;;
     ; @return The previous output transaction reference, as an OutPoint structure.  This contains the
     ; data needed to connect to the output of the transaction we're gathering coins from.
     ;;
#_public
    TransactionOutPoint getOutpoint()
    (§
        return outpoint;
    )

    ;;;
     ; The "script bytes" might not actually be a script.  In coinbase transactions where new coins are minted there
     ; is no input transaction, so instead the scriptBytes contains some extra stuff (like a rollover nonce) that we
     ; don't care about much.  The bytes are turned into a Script object (cached below) on demand via a getter.
     ; @return the scriptBytes
     ;;
#_public
    byte[] getScriptBytes()
    (§
        return scriptBytes;
    )

    ;;; Clear input scripts, e.g. in preparation for signing. ;;
#_public
    void clearScriptBytes()
    (§
        setScriptBytes(TransactionInput.EMPTY_ARRAY);
    )

    ;;;
     ; @param scriptBytes The scriptBytes to set.
     ;;
    void setScriptBytes(byte[] scriptBytes)
    (§
        unCache();
        this.scriptSig = nil;
        int oldLength = length;
        this.scriptBytes = scriptBytes;
        ;; 40 = previous_outpoint (36) + sequence (4)
        int newLength = 40 + (scriptBytes != nil ? VarInt.sizeOf(scriptBytes.length) + scriptBytes.length : 1);
        adjustLength(newLength - oldLength);
    )

    ;;;
     ; @return the Transaction that owns this input.
     ;;
#_public
    Transaction getParentTransaction()
    (§
        return (Transaction)parent;
    )

    ;;;
     ; @return the value of the output connected to this input.
     ;;
#_nilable
#_public
    Coin getValue()
    (§
        return value;
    )

#_public
    enum ConnectionResult
    (§
        NO_SUCH_TX,
        ALREADY_SPENT,
        SUCCESS
    )

    ;; TODO: Clean all this up once TransactionOutPoint disappears.

    ;;;
     ; Locates the referenced output from the given pool of transactions.
     ;
     ; @return the TransactionOutput (or null) if the transaction's map doesn't contain the referenced tx.
     ;;
#_nilable
    TransactionOutput getConnectedOutput(Map<Sha256Hash, Transaction> transactions)
    (§
        Transaction tx = transactions.get(outpoint.getHash());
        return (tx != nil) ? tx.getOutputs().get((int)outpoint.getIndex()) : nil;
    )

    ;;;
     ; Alias for getOutpoint().getConnectedRedeemData(keyBag).
     ; @see TransactionOutPoint#getConnectedRedeemData(org.bitcoinj.wallet.KeyBag)
     ;;
#_nilable
#_public
    RedeemData getConnectedRedeemData(KeyBag keyBag)
        throws ScriptException
    (§
        return getOutpoint().getConnectedRedeemData(keyBag);
    )

#_public
    enum ConnectMode
    (§
        DISCONNECT_ON_CONFLICT,
        ABORT_ON_CONFLICT
    )

    ;;;
     ; Connects this input to the relevant output of the referenced transaction if it's in the given map.
     ; Connecting means updating the internal pointers and spent flags.  If the mode is to ABORT_ON_CONFLICT,
     ; then the spent output won't be changed, but the outpoint.fromTx pointer will still be updated.
     ;
     ; @param transactions Map of txhash->transaction.
     ; @param mode Whether to abort if there's a pre-existing connection or not.
     ; @return NO_SUCH_TX if the prevtx wasn't found, ALREADY_SPENT if there was a conflict, SUCCESS if not.
     ;;
#_public
    ConnectionResult connect(Map<Sha256Hash, Transaction> transactions, ConnectMode mode)
    (§
        Transaction tx = transactions.get(outpoint.getHash());
        return (tx != nil) ? connect(tx, mode) : TransactionInput.ConnectionResult.NO_SUCH_TX;
    )

    ;;;
     ; Connects this input to the relevant output of the referenced transaction.
     ; Connecting means updating the internal pointers and spent flags.  If the mode is to ABORT_ON_CONFLICT,
     ; then the spent output won't be changed, but the outpoint.fromTx pointer will still be updated.
     ;
     ; @param transaction The transaction to try.
     ; @param mode Whether to abort if there's a pre-existing connection or not.
     ; @return NO_SUCH_TX if transaction is not the prevtx, ALREADY_SPENT if there was a conflict, SUCCESS if not.
     ;;
#_public
    ConnectionResult connect(Transaction transaction, ConnectMode mode)
    (§
        if (!transaction.getHash().equals(outpoint.getHash()))
            return ConnectionResult.NO_SUCH_TX;

        Preconditions.checkElementIndex((int)outpoint.getIndex(), transaction.getOutputs().size(), "Corrupt transaction");

        TransactionOutput out = transaction.getOutput((int)outpoint.getIndex());
        if (!out.isAvailableForSpending())
        (§
            if (getParentTransaction().equals(outpoint.fromTx))
            (§
                ;; Already connected.
                return ConnectionResult.SUCCESS;
            )
            else if (mode == ConnectMode.DISCONNECT_ON_CONFLICT)
            (§
                out.markAsUnspent();
            )
            else if (mode == ConnectMode.ABORT_ON_CONFLICT)
            (§
                outpoint.fromTx = out.getParentTransaction();
                return TransactionInput.ConnectionResult.ALREADY_SPENT;
            )
        )
        connect(out);
        return TransactionInput.ConnectionResult.SUCCESS;
    )

    ;;; Internal use only: connects this TransactionInput to the given output (updates pointers and spent flags). ;;
#_public
    void connect(TransactionOutput out)
    (§
        outpoint.fromTx = out.getParentTransaction();
        out.markAsSpent(this);
        value = out.getValue();
    )

    ;;;
     ; If this input is connected, check the output is connected back to this input and release it if so, making
     ; it spendable once again.
     ;
     ; @return true if the disconnection took place, false if it was not connected.
     ;;
#_public
    boolean disconnect()
    (§
        TransactionOutput connectedOutput;
        if (outpoint.fromTx != nil)
        (§
            ;; The outpoint is connected using a "standard" wallet, disconnect it.
            connectedOutput = outpoint.fromTx.getOutput((int)outpoint.getIndex());
            outpoint.fromTx = nil;
        )
        else if (outpoint.connectedOutput != nil)
        (§
            ;; The outpoint is connected using a UTXO based wallet, disconnect it.
            connectedOutput = outpoint.connectedOutput;
            outpoint.connectedOutput = nil;
        )
        else
        (§
            ;; The outpoint is not connected, do nothing.
            return false;
        )

        if (connectedOutput != nil && connectedOutput.getSpentBy() == this)
        (§
            ;; The outpoint was connected to an output, disconnect the output.
            connectedOutput.markAsUnspent();
            return true;
        )

        return false;
    )

    ;;;
     ; @return true if this transaction's sequence number is set (i.e. it may be a part of a time-locked transaction).
     ;;
#_public
    boolean hasSequence()
    (§
        return (sequence != NO_SEQUENCE);
    )

    ;;;
     ; Returns whether this input will cause a transaction to opt into the
     ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki">full replace-by-fee</a> semantics.
     ;;
#_public
    boolean isOptInFullRBF()
    (§
        return (sequence < NO_SEQUENCE - 1);
    )

    ;;;
     ; For a connected transaction, runs the script against the connected pubkey and verifies they are correct.
     ; @throws ScriptException if the script did not verify.
     ; @throws VerificationException if the outpoint doesn't match the given output.
     ;;
#_public
    void verify()
        throws VerificationException
    (§
#_final
        Transaction fromTx = getOutpoint().fromTx;
        long spendingIndex = getOutpoint().getIndex();

        Preconditions.checkNotNull(fromTx, "Not connected");

#_final
        TransactionOutput output = fromTx.getOutput((int)spendingIndex);
        verify(output);
    )

    ;;;
     ; Verifies that this input can spend the given output.  Note that this input must be a part of a transaction.
     ; Also note that the consistency of the outpoint will be checked, even if this input has not been connected.
     ;
     ; @param output The output that this input is supposed to spend.
     ; @throws ScriptException if the script doesn't verify.
     ; @throws VerificationException if the outpoint doesn't match the given output.
     ;;
#_public
    void verify(TransactionOutput output)
        throws VerificationException
    (§
        if (output.parent != nil)
        (§
            if (!getOutpoint().getHash().equals(output.getParentTransaction().getHash()))
                throw new VerificationException("This input does not refer to the tx containing the output.");
            if (getOutpoint().getIndex() != output.getIndex())
                throw new VerificationException("This input refers to a different output on the given tx.");
        )
        Script pubKey = output.getScriptPubKey();
        int myIndex = getParentTransaction().getInputs().indexOf(this);
        getScriptSig().correctlySpends(getParentTransaction(), myIndex, pubKey);
    )

    ;;;
     ; Returns the connected output, assuming the input was connected with
     ; {@link TransactionInput#connect(TransactionOutput)} or variants at some point.
     ; If it wasn't connected, then this method returns null.
     ;;
#_nilable
#_public
    TransactionOutput getConnectedOutput()
    (§
        return getOutpoint().getConnectedOutput();
    )

    ;;;
     ; Returns the connected transaction, assuming the input was connected with
     ; {@link TransactionInput#connect(TransactionOutput)} or variants at some point.
     ; If it wasn't connected, then this method returns null.
     ;;
#_nilable
#_public
    Transaction getConnectedTransaction()
    (§
        return getOutpoint().fromTx;
    )

    ;;; Returns a copy of the input detached from its containing transaction, if need be. ;;
#_public
    TransactionInput duplicateDetached()
    (§
        return new TransactionInput(params, nil, bitcoinSerialize(), 0);
    )

    ;;;
     ; <p>Returns either RuleViolation.NONE if the input is standard, or which rule makes it non-standard if so.
     ; The "IsStandard" rules control whether the default Bitcoin Core client blocks relay of a tx / refuses to mine it,
     ; however, non-standard transactions can still be included in blocks and will be accepted as valid if so.</p>
     ;
     ; <p>This method simply calls <tt>DefaultRiskAnalysis.isInputStandard(this)</tt>.</p>
     ;;
#_public
    DefaultRiskAnalysis.RuleViolation isStandard()
    (§
        return DefaultRiskAnalysis.isInputStandard(this);
    )

#_override
#_public
    boolean equals(Object o)
    (§
        if (this == o)
            return true;
        if (o == nil || getClass() != o.getClass())
            return false;
        TransactionInput other = (TransactionInput)o;
        return (sequence == other.sequence && parent == other.parent && outpoint.equals(other.outpoint) && Arrays.equals(scriptBytes, other.scriptBytes));
    )

#_override
#_public
    int hashCode()
    (§
        return Objects.hashCode(sequence, outpoint, Arrays.hashCode(scriptBytes));
    )

    ;;;
     ; Returns a human readable debug string.
     ;;
#_override
#_public
    String toString()
    (§
        try
        (§
            StringBuilder sb = new StringBuilder("TxIn");
            if (isCoinBase())
            (§
                sb.append(": COINBASE");
            )
            else
            (§
                sb.append(" for [").append(outpoint).append("]: ").append(getScriptSig());
                String flags = Joiner.on(", ").skipNulls().join(hasSequence() ? "sequence: " + Long.toHexString(sequence) : nil, isOptInFullRBF() ? "opts into full RBF" : nil);
                if (!flags.isEmpty())
                    sb.append(" (").append(flags).append(')');
            )
            return sb.toString();
        )
        catch (ScriptException e)
        (§
            throw new RuntimeException(e);
        )
    )
)

(ns org.bitcoinj.core #_"TransactionOutPoint"
    (:import #_[java.io *])
    (:import [com.google.common.base Objects Preconditions])
  #_(:require #_[org.bitcoinj.script *]
             #_[org.bitcoinj.wallet *]))

;;;
 ; <p>This message is a reference or pointer to an output of a different transaction.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
class TransactionOutPoint extends ChildMessage
(§
#_static
#_final
    int MESSAGE_LENGTH = 36;

    ;;; Hash of the transaction to which we refer. ;;
#_private
    Sha256Hash hash;
    ;;; Which output of that transaction we are talking about. ;;
#_private
    long index;

    ;; This is not part of bitcoin serialization.  It points to the connected transaction.
    Transaction fromTx;

    ;; The connected output.
    TransactionOutput connectedOutput;

#_public
    TransactionOutPoint(NetworkParameters params, long index, #_nilable Transaction fromTx)
    (§
        super(params);

        this.index = index;
        if (fromTx != nil)
        (§
            this.hash = fromTx.getHash();
            this.fromTx = fromTx;
        )
        else
        (§
            ;; This happens when constructing the genesis block.
            hash = Sha256Hash.ZERO_HASH;
        )
        length = MESSAGE_LENGTH;
    )

#_public
    TransactionOutPoint(NetworkParameters params, long index, Sha256Hash hash)
    (§
        super(params);

        this.index = index;
        this.hash = hash;
        length = MESSAGE_LENGTH;
    )

#_public
    TransactionOutPoint(NetworkParameters params, TransactionOutput connectedOutput)
    (§
        this(params, connectedOutput.getIndex(), connectedOutput.getParentTransactionHash());
        this.connectedOutput = connectedOutput;
    )

    ;;;
     ; Deserializes the message.  This is usually part of a transaction message.
     ;;
#_public
    TransactionOutPoint(NetworkParameters params, byte[] payload, int offset)
        throws ProtocolException
    (§
        super(params, payload, offset);
    )

    ;;;
     ; Deserializes the message.  This is usually part of a transaction message.
     ; @param params NetworkParameters object.
     ; @param offset The location of the first payload byte within the array.
     ; @param serializer The serializer to use for this message.
     ; @throws ProtocolException
     ;;
#_public
    TransactionOutPoint(NetworkParameters params, byte[] payload, int offset, Message parent, MessageSerializer serializer)
        throws ProtocolException
    (§
        super(params, payload, offset, parent, serializer, MESSAGE_LENGTH);
    )

#_override
#_protected
    void parse()
        throws ProtocolException
    (§
        length = MESSAGE_LENGTH;
        hash = readHash();
        index = readUint32();
    )

#_override
#_protected
    void bitcoinSerializeToStream(OutputStream stream)
        throws IOException
    (§
        stream.write(hash.getReversedBytes());
        Utils.uint32ToByteStreamLE(index, stream);
    )

    ;;;
     ; An outpoint is a part of a transaction input that points to the output of another transaction.  If we have both
     ; sides in memory, and they have been linked together, this returns a pointer to the connected output, or null
     ; if there is no such connection.
     ;;
#_nilable
#_public
    TransactionOutput getConnectedOutput()
    (§
        if (fromTx != nil)
            return fromTx.getOutputs().get((int)index);
        if (connectedOutput != nil)
            return connectedOutput;
        return nil;
    )

    ;;;
     ; Returns the pubkey script from the connected output.
     ; @throws java.lang.NullPointerException if there is no connected output.
     ;;
#_public
    byte[] getConnectedPubKeyScript()
    (§
        byte[] result = Preconditions.checkNotNull(getConnectedOutput()).getScriptBytes();
        Preconditions.checkState(0 < result.length);
        return result;
    )

    ;;;
     ; Returns the ECKey identified in the connected output, for either pay-to-address scripts or pay-to-key scripts.
     ; For P2SH scripts you can use {@link #getConnectedRedeemData(org.bitcoinj.wallet.KeyBag)} and then get the
     ; key from RedeemData.
     ; If the script form cannot be understood, throws ScriptException.
     ;
     ; @return an ECKey or null if the connected key cannot be found in the wallet.
     ;;
#_nilable
#_public
    ECKey getConnectedKey(KeyBag keyBag)
        throws ScriptException
    (§
        TransactionOutput connectedOutput = getConnectedOutput();
        Preconditions.checkNotNull(connectedOutput, "Input is not connected so cannot retrieve key");
        Script connectedScript = connectedOutput.getScriptPubKey();

        if (connectedScript.isSentToAddress())
        (§
            byte[] addressBytes = connectedScript.getPubKeyHash();
            return keyBag.findKeyFromPubHash(addressBytes);
        )

        if (connectedScript.isSentToRawPubKey())
        (§
            byte[] pubkeyBytes = connectedScript.getPubKey();
            return keyBag.findKeyFromPubKey(pubkeyBytes);
        )

        throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "Could not understand form of connected output script: " + connectedScript);
    )

    ;;;
     ; Returns the RedeemData identified in the connected output, for either pay-to-address scripts, pay-to-key
     ; or P2SH scripts.
     ; If the script forms cannot be understood, throws ScriptException.
     ;
     ; @return a RedeemData or null if the connected data cannot be found in the wallet.
     ;;
#_nilable
#_public
    RedeemData getConnectedRedeemData(KeyBag keyBag)
        throws ScriptException
    (§
        TransactionOutput connectedOutput = getConnectedOutput();
        Preconditions.checkNotNull(connectedOutput, "Input is not connected so cannot retrieve key");
        Script connectedScript = connectedOutput.getScriptPubKey();

        if (connectedScript.isSentToAddress())
        (§
            byte[] addressBytes = connectedScript.getPubKeyHash();
            return RedeemData.of(keyBag.findKeyFromPubHash(addressBytes), connectedScript);
        )

        if (connectedScript.isSentToRawPubKey())
        (§
            byte[] pubkeyBytes = connectedScript.getPubKey();
            return RedeemData.of(keyBag.findKeyFromPubKey(pubkeyBytes), connectedScript);
        )

        if (connectedScript.isPayToScriptHash())
        (§
            byte[] scriptHash = connectedScript.getPubKeyHash();
            return keyBag.findRedeemDataFromScriptHash(scriptHash);
        )

        throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "Could not understand form of connected output script: " + connectedScript);
    )

#_override
#_public
    String toString()
    (§
        return hash + ":" + index;
    )

    ;;;
     ; Returns the hash of the transaction this outpoint references/spends/is connected to.
     ;;
#_override
#_public
    Sha256Hash getHash()
    (§
        return hash;
    )

    void setHash(Sha256Hash hash)
    (§
        this.hash = hash;
    )

#_public
    long getIndex()
    (§
        return index;
    )

#_public
    void setIndex(long index)
    (§
        this.index = index;
    )

#_override
#_public
    boolean equals(Object o)
    (§
        if (this == o)
            return true;
        if (o == nil || getClass() != o.getClass())
            return false;
        TransactionOutPoint other = (TransactionOutPoint)o;
        return (getIndex() == other.getIndex() && getHash().equals(other.getHash()));
    )

#_override
#_public
    int hashCode()
    (§
        return Objects.hashCode(getIndex(), getHash());
    )
)

(ns org.bitcoinj.core #_"TransactionOutput"
    (:import #_[java.io *]
             #_[java.util *])
    (:import [com.google.common.base Objects Preconditions]
             #_[org.slf4j *])
  #_(:require #_[org.bitcoinj.script *]
             [org.bitcoinj.wallet Wallet]))

;;;
 ; <p>A TransactionOutput message contains a scriptPubKey that controls who is able to spend its value.
 ; It is a sub-part of the Transaction message.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
class TransactionOutput extends ChildMessage
(§
#_private
#_static
#_final
    Logger log = LoggerFactory.getLogger(TransactionOutput.class);

    ;; The output's value is kept as a native type in order to save class instances.
#_private
    long value;

    ;; A transaction output has a script used for authenticating that the redeemer is allowed to spend
    ;; this output.
#_private
    byte[] scriptBytes;

    ;; The script bytes are parsed and turned into a Script on demand.
#_private
    Script scriptPubKey;

    ;; These fields are not Bitcoin serialized.  They are used for tracking purposes in our wallet only.
    ;; If set to true, this output is counted towards our balance.  If false and spentBy is null the tx output
    ;; was owned by us and was sent to somebody else.  If false and spentBy is set it means this output was owned
    ;; by us and used in one of our own transactions (e.g. because it is a change output).
#_private
    boolean availableForSpending;
#_nilable
#_private
    TransactionInput spentBy;

#_private
    int scriptLen;

    ;;;
     ; Deserializes a transaction output message.  This is usually part of a transaction message.
     ;;
#_public
    TransactionOutput(NetworkParameters params, #_nilable Transaction parent, byte[] payload, int offset)
        throws ProtocolException
    (§
        super(params, payload, offset);

        setParent(parent);
        availableForSpending = true;
    )

    ;;;
     ; Deserializes a transaction output message.  This is usually part of a transaction message.
     ;
     ; @param params NetworkParameters object.
     ; @param payload Bitcoin protocol formatted byte array containing message content.
     ; @param offset The location of the first payload byte within the array.
     ; @param serializer The serializer to use for this message.
     ; @throws ProtocolException
     ;;
#_public
    TransactionOutput(NetworkParameters params, #_nilable Transaction parent, byte[] payload, int offset, MessageSerializer serializer)
        throws ProtocolException
    (§
        super(params, payload, offset, parent, serializer, UNKNOWN_LENGTH);

        availableForSpending = true;
    )

    ;;;
     ; Creates an output that sends 'value' to the given address (public key hash).  The amount should be
     ; created with something like {@link Coin#valueOf(int, int)}.  Typically you would use
     ; {@link Transaction#addOutput(Coin, Address)} instead of creating a TransactionOutput directly.
     ;;
#_public
    TransactionOutput(NetworkParameters params, #_nilable Transaction parent, Coin value, Address to)
    (§
        this(params, parent, value, ScriptBuilder.createOutputScript(to).getProgram());
    )

    ;;;
     ; Creates an output that sends 'value' to the given public key using a simple CHECKSIG script (no addresses).
     ; The amount should be created with something like {@link Coin#valueOf(int, int)}.  Typically you would use
     ; {@link Transaction#addOutput(Coin, ECKey)} instead of creating an output directly.
     ;;
#_public
    TransactionOutput(NetworkParameters params, #_nilable Transaction parent, Coin value, ECKey to)
    (§
        this(params, parent, value, ScriptBuilder.createOutputScript(to).getProgram());
    )

#_public
    TransactionOutput(NetworkParameters params, #_nilable Transaction parent, Coin value, byte[] scriptBytes)
    (§
        super(params);

        ;; Negative values obviously make no sense, except for -1 which is used as a sentinel value when calculating
        ;; SIGHASH_SINGLE signatures, so unfortunately we have to allow that here.
        Preconditions.checkArgument(0 <= value.signum() || value.equals(Coin.NEGATIVE_SATOSHI), "Negative values not allowed");
        Preconditions.checkArgument(!params.hasMaxMoney() || value.compareTo(params.getMaxMoney()) <= 0, "Values larger than MAX_MONEY not allowed");

        this.value = value.value;
        this.scriptBytes = scriptBytes;
        setParent(parent);
        availableForSpending = true;
        length = 8 + VarInt.sizeOf(scriptBytes.length) + scriptBytes.length;
    )

#_public
    Script getScriptPubKey()
        throws ScriptException
    (§
        if (scriptPubKey == nil)
            scriptPubKey = new Script(scriptBytes);
        return scriptPubKey;
    )

    ;;;
     ; <p>If the output script pays to an address as in <a href="https://bitcoin.org/en/developer-guide#term-p2pkh">P2PKH</a>,
     ; return the address of the receiver, i.e. a base58 encoded hash of the public key in the script.</p>
     ;
     ; @param networkParameters Needed to specify an address.
     ; @return null, if the output script is not the form <i>OP_DUP OP_HASH160 <PubkeyHash> OP_EQUALVERIFY OP_CHECKSIG</i>,
     ; i.e. not P2PKH.
     ; @return an address made out of the public key hash.
     ;;
#_nilable
#_public
    Address getAddressFromP2PKHScript(NetworkParameters networkParameters)
        throws ScriptException
    (§
        return getScriptPubKey().isSentToAddress() ? getScriptPubKey().getToAddress(networkParameters) : nil;
    )

    ;;;
     ; <p>If the output script pays to a redeem script, return the address of the redeem script as described by,
     ; i.e. a base58 encoding of [one-byte version][20-byte hash][4-byte checksum], where the 20-byte hash refers to
     ; the redeem script.</p>
     ;
     ; <p>P2SH is described by <a href="https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki">BIP 16</a> and
     ; <a href="https://bitcoin.org/en/developer-guide#p2sh-scripts">documented in the Bitcoin Developer Guide</a>.</p>
     ;
     ; @param networkParameters Needed to specify an address.
     ; @return null if the output script does not pay to a script hash.
     ; @return an address that belongs to the redeem script.
     ;;
#_nilable
#_public
    Address getAddressFromP2SH(NetworkParameters networkParameters)
        throws ScriptException
    (§
        return getScriptPubKey().isPayToScriptHash() ? getScriptPubKey().getToAddress(networkParameters) : nil;
    )

#_override
#_protected
    void parse()
        throws ProtocolException
    (§
        value = readInt64();
        scriptLen = (int)readVarInt();
        length = cursor - offset + scriptLen;
        scriptBytes = readBytes(scriptLen);
    )

#_override
#_protected
    void bitcoinSerializeToStream(OutputStream stream)
        throws IOException
    (§
        Preconditions.checkNotNull(scriptBytes);

        Utils.int64ToByteStreamLE(value, stream);
        ;; TODO: Move script serialization into the Script class, where it belongs.
        stream.write(new VarInt(scriptBytes.length).encode());
        stream.write(scriptBytes);
    )

    ;;;
     ; Returns the value of this output.
     ; This is the amount of currency that the destination address receives.
     ;;
#_public
    Coin getValue()
    (§
        try
        (§
            return Coin.valueOf(value);
        )
        catch (IllegalArgumentException e)
        (§
            throw new IllegalStateException(e.getMessage(), e);
        )
    )

    ;;;
     ; Sets the value of this output.
     ;;
#_public
    void setValue(Coin value)
    (§
        Preconditions.checkNotNull(value);

        unCache();
        this.value = value.value;
    )

    ;;;
     ; Gets the index of this output in the parent transaction, or throws if this output is free standing.
     ; Iterates over the parents list to discover this.
     ;;
#_public
    int getIndex()
    (§
        List<TransactionOutput> outputs = getParentTransaction().getOutputs();
        for (int i = 0; i < outputs.size(); i++)
            if (outputs.get(i) == this)
                return i;

        throw new IllegalStateException("Output linked to wrong parent transaction?");
    )

    ;;;
     ; Will this transaction be relayable and mined by default miners?
     ;;
#_public
    boolean isDust()
    (§
        ;; Transactions that are OP_RETURN can't be dust regardless of their value.
        return getScriptPubKey().isOpReturn() ? false : getValue().isLessThan(getMinNonDustValue());
    )

    ;;;
     ; <p>Gets the minimum value for a txout of this size to be considered non-dust by Bitcoin Core
     ; (and thus relayed).  See CTxOut::IsDust() in Bitcoin Core.  The assumption is that any output that would
     ; consume more than a third of its value in fees is not something the Bitcoin system wants to deal with right now,
     ; so we call them "dust outputs" and they're made non standard.  The choice of one third is somewhat arbitrary and
     ; may change in future.</p>
     ;
     ; <p>You probably should use {@link org.bitcoinj.core.TransactionOutput#getMinNonDustValue()} which uses
     ; a safe fee-per-kb by default.</p>
     ;
     ; @param feePerKb The fee required per kilobyte.  Note that this is the same as Bitcoin Core's -minrelaytxfee * 3.
     ;;
#_public
    Coin getMinNonDustValue(Coin feePerKb)
    (§
        ;; A typical output is 33 bytes (pubkey hash + opcodes) and requires an input of 148 bytes to spend so we add
        ;; that together to find out the total amount of data used to transfer this amount of value.  Note that this
        ;; formula is wrong for anything that's not a pay-to-address output, unfortunately, we must follow Bitcoin Core's
        ;; wrongness in order to ensure we're considered standard.  A better formula would either estimate the
        ;; size of data needed to satisfy all different script types, or just hard code 33 below.
#_final
        long size = this.unsafeBitcoinSerialize().length + 148;
        return feePerKb.multiply(size).divide(1000);
    )

    ;;;
     ; Returns the minimum value for this output to be considered "not dust", i.e. the transaction will be relayable
     ; and mined by default miners.  For normal pay to address outputs, this is 2730 satoshis, the same as
     ; {@link Transaction#MIN_NONDUST_OUTPUT}.
     ;;
#_public
    Coin getMinNonDustValue()
    (§
        return getMinNonDustValue(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.multiply(3));
    )

    ;;;
     ; Sets this objects availableForSpending flag to false and the spentBy pointer to the given input.
     ; If the input is null, it means this output was signed over to somebody else rather than one of our own keys.
     ; @throws IllegalStateException if the transaction was already marked as spent.
     ;;
#_public
    void markAsSpent(TransactionInput input)
    (§
        Preconditions.checkState(availableForSpending);

        availableForSpending = false;
        spentBy = input;

        if (log.isDebugEnabled())
        (§
            if (parent != nil)
                log.debug("Marked {}:{} as spent by {}", getParentTransactionHash(), getIndex(), input);
            else
                log.debug("Marked floating output as spent by {}", input);
        )
    )

    ;;;
     ; Resets the spent pointer / availableForSpending flag to null.
     ;;
#_public
    void markAsUnspent()
    (§
        if (log.isDebugEnabled())
        (§
            if (parent != nil)
                log.debug("Un-marked {}:{} as spent by {}", getParentTransactionHash(), getIndex(), spentBy);
            else
                log.debug("Un-marked floating output as spent by {}", spentBy);
        )

        availableForSpending = true;
        spentBy = nil;
    )

    ;;;
     ; Returns whether {@link TransactionOutput#markAsSpent(TransactionInput)} has been called on this class.
     ; A {@link Wallet} will mark a transaction output as spent once it sees a transaction input that is connected to it.
     ; Note that this flag can be false when an output has in fact been spent according to the rest of the network if
     ; the spending transaction wasn't downloaded yet, and it can be marked as spent when in reality the rest of the
     ; network believes it to be unspent if the signature or script connecting to it was not actually valid.
     ;;
#_public
    boolean isAvailableForSpending()
    (§
        return availableForSpending;
    )

    ;;;
     ; The backing script bytes which can be turned into a Script object.
     ; @return the scriptBytes
    ;;
#_public
    byte[] getScriptBytes()
    (§
        return scriptBytes;
    )

    ;;;
     ; Returns true if this output is to a key, or an address we have the keys for, in the wallet.
     ;;
#_public
    boolean isMine(TransactionBag transactionBag)
    (§
        try
        (§
            Script script = getScriptPubKey();
            if (script.isSentToRawPubKey())
                return transactionBag.isPubKeyMine(script.getPubKey());
            if (script.isPayToScriptHash())
                return transactionBag.isPayToScriptHashMine(script.getPubKeyHash());
            return transactionBag.isPubKeyHashMine(script.getPubKeyHash());
        )
        catch (ScriptException e)
        (§
            ;; Just means we didn't understand the output of this transaction: ignore it.
            log.debug("Could not parse tx {} output script: {}", (parent != nil) ? parent.getHash() : "(no parent)", e.toString());
            return false;
        )
    )

    ;;;
     ; Returns a human readable debug string.
     ;;
#_override
#_public
    String toString()
    (§
        try
        (§
            Script script = getScriptPubKey();
            StringBuilder sb = new StringBuilder("TxOut of ");
            sb.append(Coin.valueOf(value).toFriendlyString());
            if (script.isSentToAddress() || script.isPayToScriptHash())
                sb.append(" to ").append(script.getToAddress(params));
            else if (script.isSentToRawPubKey())
                sb.append(" to pubkey ").append(Utils.HEX.encode(script.getPubKey()));
            else if (script.isSentToMultiSig())
                sb.append(" to multisig");
            else
                sb.append(" (unknown type)");
            sb.append(" script:").append(script);
            return sb.toString();
        )
        catch (ScriptException e)
        (§
            throw new RuntimeException(e);
        )
    )

    ;;;
     ; Returns the connected input.
     ;;
#_nilable
#_public
    TransactionInput getSpentBy()
    (§
        return spentBy;
    )

    ;;;
     ; Returns the transaction that owns this output.
     ;;
#_nilable
#_public
    Transaction getParentTransaction()
    (§
        return (Transaction)parent;
    )

    ;;;
     ; Returns the transaction hash that owns this output.
     ;;
#_nilable
#_public
    Sha256Hash getParentTransactionHash()
    (§
        return (parent != nil) ? parent.getHash() : nil;
    )

    ;;;
     ; Returns the depth in blocks of the parent tx.
     ;
     ; <p>If the transaction appears in the top block, the depth is one.
     ; If it's anything else (pending, dead, unknown), then -1.</p>
     ; @return the tx depth or -1.
     ;;
#_public
    int getParentTransactionDepthInBlocks()
    (§
        if (getParentTransaction() != nil)
        (§
            TransactionConfidence confidence = getParentTransaction().getConfidence();
            if (confidence.getConfidenceType() == TransactionConfidence.ConfidenceType.BUILDING)
                return confidence.getDepthInBlocks();
        )
        return -1;
    )

    ;;;
     ; Returns a new {@link TransactionOutPoint}, which is essentially a structure pointing to this output.
     ; Requires that this output is not detached.
     ;;
#_public
    TransactionOutPoint getOutPointFor()
    (§
        return new TransactionOutPoint(params, getIndex(), getParentTransaction());
    )

    ;;; Returns a copy of the output detached from its containing transaction, if need be. ;;
#_public
    TransactionOutput duplicateDetached()
    (§
        return new TransactionOutput(params, nil, Coin.valueOf(value), org.spongycastle.util.Arrays.clone(scriptBytes));
    )

#_override
#_public
    boolean equals(Object o)
    (§
        if (this == o)
            return true;
        if (o == nil || getClass() != o.getClass())
            return false;
        TransactionOutput other = (TransactionOutput)o;
        return (value == other.value && (parent == nil || (parent == other.parent && getIndex() == other.getIndex())) && Arrays.equals(scriptBytes, other.scriptBytes));
    )

#_override
#_public
    int hashCode()
    (§
        return Objects.hashCode(value, parent, Arrays.hashCode(scriptBytes));
    )
)

(ns org.bitcoinj.core #_"TransactionOutputChanges"
    (:import [java.io IOException InputStream OutputStream]
             [java.util LinkedList List]))

;;;
 ; <p>TransactionOutputChanges represents a delta to the set of unspent outputs.  It used as a return value for
 ; {@link AbstractBlockChain#connectTransactions(int, Block)}.  It contains the full list of transaction outputs created
 ; and spent in a block.  It DOES contain outputs created that were spent later in the block, as those are needed for
 ; BIP30 (no duplicate txid creation if the previous one was not fully spent prior to this block) verification.</p>
 ;;
#_public
class TransactionOutputChanges
(§
#_public
#_final
    List<UTXO> txOutsCreated;
#_public
#_final
    List<UTXO> txOutsSpent;

#_public
    TransactionOutputChanges(List<UTXO> txOutsCreated, List<UTXO> txOutsSpent)
    (§
        this.txOutsCreated = txOutsCreated;
        this.txOutsSpent = txOutsSpent;
    )

#_private
#_static
#_final
    int read4x8le(InputStream is)
        throws IOException
    (§
        return (is.read() & 0xff) | ((is.read() & 0xff) << 8) | ((is.read() & 0xff) << 16) | ((is.read() & 0xff) << 24);
    )

#_public
    TransactionOutputChanges(InputStream is)
        throws IOException
    (§
        int nCreated = read4x8le(is);
        txOutsCreated = new LinkedList<>();
        for (int i = 0; i < nCreated; i++)
            txOutsCreated.add(new UTXO(is));

        int nSpent = read4x8le(is);
        txOutsSpent = new LinkedList<>();
        for (int i = 0; i < nSpent; i++)
            txOutsSpent.add(new UTXO(is));
    )

#_private
#_static
#_final
    void write4x8le(OutputStream os, int n)
        throws IOException
    (§
        os.write(0xff & n);
        os.write(0xff & (n >> 8));
        os.write(0xff & (n >> 16));
        os.write(0xff & (n >> 24));
    )

#_public
    void serializeToStream(OutputStream os)
        throws IOException
    (§
        write4x8le(os, txOutsCreated.size());
        for (UTXO output : txOutsCreated)
            output.serializeToStream(os);

        write4x8le(os, txOutsSpent.size());
        for (UTXO output : txOutsSpent)
            output.serializeToStream(os);
    )
)

(ns org.bitcoinj.core #_"TxConfidenceTable"
    (:import #_[java.lang.ref *]
             #_[java.util *]
             #_[java.util.concurrent.locks *])
    (:import [com.google.common.base Preconditions])
  #_(:require #_[org.bitcoinj.utils *]))

;;;
 ; <p>Tracks transactions that are being announced across the network.  Typically one is created for you by a
 ; {@link PeerGroup} and then given to each Peer to update.  The current purpose is to let Peers update the confidence
 ; (number of peers broadcasting).  It helps address an attack scenario in which a malicious remote peer (or several)
 ; feeds you invalid transactions, e.g. ones that spend coins which don't exist.  If you don't see most of the peers
 ; announce the transaction within a reasonable time, it may be that the TX is not valid.  Alternatively, an attacker
 ; may control your entire internet connection: in this scenario counting broadcasting peers does not help you.</p>
 ;
 ; <p>It is <b>not</b> at this time directly equivalent to the Bitcoin Core memory pool, which tracks
 ; all transactions not currently included in the best chain - it's simply a cache.</p>
 ;;
#_public
class TxConfidenceTable
(§
#_protected
    ReentrantLock lock = Threading.lock("txconfidencetable");

#_private
#_static
    class WeakConfidenceReference extends WeakReference<TransactionConfidence>
    (§
#_public
        Sha256Hash hash;

#_public
        WeakConfidenceReference(TransactionConfidence confidence, ReferenceQueue<TransactionConfidence> queue)
        (§
            super(confidence, queue);

            hash = confidence.getTransactionHash();
        )
    )
#_private
    LinkedHashMap<Sha256Hash, WeakConfidenceReference> table;

    ;; This ReferenceQueue gets entries added to it when they are only weakly reachable, i.e. the TxConfidenceTable is
    ;; the only thing that is tracking the confidence data anymore.  We check it from time to time and delete table entries
    ;; corresponding to expired transactions.  In this way memory usage of the system is in line with however many
    ;; transactions you actually care to track the confidence of.  We can still end up with lots of hashes being stored
    ;; if our peers flood us with invs but the MAX_SIZE param caps this.
#_private
    ReferenceQueue<TransactionConfidence> referenceQueue;

    ;;; The max size of a table created with the no-args constructor. ;;
#_public
#_static
#_final
    int MAX_SIZE = 1000;

    ;;;
     ; Creates a table that will track at most the given number of transactions (allowing you to bound memory usage).
     ; @param size Max number of transactions to track.  The table will fill up to this size then stop growing.
     ;;
#_public
    TxConfidenceTable(final int size)
    (§
        table = new LinkedHashMap<Sha256Hash, WeakConfidenceReference>()
        (§
#_override
#_protected
            boolean removeEldestEntry(Map.Entry<Sha256Hash, WeakConfidenceReference> entry)
            (§
                ;; An arbitrary choice to stop the memory used by tracked transactions getting too huge in the event
                ;; of some kind of DoS attack.
                return (size < size());
            )
        );
        referenceQueue = new ReferenceQueue<>();
    )

    ;;;
     ; Creates a table that will track at most {@link TxConfidenceTable#MAX_SIZE} entries.
     ; You should normally use this constructor.
     ;;
#_public
    TxConfidenceTable()
    (§
        this(MAX_SIZE);
    )

    ;;;
     ; If any transactions have expired due to being only weakly reachable through us, go ahead and delete their
     ; table entries - it means we downloaded the transaction and sent it to various event listeners, none of
     ; which bothered to keep a reference.  Typically, this is because the transaction does not involve any keys
     ; that are relevant to any of our wallets.
     ;;
#_private
    void cleanTable()
    (§
        lock.lock();
        try
        (§
            Reference<? extends TransactionConfidence> ref;
            while ((ref = referenceQueue.poll()) != nil)
            (§
                ;; Find which transaction got deleted by the GC.
                WeakConfidenceReference txRef = (WeakConfidenceReference)ref;
                ;; And remove the associated map entry, so the other bits of memory can also be reclaimed.
                table.remove(txRef.hash);
            )
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Returns the number of peers that have seen the given hash recently.
     ;;
#_public
    int numBroadcastPeers(Sha256Hash txHash)
    (§
        lock.lock();
        try
        (§
            cleanTable();
            WeakConfidenceReference entry = table.get(txHash);
            if (entry == nil)
                return 0; ;; No such TX known.

            TransactionConfidence confidence = entry.get();
            if (confidence == nil)
            (§
                ;; Such a TX hash was seen, but nothing seemed to care, so we ended up throwing away the data.
                table.remove(txHash);
                return 0;
            )

            return confidence.numBroadcastPeers();
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Called by peers when they see a transaction advertised in an "inv" message.  It passes the data on to the relevant
     ; {@link org.bitcoinj.core.TransactionConfidence} object, creating it if needed.
     ;
     ; @return the number of peers that have now announced this hash (including the caller).
     ;;
#_public
    TransactionConfidence seen(Sha256Hash hash, PeerAddress byPeer)
    (§
        TransactionConfidence confidence;
        boolean fresh = false;
        lock.lock();
        (§
            cleanTable();
            confidence = getOrCreate(hash);
            fresh = confidence.markBroadcastBy(byPeer);
        )
        lock.unlock();
        if (fresh)
            confidence.queueListeners(TransactionConfidence.Listener.ChangeReason.SEEN_PEERS);
        return confidence;
    )

    ;;;
     ; Returns the {@link TransactionConfidence} for the given hash if we have downloaded it, or null if that tx hash
     ; is unknown to the system at this time.
     ;;
#_public
    TransactionConfidence getOrCreate(Sha256Hash hash)
    (§
        Preconditions.checkNotNull(hash);

        lock.lock();
        try
        (§
            WeakConfidenceReference reference = table.get(hash);
            if (reference != nil)
            (§
                TransactionConfidence confidence = reference.get();
                if (confidence != nil)
                    return confidence;
            )
            TransactionConfidence newConfidence = new TransactionConfidence(hash);
            table.put(hash, new WeakConfidenceReference(newConfidence, referenceQueue));
            return newConfidence;
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Returns the {@link TransactionConfidence} for the given hash if we have downloaded it, or null if that tx hash
     ; is unknown to the system at this time.
     ;;
#_nilable
#_public
    TransactionConfidence get(Sha256Hash hash)
    (§
        lock.lock();
        try
        (§
            WeakConfidenceReference ref = table.get(hash);
            return (ref != nil) ? ref.get() : nil;
        )
        finally
        (§
            lock.unlock();
        )
    )
)

(ns org.bitcoinj.core #_"UTXO"
    (:import #_[java.io *]
             #_[java.math *]
             [java.util Locale])
    (:import [com.google.common.base Objects])
  #_(:require #_[org.bitcoinj.script *]))

;; TODO: Fix this class: should not talk about addresses, height should be optional/support mempool height etc.

;;;
 ; A UTXO message contains the information necessary to check a spending transaction.
 ; It avoids having to store the entire parentTransaction just to get the hash and index.
 ; Useful when working with free standing outputs.
 ;;
#_public
class UTXO implements Serializable
(§
#_private
    Coin value;
#_private
    Script script;
#_private
    Sha256Hash hash;
#_private
    long index;
#_private
    int height;
#_private
    boolean coinbase;
#_private
    String address;

    ;;;
     ; Creates a stored transaction output.
     ;
     ; @param hash     The hash of the containing transaction.
     ; @param index    The outpoint.
     ; @param value    The value available.
     ; @param height   The height this output was created in.
     ; @param coinbase The coinbase flag.
     ;;
#_public
    UTXO(Sha256Hash hash, long index, Coin value, int height, boolean coinbase, Script script)
    (§
        this.hash = hash;
        this.index = index;
        this.value = value;
        this.height = height;
        this.script = script;
        this.coinbase = coinbase;
        this.address = "";
    )

    ;;;
     ; Creates a stored transaction output.
     ;
     ; @param hash     The hash of the containing transaction.
     ; @param index    The outpoint.
     ; @param value    The value available.
     ; @param height   The height this output was created in.
     ; @param coinbase The coinbase flag.
     ; @param address  The address.
     ;;
#_public
    UTXO(Sha256Hash hash, long index, Coin value, int height, boolean coinbase, Script script, String address)
    (§
        this(hash, index, value, height, coinbase, script);
        this.address = address;
    )

#_public
    UTXO(InputStream in)
        throws IOException
    (§
        deserializeFromStream(in);
    )

    ;;; The value which this Transaction output holds. ;;
#_public
    Coin getValue()
    (§
        return value;
    )

    ;;; The Script object which you can use to get address, script bytes or script type. ;;
#_public
    Script getScript()
    (§
        return script;
    )

    ;;; The hash of the transaction which holds this output. ;;
#_public
    Sha256Hash getHash()
    (§
        return hash;
    )

    ;;; The index of this output in the transaction which holds it. ;;
#_public
    long getIndex()
    (§
        return index;
    )

    ;;; Gets the height of the block that created this output. ;;
#_public
    int getHeight()
    (§
        return height;
    )

    ;;; Gets the flag of whether this was created by a coinbase tx. ;;
#_public
    boolean isCoinbase()
    (§
        return coinbase;
    )

    ;;; The address of this output, can be the empty string if none was provided at construction time or was deserialized. ;;
#_public
    String getAddress()
    (§
        return address;
    )

#_override
#_public
    String toString()
    (§
        return String.format(Locale.US, "Stored TxOut of %s (%s:%d)", value.toFriendlyString(), hash, index);
    )

#_override
#_public
    int hashCode()
    (§
        return Objects.hashCode(getIndex(), getHash());
    )

#_override
#_public
    boolean equals(Object o)
    (§
        if (this == o)
            return true;
        if (o == nil || getClass() != o.getClass())
            return false;
        UTXO other = (UTXO)o;
        return (getIndex() == other.getIndex() && getHash().equals(other.getHash()));
    )

#_private
#_static
#_final
    void write4x8le(OutputStream os, int n)
        throws IOException
    (§
        os.write(0xff & n);
        os.write(0xff & (n >> 8));
        os.write(0xff & (n >> 16));
        os.write(0xff & (n >> 24));
    )

#_public
    void serializeToStream(OutputStream os)
        throws IOException
    (§
        Utils.uint64ToByteStreamLE(BigInteger.valueOf(value.value), os);

        byte[] scriptBytes = script.getProgram();
        write4x8le(os, scriptBytes.length);
        os.write(scriptBytes);

        os.write(hash.getBytes());
        Utils.uint32ToByteStreamLE(index, os);

        write4x8le(os, height);
        os.write(new byte[] { (byte)(coinbase ? 1 : 0) });
    )

#_private
#_static
#_final
    int read4x8le(InputStream is)
        throws IOException
    (§
        return (is.read() & 0xff) | ((is.read() & 0xff) << 8) | ((is.read() & 0xff) << 16) | ((is.read() & 0xff) << 24);
    )

#_public
    void deserializeFromStream(InputStream is)
        throws IOException
    (§
        byte[] valueBytes = new byte[8];
        if (is.read(valueBytes, 0, 8) != 8)
            throw new EOFException();
        value = Coin.valueOf(Utils.readInt64(valueBytes, 0));

        int scriptBytesLength = read4x8le(is);
        byte[] scriptBytes = new byte[scriptBytesLength];
        if (is.read(scriptBytes) != scriptBytesLength)
            throw new EOFException();
        script = new Script(scriptBytes);

        byte[] hashBytes = new byte[32];
        if (is.read(hashBytes) != 32)
            throw new EOFException();
        hash = Sha256Hash.wrap(hashBytes);

        byte[] indexBytes = new byte[4];
        if (is.read(indexBytes) != 4)
            throw new EOFException();
        index = Utils.readUint32(indexBytes, 0);

        height = read4x8le(is);

        byte[] coinbaseByte = new byte[1];
        is.read(coinbaseByte);
        coinbase = (coinbaseByte[0] == 1);
    )

#_private
    void writeObject(ObjectOutputStream o)
        throws IOException
    (§
        serializeToStream(o);
    )

#_private
    void readObject(ObjectInputStream o)
        throws IOException, ClassNotFoundException
    (§
        deserializeFromStream(o);
    )
)

(ns org.bitcoinj.core #_"UnknownMessage"
)

;;;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
class UnknownMessage extends EmptyMessage
(§
#_private
    String name;

#_public
    UnknownMessage(NetworkParameters params, String name, byte[] payloadBytes)
        throws ProtocolException
    (§
        super(params, payloadBytes, 0);

        this.name = name;
    )

#_override
#_public
    String toString()
    (§
        return "Unknown message [" + name + "]: " + (payload != nil ? Utils.HEX.encode(payload) : "");
    )
)

(ns org.bitcoinj.core #_"UnsafeByteArrayOutputStream"
    (:import [java.io ByteArrayOutputStream IOException OutputStream]))

;;;
 ; An unsynchronized implementation of ByteArrayOutputStream that will return the backing byte array
 ; if its length == size().  This avoids unneeded array copy where the BOS is simply being used to
 ; extract a byte array of known length from a 'serialized to stream' method.
 ;
 ; Unless the final length can be accurately predicted the only performance this will yield is due
 ; to unsynchronized methods.
 ;
 ; @author git
 ;;
#_public
class UnsafeByteArrayOutputStream extends ByteArrayOutputStream
(§
#_public
    UnsafeByteArrayOutputStream()
    (§
        super(32);
    )

#_public
    UnsafeByteArrayOutputStream(int size)
    (§
        super(size);
    )

    ;;;
     ; Writes the specified byte to this byte array output stream.
     ;
     ; @param b The byte to be written.
     ;;
#_override
#_public
    void write(int b)
    (§
        int n = count + 1;
        if (buf.length < n)
            buf = Utils.copyOf(buf, Math.max(buf.length << 1, n));
        buf[count] = (byte)b;
        count = n;
    )

    ;;;
     ; Writes <code>len</code> bytes from the specified byte array
     ; starting at offset <code>off</code> to this byte array output stream.
     ;
     ; @param b   The data.
     ; @param off The start offset in the data.
     ; @param len The number of bytes to write.
     ;;
#_override
#_public
    void write(byte[] b, int off, int len)
    (§
        if (off < 0 || b.length < off || len < 0 || b.length < off + len || off + len < 0)
            throw new IndexOutOfBoundsException();

        if (len != 0)
        (§
            int n = count + len;
            if (buf.length < n)
                buf = Utils.copyOf(buf, Math.max(buf.length << 1, n));
            System.arraycopy(b, off, buf, count, len);
            count = n;
        )
    )

    ;;;
     ; Writes the complete contents of this byte array output stream to
     ; the specified output stream argument, as if by calling the output
     ; stream's write method using <code>out.write(buf, 0, count)</code>.
     ;
     ; @param out The output stream to which to write the data.
     ; @throws IOException if an I/O error occurs.
     ;;
#_override
#_public
    void writeTo(OutputStream out)
        throws IOException
    (§
        out.write(buf, 0, count);
    )

    ;;;
     ; Resets the <code>count</code> field of this byte array output
     ; stream to zero, so that all currently accumulated output in the
     ; output stream is discarded.  The output stream can be used again,
     ; reusing the already allocated buffer space.
     ;
     ; @see java.io.ByteArrayInputStream#count
     ;;
#_override
#_public
    void reset()
    (§
        count = 0;
    )

    ;;;
     ; Creates a newly allocated byte array.  Its size is the current
     ; size of this output stream and the valid contents of the buffer
     ; have been copied into it.
     ;
     ; @return the current contents of this output stream, as a byte array.
     ; @see java.io.ByteArrayOutputStream#size()
     ;;
#_override
#_public
    byte toByteArray()[]
    (§
        return (count == buf.length) ? buf : Utils.copyOf(buf, count);
    )

    ;;;
     ; Returns the current size of the buffer.
     ;
     ; @return the value of the <code>count</code> field, which is the number
     ;         of valid bytes in this output stream.
     ; @see java.io.ByteArrayOutputStream#count
     ;;
#_override
#_public
    int size()
    (§
        return count;
    )
)

(ns org.bitcoinj.core #_"Utils"
    (:import [java.io ByteArrayOutputStream IOException InputStream OutputStream UnsupportedEncodingException]
             [java.math BigInteger]
             [java.net URL]
             [java.text DateFormat SimpleDateFormat]
             #_[java.util *]
             [java.util.concurrent ArrayBlockingQueue BlockingQueue TimeUnit])
    (:import [com.google.common.base Charsets Joiner Preconditions]
             [com.google.common.collect Lists Ordering]
             [com.google.common.io BaseEncoding Resources]
             [com.google.common.primitives Ints UnsignedLongs]
             #_static #_[com.google.common.util.concurrent.Uninterruptibles sleepUninterruptibly]
             [org.spongycastle.crypto.digests RIPEMD160Digest]))

;;;
 ; A collection of various utility methods that are helpful for working with the Bitcoin protocol.
 ; To enable debug logging from the library, run with -Dbitcoinj.logging=true on your command line.
 ;;
#_public
class Utils
(§
    ;;; The string that prefixes all text messages signed using Bitcoin keys. ;;
#_public
#_static
#_final
    String BITCOIN_SIGNED_MESSAGE_HEADER = "Bitcoin Signed Message:\n";
#_public
#_static
#_final
    byte[] BITCOIN_SIGNED_MESSAGE_HEADER_BYTES = BITCOIN_SIGNED_MESSAGE_HEADER.getBytes(Charsets.UTF_8);

#_public
#_static
#_final
    Joiner SPACE_JOINER = Joiner.on(" ");

#_private
#_static
    BlockingQueue<Boolean> mockSleepQueue;

    ;;;
     ; The regular {@link java.math.BigInteger#toByteArray()} includes the sign bit of the number and
     ; might result in an extra byte addition.  This method removes this extra byte.
     ;
     ; Assuming only positive numbers, it's possible to discriminate if an extra byte
     ; is added by checking if the first element of the array is 0 (0000_0000).
     ; Due to the minimal representation provided by BigInteger, it means that the bit sign
     ; is the least significant bit 0000_000<b>0</b>.  Otherwise the representation is not minimal.
     ; For example, if the sign bit is 0000_00<b>0</b>0, then the representation is not minimal due to the rightmost zero.
     ;
     ; @param b The integer to format into a byte array.
     ; @param numBytes The desired size of the resulting byte array.
     ; @return numBytes byte long array.
     ;;
#_public
#_static
    byte[] bigIntegerToBytes(BigInteger b, int numBytes)
    (§
        Preconditions.checkArgument(0 <= b.signum(), "b must be positive or zero");
        Preconditions.checkArgument(0 < numBytes, "numBytes must be positive");

        byte[] src = b.toByteArray();
        byte[] dest = new byte[numBytes];
        boolean isFirstByteOnlyForSign = (src[0] == 0);
        int length = isFirstByteOnlyForSign ? src.length - 1 : src.length;

        Preconditions.checkArgument(length <= numBytes, "The given number does not fit in " + numBytes);

        int srcPos = isFirstByteOnlyForSign ? 1 : 0;
        int destPos = numBytes - length;
        System.arraycopy(src, srcPos, dest, destPos, length);
        return dest;
    )

#_public
#_static
    void uint32ToByteArrayBE(long val, byte[] out, int offset)
    (§
        out[offset] = (byte)(0xff & (val >> 24));
        out[offset + 1] = (byte)(0xff & (val >> 16));
        out[offset + 2] = (byte)(0xff & (val >> 8));
        out[offset + 3] = (byte)(0xff & val);
    )

#_public
#_static
    void uint32ToByteArrayLE(long val, byte[] out, int offset)
    (§
        out[offset] = (byte)(0xff & val);
        out[offset + 1] = (byte)(0xff & (val >> 8));
        out[offset + 2] = (byte)(0xff & (val >> 16));
        out[offset + 3] = (byte)(0xff & (val >> 24));
    )

#_public
#_static
    void uint64ToByteArrayLE(long val, byte[] out, int offset)
    (§
        out[offset] = (byte)(0xff & val);
        out[offset + 1] = (byte)(0xff & (val >> 8));
        out[offset + 2] = (byte)(0xff & (val >> 16));
        out[offset + 3] = (byte)(0xff & (val >> 24));
        out[offset + 4] = (byte)(0xff & (val >> 32));
        out[offset + 5] = (byte)(0xff & (val >> 40));
        out[offset + 6] = (byte)(0xff & (val >> 48));
        out[offset + 7] = (byte)(0xff & (val >> 56));
    )

#_public
#_static
    void uint32ToByteStreamLE(long val, OutputStream stream)
        throws IOException
    (§
        stream.write((int)(0xff & val));
        stream.write((int)(0xff & (val >> 8)));
        stream.write((int)(0xff & (val >> 16)));
        stream.write((int)(0xff & (val >> 24)));
    )

#_public
#_static
    void int64ToByteStreamLE(long val, OutputStream stream)
        throws IOException
    (§
        stream.write((int)(0xff & val));
        stream.write((int)(0xff & (val >> 8)));
        stream.write((int)(0xff & (val >> 16)));
        stream.write((int)(0xff & (val >> 24)));
        stream.write((int)(0xff & (val >> 32)));
        stream.write((int)(0xff & (val >> 40)));
        stream.write((int)(0xff & (val >> 48)));
        stream.write((int)(0xff & (val >> 56)));
    )

#_public
#_static
    void uint64ToByteStreamLE(BigInteger val, OutputStream stream)
        throws IOException
    (§
        byte[] bytes = val.toByteArray();
        if (8 < bytes.length)
            throw new RuntimeException("Input too large to encode into a uint64");

        bytes = reverseBytes(bytes);
        stream.write(bytes);
        if (bytes.length < 8)
            for (int i = 0; i < 8 - bytes.length; i++)
                stream.write(0);
    )

    ;;;
     ; Work around lack of unsigned types in Java.
     ;;
#_public
#_static
    boolean isLessThanUnsigned(long n1, long n2)
    (§
        return (UnsignedLongs.compare(n1, n2) < 0);
    )

    ;;;
     ; Work around lack of unsigned types in Java.
     ;;
#_public
#_static
    boolean isLessThanOrEqualToUnsigned(long n1, long n2)
    (§
        return (UnsignedLongs.compare(n1, n2) <= 0);
    )

    ;;;
     ; Hex encoding used throughout the framework.  Use with HEX.encode(byte[]) or HEX.decode(CharSequence).
     ;;
#_public
#_static
#_final
    BaseEncoding HEX = BaseEncoding.base16().lowerCase();

    ;;;
     ; Returns a copy of the given byte array in reverse order.
     ;;
#_public
#_static
    byte[] reverseBytes(byte[] bytes)
    (§
        ;; We could use the XOR trick here, but it's easier to understand if we don't.
        ;; If we find this is really a performance issue, the matter can be revisited.
        byte[] buf = new byte[bytes.length];
        for (int i = 0; i < bytes.length; i++)
            buf[i] = bytes[bytes.length - 1 - i];
        return buf;
    )

    ;;;
     ; Returns a copy of the given byte array with the bytes of each double-word (4 bytes) reversed.
     ;
     ; @param bytes Length must be divisible by 4.
     ; @param trimLength Trim output to this length.  If positive, must be divisible by 4.
     ;;
#_public
#_static
    byte[] reverseDwordBytes(byte[] bytes, int trimLength)
    (§
        Preconditions.checkArgument(bytes.length % 4 == 0);
        Preconditions.checkArgument(trimLength < 0 || trimLength % 4 == 0);

        byte[] rev = new byte[(0 <= trimLength && trimLength < bytes.length) ? trimLength : bytes.length];

        for (int i = 0; i < rev.length; i += 4)
        (§
            System.arraycopy(bytes, i, rev, i , 4);
            for (int j = 0; j < 4; j++)
                rev[i + j] = bytes[i + 3 - j];
        )
        return rev;
    )

    ;;; Parse 4 bytes from the byte array (starting at the offset) as unsigned 32-bit integer in little endian format. ;;
#_public
#_static
    long readUint32(byte[] bytes, int offset)
    (§
        return (bytes[offset] & 0xffL)
            | ((bytes[offset + 1] & 0xffL) << 8)
            | ((bytes[offset + 2] & 0xffL) << 16)
            | ((bytes[offset + 3] & 0xffL) << 24);
    )

    ;;; Parse 8 bytes from the byte array (starting at the offset) as signed 64-bit integer in little endian format. ;;
#_public
#_static
    long readInt64(byte[] bytes, int offset)
    (§
        return (bytes[offset] & 0xffL)
            | ((bytes[offset + 1] & 0xffL) << 8)
            | ((bytes[offset + 2] & 0xffL) << 16)
            | ((bytes[offset + 3] & 0xffL) << 24)
            | ((bytes[offset + 4] & 0xffL) << 32)
            | ((bytes[offset + 5] & 0xffL) << 40)
            | ((bytes[offset + 6] & 0xffL) << 48)
            | ((bytes[offset + 7] & 0xffL) << 56);
    )

    ;;; Parse 4 bytes from the byte array (starting at the offset) as unsigned 32-bit integer in big endian format. ;;
#_public
#_static
    long readUint32BE(byte[] bytes, int offset)
    (§
        return ((bytes[offset] & 0xffL) << 24)
            |  ((bytes[offset + 1] & 0xffL) << 16)
            |  ((bytes[offset + 2] & 0xffL) << 8)
            |   (bytes[offset + 3] & 0xffL);
    )

    ;;; Parse 2 bytes from the byte array (starting at the offset) as unsigned 16-bit integer in big endian format. ;;
#_public
#_static
    int readUint16BE(byte[] bytes, int offset)
    (§
        return ((bytes[offset] & 0xff) << 8)
            |   (bytes[offset + 1] & 0xff);
    )

    ;;;
     ; Calculates RIPEMD160(SHA256(input)).  This is used in Address calculations.
     ;;
#_public
#_static
    byte[] sha256hash160(byte[] input)
    (§
        byte[] sha256 = Sha256Hash.hash(input);
        RIPEMD160Digest digest = new RIPEMD160Digest();
        digest.update(sha256, 0, sha256.length);
        byte[] out = new byte[20];
        digest.doFinal(out, 0);
        return out;
    )

    ;;;
     ; MPI encoded numbers are produced by the OpenSSL BN_bn2mpi function.  They consist of
     ; a 4 byte big endian length field, followed by the stated number of bytes representing
     ; the number in big endian format (with a sign bit).
     ; @param hasLength can be set to false if the given array is missing the 4 byte length field.
     ;;
#_public
#_static
    BigInteger decodeMPI(byte[] mpi, boolean hasLength)
    (§
        byte[] buf;
        if (hasLength)
        (§
            int length = (int)readUint32BE(mpi, 0);
            buf = new byte[length];
            System.arraycopy(mpi, 4, buf, 0, length);
        )
        else
            buf = mpi;
        if (buf.length == 0)
            return BigInteger.ZERO;

        boolean isNegative = ((buf[0] & 0x80) == 0x80);
        if (isNegative)
            buf[0] &= 0x7f;
        BigInteger result = new BigInteger(buf);
        return isNegative ? result.negate() : result;
    )

    ;;;
     ; MPI encoded numbers are produced by the OpenSSL BN_bn2mpi function.  They consist of
     ; a 4 byte big endian length field, followed by the stated number of bytes representing
     ; the number in big endian format (with a sign bit).
     ; @param includeLength indicates whether the 4 byte length field should be included.
     ;;
#_public
#_static
    byte[] encodeMPI(BigInteger value, boolean includeLength)
    (§
        if (value.equals(BigInteger.ZERO))
            return includeLength ? new byte[] { 0x00, 0x00, 0x00, 0x00 } : new byte[] {};

        boolean isNegative = (value.signum() < 0);
        if (isNegative)
            value = value.negate();
        byte[] array = value.toByteArray();
        int length = array.length;
        if ((array[0] & 0x80) == 0x80)
            length++;

        if (includeLength)
        (§
            byte[] result = new byte[length + 4];
            System.arraycopy(array, 0, result, length - array.length + 3, array.length);
            uint32ToByteArrayBE(length, result, 0);
            if (isNegative)
                result[4] |= 0x80;
            return result;
        )
        else
        (§
            byte[] result;
            if (length != array.length)
            (§
                result = new byte[length];
                System.arraycopy(array, 0, result, 1, array.length);
            )
            else
                result = array;
            if (isNegative)
                result[0] |= 0x80;
            return result;
        )
    )

    ;;;
     ; <p>The "compact" format is a representation of a whole number N using an unsigned 32 bit number similar to
     ; a floating point format.  The most significant 8 bits are the unsigned exponent of base 256.  This exponent
     ; can be thought of as "number of bytes of N".  The lower 23 bits are the mantissa.  Bit number 24 (0x800000)
     ; represents the sign of N.  Therefore, N = (-1^sign) * mantissa * 256^(exponent-3).</p>
     ;
     ; <p>Satoshi's original implementation used BN_bn2mpi() and BN_mpi2bn().  MPI uses the most significant bit of
     ; the first byte as sign.  Thus 0x1234560000 is compact 0x05123456 and 0xc0de000000 is compact 0x0600c0de.
     ; Compact 0x05c0de00 would be -0x40de000000.</p>
     ;
     ; <p>Bitcoin only uses this "compact" format for encoding difficulty targets, which are unsigned 256bit quantities.
     ; Thus, all the complexities of the sign bit and using base 256 are probably an implementation accident.</p>
     ;;
#_public
#_static
    BigInteger decodeCompactBits(long compact)
    (§
        int size = ((int)(compact >> 24)) & 0xff;
        byte[] bytes = new byte[4 + size];
        bytes[3] = (byte)size;
        if (1 <= size)
            bytes[4] = (byte)((compact >> 16) & 0xff);
        if (2 <= size)
            bytes[5] = (byte)((compact >> 8) & 0xff);
        if (3 <= size)
            bytes[6] = (byte)(compact & 0xff);
        return decodeMPI(bytes, true);
    )

    ;;;
     ; @see Utils#decodeCompactBits(long)
     ;;
#_public
#_static
    long encodeCompactBits(BigInteger value)
    (§
        long result;
        int size = value.toByteArray().length;
        if (size <= 3)
            result = value.longValue() << 8 * (3 - size);
        else
            result = value.shiftRight(8 * (size - 3)).longValue();
        ;; The 0x00800000 bit denotes the sign.
        ;; Thus, if it is already set, divide the mantissa by 256 and increase the exponent.
        if ((result & 0x00800000L) != 0)
        (§
            result >>= 8;
            size++;
        )
        result |= size << 24;
        result |= (value.signum() == -1) ? 0x00800000 : 0;
        return result;
    )

    ;;;
     ; If non-null, overrides the return value of now().
     ;;
#_public
#_static
#_volatile
    Date mockTime;

    ;;;
     ; Advances (or rewinds) the mock clock by the given number of seconds.
     ;;
#_public
#_static
    Date rollMockClock(int seconds)
    (§
        return rollMockClockMillis(seconds * 1000);
    )

    ;;;
     ; Advances (or rewinds) the mock clock by the given number of milliseconds.
     ;;
#_public
#_static
    Date rollMockClockMillis(long millis)
    (§
        if (mockTime == nil)
            throw new IllegalStateException("You need to use setMockClock() first.");

        mockTime = new Date(mockTime.getTime() + millis);
        return mockTime;
    )

    ;;;
     ; Sets the mock clock to the current time.
     ;;
#_public
#_static
    void setMockClock()
    (§
        mockTime = new Date();
    )

    ;;;
     ; Sets the mock clock to the given time (in seconds).
     ;;
#_public
#_static
    void setMockClock(long mockClockSeconds)
    (§
        mockTime = new Date(mockClockSeconds * 1000);
    )

    ;;;
     ; Returns the current time, or a mocked out equivalent.
     ;;
#_public
#_static
    Date now()
    (§
        return (mockTime != nil) ? mockTime : new Date();
    )

    ;; TODO: Replace usages of this where the result is / 1000 with currentTimeSeconds.
    ;;; Returns the current time in milliseconds since the epoch, or a mocked out equivalent. ;;
#_public
#_static
    long currentTimeMillis()
    (§
        return (mockTime != nil) ? mockTime.getTime() : System.currentTimeMillis();
    )

#_public
#_static
    long currentTimeSeconds()
    (§
        return currentTimeMillis() / 1000;
    )

#_private
#_static
#_final
    TimeZone UTC = TimeZone.getTimeZone("UTC");

    ;;;
     ; Formats a given date+time value to an ISO 8601 string.
     ; @param dateTime value to format, as a Date
     ;;
#_public
#_static
    String dateTimeFormat(Date dateTime)
    (§
        DateFormat iso8601 = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.US);
        iso8601.setTimeZone(UTC);
        return iso8601.format(dateTime);
    )

    ;;;
     ; Formats a given date+time value to an ISO 8601 string.
     ; @param dateTime value to format, unix time (ms)
     ;;
#_public
#_static
    String dateTimeFormat(long dateTime)
    (§
        DateFormat iso8601 = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.US);
        iso8601.setTimeZone(UTC);
        return iso8601.format(dateTime);
    )

#_public
#_static
    byte[] copyOf(byte[] in, int length)
    (§
        byte[] out = new byte[length];
        System.arraycopy(in, 0, out, 0, Math.min(length, in.length));
        return out;
    )

    ;;;
     ; Creates a copy of bytes and appends b to the end of it.
     ;;
#_public
#_static
    byte[] appendByte(byte[] bytes, byte b)
    (§
        byte[] result = Arrays.copyOf(bytes, bytes.length + 1);
        result[result.length - 1] = b;
        return result;
    )

    ;;;
     ; Constructs a new String by decoding the given bytes using the specified charset.
     ;
     ; This is a convenience method which wraps the checked exception with a RuntimeException.
     ; The exception can never occur given the charsets
     ; US-ASCII, ISO-8859-1, UTF-8, UTF-16, UTF-16LE or UTF-16BE.
     ;
     ; @param bytes The bytes to be decoded into characters.
     ; @param charsetName The name of a supported {@linkplain java.nio.charset.Charset charset}.
     ; @return the decoded String.
     ;;
#_public
#_static
    String toString(byte[] bytes, String charsetName)
    (§
        try
        (§
            return new String(bytes, charsetName);
        )
        catch (UnsupportedEncodingException e)
        (§
            throw new RuntimeException(e);
        )
    )

    ;;;
     ; Encodes the given string into a sequence of bytes using the named charset.
     ;
     ; This is a convenience method which wraps the checked exception with a RuntimeException.
     ; The exception can never occur given the charsets
     ; US-ASCII, ISO-8859-1, UTF-8, UTF-16, UTF-16LE or UTF-16BE.
     ;
     ; @param str The string to encode into bytes.
     ; @param charsetName The name of a supported {@linkplain java.nio.charset.Charset charset}.
     ; @return the encoded bytes.
     ;;
#_public
#_static
    byte[] toBytes(CharSequence str, String charsetName)
    (§
        try
        (§
            return str.toString().getBytes(charsetName);
        )
        catch (UnsupportedEncodingException e)
        (§
            throw new RuntimeException(e);
        )
    )

    ;;;
     ; Attempts to parse the given string as arbitrary-length hex or base58 and then return the results,
     ; or null if neither parse was successful.
     ;;
#_public
#_static
    byte[] parseAsHexOrBase58(String data)
    (§
        try
        (§
            return HEX.decode(data);
        )
        catch (Exception _)
        (§
            ;; Didn't decode as hex, try base58.
            try
            (§
                return Base58.decodeChecked(data);
            )
            catch (AddressFormatException __)
            (§
                return nil;
            )
        )
    )

#_public
#_static
    boolean isWindows()
    (§
        return System.getProperty("os.name").toLowerCase().contains("win");
    )

    ;;;
     ; <p>Given a textual message, returns a byte buffer formatted as follows:</p>
     ;
     ; <p><tt>[24] "Bitcoin Signed Message:\n" [message.length as a varint] message</tt>.</p>
     ;;
#_public
#_static
    byte[] formatMessageForSigning(String message)
    (§
        try
        (§
            ByteArrayOutputStream bos = new ByteArrayOutputStream();
            bos.write(BITCOIN_SIGNED_MESSAGE_HEADER_BYTES.length);
            bos.write(BITCOIN_SIGNED_MESSAGE_HEADER_BYTES);
            byte[] messageBytes = message.getBytes(Charsets.UTF_8);
            VarInt size = new VarInt(messageBytes.length);
            bos.write(size.encode());
            bos.write(messageBytes);
            return bos.toByteArray();
        )
        catch (IOException e)
        (§
            throw new RuntimeException(e); ;; Cannot happen.
        )
    )

    ;; 00000001, 00000010, 00000100, 00001000, ...
#_private
#_static
#_final
    int[] bitMask = { 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80 };

    ;;; Checks if the given bit is set in data, using little endian (not the same as Java native big endian). ;;
#_public
#_static
    boolean checkBitLE(byte[] data, int index)
    (§
        return ((data[index >>> 3] & bitMask[7 & index]) != 0);
    )

    ;;; Sets the given bit in data to one, using little endian (not the same as Java native big endian). ;;
#_public
#_static
    void setBitLE(byte[] data, int index)
    (§
        data[index >>> 3] |= bitMask[7 & index];
    )

    ;;; Sleep for a span of time, or mock sleep if enabled. ;;
#_public
#_static
    void sleep(long millis)
    (§
        if (mockSleepQueue == nil)
        (§
            sleepUninterruptibly(millis, TimeUnit.MILLISECONDS);
        )
        else
        (§
            try
            (§
                boolean isMultiPass = mockSleepQueue.take();
                rollMockClockMillis(millis);
                if (isMultiPass)
                    mockSleepQueue.offer(true);
            )
            catch (InterruptedException _)
            (§
                ;; Ignored.
            )
        )
    )

    ;;; Enable or disable mock sleep.  If enabled, set mock time to current time. ;;
#_public
#_static
    void setMockSleep(boolean isEnable)
    (§
        if (isEnable)
        (§
            mockSleepQueue = new ArrayBlockingQueue<>(1);
            mockTime = new Date(System.currentTimeMillis());
        )
        else
        (§
            mockSleepQueue = nil;
        )
    )

    ;;; Let sleeping thread pass the synchronization point. ;;
#_public
#_static
    void passMockSleep()
    (§
        mockSleepQueue.offer(false);
    )

    ;;; Let the sleeping thread pass the synchronization point any number of times. ;;
#_public
#_static
    void finishMockSleep()
    (§
        if (mockSleepQueue != nil)
            mockSleepQueue.offer(true);
    )

#_private
#_static
    int isAndroid = -1;
#_public
#_static
    boolean isAndroidRuntime()
    (§
        if (isAndroid == -1)
        (§
#_final
            String runtime = System.getProperty("java.runtime.name");
            isAndroid = (runtime != nil && runtime.equals("Android Runtime")) ? 1 : 0;
        )
        return (isAndroid == 1);
    )

#_private
#_static
    class Pair implements Comparable<Pair>
    (§
        int item, count;

#_public
        Pair(int item, int count)
        (§
            this.count = count;
            this.item = item;
        )

        ;; Note that in this implementation compareTo() is not consistent with equals().
#_override
#_public
        int compareTo(Pair o)
        (§
            return -Ints.compare(count, o.count);
        )
    )

#_public
#_static
    int maxOfMostFreq(int... items)
    (§
        ;; Java 6 sucks.
        ArrayList<Integer> list = new ArrayList<>(items.length);
        for (int item : items)
            list.add(item);
        return maxOfMostFreq(list);
    )

#_public
#_static
    int maxOfMostFreq(List<Integer> items)
    (§
        if (items.isEmpty())
            return 0;

        ;; This would be much easier in a functional language (or in Java 8).
        items = Ordering.natural().reverse().sortedCopy(items);
        LinkedList<Pair> pairs = Lists.newLinkedList();
        pairs.add(new Pair(items.get(0), 0));
        for (int item : items)
        (§
            Pair pair = pairs.getLast();
            if (pair.item != item)
                pairs.add((pair = new Pair(item, 0)));
            pair.count++;
        )
        ;; pairs now contains a uniqified list of the sorted inputs, with counts for how often that item appeared.
        ;; Now sort by how frequently they occur, and pick the max of the most frequent.
        Collections.sort(pairs);
        int maxCount = pairs.getFirst().count;
        int maxItem = pairs.getFirst().item;
        for (Pair pair : pairs)
        (§
            if (pair.count != maxCount)
                break;
            maxItem = Math.max(maxItem, pair.item);
        )
        return maxItem;
    )

    ;;;
     ; Reads and joins together with LF char (\n) all the lines from given file.
     ; It's assumed that file is in UTF-8.
     ;;
#_public
#_static
    String getResourceAsString(URL url)
        throws IOException
    (§
        List<String> lines = Resources.readLines(url, Charsets.UTF_8);
        return Joiner.on('\n').join(lines);
    )

    ;; Can't use Closeable here because it's Java 7 only and Android devices only got that with KitKat.
#_public
#_static
    InputStream closeUnchecked(InputStream stream)
    (§
        try
        (§
            stream.close();
            return stream;
        )
        catch (IOException e)
        (§
            throw new RuntimeException(e);
        )
    )

#_public
#_static
    OutputStream closeUnchecked(OutputStream stream)
    (§
        try
        (§
            stream.close();
            return stream;
        )
        catch (IOException e)
        (§
            throw new RuntimeException(e);
        )
    )
)

(ns org.bitcoinj.core #_"VarInt"
)

;;;
 ; A variable-length encoded unsigned integer using Satoshi's encoding (a.k.a. "CompactSize").
 ;;
#_public
class VarInt
(§
#_public
#_final
    long value;
#_private
#_final
    int originallyEncodedSize;

    ;;;
     ; Constructs a new VarInt with the given unsigned long value.
     ;
     ; @param value the unsigned long value (beware widening conversion of negatives!)
     ;;
#_public
    VarInt(long value)
    (§
        this.value = value;
        originallyEncodedSize = getSizeInBytes();
    )

    ;;;
     ; Constructs a new VarInt with the value parsed from the specified offset of the given buffer.
     ;
     ; @param buf The buffer containing the value.
     ; @param offset The offset of the value.
     ;;
#_public
    VarInt(byte[] buf, int offset)
    (§
        int first = 0xff & buf[offset];
        if (first < 253)
        (§
            value = first;
            originallyEncodedSize = 1; ;; 1 data byte (8 bits)
        )
        else if (first == 253)
        (§
            value = (0xff & buf[offset + 1]) | ((0xff & buf[offset + 2]) << 8);
            originallyEncodedSize = 3; ;; 1 marker + 2 data bytes (16 bits)
        )
        else if (first == 254)
        (§
            value = Utils.readUint32(buf, offset + 1);
            originallyEncodedSize = 5; ;; 1 marker + 4 data bytes (32 bits)
        )
        else
        (§
            value = Utils.readInt64(buf, offset + 1);
            originallyEncodedSize = 9; ;; 1 marker + 8 data bytes (64 bits)
        )
    )

    ;;;
     ; Returns the original number of bytes used to encode the value if it was
     ; deserialized from a byte array, or the minimum encoded size if it was not.
     ;;
#_public
    int getOriginalSizeInBytes()
    (§
        return originallyEncodedSize;
    )

    ;;;
     ; Returns the minimum encoded size of the value.
     ;;
#_public
#_final
    int getSizeInBytes()
    (§
        return sizeOf(value);
    )

    ;;;
     ; Returns the minimum encoded size of the given unsigned long value.
     ;
     ; @param value the unsigned long value (beware widening conversion of negatives!)
     ;;
#_public
#_static
    int sizeOf(long value)
    (§
        ;; if negative, it's actually a very large unsigned long value
        if (value < 0) return 9; ;; 1 marker + 8 data bytes
        if (value < 253) return 1; ;; 1 data byte
        if (value <= 0xffffL) return 3; ;; 1 marker + 2 data bytes
        if (value <= 0xffffffffL) return 5; ;; 1 marker + 4 data bytes
        return 9; ;; 1 marker + 8 data bytes
    )

    ;;;
     ; Encodes the value into its minimal representation.
     ;
     ; @return the minimal encoded bytes of the value.
     ;;
#_public
    byte[] encode()
    (§
        byte[] bytes;
        switch (sizeOf(value))
        (§
            case 1:
                return new byte[] { (byte)value };
            case 3:
                return new byte[] { (byte)253, (byte)value, (byte)(value >> 8) };
            case 5:
                bytes = new byte[5];
                bytes[0] = (byte)254;
                Utils.uint32ToByteArrayLE(value, bytes, 1);
                return bytes;
            default:
                bytes = new byte[9];
                bytes[0] = (byte)255;
                Utils.uint64ToByteArrayLE(value, bytes, 1);
                return bytes;
        )
    )
)

(ns org.bitcoinj.core #_"VerificationException"
)

#_public
class VerificationException extends RuntimeException
(§
#_public
    VerificationException(String msg)
    (§
        super(msg);
    )

#_public
    VerificationException(Exception e)
    (§
        super(e);
    )

#_public
    VerificationException(String msg, Throwable t)
    (§
        super(msg, t);
    )

#_public
#_static
    class EmptyInputsOrOutputs extends VerificationException
    (§
#_public
        EmptyInputsOrOutputs()
        (§
            super("Transaction had no inputs or no outputs.");
        )
    )

#_public
#_static
    class LargerThanMaxBlockSize extends VerificationException
    (§
#_public
        LargerThanMaxBlockSize()
        (§
            super("Transaction larger than MAX_BLOCK_SIZE");
        )
    )

#_public
#_static
    class DuplicatedOutPoint extends VerificationException
    (§
#_public
        DuplicatedOutPoint()
        (§
            super("Duplicated outpoint");
        )
    )

#_public
#_static
    class NegativeValueOutput extends VerificationException
    (§
#_public
        NegativeValueOutput()
        (§
            super("Transaction output negative");
        )
    )

#_public
#_static
    class ExcessiveValue extends VerificationException
    (§
#_public
        ExcessiveValue()
        (§
            super("Total transaction output value greater than possible");
        )
    )

#_public
#_static
    class CoinbaseScriptSizeOutOfRange extends VerificationException
    (§
#_public
        CoinbaseScriptSizeOutOfRange()
        (§
            super("Coinbase script size out of range");
        )
    )

#_public
#_static
    class BlockVersionOutOfDate extends VerificationException
    (§
#_public
        BlockVersionOutOfDate(final long version)
        (§
            super("Block version #" + version + " is outdated.");
        )
    )

#_public
#_static
    class UnexpectedCoinbaseInput extends VerificationException
    (§
#_public
        UnexpectedCoinbaseInput()
        (§
            super("Coinbase input as input in non-coinbase transaction");
        )
    )

#_public
#_static
    class CoinbaseHeightMismatch extends VerificationException
    (§
#_public
        CoinbaseHeightMismatch(final String message)
        (§
            super(message);
        )
    )
)

(ns org.bitcoinj.core #_"VersionAck"
)

;;;
 ; <p>The verack message, sent by a client accepting the version message they
 ; received from their peer.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
class VersionAck extends EmptyMessage
(§
#_public
    VersionAck()
    (§
    )

    ;; this is needed by the BitcoinSerializer
#_public
    VersionAck(NetworkParameters params, byte[] payload)
    (§
    )
)

(ns org.bitcoinj.core #_"VersionMessage"
    (:import [java.io IOException OutputStream]
             [java.math BigInteger]
             [java.net InetAddress UnknownHostException]
             [java.util Locale])
    (:import [com.google.common.base Objects]
             [com.google.common.net InetAddresses]))

;;;
 ; <p>A VersionMessage holds information exchanged during connection setup with another peer.  Most of the fields are
 ; not particularly interesting.  The subVer field, since BIP 14, acts as a User-Agent string would.  You can and should
 ; append to or change the subVer for your own software so other implementations can identify it, and you can look at
 ; the subVer field received from other nodes to see what they are running.</p>
 ;
 ; <p>After creating yourself a VersionMessage, you can pass it to {@link PeerGroup#setVersionMessage(VersionMessage)}
 ; to ensure it will be used for each new connection.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
class VersionMessage extends Message
(§
    ;;; The version of this library release, as a string. ;;
#_public
#_static
#_final
    String BITCOINJ_VERSION = "0.15-SNAPSHOT";
    ;;; The value that is prepended to the subVer field of this application. ;;
#_public
#_static
#_final
    String LIBRARY_SUBVER = "/bitcoinj:" + BITCOINJ_VERSION + "/";

    ;;; A services flag that denotes whether the peer has a copy of the block chain or not. ;;
#_public
#_static
#_final
    int NODE_NETWORK = 1;

    ;;;
     ; The version number of the protocol spoken.
     ;;
#_public
    int clientVersion;
    ;;;
     ; Flags defining what optional services are supported.
     ;;
#_public
    long localServices;
    ;;;
     ; What the other side believes the current time to be, in seconds.
     ;;
#_public
    long time;
    ;;;
     ; What the other side believes the address of this program is.  Not used.
     ;;
#_public
    PeerAddress myAddr;
    ;;;
     ; What the other side believes their own address is.  Not used.
     ;;
#_public
    PeerAddress theirAddr;
    ;;;
     ; User-Agent as defined in <a href="https://github.com/bitcoin/bips/blob/master/bip-0014.mediawiki">BIP 14</a>.
     ; Bitcoin Core sets it to something like "/Satoshi:0.9.1/".
     ;;
#_public
    String subVer;
    ;;;
     ; How many blocks are in the chain, according to the other side.
     ;;
#_public
    long bestHeight;
    ;;;
     ; Whether or not to relay tx invs before a filter is received.
     ; See <a href="https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki#extensions-to-existing-messages">BIP 37</a>.
     ;;
#_public
    boolean relayTxesBeforeFilter;

#_public
    VersionMessage(NetworkParameters params, byte[] payload)
        throws ProtocolException
    (§
        super(params, payload, 0);
    )

    ;; It doesn't really make sense to ever lazily parse a version message or to retain the backing bytes.
    ;; If you're receiving this on the wire you need to check the protocol version and it will never need
    ;; to be sent back down the wire.

#_public
    VersionMessage(NetworkParameters params, int newBestHeight)
    (§
        super(params);

        clientVersion = params.getProtocolVersionNum(NetworkParameters.ProtocolVersion.CURRENT);
        localServices = 0;
        time = System.currentTimeMillis() / 1000;
        ;; Note that the Bitcoin Core doesn't do anything with these, and finding out your own external IP address
        ;; is kind of tricky anyway, so we just put nonsense here for now.
        InetAddress localhost = InetAddresses.forString("127.0.0.1");
        myAddr = new PeerAddress(params, localhost, params.getPort(), 0, BigInteger.ZERO);
        theirAddr = new PeerAddress(params, localhost, params.getPort(), 0, BigInteger.ZERO);
        subVer = LIBRARY_SUBVER;
        bestHeight = newBestHeight;
        relayTxesBeforeFilter = true;

        length = 85;
        if (31402 < protocolVersion)
            length += 8;
        length += VarInt.sizeOf(subVer.length()) + subVer.length();
    )

#_override
#_protected
    void parse()
        throws ProtocolException
    (§
        clientVersion = (int)readUint32();
        localServices = readUint64().longValue();
        time = readUint64().longValue();
        myAddr = new PeerAddress(params, payload, cursor, 0);
        cursor += myAddr.getMessageSize();
        theirAddr = new PeerAddress(params, payload, cursor, 0);
        cursor += theirAddr.getMessageSize();
        ;; uint64 localHostNonce (random data)
        ;; We don't care about the localhost nonce.  It's used to detect connecting back to yourself in cases where
        ;; there are NATs and proxies in the way.  However we don't listen for inbound connections so it's irrelevant.
        readUint64();
        try
        (§
            ;; Initialize default values for flags which may not be sent by old nodes.
            subVer = "";
            bestHeight = 0;
            relayTxesBeforeFilter = true;
            if (!hasMoreBytes())
                return;

            ;; string subVer (currently "")
            subVer = readStr();
            if (!hasMoreBytes())
                return;

            ;; int bestHeight (size of known block chain)
            bestHeight = readUint32();
            if (!hasMoreBytes())
                return;

            relayTxesBeforeFilter = (readBytes(1)[0] != 0);
        )
        finally
        (§
            length = cursor - offset;
        )
    )

#_override
#_public
    void bitcoinSerializeToStream(OutputStream buf)
        throws IOException
    (§
        Utils.uint32ToByteStreamLE(clientVersion, buf);
        Utils.uint32ToByteStreamLE(localServices, buf);
        Utils.uint32ToByteStreamLE(localServices >> 32, buf);
        Utils.uint32ToByteStreamLE(time, buf);
        Utils.uint32ToByteStreamLE(time >> 32, buf);
        try
        (§
            ;; My address.
            myAddr.bitcoinSerialize(buf);
            ;; Their address.
            theirAddr.bitcoinSerialize(buf);
        )
        catch (UnknownHostException e)
        (§
            throw new RuntimeException(e); ;; Can't happen.
        )
        catch (IOException e)
        (§
            throw new RuntimeException(e); ;; Can't happen.
        )
        ;; Next up is the "local host nonce", this is to detect the case of connecting back to yourself.
        ;; We don't care about this as we won't be accepting inbound connections.
        Utils.uint32ToByteStreamLE(0, buf);
        Utils.uint32ToByteStreamLE(0, buf);
        ;; Now comes subVer.
        byte[] subVerBytes = subVer.getBytes("UTF-8");
        buf.write(new VarInt(subVerBytes.length).encode());
        buf.write(subVerBytes);
        ;; Size of known block chain.
        Utils.uint32ToByteStreamLE(bestHeight, buf);
        buf.write(relayTxesBeforeFilter ? 1 : 0);
    )

    ;;;
     ; Returns true if the version message indicates the sender has a full copy of the block chain,
     ; or if it's running in client mode (only has the headers).
     ;;
#_public
    boolean hasBlockChain()
    (§
        return ((localServices & NODE_NETWORK) == NODE_NETWORK);
    )

#_override
#_public
    boolean equals(Object o)
    (§
        if (this == o)
            return true;
        if (o == nil || getClass() != o.getClass())
            return false;
        VersionMessage other = (VersionMessage)o;
        return other.bestHeight == bestHeight
            && other.clientVersion == clientVersion
            && other.localServices == localServices
            && other.time == time
            && other.subVer.equals(subVer)
            && other.myAddr.equals(myAddr)
            && other.theirAddr.equals(theirAddr)
            && other.relayTxesBeforeFilter == relayTxesBeforeFilter;
    )

#_override
#_public
    int hashCode()
    (§
        return Objects.hashCode(bestHeight, clientVersion, localServices, time, subVer, myAddr, theirAddr, relayTxesBeforeFilter);
    )

#_override
#_public
    String toString()
    (§
        StringBuilder sb = new StringBuilder();
        sb.append("\n");
        sb.append("client version: ").append(clientVersion).append("\n");
        sb.append("local services: ").append(localServices).append("\n");
        sb.append("time:           ").append(time).append("\n");
        sb.append("my addr:        ").append(myAddr).append("\n");
        sb.append("their addr:     ").append(theirAddr).append("\n");
        sb.append("sub version:    ").append(subVer).append("\n");
        sb.append("best height:    ").append(bestHeight).append("\n");
        sb.append("delay tx relay: ").append(!relayTxesBeforeFilter).append("\n");
        return sb.toString();
    )

#_public
    VersionMessage duplicate()
    (§
        VersionMessage v = new VersionMessage(params, (int)bestHeight);
        v.clientVersion = clientVersion;
        v.localServices = localServices;
        v.time = time;
        v.myAddr = myAddr;
        v.theirAddr = theirAddr;
        v.subVer = subVer;
        v.relayTxesBeforeFilter = relayTxesBeforeFilter;
        return v;
    )

    ;;;
     ; Appends the given user-agent information to the subVer field.  The subVer is composed of a series of
     ; name:version pairs separated by slashes in the form of a path.  For example a typical subVer field for bitcoinj
     ; users might look like "/bitcoinj:0.13/MultiBit:1.2/" where libraries come further to the left.
     ;
     ; There can be as many components as you feel a need for, and the version string can be anything, but it is
     ; recommended to use A.B.C where A = major, B = minor and C = revision for software releases, and dates for
     ; auto-generated source repository snapshots.  A valid subVer begins and ends with a slash, therefore name
     ; and version are not allowed to contain such characters.
     ;
     ; Anything put in the "comments" field will appear in brackets and may be used for platform info, or anything
     ; else.  For example, calling <tt>appendToSubVer("MultiBit", "1.0", "Windows")</tt> will result in a subVer being
     ; set of "/bitcoinj:1.0/MultiBit:1.0(Windows)/".  Therefore the / ( and ) characters are reserved in all these
     ; components.  If you don't want to add a comment (recommended), pass null.
     ;
     ; See <a href="https://github.com/bitcoin/bips/blob/master/bip-0014.mediawiki">BIP 14</a> for more information.
     ;
     ; @param comments Optional (can be null) platform or other node specific information.
     ; @throws IllegalArgumentException if name, version or comments contains invalid characters.
     ;;
#_public
    void appendToSubVer(String name, String version, #_nilable String comments)
    (§
        checkSubVerComponent(name);
        checkSubVerComponent(version);

        if (comments != nil)
        (§
            checkSubVerComponent(comments);
            subVer = subVer.concat(String.format(Locale.US, "%s:%s(%s)/", name, version, comments));
        )
        else
        (§
            subVer = subVer.concat(String.format(Locale.US, "%s:%s/", name, version));
        )
    )

#_private
#_static
    void checkSubVerComponent(String component)
    (§
        if (component.contains("/") || component.contains("(") || component.contains(")"))
            throw new IllegalArgumentException("name contains invalid characters");
    )

    ;;;
     ; Returns true if the clientVersion field is >= Pong.MIN_PROTOCOL_VERSION.  If it is then ping() is usable.
     ;;
#_public
    boolean isPingPongSupported()
    (§
        return (params.getProtocolVersionNum(NetworkParameters.ProtocolVersion.PONG) <= clientVersion);
    )

    ;;;
     ; Returns true if the clientVersion field is >= FilteredBlock.MIN_PROTOCOL_VERSION.  If it is then Bloom filtering
     ; is available and the memory pool of the remote peer will be queried when the downloadData property is true.
     ;;
#_public
    boolean isBloomFilteringSupported()
    (§
        return (params.getProtocolVersionNum(NetworkParameters.ProtocolVersion.BLOOM_FILTER) <= clientVersion);
    )
)

(ns org.bitcoinj.core #_"VersionedChecksummedBytes"
    (:import [java.io Serializable]
             [java.util Arrays])
    (:import [com.google.common.base Objects Preconditions]
             [com.google.common.primitives Ints UnsignedBytes]))

;;;
 ; <p>In Bitcoin the following format is often used to represent some type of key:</p>
 ;
 ; <pre>[one version byte] [data bytes] [4 checksum bytes]</pre>
 ;
 ; <p>and the result is then Base58 encoded.
 ; This format is used for addresses, and private keys exported using the dumpprivkey command.</p>
 ;;
#_public
class VersionedChecksummedBytes implements Serializable, Cloneable, Comparable<VersionedChecksummedBytes>
(§
#_protected
#_final
    int version;
#_protected
    byte[] bytes;

#_protected
    VersionedChecksummedBytes(String encoded)
        throws AddressFormatException
    (§
        byte[] versionAndDataBytes = Base58.decodeChecked(encoded);
        byte versionByte = versionAndDataBytes[0];
        version = versionByte & 0xff;
        bytes = new byte[versionAndDataBytes.length - 1];
        System.arraycopy(versionAndDataBytes, 1, bytes, 0, versionAndDataBytes.length - 1);
    )

#_protected
    VersionedChecksummedBytes(int version, byte[] bytes)
    (§
        Preconditions.checkArgument(0 <= version && version < 256);

        this.version = version;
        this.bytes = bytes;
    )

    ;;;
     ; Returns the base-58 encoded String representation of this object,
     ; including version and checksum bytes.
     ;;
#_public
#_final
    String toBase58()
    (§
        ;; A stringified buffer is: 1 byte version + data bytes + 4 bytes check code (a truncated hash).
        byte[] addressBytes = new byte[1 + bytes.length + 4];
        addressBytes[0] = (byte)version;
        System.arraycopy(bytes, 0, addressBytes, 1, bytes.length);
        byte[] checksum = Sha256Hash.hashTwice(addressBytes, 0, bytes.length + 1);
        System.arraycopy(checksum, 0, addressBytes, bytes.length + 1, 4);
        return Base58.encode(addressBytes);
    )

#_override
#_public
    String toString()
    (§
        return toBase58();
    )

#_override
#_public
    int hashCode()
    (§
        return Objects.hashCode(version, Arrays.hashCode(bytes));
    )

#_override
#_public
    boolean equals(Object o)
    (§
        if (this == o)
            return true;
        if (o == nil || getClass() != o.getClass())
            return false;
        VersionedChecksummedBytes other = (VersionedChecksummedBytes)o;
        return (this.version == other.version && Arrays.equals(this.bytes, other.bytes));
    )

    ;;;
     ; {@inheritDoc}
     ;
     ; This implementation narrows the return type to <code>VersionedChecksummedBytes</code>
     ; and allows subclasses to throw <code>CloneNotSupportedException</code> even though it
     ; is never thrown by this implementation.
     ;;
#_override
#_public
    VersionedChecksummedBytes clone()
        throws CloneNotSupportedException
    (§
        return (VersionedChecksummedBytes)super.clone();
    )

    ;;;
     ; {@inheritDoc}
     ;
     ; This implementation uses an optimized Google Guava method to compare <code>bytes</code>.
     ;;
#_override
#_public
    int compareTo(VersionedChecksummedBytes o)
    (§
        int result = Ints.compare(this.version, o.version);
        return (result != 0) ? result : UnsignedBytes.lexicographicalComparator().compare(this.bytes, o.bytes);
    )

    ;;;
     ; Returns the "version" or "header" byte: the first byte of the data.  This is used to disambiguate what
     ; the contents apply to, for example, which network the key or address is valid on.
     ;
     ; @return a positive number between 0 and 255.
     ;;
#_public
    int getVersion()
    (§
        return version;
    )
)

(ns org.bitcoinj.core #_"WrongNetworkException"
    (:import [java.util Arrays]))

;;;
 ; This exception is thrown by the Address class when you try and decode an address with a version code that isn't
 ; used by that network.  You shouldn't allow the user to proceed in this case as they are trying to send money across
 ; different chains, an operation that is guaranteed to destroy the money.
 ;;
#_public
class WrongNetworkException extends AddressFormatException
(§
    ;;; The version code that was provided in the address. ;;
#_public
    int verCode;
    ;;; The list of acceptable versions that were expected given the addresses network parameters. ;;
#_public
    int[] acceptableVersions;

#_public
    WrongNetworkException(int verCode, int[] acceptableVersions)
    (§
        super("Version code of address did not match acceptable versions for network: " + verCode + " not in " + Arrays.toString(acceptableVersions));

        this.verCode = verCode;
        this.acceptableVersions = acceptableVersions;
    )
)

(ns org.bitcoinj.core.listeners #_"AbstractPeerDataEventListener"
    (:import #_[java.util *])
  #_(:require #_[org.bitcoinj.core *]))

;;;
 ; Deprecated: implement the more specific event listener interfaces instead to fill out only what you need.
 ;;
#_deprecated
#_public
#_abstract
class AbstractPeerDataEventListener implements PeerDataEventListener
(§
#_override
#_public
    void onBlocksDownloaded(Peer peer, Block block, #_nilable FilteredBlock filteredBlock, int blocksLeft)
    (§
    )

#_override
#_public
    void onChainDownloadStarted(Peer peer, int blocksLeft)
    (§
    )

#_override
#_public
    Message onPreMessageReceived(Peer peer, Message m)
    (§
        ;; Just pass the message right through for further processing.
        return m;
    )

#_override
#_public
    List<Message> getData(Peer peer, GetDataMessage m)
    (§
        return nil;
    )
)

(ns org.bitcoinj.core.listeners #_"BlockChainListener"
)

;;;
 ; Old interface for backwards compatibility. Implement the more specific interfaces instead.
 ;;
#_deprecated
#_public
interface BlockChainListener extends NewBestBlockListener, TransactionReceivedInBlockListener, ReorganizeListener
(§
)

(ns org.bitcoinj.core.listeners #_"BlocksDownloadedEventListener"
  #_(:require #_[org.bitcoinj.core *]))

;;;
 ; <p>Implementors can listen to events like blocks being downloaded/transactions being broadcast/connect/disconnects,
 ; they can pre-filter messages before they are procesesed by a {@link Peer} or {@link PeerGroup}, and they can
 ; provide transactions to remote peers when they ask for them.</p>
 ;;
#_public
interface BlocksDownloadedEventListener
(§
    ;; TODO: Fix the Block/FilteredBlock type hierarchy so we can avoid the stupid typeless API here.
    ;;;
     ; <p>Called on a Peer thread when a block is received.</p>
     ;
     ; <p>The block may be a Block object that contains transactions, a Block object that is only a header when
     ; fast catchup is being used.  If set, filteredBlock can be used to retrieve the list of associated transactions.</p>
     ;
     ; @param peer The peer receiving the block.
     ; @param block The downloaded block.
     ; @param filteredBlock If non-null, the object that wraps the block header passed as the block param.
     ; @param blocksLeft The number of blocks left to download.
     ;;
    void onBlocksDownloaded(Peer peer, Block block, #_nilable FilteredBlock filteredBlock, int blocksLeft);
)

(ns org.bitcoinj.core.listeners #_"ChainDownloadStartedEventListener"
  #_(:require #_[org.bitcoinj.core *]))

;;;
 ; <p>Implementors can listen to events like blocks being downloaded/transactions being broadcast/connect/disconnects,
 ; they can pre-filter messages before they are procesesed by a {@link Peer} or {@link PeerGroup}, and they can
 ; provide transactions to remote peers when they ask for them.</p>
 ;;
#_public
interface ChainDownloadStartedEventListener
(§
    ;;;
     ; Called when a download is started with the initial number of blocks to be downloaded.
     ;
     ; @param peer The peer receiving the block.
     ; @param blocksLeft The number of blocks left to download.
     ;;
    void onChainDownloadStarted(Peer peer, int blocksLeft);
)

(ns org.bitcoinj.core.listeners #_"DownloadProgressTracker"
    (:import [java.util Date Locale]
             [java.util.concurrent ExecutionException])
    (:import [com.google.common.util.concurrent ListenableFuture SettableFuture]
             [org.slf4j Logger LoggerFactory])
  #_(:require [org.bitcoinj.core Block FilteredBlock Peer Utils]))

;;;
 ; <p>An implementation of {@link AbstractPeerDataEventListener} that listens to chain download events and tracks
 ; progress as a percentage.  The default implementation prints progress to stdout, but you can subclass it and
 ; override the progress method to update a GUI instead.</p>
 ;;
#_public
class DownloadProgressTracker extends AbstractPeerDataEventListener
(§
#_private
#_static
#_final
    Logger log = LoggerFactory.getLogger(DownloadProgressTracker.class);

#_private
    int originalBlocksLeft = -1;
#_private
    int lastPercent = 0;
#_private
    SettableFuture<Long> future = SettableFuture.create();
#_private
    boolean caughtUp = false;

#_override
#_public
    void onChainDownloadStarted(Peer peer, int blocksLeft)
    (§
        if (0 < blocksLeft && originalBlocksLeft == -1)
            startDownload(blocksLeft);
        ;; Only mark this the first time, because this method can be called more than once during a chain download
        ;; if we switch peers during it.
        if (originalBlocksLeft == -1)
            originalBlocksLeft = blocksLeft;
        else
            log.info("Chain download switched to {}", peer);
        if (blocksLeft == 0)
        (§
            doneDownload();
            future.set(peer.getBestHeight());
        )
    )

#_override
#_public
    void onBlocksDownloaded(Peer peer, Block block, #_nilable FilteredBlock filteredBlock, int blocksLeft)
    (§
        if (caughtUp)
            return;

        if (blocksLeft == 0)
        (§
            caughtUp = true;
            doneDownload();
            future.set(peer.getBestHeight());
        )

        if (blocksLeft < 0 || originalBlocksLeft <= 0)
            return;

        double pct = 100.0 - (100.0 * (blocksLeft / (double)originalBlocksLeft));
        if ((int)pct != lastPercent)
        (§
            progress(pct, blocksLeft, new Date(block.getTimeSeconds() * 1000));
            lastPercent = (int)pct;
        )
    )

    ;;;
     ; Called when download progress is made.
     ;
     ; @param pct The percentage of chain downloaded, estimated.
     ; @param date The date of the last block downloaded.
     ;;
#_protected
    void progress(double pct, int blocksSoFar, Date date)
    (§
        log.info(String.format(Locale.US, "Chain download %d%% done with %d blocks to go, block date %s", (int)pct, blocksSoFar, Utils.dateTimeFormat(date)));
    )

    ;;;
     ; Called when download is initiated.
     ;
     ; @param blocks The number of blocks to download, estimated.
     ;;
#_protected
    void startDownload(int blocks)
    (§
        log.info("Downloading block chain of size " + blocks + ". " + (1000 < blocks ? "This may take a while." : ""));
    )

    ;;;
     ; Called when we are done downloading the block chain.
     ;;
#_protected
    void doneDownload()
    (§
    )

    ;;;
     ; Wait for the chain to be downloaded.
     ;;
#_public
    void await()
        throws InterruptedException
    (§
        try
        (§
            future.get();
        )
        catch (ExecutionException e)
        (§
            throw new RuntimeException(e);
        )
    )

    ;;;
     ; Returns a listenable future that completes with the height of the best chain (as reported by the peer) once chain
     ; download seems to be finished.
     ;;
#_public
    ListenableFuture<Long> getFuture()
    (§
        return future;
    )
)

(ns org.bitcoinj.core.listeners #_"GetDataEventListener"
    (:import #_[java.util *])
  #_(:require #_[org.bitcoinj.core *]))

;;;
 ; <p>Implementors can listen to events like blocks being downloaded/transactions being broadcast/connect/disconnects,
 ; they can pre-filter messages before they are procesesed by a {@link Peer} or {@link PeerGroup}, and they can
 ; provide transactions to remote peers when they ask for them.</p>
 ;;
#_public
interface GetDataEventListener
(§
    ;;;
     ; <p>Called when a peer receives a getdata message, usually in response to an "inv" being broadcast.  Return as many
     ; items as possible which appear in the {@link GetDataMessage}, or null if you're not interested in responding.</p>
     ;
     ; <p>Note that this will never be called if registered with any executor other than
     ; {@link org.bitcoinj.utils.Threading#SAME_THREAD}</p>
     ;;
#_nilable
    List<Message> getData(Peer peer, GetDataMessage m);
)

(ns org.bitcoinj.core.listeners #_"NewBestBlockListener"
  #_(:require [org.bitcoinj.core StoredBlock VerificationException]))

;;;
 ; Listener interface for when a new block on the best chain is seen.
 ;;
#_public
interface NewBestBlockListener
(§
    ;;;
     ; Called when a new block on the best chain is seen, after relevant transactions are extracted and sent to us via either
     ; {@link TransactionReceivedInBlockListener#receiveFromBlock(org.bitcoinj.core.Transaction, org.bitcoinj.core.StoredBlock, org.bitcoinj.core.BlockChain.NewBlockType, int relativityOffset)}
     ; or {@link TransactionReceivedInBlockListener#notifyTransactionIsInBlock(org.bitcoinj.core.Sha256Hash, org.bitcoinj.core.StoredBlock, org.bitcoinj.core.BlockChain.NewBlockType, int)}.
     ;
     ; If this block is causing a re-organise to a new chain, this method is NOT
     ; called even though the block may be the new best block: your reorganize
     ; implementation is expected to do whatever would normally be done do for a
     ; new best block in this case.
     ;;
    void notifyNewBestBlock(final StoredBlock block)
        throws VerificationException;
)

(ns org.bitcoinj.core.listeners #_"OnTransactionBroadcastListener"
  #_(:require #_[org.bitcoinj.core *]))

;;;
 ; Called when a new transaction is broadcast over the network.
 ;;
#_public
interface OnTransactionBroadcastListener
(§
    ;;;
     ; Called when a new transaction is broadcast over the network.
     ;;
    void onTransaction(Peer peer, Transaction t);
)

(ns org.bitcoinj.core.listeners #_"PeerConnectedEventListener"
  #_(:require [org.bitcoinj.core Peer]))

;;;
 ; <p>Implementors can listen to events indicating a new peer connecting.</p>
 ;;
#_public
interface PeerConnectedEventListener
(§
    ;;;
     ; Called when a peer is connected.  If this listener is registered to a {@link Peer} instead of a {@link PeerGroup},
     ; peerCount will always be 1.
     ;
     ; @param peer
     ; @param peerCount The total number of connected peers.
     ;;
    void onPeerConnected(Peer peer, int peerCount);
)

(ns org.bitcoinj.core.listeners #_"PeerDataEventListener"
  #_(:require #_[org.bitcoinj.core *]))

;;;
 ; <p>Implementors can listen to events like blocks being downloaded/transactions being broadcast/connect/disconnects,
 ; they can pre-filter messages before they are processed by a {@link Peer} or {@link PeerGroup}, and they can
 ; provide transactions to remote peers when they ask for them.</p>
 ;;
#_public
interface PeerDataEventListener extends BlocksDownloadedEventListener, ChainDownloadStartedEventListener, GetDataEventListener, PreMessageReceivedEventListener
(§
)

(ns org.bitcoinj.core.listeners #_"PeerDisconnectedEventListener"
  #_(:require [org.bitcoinj.core Peer]))

;;;
 ; <p>Implementors can listen to events indicating a peer disconnecting.</p>
 ;;
#_public
interface PeerDisconnectedEventListener
(§
    ;;;
     ; Called when a peer is disconnected.  Note that this won't be called if the listener is registered on
     ; a {@link PeerGroup} and the group is in the process of shutting down.  If this listener is registered to
     ; a {@link Peer} instead of a {@link PeerGroup}, peerCount will always be 0.  This handler can be called
     ; without a corresponding invocation of onPeerConnected if the initial connection is never successful.
     ;
     ; @param peer
     ; @param peerCount The total number of connected peers.
     ;;
    void onPeerDisconnected(Peer peer, int peerCount);
)

(ns org.bitcoinj.core.listeners #_"PeerDiscoveredEventListener"
    (:import [java.util Set])
  #_(:require [org.bitcoinj.core Peer PeerAddress]))

;;;
 ; <p>Implementors can listen to events for peers being discovered.</p>
 ;;
#_public
interface PeerDiscoveredEventListener
(§
    ;;;
     ; <p>Called when peers are discovered, this happens at startup of {@link PeerGroup}
     ; or if we run out of suitable {@link Peer}s to connect to.</p>
     ;
     ; @param peerAddresses The set of discovered {@link PeerAddress}es.
     ;;
    void onPeersDiscovered(Set<PeerAddress> peerAddresses);
)

(ns org.bitcoinj.core.listeners #_"PreMessageReceivedEventListener"
  #_(:require #_[org.bitcoinj.core *]))

;;;
 ; <p>Implementors can listen to events like blocks being downloaded/transactions being broadcast/connect/disconnects,
 ; they can pre-filter messages before they are procesesed by a {@link Peer} or {@link PeerGroup}, and they can
 ; provide transactions to remote peers when they ask for them.</p>
 ;;
#_public
interface PreMessageReceivedEventListener
(§
    ;;;
     ; <p>Called when a message is received by a peer, before the message is processed.  The returned message is
     ; processed instead.  Returning null will cause the message to be ignored by the Peer returning the same message
     ; object allows you to see the messages received but not change them.  The result from one event listeners
     ; callback is passed as "m" to the next, forming a chain.</p>
     ;
     ; <p>Note that this will never be called if registered with any executor other than
     ; {@link org.bitcoinj.utils.Threading#SAME_THREAD}.</p>
     ;;
    Message onPreMessageReceived(Peer peer, Message m);
)

(ns org.bitcoinj.core.listeners #_"ReorganizeListener"
    (:import [java.util List])
  #_(:require [org.bitcoinj.core StoredBlock VerificationException]))

;;;
 ; Listener interface for when the best chain has changed.
 ;;
#_public
interface ReorganizeListener
(§
    ;;;
     ; Called by the {@link org.bitcoinj.core.BlockChain} when the best chain (representing total work done)
     ; has changed.  In this case, we need to go through our transactions and find out if any have become invalid.
     ; It's possible for our balance to go down in this case: money we thought we had can suddenly vanish
     ; if the rest of the network agrees it should be so.
     ;
     ; The oldBlocks/newBlocks lists are ordered height-wise from top first to bottom last (i.e. newest blocks first).
     ;;
    void reorganize(StoredBlock splitPoint, List<StoredBlock> oldBlocks, List<StoredBlock> newBlocks)
        throws VerificationException;
)

(ns org.bitcoinj.core.listeners #_"TransactionConfidenceEventListener"
  #_(:require [org.bitcoinj.core Transaction]
             [org.bitcoinj.wallet Wallet]))

;;;
 ; <p>Implementors are called when confidence of a transaction changes.</p>
 ;;
#_public
interface TransactionConfidenceEventListener
(§
    ;;;
     ; <p>Called when a transaction changes its confidence level.  You can also attach event listeners to
     ; the individual transactions, if you don't care about all of them.  Usually you would save the wallet to disk
     ; after receiving this callback unless you already set up autosaving.</p>
     ;
     ; <p>You should pay attention to this callback in case a transaction becomes <i>dead</i>, that is, a transaction
     ; you believed to be active (send or receive) becomes overridden by the network.  This can happen if</p>
     ;
     ; <ol>
     ;     <li>You are sharing keys between wallets and accidentally create/broadcast a double spend.</li>
     ;     <li>Somebody is attacking the network and reversing transactions, i.e. the user is a victim of fraud.</li>
     ;     <li>A bug: for example you create a transaction, broadcast it but fail to commit it.
     ;     The {@link Wallet} will then re-use the same outputs when creating the next spend.</li>
     ; </ol>
     ;
     ; <p>To find if the transaction is dead, you can use <tt>tx.getConfidence().getConfidenceType() ==
     ; TransactionConfidence.ConfidenceType.DEAD</tt>.  If it is, you should notify the user in some way
     ; so they know the thing they bought may not arrive/the thing they sold should not be dispatched.</p>
     ;
     ; <p>Note that this callback will be invoked for every transaction in the wallet, for every new block that is
     ; received (because the depth has changed).  <b>If you want to update a UI view from the contents of the wallet
     ; it is more efficient to use onWalletChanged instead.</b></p>
     ;;
    void onTransactionConfidenceChanged(Wallet wallet, Transaction tx);
)

(ns org.bitcoinj.core.listeners #_"TransactionReceivedInBlockListener"
  #_(:require [org.bitcoinj.core BlockChain Sha256Hash StoredBlock Transaction VerificationException]))

;;;
 ; Listener interface for when we receive a new block that contains a relevant transaction.
 ;;
#_public
interface TransactionReceivedInBlockListener
(§
    ;;;
     ; <p>Called by the {@link BlockChain} when we receive a new block that contains a relevant transaction.</p>
     ;
     ; <p>A transaction may be received multiple times if is included into blocks in parallel chains.  The blockType
     ; parameter describes whether the containing block is on the main/best chain or whether it's on a presently
     ; inactive side chain.</p>
     ;
     ; <p>The relativityOffset parameter is an arbitrary number used to establish an ordering between transactions
     ; within the same block.  In the case where full blocks are being downloaded, it is simply the index of the
     ; transaction within that block.  When Bloom filtering is in use, we don't find out the exact offset into a block
     ; that a transaction occurred at, so the relativity count is not reflective of anything in an absolute sense but
     ; rather exists only to order the transaction relative to the others.</p>
     ;;
    void receiveFromBlock(Transaction tx, StoredBlock block, BlockChain.NewBlockType blockType, int relativityOffset)
        throws VerificationException;

    ;;;
     ; <p>Called by the {@link BlockChain} when we receive a new {@link FilteredBlock} that contains the given
     ; transaction hash in its merkle tree.</p>
     ;
     ; <p>A transaction may be received multiple times if is included into blocks in parallel chains.  The blockType
     ; parameter describes whether the containing block is on the main/best chain or whether it's on a presently
     ; inactive side chain.</p>
     ;
     ; <p>The relativityOffset parameter in this case is an arbitrary (meaningless) number, that is useful only when
     ; compared to the relativity count of another transaction received inside the same block.  It is used to establish
     ; an ordering of transactions relative to one another.</p>
     ;
     ; <p>This method should return false if the given tx hash isn't known about, e.g. because the the transaction was
     ; a Bloom false positive.  If it was known about and stored, it should return true.  The caller may need to know
     ; this to calculate the effective FP rate.</p>
     ;
     ; @return whether the transaction is known about i.e. was considered relevant previously.
     ;;
    boolean notifyTransactionIsInBlock(Sha256Hash txHash, StoredBlock block, BlockChain.NewBlockType blockType, int relativityOffset)
        throws VerificationException;
)

(ns org.bitcoinj.crypto #_"ChildNumber"
    (:import [java.util Locale])
    (:import [com.google.common.primitives Ints]))

;;;
 ; <p>This is just a wrapper for the i (child number) as per BIP 32 with a boolean getter for the most significant bit
 ; and a getter for the actual 0-based child number.  A {@link java.util.List} of these forms a <i>path</i> through a
 ; {@link DeterministicHierarchy}.  This class is immutable.
 ;;
#_public
class ChildNumber implements Comparable<ChildNumber>
(§
    ;;;
     ; The bit that's set in the child number to indicate whether this key is "hardened".  Given a hardened key, it is
     ; not possible to derive a child public key if you know only the hardened public key.  With a non-hardened key this
     ; is possible, so you can derive trees of public keys given only a public parent, but the downside is that it's
     ; possible to leak private keys if you disclose a parent public key and a child private key (elliptic curve maths
     ; allows you to work upwards).
     ;;
#_public
#_static
#_final
    int HARDENED_BIT = 0x80000000;

#_public
#_static
#_final
    ChildNumber ZERO = new ChildNumber(0);
#_public
#_static
#_final
    ChildNumber ONE = new ChildNumber(1);
#_public
#_static
#_final
    ChildNumber ZERO_HARDENED = new ChildNumber(0, true);

    ;;; Integer i as per BIP 32 spec, including the MSB denoting derivation type (0 = public, 1 = private). ;;
#_private
#_final
    int i;

#_public
    ChildNumber(int childNumber, boolean isHardened)
    (§
        if (hasHardenedBit(childNumber))
            throw new IllegalArgumentException("Most significant bit is reserved and shouldn't be set: " + childNumber);

        i = isHardened ? (childNumber | HARDENED_BIT) : childNumber;
    )

#_public
    ChildNumber(int i)
    (§
        this.i = i;
    )

    ;;; Returns the uint32 encoded form of the path element, including the most significant bit. ;;
#_public
    int getI()
    (§
        return i;
    )

    ;;; Returns the uint32 encoded form of the path element, including the most significant bit. ;;
#_public
    int i()
    (§
        return i;
    )

#_public
    boolean isHardened()
    (§
        return hasHardenedBit(i);
    )

#_private
#_static
    boolean hasHardenedBit(int a)
    (§
        return ((a & HARDENED_BIT) != 0);
    )

    ;;; Returns the child number without the hardening bit set (i.e. index in that part of the tree). ;;
#_public
    int num()
    (§
        return (i & ~HARDENED_BIT);
    )

#_override
#_public
    String toString()
    (§
        return String.format(Locale.US, "%d%s", num(), isHardened() ? "H" : "");
    )

#_override
#_public
    boolean equals(Object o)
    (§
        if (this == o)
            return true;
        if (o == nil || getClass() != o.getClass())
            return false;
        return (i == ((ChildNumber)o).i);
    )

#_override
#_public
    int hashCode()
    (§
        return i;
    )

#_override
#_public
    int compareTo(ChildNumber other)
    (§
        ;; Note that in this implementation compareTo() is not consistent with equals().
        return Ints.compare(this.num(), other.num());
    )
)

(ns org.bitcoinj.crypto #_"DeterministicHierarchy"
    (:import [java.util List Locale Map])
    (:import [com.google.common.base Preconditions]
             [com.google.common.collect ImmutableList Maps]))

;; TODO: This whole API feels a bit object heavy.  Do we really need ChildNumber and so many maps, etc?
;; TODO: Should we be representing this using an actual tree arrangement in memory instead of a bunch of hashmaps?

;;;
 ; <p>A DeterministicHierarchy calculates and keeps a whole tree (hierarchy) of keys originating from a single
 ; root key.  This implements part of the BIP 32 specification.  A deterministic key tree is useful because
 ; Bitcoin's privacy system require new keys to be created for each transaction, but managing all these
 ; keys quickly becomes unwieldy.  In particular it becomes hard to back up and distribute them.  By having
 ; a way to derive random-looking but deterministic keys we can make wallet backup simpler and gain the
 ; ability to hand out {@link DeterministicKey}s to other people who can then create new addresses
 ; on the fly, without having to contact us.</p>
 ;
 ; <p>The hierarchy is started from a single root key, and a location in the tree is given by a path which
 ; is a list of {@link ChildNumber}s.</p>
 ;;
#_public
class DeterministicHierarchy
(§
#_private
#_final
    Map<ImmutableList<ChildNumber>, DeterministicKey> keys = Maps.newHashMap();
#_private
#_final
    ImmutableList<ChildNumber> rootPath;
    ;; Keep track of how many child keys each node has.  This is kind of weak.
#_private
#_final
    Map<ImmutableList<ChildNumber>, ChildNumber> lastChildNumbers = Maps.newHashMap();

#_public
#_static
#_final
    int BIP32_STANDARDISATION_TIME_SECS = 1369267200;

    ;;;
     ; Constructs a new hierarchy rooted at the given key.  Note that this does not have to be the top of the tree.
     ; You can construct a DeterministicHierarchy for a subtree of a larger tree that you may not own.
     ;;
#_public
    DeterministicHierarchy(DeterministicKey rootKey)
    (§
        putKey(rootKey);
        rootPath = rootKey.getPath();
    )

    ;;;
     ; Inserts a key into the heirarchy.  Used during deserialization: you normally don't need this.  Keys must be
     ; inserted in order.
     ;;
#_public
#_final
    void putKey(DeterministicKey key)
    (§
        ImmutableList<ChildNumber> path = key.getPath();
        ;; Update our tracking of what the next child in each branch of the tree should be.  Just assume that keys
        ;; are inserted in order here.
#_final
        DeterministicKey parent = key.getParent();
        if (parent != nil)
            lastChildNumbers.put(parent.getPath(), key.getChildNumber());
        keys.put(path, key);
    )

    ;;;
     ; Returns a key for the given path, optionally creating it.
     ;
     ; @param path The path to the key.
     ; @param relativePath Whether the path is relative to the root path.
     ; @param create Whether the key corresponding to path should be created (with any necessary ancestors) if it doesn't exist already.
     ; @return next newly created key using the child derivation function.
     ; @throws IllegalArgumentException if create is false and the path was not found.
     ;;
#_public
    DeterministicKey get(List<ChildNumber> path, boolean relativePath, boolean create)
    (§
        ImmutableList<ChildNumber> absolutePath = relativePath
                ? ImmutableList.<ChildNumber>builder().addAll(rootPath).addAll(path).build()
                : ImmutableList.copyOf(path);
        if (!keys.containsKey(absolutePath))
        (§
            if (!create)
                throw new IllegalArgumentException(String.format(Locale.US, "No key found for %s path %s.", relativePath ? "relative" : "absolute", HDUtils.formatPath(path)));
            Preconditions.checkArgument(0 < absolutePath.size(), "Can't derive the master key: nothing to derive from.");
            DeterministicKey parent = get(absolutePath.subList(0, absolutePath.size() - 1), false, true);
            putKey(HDKeyDerivation.deriveChildKey(parent, absolutePath.get(absolutePath.size() - 1)));
        )
        return keys.get(absolutePath);
    )

    ;;;
     ; Extends the tree by calculating the next key that hangs off the given parent path.  For example, if you pass
     ; a path of 1/2 here and there are already keys 1/2/1 and 1/2/2 then it will derive 1/2/3.
     ;
     ; @param parentPath The path to the parent.
     ; @param relative Whether the path is relative to the root path.
     ; @param createParent Whether the parent corresponding to path should be created (with any necessary ancestors) if it doesn't exist already.
     ; @param privateDerivation Whether to use private or public derivation.
     ; @return next newly created key using the child derivation funtcion.
     ; @throws IllegalArgumentException if the parent doesn't exist and createParent is false.
     ;;
#_public
    DeterministicKey deriveNextChild(ImmutableList<ChildNumber> parentPath, boolean relative, boolean createParent, boolean privateDerivation)
    (§
        DeterministicKey parent = get(parentPath, relative, createParent);
        int nAttempts = 0;
        while (nAttempts++ < HDKeyDerivation.MAX_CHILD_DERIVATION_ATTEMPTS)
        (§
            try
            (§
                ChildNumber createChildNumber = getNextChildNumberToDerive(parent.getPath(), privateDerivation);
                return deriveChild(parent, createChildNumber);
            )
            catch (HDDerivationException _)
            (§
            )
        )
        throw new HDDerivationException("Maximum number of child derivation attempts reached, this is probably an indication of a bug.");
    )

#_private
    ChildNumber getNextChildNumberToDerive(ImmutableList<ChildNumber> path, boolean privateDerivation)
    (§
        ChildNumber lastChildNumber = lastChildNumbers.get(path);
        ChildNumber nextChildNumber = new ChildNumber(lastChildNumber != nil ? lastChildNumber.num() + 1 : 0, privateDerivation);
        lastChildNumbers.put(path, nextChildNumber);
        return nextChildNumber;
    )

#_public
    int getNumChildren(ImmutableList<ChildNumber> path)
    (§
#_final
        ChildNumber cn = lastChildNumbers.get(path);
        ;; Children start with zero based childnumbers.
        return (cn == nil) ? 0 : 1 + cn.num();
    )

    ;;;
     ; Extends the tree by calculating the requested child for the given path.  For example, to get the key at position
     ; 1/2/3 you would pass 1/2 as the parent path and 3 as the child number.
     ;
     ; @param parentPath The path to the parent.
     ; @param relative Whether the path is relative to the root path.
     ; @param createParent Whether the parent corresponding to path should be created (with any necessary ancestors) if it doesn't exist already.
     ; @return the requested key.
     ; @throws IllegalArgumentException if the parent doesn't exist and createParent is false.
     ;;
#_public
    DeterministicKey deriveChild(List<ChildNumber> parentPath, boolean relative, boolean createParent, ChildNumber createChildNumber)
    (§
        return deriveChild(get(parentPath, relative, createParent), createChildNumber);
    )

#_private
    DeterministicKey deriveChild(DeterministicKey parent, ChildNumber createChildNumber)
    (§
        DeterministicKey childKey = HDKeyDerivation.deriveChildKey(parent, createChildNumber);
        putKey(childKey);
        return childKey;
    )

    ;;;
     ; Returns the root key that the {@link DeterministicHierarchy} was created with.
     ;;
#_public
    DeterministicKey getRootKey()
    (§
        return get(rootPath, false, false);
    )
)

(ns org.bitcoinj.crypto #_"DeterministicKey"
    (:import [java.math BigInteger]
             [java.nio ByteBuffer]
             [java.util Arrays Comparator])
    (:import [com.google.common.base MoreObjects Objects Preconditions]
             [com.google.common.collect ImmutableList]
             [org.spongycastle.crypto.params KeyParameter]
             [org.spongycastle.math.ec ECPoint])
  #_(:require #_[org.bitcoinj.core *]
             #_static #_[org.bitcoinj.core.Utils HEX]))

;;;
 ; A deterministic key is a node in a {@link DeterministicHierarchy}.  As per
 ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">the BIP 32 specification</a> it is a pair
 ; (key, chaincode).  If you know its path in the tree and its chain code you can derive more keys from this.
 ; To obtain one of these, you can call {@link HDKeyDerivation#createMasterPrivateKey(byte[])}.
 ;;
#_public
class DeterministicKey extends ECKey
(§
    ;;; Sorts deterministic keys in the order of their child number.  That's <i>usually</i> the order used to derive them. ;;
#_public
#_static
#_final
    Comparator<ECKey> CHILDNUM_ORDER = new Comparator<ECKey>()
    (§
#_override
#_public
        int compare(ECKey k1, ECKey k2)
        (§
            ChildNumber cn1 = ((DeterministicKey)k1).getChildNumber();
            ChildNumber cn2 = ((DeterministicKey)k2).getChildNumber();
            return cn1.compareTo(cn2);
        )
    );

#_private
#_final
    DeterministicKey parent;
#_private
#_final
    ImmutableList<ChildNumber> childNumberPath;
#_private
#_final
    int depth;
#_private
    int parentFingerprint; ;; 0 if this key is root node of key hierarchy

    ;;; 32 bytes ;;
#_private
#_final
    byte[] chainCode;

    ;;; Constructs a key from its components.  This is not normally something you should use. ;;
#_public
    DeterministicKey(ImmutableList<ChildNumber> childNumberPath, byte[] chainCode, LazyECPoint publicAsPoint, #_nilable BigInteger priv, #_nilable DeterministicKey parent)
    (§
        super(priv, compressPoint(Preconditions.checkNotNull(publicAsPoint)));

        Preconditions.checkArgument(chainCode.length == 32);

        this.parent = parent;
        this.childNumberPath = Preconditions.checkNotNull(childNumberPath);
        this.chainCode = Arrays.copyOf(chainCode, chainCode.length);
        this.depth = (parent != nil) ? parent.depth + 1 : 0;
        this.parentFingerprint = (parent != nil) ? parent.getFingerprint() : 0;
    )

#_public
    DeterministicKey(ImmutableList<ChildNumber> childNumberPath, byte[] chainCode, ECPoint publicAsPoint, #_nilable BigInteger priv, #_nilable DeterministicKey parent)
    (§
        this(childNumberPath, chainCode, new LazyECPoint(publicAsPoint), priv, parent);
    )

    ;;; Constructs a key from its components.  This is not normally something you should use. ;;
#_public
    DeterministicKey(ImmutableList<ChildNumber> childNumberPath, byte[] chainCode, BigInteger priv, #_nilable DeterministicKey parent)
    (§
        super(priv, compressPoint(ECKey.publicPointFromPrivate(priv)));

        Preconditions.checkArgument(chainCode.length == 32);

        this.parent = parent;
        this.childNumberPath = Preconditions.checkNotNull(childNumberPath);
        this.chainCode = Arrays.copyOf(chainCode, chainCode.length);
        this.depth = (parent != nil) ? parent.depth + 1 : 0;
        this.parentFingerprint = (parent != nil) ? parent.getFingerprint() : 0;
    )

    ;;; Constructs a key from its components.  This is not normally something you should use. ;;
#_public
    DeterministicKey(ImmutableList<ChildNumber> childNumberPath, byte[] chainCode, KeyCrypter crypter, LazyECPoint pub, EncryptedData priv, #_nilable DeterministicKey parent)
    (§
        this(childNumberPath, chainCode, pub, nil, parent);
        this.encryptedPrivateKey = Preconditions.checkNotNull(priv);
        this.keyCrypter = Preconditions.checkNotNull(crypter);
    )

    ;;;
     ; Return the fingerprint of this key's parent as an int value, or zero if this key is the
     ; root node of the key hierarchy.  Raise an exception if the arguments are inconsistent.
     ; This method exists to avoid code repetition in the constructors.
     ;;
#_private
    int ascertainParentFingerprint(DeterministicKey parentKey, int parentFingerprint)
        throws IllegalArgumentException
    (§
        if (parentFingerprint != 0)
        (§
            if (parent != nil)
                Preconditions.checkArgument(parent.getFingerprint() == parentFingerprint, "parent fingerprint mismatch", Integer.toHexString(parent.getFingerprint()), Integer.toHexString(parentFingerprint));
            return parentFingerprint;
        )

        return 0;
    )

    ;;;
     ; Constructs a key from its components, including its public key data and possibly-redundant
     ; information about its parent key.  Invoked when deserializing, but otherwise not something
     ; that you normally should use.
     ;;
#_public
    DeterministicKey(ImmutableList<ChildNumber> childNumberPath, byte[] chainCode, LazyECPoint publicAsPoint, #_nilable DeterministicKey parent, int depth, int parentFingerprint)
    (§
        super(nil, compressPoint(Preconditions.checkNotNull(publicAsPoint)));

        Preconditions.checkArgument(chainCode.length == 32);

        this.parent = parent;
        this.childNumberPath = Preconditions.checkNotNull(childNumberPath);
        this.chainCode = Arrays.copyOf(chainCode, chainCode.length);
        this.depth = depth;
        this.parentFingerprint = ascertainParentFingerprint(parent, parentFingerprint);
    )

    ;;;
     ; Constructs a key from its components, including its private key data and possibly-redundant
     ; information about its parent key.  Invoked when deserializing, but otherwise not something that
     ; you normally should use.
     ;;
#_public
    DeterministicKey(ImmutableList<ChildNumber> childNumberPath, byte[] chainCode, BigInteger priv, #_nilable DeterministicKey parent, int depth, int parentFingerprint)
    (§
        super(priv, compressPoint(ECKey.publicPointFromPrivate(priv)));

        Preconditions.checkArgument(chainCode.length == 32);

        this.parent = parent;
        this.childNumberPath = Preconditions.checkNotNull(childNumberPath);
        this.chainCode = Arrays.copyOf(chainCode, chainCode.length);
        this.depth = depth;
        this.parentFingerprint = ascertainParentFingerprint(parent, parentFingerprint);
    )

    ;;; Clones the key. ;;
#_public
    DeterministicKey(DeterministicKey keyToClone, DeterministicKey newParent)
    (§
        super(keyToClone.priv, keyToClone.pub.get());

        this.parent = newParent;
        this.childNumberPath = keyToClone.childNumberPath;
        this.chainCode = keyToClone.chainCode;
        this.encryptedPrivateKey = keyToClone.encryptedPrivateKey;
        this.depth = this.childNumberPath.size();
        this.parentFingerprint = this.parent.getFingerprint();
    )

    ;;;
     ; Returns the path through some {@link DeterministicHierarchy} which reaches this keys position in the tree.
     ; A path can be written as 1/2/1 which means the first child of the root, the second child of that node, then
     ; the first child of that node.
     ;;
#_public
    ImmutableList<ChildNumber> getPath()
    (§
        return childNumberPath;
    )

    ;;;
     ; Returns the path of this key as a human readable string starting with M to indicate the master key.
     ;;
#_public
    String getPathAsString()
    (§
        return HDUtils.formatPath(getPath());
    )

    ;;;
     ; Return this key's depth in the hierarchy, where the root node is at depth zero.
     ; This may be different than the number of segments in the path if this key was
     ; deserialized without access to its parent.
     ;;
#_public
    int getDepth()
    (§
        return depth;
    )

    ;;; Returns the last element of the path returned by {@link DeterministicKey#getPath()}. ;;
#_public
    ChildNumber getChildNumber()
    (§
        return (childNumberPath.size() == 0) ? ChildNumber.ZERO : childNumberPath.get(childNumberPath.size() - 1);
    )

    ;;;
     ; Returns the chain code associated with this key.  See the specification to learn more about chain codes.
     ;;
#_public
    byte[] getChainCode()
    (§
        return chainCode;
    )

    ;;;
     ; Returns RIPE-MD160(SHA256(pub key bytes)).
     ;;
#_public
    byte[] getIdentifier()
    (§
        return Utils.sha256hash160(getPubKey());
    )

    ;;; Returns the first 32 bits of the result of {@link #getIdentifier()}. ;;
#_public
    int getFingerprint()
    (§
        ;; TODO: Why is this different than armory's fingerprint?  BIP 32: "The first 32 bits of the identifier are called the fingerprint."
        return ByteBuffer.wrap(Arrays.copyOfRange(getIdentifier(), 0, 4)).getInt();
    )

#_nilable
#_public
    DeterministicKey getParent()
    (§
        return parent;
    )

    ;;;
     ; Return the fingerprint of the key from which this key was derived, if this is
     ; a child key, or else an array of four zero-value bytes.
     ;;
#_public
    int getParentFingerprint()
    (§
        return parentFingerprint;
    )

    ;;;
     ; Returns private key bytes, padded with zeros to 33 bytes.
     ; @throws java.lang.IllegalStateException if the private key bytes are missing.
     ;;
#_public
    byte[] getPrivKeyBytes33()
    (§
        byte[] bytes33 = new byte[33];
        byte[] priv = getPrivKeyBytes();
        System.arraycopy(priv, 0, bytes33, 33 - priv.length, priv.length);
        return bytes33;
    )

    ;;;
     ; Returns the same key with the private bytes removed.  May return the same instance.  The purpose of this is to
     ; save memory: the private key can always be very efficiently rederived from a parent that a private key, so storing
     ; all the private keys in RAM is a poor tradeoff especially on constrained devices.  This means that the returned
     ; key may still be usable for signing and so on, so don't expect it to be a true pubkey-only object!  If you want
     ; that then you should follow this call with a call to {@link #dropParent()}.
     ;;
#_public
    DeterministicKey dropPrivateBytes()
    (§
        return isPubKeyOnly() ? this : new DeterministicKey(getPath(), getChainCode(), pub, nil, parent);
    )

    ;;;
     ; <p>Returns the same key with the parent pointer removed (it still knows its own path and the parent fingerprint).</p>
     ;
     ; <p>If this key doesn't have private key bytes stored/cached itself, but could rederive them from the parent, then
     ; the new key returned by this method won't be able to do that.  Thus, using dropPrivateBytes().dropParent() on a
     ; regular DeterministicKey will yield a new DeterministicKey that cannot sign or do other things involving the
     ; private key at all.</p>
     ;;
#_public
    DeterministicKey dropParent()
    (§
        DeterministicKey key = new DeterministicKey(getPath(), getChainCode(), pub, priv, nil);
        key.parentFingerprint = parentFingerprint;
        return key;
    )

#_static
    byte[] addChecksum(byte[] input)
    (§
        int inputLength = input.length;
        byte[] checksummed = new byte[inputLength + 4];
        System.arraycopy(input, 0, checksummed, 0, inputLength);
        byte[] checksum = Sha256Hash.hashTwice(input);
        System.arraycopy(checksum, 0, checksummed, inputLength, 4);
        return checksummed;
    )

#_override
#_public
    DeterministicKey encrypt(KeyCrypter keyCrypter, KeyParameter aesKey)
        throws KeyCrypterException
    (§
        throw new UnsupportedOperationException("Must supply a new parent for encryption");
    )

#_public
    DeterministicKey encrypt(KeyCrypter keyCrypter, KeyParameter aesKey, #_nilable DeterministicKey newParent)
        throws KeyCrypterException
    (§
        ;; Same as the parent code, except we construct a DeterministicKey instead of an ECKey.
        Preconditions.checkNotNull(keyCrypter);
        if (newParent != nil)
            Preconditions.checkArgument(newParent.isEncrypted());

#_final
        byte[] privKeyBytes = getPrivKeyBytes();
        Preconditions.checkState(privKeyBytes != nil, "Private key is not available");

        EncryptedData encryptedPrivateKey = keyCrypter.encrypt(privKeyBytes, aesKey);
        DeterministicKey key = new DeterministicKey(childNumberPath, chainCode, keyCrypter, pub, encryptedPrivateKey, newParent);
        if (newParent == nil)
            key.setCreationTimeSeconds(getCreationTimeSeconds());
        return key;
    )

    ;;;
     ; A deterministic key is considered to be 'public key only' if it hasn't got a private key part and it cannot be
     ; rederived.  If the hierarchy is encrypted this returns true.
     ;;
#_override
#_public
    boolean isPubKeyOnly()
    (§
        return (super.isPubKeyOnly() && (parent == nil || parent.isPubKeyOnly()));
    )

    ;;; {@inheritDoc} ;;
#_override
#_public
    boolean hasPrivKey()
    (§
        return (findParentWithPrivKey() != nil);
    )

#_nilable
#_override
#_public
    byte[] getSecretBytes()
    (§
        return (priv != nil) ? getPrivKeyBytes() : nil;
    )

    ;;;
     ; A deterministic key is considered to be encrypted if it has access to encrypted private key bytes, OR if its
     ; parent does.  The reason is because the parent would be encrypted under the same key and this key knows how to
     ; rederive its own private key bytes from the parent, if needed.
     ;;
#_override
#_public
    boolean isEncrypted()
    (§
        return (priv == nil && (super.isEncrypted() || (parent != nil && parent.isEncrypted())));
    )

    ;;;
     ; Returns this keys {@link org.bitcoinj.crypto.KeyCrypter} <b>or</b> the keycrypter of its parent key.
     ;;
#_override
#_nilable
#_public
    KeyCrypter getKeyCrypter()
    (§
        if (keyCrypter != nil)
            return keyCrypter;
        if (parent != nil)
            return parent.getKeyCrypter();

        return nil;
    )

#_override
#_public
    ECDSASignature sign(Sha256Hash input, #_nilable KeyParameter aesKey)
        throws KeyCrypterException
    (§
        if (isEncrypted())
        (§
            ;; If the key is encrypted, ECKey.sign will decrypt it first before rerunning sign.  Decryption walks
            ;; the key heirarchy to find the private key (see below), so, we can just run the inherited method.
            return super.sign(input, aesKey);
        )
        else
        (§
            ;; If it's not encrypted, derive the private via the parents.
#_final
            BigInteger privateKey = findOrDerivePrivateKey();
            ;; This key is a part of a public-key only heirarchy and cannot be used for signing.
            if (privateKey == nil)
                throw new MissingPrivateKeyException();

            return super.doSign(input, privateKey);
        )
    )

#_override
#_public
    DeterministicKey decrypt(KeyCrypter keyCrypter, KeyParameter aesKey)
        throws KeyCrypterException
    (§
        Preconditions.checkNotNull(keyCrypter);
        ;; Check that the keyCrypter matches the one used to encrypt the keys, if set.
        if (this.keyCrypter != nil && !this.keyCrypter.equals(keyCrypter))
            throw new KeyCrypterException("The keyCrypter being used to decrypt the key is different to the one that was used to encrypt it");

        BigInteger privKey = findOrDeriveEncryptedPrivateKey(keyCrypter, aesKey);
        DeterministicKey key = new DeterministicKey(childNumberPath, chainCode, privKey, parent);
        if (!Arrays.equals(key.getPubKey(), getPubKey()))
            throw new KeyCrypterException("Provided AES key is wrong");

        if (parent == nil)
            key.setCreationTimeSeconds(getCreationTimeSeconds());
        return key;
    )

#_override
#_public
    DeterministicKey decrypt(KeyParameter aesKey)
        throws KeyCrypterException
    (§
        return (DeterministicKey)super.decrypt(aesKey);
    )

    ;; For when a key is encrypted, either decrypt our encrypted private key bytes, or work up the tree asking parents
    ;; to decrypt and re-derive.
#_private
    BigInteger findOrDeriveEncryptedPrivateKey(KeyCrypter keyCrypter, KeyParameter aesKey)
    (§
        if (encryptedPrivateKey != nil)
            return new BigInteger(1, keyCrypter.decrypt(encryptedPrivateKey, aesKey));

        ;; Otherwise we don't have it, but maybe we can figure it out from our parents.  Walk up the tree looking for
        ;; the first key that has some encrypted private key data.
        DeterministicKey cursor = parent;
        while (cursor != nil)
        (§
            if (cursor.encryptedPrivateKey != nil)
                break;
            cursor = cursor.parent;
        )
        if (cursor == nil)
            throw new KeyCrypterException("Neither this key nor its parents have an encrypted private key");

        byte[] parentalPrivateKeyBytes = keyCrypter.decrypt(cursor.encryptedPrivateKey, aesKey);
        return derivePrivateKeyDownwards(cursor, parentalPrivateKeyBytes);
    )

#_private
    DeterministicKey findParentWithPrivKey()
    (§
        DeterministicKey cursor = this;
        while (cursor != nil)
        (§
            if (cursor.priv != nil)
                break;
            cursor = cursor.parent;
        )
        return cursor;
    )

#_nilable
#_private
    BigInteger findOrDerivePrivateKey()
    (§
        DeterministicKey cursor = findParentWithPrivKey();
        if (cursor == nil)
            return nil;

        return derivePrivateKeyDownwards(cursor, cursor.priv.toByteArray());
    )

#_private
    BigInteger derivePrivateKeyDownwards(DeterministicKey cursor, byte[] parentalPrivateKeyBytes)
    (§
        DeterministicKey downCursor = new DeterministicKey(cursor.childNumberPath, cursor.chainCode, cursor.pub, new BigInteger(1, parentalPrivateKeyBytes), cursor.parent);
        ;; Now we have to rederive the keys along the path back to ourselves.  That path can be found by just truncating
        ;; our path with the length of the parents path.
        ImmutableList<ChildNumber> path = childNumberPath.subList(cursor.getPath().size(), childNumberPath.size());
        for (ChildNumber num : path)
            downCursor = HDKeyDerivation.deriveChildKey(downCursor, num);
        ;; downCursor is now the same key as us, but with private key bytes.
        ;; If it's not, it means we tried decrypting with an invalid password and earlier checks e.g. for padding didn't
        ;; catch it.
        if (!downCursor.pub.equals(pub))
            throw new KeyCrypterException("Could not decrypt bytes");

        return Preconditions.checkNotNull(downCursor.priv);
    )

    ;;;
     ; Derives a child at the given index using hardened derivation.  Note: <code>index</code>
     ; is not the "i" value.  If you want the softened derivation, then use instead
     ; <code>HDKeyDerivation.deriveChildKey(this, new ChildNumber(child, false))</code>.
     ;;
#_public
    DeterministicKey derive(int child)
    (§
        return HDKeyDerivation.deriveChildKey(this, new ChildNumber(child, true));
    )

    ;;;
     ; Returns the private key of this deterministic key.  Even if this object isn't storing the private key,
     ; it can be re-derived by walking up to the parents if necessary and this is what will happen.
     ; @throws java.lang.IllegalStateException if the parents are encrypted or a watching chain.
     ;;
#_override
#_public
    BigInteger getPrivKey()
    (§
#_final
        BigInteger key = findOrDerivePrivateKey();
        Preconditions.checkState(key != nil, "Private key bytes not available");
        return key;
    )

#_public
    byte[] serializePublic(NetworkParameters params)
    (§
        return serialize(params, true);
    )

#_public
    byte[] serializePrivate(NetworkParameters params)
    (§
        return serialize(params, false);
    )

#_private
    byte[] serialize(NetworkParameters params, boolean pub)
    (§
        ByteBuffer ser = ByteBuffer.allocate(78);
        ser.putInt(pub ? params.getBip32HeaderPub() : params.getBip32HeaderPriv());
        ser.put((byte)getDepth());
        ser.putInt(getParentFingerprint());
        ser.putInt(getChildNumber().i());
        ser.put(getChainCode());
        ser.put(pub ? getPubKey() : getPrivKeyBytes33());
        Preconditions.checkState(ser.position() == 78);
        return ser.array();
    )

#_public
    String serializePubB58(NetworkParameters params)
    (§
        return toBase58(serialize(params, true));
    )

#_public
    String serializePrivB58(NetworkParameters params)
    (§
        return toBase58(serialize(params, false));
    )

#_static
    String toBase58(byte[] ser)
    (§
        return Base58.encode(addChecksum(ser));
    )

    ;;; Deserialize a base-58-encoded HD Key with no parent. ;;
#_public
#_static
    DeterministicKey deserializeB58(String base58, NetworkParameters params)
    (§
        return deserializeB58(nil, base58, params);
    )

    ;;;
     ; Deserialize a base-58-encoded HD Key.
     ; @param parent The parent node in the given key's deterministic hierarchy.
     ; @throws IllegalArgumentException if the base58 encoded key could not be parsed.
     ;;
#_public
#_static
    DeterministicKey deserializeB58(#_nilable DeterministicKey parent, String base58, NetworkParameters params)
    (§
        return deserialize(params, Base58.decodeChecked(base58), parent);
    )

    ;;;
     ; Deserialize an HD Key with no parent.
     ;;
#_public
#_static
    DeterministicKey deserialize(NetworkParameters params, byte[] serializedKey)
    (§
        return deserialize(params, serializedKey, nil);
    )

    ;;;
     ; Deserialize an HD Key.
     ; @param parent The parent node in the given key's deterministic hierarchy.
     ;;
#_public
#_static
    DeterministicKey deserialize(NetworkParameters params, byte[] serializedKey, #_nilable DeterministicKey parent)
    (§
        ByteBuffer buffer = ByteBuffer.wrap(serializedKey);
        int header = buffer.getInt();
        if (header != params.getBip32HeaderPriv() && header != params.getBip32HeaderPub())
            throw new IllegalArgumentException("Unknown header bytes: " + toBase58(serializedKey).substring(0, 4));

        boolean pub = (header == params.getBip32HeaderPub());
        int depth = buffer.get() & 0xff; ;; convert signed byte to positive int since depth cannot be negative
#_final
        int parentFingerprint = buffer.getInt();
#_final
        int i = buffer.getInt();
#_final
        ChildNumber childNumber = new ChildNumber(i);
        ImmutableList<ChildNumber> path;
        if (parent != nil)
        (§
            if (parentFingerprint == 0)
                throw new IllegalArgumentException("Parent was provided but this key doesn't have one");
            if (parent.getFingerprint() != parentFingerprint)
                throw new IllegalArgumentException("Parent fingerprints don't match");
            path = HDUtils.append(parent.getPath(), childNumber);
            if (path.size() != depth)
                throw new IllegalArgumentException("Depth does not match");
        )
        else
        (§
            ;; We have been given a key that is not a root key, yet we lack the object representing the parent.
            ;; This can happen when deserializing an account key for a watching wallet.  In this case, we assume that
            ;; the client wants to conceal the key's position in the hierarchy.  The path is truncated at the
            ;; parent's node.
            if (1 <= depth)
                path = ImmutableList.of(childNumber);
            else
                path = ImmutableList.of();
        )
        byte[] chainCode = new byte[32];
        buffer.get(chainCode);
        byte[] data = new byte[33];
        buffer.get(data);
        Preconditions.checkArgument(!buffer.hasRemaining(), "Found unexpected data in key");
        if (pub)
            return new DeterministicKey(path, chainCode, new LazyECPoint(ECKey.CURVE.getCurve(), data), parent, depth, parentFingerprint);
        else
            return new DeterministicKey(path, chainCode, new BigInteger(1, data), parent, depth, parentFingerprint);
    )

    ;;;
     ; The creation time of a deterministic key is equal to that of its parent, unless this key is the root of a tree
     ; in which case the time is stored alongside the key as per normal, see {@link org.bitcoinj.core.ECKey#getCreationTimeSeconds()}.
     ;;
#_override
#_public
    long getCreationTimeSeconds()
    (§
        if (parent != nil)
            return parent.getCreationTimeSeconds();
        else
            return super.getCreationTimeSeconds();
    )

    ;;;
     ; The creation time of a deterministic key is equal to that of its parent, unless this key is the root of a tree.
     ; Thus, setting the creation time on a leaf is forbidden.
     ;;
#_override
#_public
    void setCreationTimeSeconds(long newCreationTimeSeconds)
    (§
        if (parent != nil)
            throw new IllegalStateException("Creation time can only be set on root keys.");
        else
            super.setCreationTimeSeconds(newCreationTimeSeconds);
    )

    ;;;
     ; Verifies equality of all fields but NOT the parent pointer (thus the same key derived in two separate heirarchy
     ; objects will equal each other.
     ;;
#_override
#_public
    boolean equals(Object o)
    (§
        if (this == o)
            return true;
        if (o == nil || getClass() != o.getClass())
            return false;
        DeterministicKey other = (DeterministicKey)o;
        return (super.equals(other) && Arrays.equals(this.chainCode, other.chainCode) && Objects.equal(this.childNumberPath, other.childNumberPath));
    )

#_override
#_public
    int hashCode()
    (§
        return Objects.hashCode(super.hashCode(), Arrays.hashCode(chainCode), childNumberPath);
    )

#_override
#_public
    String toString()
    (§
#_final
        MoreObjects.ToStringHelper helper = MoreObjects.toStringHelper(this).omitNullValues();
        helper.add("pub", Utils.HEX.encode(pub.getEncoded()));
        helper.add("chainCode", HEX.encode(chainCode));
        helper.add("path", getPathAsString());
        if (0 < creationTimeSeconds)
            helper.add("creationTimeSeconds", creationTimeSeconds);
        helper.add("isEncrypted", isEncrypted());
        helper.add("isPubKeyOnly", isPubKeyOnly());
        return helper.toString();
    )

#_override
#_public
    void formatKeyWithAddress(boolean includePrivateKeys, StringBuilder sb, NetworkParameters params)
    (§
#_final
        Address address = toAddress(params);
        sb.append("  addr:").append(address);
        sb.append("  hash160:").append(Utils.HEX.encode(getPubKeyHash()));
        sb.append("  (").append(getPathAsString()).append(")\n");
        if (includePrivateKeys)
            sb.append("  ").append(toStringWithPrivate(params)).append("\n");
    )
)

(ns org.bitcoinj.crypto #_"EncryptableItem"
  #_(:require [org.bitcoinj.wallet Protos]))

;;;
 ; Provides a uniform way to access something that can be optionally encrypted with a
 ; {@link org.bitcoinj.crypto.KeyCrypter}, yielding an {@link org.bitcoinj.crypto.EncryptedData},
 ; and which can have a creation time associated with it.
 ;;
#_public
interface EncryptableItem
(§
    ;;; Returns whether the item is encrypted or not.  If it is, then {@link #getSecretBytes()} will return null. ;;
    boolean isEncrypted();

    ;;; Returns the raw bytes of the item, if not encrypted, or null if encrypted or the secret is missing. ;;
#_nilable
    byte[] getSecretBytes();

    ;;; Returns the initialization vector and encrypted secret bytes, or null if not encrypted. ;;
#_nilable
    EncryptedData getEncryptedData();

    ;;; Returns an enum constant describing what algorithm was used to encrypt the key or UNENCRYPTED. ;;
    Protos.Wallet.EncryptionType getEncryptionType();

    ;;; Returns the time in seconds since the UNIX epoch at which this encryptable item was first created/derived. ;;
    long getCreationTimeSeconds();
)

(ns org.bitcoinj.crypto #_"EncryptedData"
    (:import [java.util Arrays])
    (:import [com.google.common.base Objects]))

;;;
 ; <p>An instance of EncryptedData is a holder for an initialization vector and encrypted bytes.
 ; It is typically used to hold encrypted private key bytes.</p>
 ;
 ; <p>The initialisation vector is random data that is used to initialise the AES block cipher when
 ; the private key bytes were encrypted.  You need these for decryption.</p>
 ;;
#_public
#_final
class EncryptedData
(§
#_public
#_final
    byte[] initialisationVector;
#_public
#_final
    byte[] encryptedBytes;

#_public
    EncryptedData(byte[] initialisationVector, byte[] encryptedBytes)
    (§
        this.initialisationVector = Arrays.copyOf(initialisationVector, initialisationVector.length);
        this.encryptedBytes = Arrays.copyOf(encryptedBytes, encryptedBytes.length);
    )

#_override
#_public
    boolean equals(Object o)
    (§
        if (this == o)
            return true;
        if (o == nil || getClass() != o.getClass())
            return false;
        EncryptedData other = (EncryptedData)o;
        return (Arrays.equals(encryptedBytes, other.encryptedBytes) && Arrays.equals(initialisationVector, other.initialisationVector));
    )

#_override
#_public
    int hashCode()
    (§
        return Objects.hashCode(Arrays.hashCode(encryptedBytes), Arrays.hashCode(initialisationVector));
    )

#_override
#_public
    String toString()
    (§
        return "EncryptedData [initialisationVector=" + Arrays.toString(initialisationVector)
            + ", encryptedPrivateKey=" + Arrays.toString(encryptedBytes) + "]";
    )
)

(ns org.bitcoinj.crypto #_"HDDerivationException"
)

#_public
class HDDerivationException extends RuntimeException
(§
#_public
    HDDerivationException(String message)
    (§
        super(message);
    )
)

(ns org.bitcoinj.crypto #_"HDKeyDerivation"
    (:import #_[java.math *]
             #_[java.nio *]
             #_[java.security *]
             #_[java.util *])
    (:import [com.google.common.base Preconditions]
             #_[com.google.common.collect *]
             #_[org.spongycastle.math.ec *])
  #_(:require #_[org.bitcoinj.core *]))

;;;
 ; Implementation of the <a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">BIP 32</a>
 ; deterministic wallet child key generation algorithm.
 ;;
#_public
#_final
class HDKeyDerivation
(§
    #_static
    (§
        ;; Init proper random number generator, as some old Android installations have bugs that make it unsecure.
        if (Utils.isAndroidRuntime())
            new LinuxSecureRandom();

        RAND_INT = new BigInteger(256, new SecureRandom());
    )

    ;; Some arbitrary random number.  Doesn't matter what it is.
#_private
#_static
#_final
    BigInteger RAND_INT;

#_private
    HDKeyDerivation()
    (§
    )

    ;;;
     ; Child derivation may fail (although with extremely low probability); in such case it is re-attempted.
     ; This is the maximum number of re-attempts (to avoid an infinite loop in case of bugs etc.)
     ;;
#_public
#_static
#_final
    int MAX_CHILD_DERIVATION_ATTEMPTS = 100;

    ;;;
     ; Generates a new deterministic key from the given seed, which can be any arbitrary byte array.
     ; However resist the temptation to use a string as the seed - any key derived from a password
     ; is likely to be weak and easily broken by attackers (this is not theoretical, people have had
     ; money stolen that way).  This method checks that the given seed is at least 64 bits long.
     ;
     ; @throws HDDerivationException if generated master key is invalid (private key 0 or >= n).
     ; @throws IllegalArgumentException if the seed is less than 8 bytes and could be brute forced.
     ;;
#_public
#_static
    DeterministicKey createMasterPrivateKey(byte[] seed)
        throws HDDerivationException
    (§
        Preconditions.checkArgument(8 < seed.length, "Seed is too short and could be brute forced");

        ;; Calculate I = HMAC-SHA512(key="Bitcoin seed", msg=S).
        byte[] i = HDUtils.hmacSha512(HDUtils.createHmacSha512Digest("Bitcoin seed".getBytes()), seed);
        ;; Split I into two 32-byte sequences, Il and Ir.
        ;; Use Il as master secret key, and Ir as master chain code.
        Preconditions.checkState(i.length == 64, i.length);

        byte[] il = Arrays.copyOfRange(i, 0, 32);
        byte[] ir = Arrays.copyOfRange(i, 32, 64);
        Arrays.fill(i, (byte)0);
        DeterministicKey masterPrivKey = createMasterPrivKeyFromBytes(il, ir);
        Arrays.fill(il, (byte)0);
        Arrays.fill(ir, (byte)0);

        ;; Child deterministic keys will chain up to their parents to find the keys.
        masterPrivKey.setCreationTimeSeconds(Utils.currentTimeSeconds());
        return masterPrivKey;
    )

    ;;;
     ; @throws HDDerivationException if privKeyBytes is invalid (0 or >= n).
     ;;
#_public
#_static
    DeterministicKey createMasterPrivKeyFromBytes(byte[] privKeyBytes, byte[] chainCode)
        throws HDDerivationException
    (§
        BigInteger priv = new BigInteger(1, privKeyBytes);
        assertNonZero(priv, "Generated master key is invalid.");
        assertLessThanN(priv, "Generated master key is invalid.");
        return new DeterministicKey(ImmutableList.<ChildNumber>of(), chainCode, priv, nil);
    )

#_public
#_static
    DeterministicKey createMasterPubKeyFromBytes(byte[] pubKeyBytes, byte[] chainCode)
    (§
        return new DeterministicKey(ImmutableList.<ChildNumber>of(), chainCode, new LazyECPoint(ECKey.CURVE.getCurve(), pubKeyBytes), nil, nil);
    )

    ;;;
     ; Derives a key given the "extended" child number, i.e. the 0x80000000 bit of the value that you
     ; pass for <code>childNumber</code> will determine whether to use hardened derivation or not.
     ; Consider whether your code would benefit from the clarity of the equivalent, but explicit, form
     ; of this method that takes a <code>ChildNumber</code> rather than an <code>int</code>, for example:
     ; <code>deriveChildKey(parent, new ChildNumber(childNumber, true))</code>
     ; where the value of the hardened bit of <code>childNumber</code> is zero.
     ;;
#_public
#_static
    DeterministicKey deriveChildKey(DeterministicKey parent, int childNumber)
    (§
        return deriveChildKey(parent, new ChildNumber(childNumber));
    )

    ;;;
     ; Derives a key of the "extended" child number, i.e. with the 0x80000000 bit specifying whether
     ; to use hardened derivation or not.  If derivation fails, tries a next child.
     ;;
#_public
#_static
    DeterministicKey deriveThisOrNextChildKey(DeterministicKey parent, int childNumber)
    (§
        int nAttempts = 0;
        ChildNumber child = new ChildNumber(childNumber);
        boolean isHardened = child.isHardened();
        while (nAttempts < MAX_CHILD_DERIVATION_ATTEMPTS)
        (§
            try
            (§
                child = new ChildNumber(child.num() + nAttempts, isHardened);
                return deriveChildKey(parent, child);
            )
            catch (HDDerivationException _)
            (§
            )
            nAttempts++;
        )
        throw new HDDerivationException("Maximum number of child derivation attempts reached, this is probably an indication of a bug.");
    )

    ;;;
     ; @throws HDDerivationException if private derivation is attempted for a public-only parent key, or
     ; if the resulting derived key is invalid (e.g. private key == 0).
     ;;
#_public
#_static
    DeterministicKey deriveChildKey(DeterministicKey parent, ChildNumber childNumber)
        throws HDDerivationException
    (§
        if (!parent.hasPrivKey())
        (§
            RawKeyBytes rawKey = deriveChildKeyBytesFromPublic(parent, childNumber, PublicDeriveMode.NORMAL);
            return new DeterministicKey(HDUtils.append(parent.getPath(), childNumber), rawKey.chainCode, new LazyECPoint(ECKey.CURVE.getCurve(), rawKey.keyBytes), nil, parent);
        )
        else
        (§
            RawKeyBytes rawKey = deriveChildKeyBytesFromPrivate(parent, childNumber);
            return new DeterministicKey(HDUtils.append(parent.getPath(), childNumber), rawKey.chainCode, new BigInteger(1, rawKey.keyBytes), parent);
        )
    )

#_public
#_static
    RawKeyBytes deriveChildKeyBytesFromPrivate(DeterministicKey parent, ChildNumber childNumber)
        throws HDDerivationException
    (§
        Preconditions.checkArgument(parent.hasPrivKey(), "Parent key must have private key bytes for this method.");

        byte[] parentPublicKey = parent.getPubKeyPoint().getEncoded(true);
        Preconditions.checkState(parentPublicKey.length == 33, "Parent pubkey must be 33 bytes, but is " + parentPublicKey.length);

        ByteBuffer data = ByteBuffer.allocate(37);
        data.put(childNumber.isHardened() ? parent.getPrivKeyBytes33() : parentPublicKey);
        data.putInt(childNumber.i());

        byte[] i = HDUtils.hmacSha512(parent.getChainCode(), data.array());
        Preconditions.checkState(i.length == 64, i.length);

        byte[] il = Arrays.copyOfRange(i, 0, 32);
        byte[] chainCode = Arrays.copyOfRange(i, 32, 64);
        BigInteger ilInt = new BigInteger(1, il);
        assertLessThanN(ilInt, "Illegal derived key: I_L >= n");

#_final
        BigInteger priv = parent.getPrivKey();
        BigInteger ki = priv.add(ilInt).mod(ECKey.CURVE.getN());
        assertNonZero(ki, "Illegal derived key: derived private key equals 0.");

        return new RawKeyBytes(ki.toByteArray(), chainCode);
    )

#_public
    enum PublicDeriveMode
    (§
        NORMAL,
        WITH_INVERSION
    )

#_public
#_static
    RawKeyBytes deriveChildKeyBytesFromPublic(DeterministicKey parent, ChildNumber childNumber, PublicDeriveMode mode)
        throws HDDerivationException
    (§
        Preconditions.checkArgument(!childNumber.isHardened(), "Can't use private derivation with public keys only.");

        byte[] parentPublicKey = parent.getPubKeyPoint().getEncoded(true);
        Preconditions.checkState(parentPublicKey.length == 33, "Parent pubkey must be 33 bytes, but is " + parentPublicKey.length);

        ByteBuffer data = ByteBuffer.allocate(37);
        data.put(parentPublicKey);
        data.putInt(childNumber.i());

        byte[] i = HDUtils.hmacSha512(parent.getChainCode(), data.array());
        Preconditions.checkState(i.length == 64, i.length);

        byte[] il = Arrays.copyOfRange(i, 0, 32);
        byte[] chainCode = Arrays.copyOfRange(i, 32, 64);
        BigInteger ilInt = new BigInteger(1, il);
        assertLessThanN(ilInt, "Illegal derived key: I_L >= n");

#_final
        BigInteger N = ECKey.CURVE.getN();
        ECPoint Ki;
        switch (mode)
        (§
            case NORMAL:
                Ki = ECKey.publicPointFromPrivate(ilInt).add(parent.getPubKeyPoint());
                break;
            case WITH_INVERSION:
                ;; This trick comes from Gregory Maxwell.  Check the homomorphic properties of our curve hold.  The
                ;; below calculations should be redundant and give the same result as NORMAL but if the precalculated
                ;; tables have taken a bit flip will yield a different answer.  This mode is used when vending a key
                ;; to perform a last-ditch sanity check trying to catch bad RAM.
                Ki = ECKey.publicPointFromPrivate(ilInt.add(RAND_INT).mod(N));
                BigInteger additiveInverse = RAND_INT.negate().mod(N);
                Ki = Ki.add(ECKey.publicPointFromPrivate(additiveInverse));
                Ki = Ki.add(parent.getPubKeyPoint());
                break;
            default:
                throw new AssertionError();
        )

        assertNonInfinity(Ki, "Illegal derived key: derived public key equals infinity.");
        return new RawKeyBytes(Ki.getEncoded(true), chainCode);
    )

#_private
#_static
    void assertNonZero(BigInteger integer, String errorMessage)
    (§
        if (integer.equals(BigInteger.ZERO))
            throw new HDDerivationException(errorMessage);
    )

#_private
#_static
    void assertNonInfinity(ECPoint point, String errorMessage)
    (§
        if (point.equals(ECKey.CURVE.getCurve().getInfinity()))
            throw new HDDerivationException(errorMessage);
    )

#_private
#_static
    void assertLessThanN(BigInteger integer, String errorMessage)
    (§
        if (integer.compareTo(ECKey.CURVE.getN()) > 0)
            throw new HDDerivationException(errorMessage);
    )

#_public
#_static
    class RawKeyBytes
    (§
#_public
#_final
        byte[] keyBytes, chainCode;

#_public
        RawKeyBytes(byte[] keyBytes, byte[] chainCode)
        (§
            this.keyBytes = keyBytes;
            this.chainCode = chainCode;
        )
    )
)

(ns org.bitcoinj.crypto #_"HDUtils"
    (:import [java.nio ByteBuffer]
             [java.util ArrayList Arrays Collections List])
    (:import [com.google.common.base Joiner]
             [com.google.common.collect ImmutableList Iterables]
             [org.spongycastle.crypto.digests SHA512Digest]
             [org.spongycastle.crypto.macs HMac]
             [org.spongycastle.crypto.params KeyParameter])
  #_(:require [org.bitcoinj.core ECKey]))

;;;
 ; Static utilities used in BIP 32 Hierarchical Deterministic Wallets (HDW).
 ;;
#_public
#_final
class HDUtils
(§
#_private
#_static
#_final
    Joiner PATH_JOINER = Joiner.on("/");

#_static
    HMac createHmacSha512Digest(byte[] key)
    (§
        SHA512Digest digest = new SHA512Digest();
        HMac hMac = new HMac(digest);
        hMac.init(new KeyParameter(key));
        return hMac;
    )

#_static
    byte[] hmacSha512(HMac hmacSha512, byte[] input)
    (§
        hmacSha512.reset();
        hmacSha512.update(input, 0, input.length);
        byte[] out = new byte[64];
        hmacSha512.doFinal(out, 0);
        return out;
    )

#_public
#_static
    byte[] hmacSha512(byte[] key, byte[] data)
    (§
        return hmacSha512(createHmacSha512Digest(key), data);
    )

#_static
    byte[] toCompressed(byte[] uncompressedPoint)
    (§
        return ECKey.CURVE.getCurve().decodePoint(uncompressedPoint).getEncoded(true);
    )

#_static
    byte[] longTo4ByteArray(long n)
    (§
        byte[] bytes = Arrays.copyOfRange(ByteBuffer.allocate(8).putLong(n).array(), 4, 8);
        assert (bytes.length == 4) : bytes.length;
        return bytes;
    )

    ;;; Append a derivation level to an existing path. ;;
#_public
#_static
    ImmutableList<ChildNumber> append(List<ChildNumber> path, ChildNumber childNumber)
    (§
        return ImmutableList.<ChildNumber>builder().addAll(path).add(childNumber).build();
    )

    ;;; Concatenate two derivation paths. ;;
#_public
#_static
    ImmutableList<ChildNumber> concat(List<ChildNumber> path, List<ChildNumber> path2)
    (§
        return ImmutableList.<ChildNumber>builder().addAll(path).addAll(path2).build();
    )

    ;;; Convert to a string path, starting with "M/". ;;
#_public
#_static
    String formatPath(List<ChildNumber> path)
    (§
        return PATH_JOINER.join(Iterables.concat(Collections.singleton("M"), path));
    )

    ;;;
     ; The path is a human-friendly representation of the deterministic path.  For example:
     ;
     ; "44H / 0H / 0H / 1 / 1"
     ;
     ; Where a letter "H" means hardened key.  Spaces are ignored.
     ;;
#_public
#_static
    List<ChildNumber> parsePath(#_non-nil String path)
    (§
        String[] parsedNodes = path.replace("M", "").split("/");
        List<ChildNumber> nodes = new ArrayList<>();

        for (String n : parsedNodes)
        (§
            n = n.replaceAll(" ", "");
            if (n.length() != 0)
            (§
                boolean isHard = n.endsWith("H");
                if (isHard)
                    n = n.substring(0, n.length() - 1);
                int nodeNumber = Integer.parseInt(n);
                nodes.add(new ChildNumber(nodeNumber, isHard));
            )
        )

        return nodes;
    )
)

(ns org.bitcoinj.crypto #_"KeyCrypter"
    (:import [java.io Serializable])
    (:import [org.spongycastle.crypto.params KeyParameter])
  #_(:require [org.bitcoinj.wallet.Protos.Wallet EncryptionType]))

;;;
 ; <p>A KeyCrypter can be used to encrypt and decrypt a message.  The sequence of events to encrypt and then decrypt
 ; a message are as follows:</p>
 ;
 ; <p>(1) Ask the user for a password.  deriveKey() is then called to create an KeyParameter.  This contains the AES
 ; key that will be used for encryption.</p>
 ; <p>(2) Encrypt the message using encrypt(), providing the message bytes and the KeyParameter from (1).  This returns
 ; an EncryptedData which contains the encryptedPrivateKey bytes and an initialisation vector.</p>
 ; <p>(3) To decrypt an EncryptedData, repeat step (1) to get a KeyParameter, then call decrypt().</p>
 ;
 ; <p>There can be different algorithms used for encryption/ decryption so the getUnderstoodEncryptionType is used
 ; to determine whether any given KeyCrypter can understand the type of encrypted data you have.</p>
 ;;
#_public
interface KeyCrypter extends Serializable
(§
    ;;;
     ; Return the EncryptionType enum value which denotes the type of encryption/ decryption that this KeyCrypter
     ; can understand.
     ;;
    EncryptionType getUnderstoodEncryptionType();

    ;;;
     ; Create a KeyParameter (which typically contains an AES key).
     ; @param password
     ; @return the KeyParameter which typically contains the AES key to use for encrypting and decrypting.
     ; @throws KeyCrypterException
     ;;
    KeyParameter deriveKey(CharSequence password)
        throws KeyCrypterException;

    ;;;
     ; Decrypt the provided encrypted bytes, converting them into unencrypted bytes.
     ;
     ; @throws KeyCrypterException if decryption was unsuccessful.
     ;;
    byte[] decrypt(EncryptedData encryptedBytesToDecode, KeyParameter aesKey)
        throws KeyCrypterException;

    ;;;
     ; Encrypt the supplied bytes, converting them into ciphertext.
     ;
     ; @return an encryptedPrivateKey containing the encrypted bytes and an initialisation vector.
     ; @throws KeyCrypterException if encryption was unsuccessful.
     ;;
    EncryptedData encrypt(byte[] plainBytes, KeyParameter aesKey)
        throws KeyCrypterException;
)

(ns org.bitcoinj.crypto #_"KeyCrypterException"
)

;;;
 ; <p>Exception to provide the following:</p>
 ; <ul>
 ; <li>Provision of encryption / decryption exception.</li>
 ; </ul>
 ; <p>This base exception acts as a general failure mode not attributable to a specific cause (other than
 ; that reported in the exception message).  Since this is in English, it may not be worth reporting directly
 ; to the user other than as part of a "general failure to parse" response.</p>
 ;;
#_public
class KeyCrypterException extends RuntimeException
(§
#_public
    KeyCrypterException(String s)
    (§
        super(s);
    )

#_public
    KeyCrypterException(String s, Throwable throwable)
    (§
        super(s, throwable);
    )
)

(ns org.bitcoinj.crypto #_"KeyCrypterScrypt"
    (:import [java.security SecureRandom]
             [java.util Arrays])
    (:import [com.google.common.base Objects Preconditions Stopwatch]
             [com.google.protobuf ByteString]
             [com.lambdaworks.crypto SCrypt]
             [org.slf4j Logger LoggerFactory]
             [org.spongycastle.crypto BufferedBlockCipher]
             [org.spongycastle.crypto.engines AESFastEngine]
             [org.spongycastle.crypto.modes CBCBlockCipher]
             [org.spongycastle.crypto.paddings PaddedBufferedBlockCipher]
             [org.spongycastle.crypto.params KeyParameter ParametersWithIV])
  #_(:require [org.bitcoinj.core Utils]
             [org.bitcoinj.wallet Protos]
             [org.bitcoinj.wallet.Protos ScryptParameters]
             [org.bitcoinj.wallet.Protos.Wallet EncryptionType]))

;;;
 ; <p>This class encrypts and decrypts byte arrays and strings using scrypt as the
 ; key derivation function and AES for the encryption.</p>
 ;
 ; <p>You can use this class to:</p>
 ;
 ; <p>1) Using a user password, create an AES key that can encrypt and decrypt your private keys.
 ; To convert the password to the AES key, scrypt is used.  This is an algorithm resistant
 ; to brute force attacks.  You can use the ScryptParameters to tune how difficult you
 ; want this to be generation to be.</p>
 ;
 ; <p>2) Using the AES Key generated above, you then can encrypt and decrypt any bytes using
 ; the AES symmetric cipher.  Eight bytes of salt is used to prevent dictionary attacks.</p>
 ;;
#_public
class KeyCrypterScrypt implements KeyCrypter
(§
#_private
#_static
#_final
    Logger log = LoggerFactory.getLogger(KeyCrypterScrypt.class);

    ;;;
     ; Key length in bytes.
     ;;
#_public
#_static
#_final
    int KEY_LENGTH = 32; ;; = 256 bits.

    ;;;
     ; The size of an AES block in bytes.
     ; This is also the length of the initialisation vector.
     ;;
#_public
#_static
#_final
    int BLOCK_LENGTH = 16; ;; = 128 bits.

    ;;;
     ; The length of the salt used.
     ;;
#_public
#_static
#_final
    int SALT_LENGTH = 8;

    #_static
    (§
        ;; Init proper random number generator, as some old Android installations have bugs that make it unsecure.
        if (Utils.isAndroidRuntime())
            new LinuxSecureRandom();

        secureRandom = new SecureRandom();
    )

#_private
#_static
#_final
    SecureRandom secureRandom;

    ;;; Returns SALT_LENGTH (8) bytes of random data. ;;
#_public
#_static
    byte[] randomSalt()
    (§
        byte[] salt = new byte[SALT_LENGTH];
        secureRandom.nextBytes(salt);
        return salt;
    )

    ;; Scrypt parameters.
#_private
#_final
    ScryptParameters scryptParameters;

    ;;;
     ; Encryption/Decryption using default parameters and a random salt.
     ;;
#_public
    KeyCrypterScrypt()
    (§
        Protos.ScryptParameters.Builder builder = Protos.ScryptParameters.newBuilder().setSalt(ByteString.copyFrom(randomSalt()));
        this.scryptParameters = builder.build();
    )

    ;;;
     ; Encryption/Decryption using custom number of iterations parameters and a random salt.
     ; As of August 2016, a useful value for mobile devices is 4096 (derivation takes about 1 second).
     ;
     ; @param iterations Number of scrypt iterations.
     ;;
#_public
    KeyCrypterScrypt(int iterations)
    (§
        Protos.ScryptParameters.Builder builder = Protos.ScryptParameters.newBuilder().setSalt(ByteString.copyFrom(randomSalt())).setN(iterations);
        this.scryptParameters = builder.build();
    )

    ;;;
     ; Encryption/ Decryption using specified Scrypt parameters.
     ;
     ; @param scryptParameters ScryptParameters to use.
     ; @throws NullPointerException if the scryptParameters or any of its N, R or P is null.
     ;;
#_public
    KeyCrypterScrypt(ScryptParameters scryptParameters)
    (§
        this.scryptParameters = Preconditions.checkNotNull(scryptParameters);

        ;; Check there is a non-empty salt.  Some early MultiBit wallets has a missing salt, so it is not a hard fail.
        if (scryptParameters.getSalt() == nil || scryptParameters.getSalt().toByteArray() == nil || scryptParameters.getSalt().toByteArray().length == 0)
            log.warn("You are using a ScryptParameters with no salt. Your encryption may be vulnerable to a dictionary attack.");
    )

    ;;;
     ; Generate AES key.
     ;
     ; This is a very slow operation compared to encrypt/ decrypt so it is normally worth caching the result.
     ;
     ; @param password The password to use in key generation.
     ; @return the KeyParameter containing the created AES key.
     ; @throws KeyCrypterException
     ;;
#_override
#_public
    KeyParameter deriveKey(CharSequence password)
        throws KeyCrypterException
    (§
        byte[] passwordBytes = nil;
        try
        (§
            passwordBytes = convertToByteArray(password);
            byte[] salt = new byte[0];
            if (scryptParameters.getSalt() != nil)
            (§
                salt = scryptParameters.getSalt().toByteArray();
            )
            else
            (§
                ;; Warn the user that they are not using a salt.  Some early MultiBit wallets had a blank salt.
                log.warn("You are using a ScryptParameters with no salt. Your encryption may be vulnerable to a dictionary attack.");
            )

#_final
            Stopwatch watch = Stopwatch.createStarted();
            byte[] keyBytes = SCrypt.scrypt(passwordBytes, salt, (int)scryptParameters.getN(), scryptParameters.getR(), scryptParameters.getP(), KEY_LENGTH);
            watch.stop();
            log.info("Deriving key took {} for {} scrypt iterations.", watch, scryptParameters.getN());
            return new KeyParameter(keyBytes);
        )
        catch (Exception e)
        (§
            throw new KeyCrypterException("Could not generate key from password and salt.", e);
        )
        finally
        (§
            ;; Zero the password bytes.
            if (passwordBytes != nil)
                java.util.Arrays.fill(passwordBytes, (byte)0);
        )
    )

    ;;;
     ; Password based encryption using AES - CBC 256 bits.
     ;;
#_override
#_public
    EncryptedData encrypt(byte[] plainBytes, KeyParameter aesKey)
        throws KeyCrypterException
    (§
        Preconditions.checkNotNull(plainBytes);
        Preconditions.checkNotNull(aesKey);

        try
        (§
            ;; Generate iv - each encryption call has a different iv.
            byte[] iv = new byte[BLOCK_LENGTH];
            secureRandom.nextBytes(iv);

            ParametersWithIV keyWithIv = new ParametersWithIV(aesKey, iv);

            ;; Encrypt using AES.
            BufferedBlockCipher cipher = new PaddedBufferedBlockCipher(new CBCBlockCipher(new AESFastEngine()));
            cipher.init(true, keyWithIv);
            byte[] encryptedBytes = new byte[cipher.getOutputSize(plainBytes.length)];
#_final
            int length1 = cipher.processBytes(plainBytes, 0, plainBytes.length, encryptedBytes, 0);
#_final
            int length2 = cipher.doFinal(encryptedBytes, length1);

            return new EncryptedData(iv, Arrays.copyOf(encryptedBytes, length1 + length2));
        )
        catch (Exception e)
        (§
            throw new KeyCrypterException("Could not encrypt bytes.", e);
        )
    )

    ;;;
     ; Decrypt bytes previously encrypted with this class.
     ;
     ; @param dataToDecrypt The data to decrypt.
     ; @param aesKey The AES key to use for decryption.
     ; @return the decrypted bytes.
     ; @throws KeyCrypterException if bytes could not be decrypted.
     ;;
#_override
#_public
    byte[] decrypt(EncryptedData dataToDecrypt, KeyParameter aesKey)
        throws KeyCrypterException
    (§
        Preconditions.checkNotNull(dataToDecrypt);
        Preconditions.checkNotNull(aesKey);

        try
        (§
            ParametersWithIV keyWithIv = new ParametersWithIV(new KeyParameter(aesKey.getKey()), dataToDecrypt.initialisationVector);

            ;; Decrypt the message.
            BufferedBlockCipher cipher = new PaddedBufferedBlockCipher(new CBCBlockCipher(new AESFastEngine()));
            cipher.init(false, keyWithIv);

            byte[] cipherBytes = dataToDecrypt.encryptedBytes;
            byte[] decryptedBytes = new byte[cipher.getOutputSize(cipherBytes.length)];
#_final
            int length1 = cipher.processBytes(cipherBytes, 0, cipherBytes.length, decryptedBytes, 0);
#_final
            int length2 = cipher.doFinal(decryptedBytes, length1);

            return Arrays.copyOf(decryptedBytes, length1 + length2);
        )
        catch (Exception e)
        (§
            throw new KeyCrypterException("Could not decrypt bytes", e);
        )
    )

    ;;;
     ; Convert a CharSequence (which are UTF16) into a byte array.
     ;
     ; Note: a String.getBytes() is not used to avoid creating a String of the password in the JVM.
     ;;
#_private
#_static
    byte[] convertToByteArray(CharSequence charSequence)
    (§
        Preconditions.checkNotNull(charSequence);

        byte[] byteArray = new byte[charSequence.length() << 1];
        for(int i = 0; i < charSequence.length(); i++)
        (§
            int bytePosition = i << 1;
            byteArray[bytePosition] = (byte)((charSequence.charAt(i) & 0xff00) >> 8);
            byteArray[bytePosition + 1] = (byte)(charSequence.charAt(i) & 0x00ff);
        )
        return byteArray;
    )

#_public
    ScryptParameters getScryptParameters()
    (§
        return scryptParameters;
    )

    ;;;
     ; Return the EncryptionType enum value which denotes the type of encryption/ decryption that this KeyCrypter
     ; can understand.
     ;;
#_override
#_public
    EncryptionType getUnderstoodEncryptionType()
    (§
        return EncryptionType.ENCRYPTED_SCRYPT_AES;
    )

#_override
#_public
    String toString()
    (§
        return "AES-" + KEY_LENGTH * 8 + "-CBC, Scrypt (N: " + scryptParameters.getN() + ")";
    )

#_override
#_public
    int hashCode()
    (§
        return Objects.hashCode(scryptParameters);
    )

#_override
#_public
    boolean equals(Object o)
    (§
        if (this == o)
            return true;
        if (o == nil || getClass() != o.getClass())
            return false;
        return Objects.equal(scryptParameters, ((KeyCrypterScrypt)o).scryptParameters);
    )
)

(ns org.bitcoinj.crypto #_"LazyECPoint"
    (:import [java.math BigInteger]
             [java.util Arrays])
    (:import [com.google.common.base Preconditions]
             [org.spongycastle.math.ec ECCurve ECFieldElement ECPoint]))

;;;
 ; A wrapper around ECPoint that delays decoding of the point for as long as possible.  This is useful because point
 ; encode/decode in Bouncy Castle is quite slow especially on Dalvik, as it often involves decompression/recompression.
 ;;
#_public
class LazyECPoint
(§
    ;; If curve is set, bits is also set.  If curve is unset, point is set and bits is unset.  Point can be set along
    ;; with curve and bits when the cached form has been accessed and thus must have been converted.
#_private
#_final
    ECCurve curve;
#_private
#_final
    byte[] bits;

    ;; This field is effectively final - once set it won't change again.  However it can be set after construction.
#_nilable
#_private
    ECPoint point;

#_public
    LazyECPoint(ECCurve curve, byte[] bits)
    (§
        this.curve = curve;
        this.bits = bits;
    )

#_public
    LazyECPoint(ECPoint point)
    (§
        this.point = Preconditions.checkNotNull(point);
        this.curve = nil;
        this.bits = nil;
    )

#_public
    ECPoint get()
    (§
        if (point == nil)
            point = curve.decodePoint(bits);
        return point;
    )

    ;; Delegated methods.

#_public
    ECPoint getDetachedPoint()
    (§
        return get().getDetachedPoint();
    )

#_public
    byte[] getEncoded()
    (§
        if (bits != nil)
            return Arrays.copyOf(bits, bits.length);
        else
            return get().getEncoded();
    )

#_public
    boolean isInfinity()
    (§
        return get().isInfinity();
    )

#_public
    ECPoint timesPow2(int e)
    (§
        return get().timesPow2(e);
    )

#_public
    ECFieldElement getYCoord()
    (§
        return get().getYCoord();
    )

#_public
    ECFieldElement[] getZCoords()
    (§
        return get().getZCoords();
    )

#_public
    boolean isNormalized()
    (§
        return get().isNormalized();
    )

#_public
    boolean isCompressed()
    (§
        if (bits != nil)
            return (bits[0] == 2 || bits[0] == 3);
        else
            return get().isCompressed();
    )

#_public
    ECPoint multiply(BigInteger k)
    (§
        return get().multiply(k);
    )

#_public
    ECPoint subtract(ECPoint b)
    (§
        return get().subtract(b);
    )

#_public
    boolean isValid()
    (§
        return get().isValid();
    )

#_public
    ECPoint scaleY(ECFieldElement scale)
    (§
        return get().scaleY(scale);
    )

#_public
    ECFieldElement getXCoord()
    (§
        return get().getXCoord();
    )

#_public
    ECPoint scaleX(ECFieldElement scale)
    (§
        return get().scaleX(scale);
    )

#_public
    boolean equals(ECPoint other)
    (§
        return get().equals(other);
    )

#_public
    ECPoint negate()
    (§
        return get().negate();
    )

#_public
    ECPoint threeTimes()
    (§
        return get().threeTimes();
    )

#_public
    ECFieldElement getZCoord(int index)
    (§
        return get().getZCoord(index);
    )

#_public
    byte[] getEncoded(boolean compressed)
    (§
        if (compressed == isCompressed() && bits != nil)
            return Arrays.copyOf(bits, bits.length);
        else
            return get().getEncoded(compressed);
    )

#_public
    ECPoint add(ECPoint b)
    (§
        return get().add(b);
    )

#_public
    ECPoint twicePlus(ECPoint b)
    (§
        return get().twicePlus(b);
    )

#_public
    ECCurve getCurve()
    (§
        return get().getCurve();
    )

#_public
    ECPoint normalize()
    (§
        return get().normalize();
    )

#_public
    ECFieldElement getY()
    (§
        return this.normalize().getYCoord();
    )

#_public
    ECPoint twice()
    (§
        return get().twice();
    )

#_public
    ECFieldElement getAffineYCoord()
    (§
        return get().getAffineYCoord();
    )

#_public
    ECFieldElement getAffineXCoord()
    (§
        return get().getAffineXCoord();
    )

#_public
    ECFieldElement getX()
    (§
        return this.normalize().getXCoord();
    )

#_override
#_public
    boolean equals(Object o)
    (§
        if (this == o)
            return true;
        if (o == nil || getClass() != o.getClass())
            return false;
        return Arrays.equals(getCanonicalEncoding(), ((LazyECPoint)o).getCanonicalEncoding());
    )

#_override
#_public
    int hashCode()
    (§
        return Arrays.hashCode(getCanonicalEncoding());
    )

#_private
    byte[] getCanonicalEncoding()
    (§
        return getEncoded(true);
    )
)

(ns org.bitcoinj.crypto #_"LinuxSecureRandom"
    (:import #_[java.io *]
             #_[java.security *])
    (:import #_[org.slf4j *]))

;;;
 ; A SecureRandom implementation that is able to override the standard JVM provided implementation, and which simply
 ; serves random numbers by reading /dev/urandom.  That is, it delegates to the kernel on UNIX systems and is unusable
 ; on other platforms.  Attempts to manually set the seed are ignored.  There is no difference between seed bytes and
 ; non-seed bytes, they are all from the same source.
 ;;
#_public
class LinuxSecureRandom extends SecureRandomSpi
(§
#_private
#_static
#_final
    FileInputStream urandom;

#_private
#_static
    class LinuxSecureRandomProvider extends Provider
    (§
#_public
        LinuxSecureRandomProvider()
        (§
            super("LinuxSecureRandom", 1.0, "A Linux specific random number provider that uses /dev/urandom");

            put("SecureRandom.LinuxSecureRandom", LinuxSecureRandom.class.getName());
        )
    )

#_private
#_static
#_final
    Logger log = LoggerFactory.getLogger(LinuxSecureRandom.class);

    #_static
    (§
        try
        (§
            File file = new File("/dev/urandom");
            ;; This stream is deliberately leaked.
            urandom = new FileInputStream(file);
            if (urandom.read() == -1)
                throw new RuntimeException("/dev/urandom not readable?");

            ;; Now override the default SecureRandom implementation with this one.
            int position = Security.insertProviderAt(new LinuxSecureRandomProvider(), 1);

            if (position != -1)
                log.info("Secure randomness will be read from {} only.", file);
            else
                log.info("Randomness is already secure.");
        )
        catch (FileNotFoundException e)
        (§
            ;; Should never happen.
            log.error("/dev/urandom does not appear to exist or is not openable");
            throw new RuntimeException(e);
        )
        catch (IOException e)
        (§
            log.error("/dev/urandom does not appear to be readable");
            throw new RuntimeException(e);
        )
    )

#_private
#_final
    DataInputStream dis;

#_public
    LinuxSecureRandom()
    (§
        ;; DataInputStream is not thread safe, so each random object has its own.
        dis = new DataInputStream(urandom);
    )

#_override
#_protected
    void engineSetSeed(byte[] bytes)
    (§
        ;; Ignore.
    )

#_override
#_protected
    void engineNextBytes(byte[] bytes)
    (§
        try
        (§
            dis.readFully(bytes); ;; This will block until all the bytes can be read.
        )
        catch (IOException e)
        (§
            throw new RuntimeException(e); ;; Fatal error.  Do not attempt to recover from this.
        )
    )

#_override
#_protected
    byte[] engineGenerateSeed(int i)
    (§
        byte[] bits = new byte[i];
        engineNextBytes(bits);
        return bits;
    )
)

(ns org.bitcoinj.crypto #_"MnemonicCode"
    (:import [java.io BufferedReader FileNotFoundException IOException InputStream InputStreamReader]
             [java.security MessageDigest]
             [java.util ArrayList Collections List])
    (:import [com.google.common.base Stopwatch]
             [org.slf4j Logger LoggerFactory])
  #_(:require [org.bitcoinj.core Sha256Hash Utils]
             #_static #_[org.bitcoinj.core.Utils HEX]))

;;;
 ; A MnemonicCode object may be used to convert between binary seed values and lists of words per
 ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki">the BIP 39 specification</a>.
 ;;

#_public
class MnemonicCode
(§
#_private
#_static
#_final
    Logger log = LoggerFactory.getLogger(MnemonicCode.class);

#_private
    ArrayList<String> wordList;

#_private
#_static
#_final
    String BIP39_ENGLISH_RESOURCE_NAME = "mnemonic/wordlist/english.txt";
#_private
#_static
#_final
    String BIP39_ENGLISH_SHA256 = "ad90bf3beb7b0eb7e5acd74727dc0da96e0a280a258354e7293fb7e211ac03db";

    ;;; UNIX time for when the BIP39 standard was finalised.  This can be used as a default seed birthday. ;;
#_public
#_static
    long BIP39_STANDARDISATION_TIME_SECS = 1381276800;

#_private
#_static
#_final
    int PBKDF2_ROUNDS = 2048;

#_public
#_static
    MnemonicCode INSTANCE;

    #_static
    (§
        try
        (§
            INSTANCE = new MnemonicCode();
        )
        catch (FileNotFoundException e)
        (§
            ;; We expect failure on Android.  The developer has to set INSTANCE themselves.
            if (!Utils.isAndroidRuntime())
                log.error("Could not find word list", e);
        )
        catch (IOException e)
        (§
            log.error("Failed to load word list", e);
        )
    )

    ;;; Initialise from the included word list.  Won't work on Android. ;;
#_public
    MnemonicCode()
        throws IOException
    (§
        this(openDefaultWords(), BIP39_ENGLISH_SHA256);
    )

#_private
#_static
    InputStream openDefaultWords()
        throws IOException
    (§
        InputStream stream = MnemonicCode.class.getResourceAsStream(BIP39_ENGLISH_RESOURCE_NAME);
        if (stream == nil)
            throw new FileNotFoundException(BIP39_ENGLISH_RESOURCE_NAME);
        return stream;
    )

    ;;;
     ; Creates an MnemonicCode object, initializing with words read from the supplied input stream.
     ; If a wordListDigest is supplied, the digest of the words will be checked.
     ;;
#_public
    MnemonicCode(InputStream wordstream, String wordListDigest)
        throws IOException, IllegalArgumentException
    (§
        BufferedReader br = new BufferedReader(new InputStreamReader(wordstream, "UTF-8"));
        this.wordList = new ArrayList<>(2048);
        MessageDigest md = Sha256Hash.newDigest();
        String word;
        while ((word = br.readLine()) != nil)
        (§
            md.update(word.getBytes());
            this.wordList.add(word);
        )
        br.close();

        if (this.wordList.size() != 2048)
            throw new IllegalArgumentException("input stream did not contain 2048 words");

        ;; If a wordListDigest is supplied, check to make sure it matches.
        if (wordListDigest != nil)
        (§
            byte[] digest = md.digest();
            String hexdigest = HEX.encode(digest);
            if (!hexdigest.equals(wordListDigest))
                throw new IllegalArgumentException("wordlist digest mismatch");
        )
    )

    ;;;
     ; Gets the word list this code uses.
     ;;
#_public
    List<String> getWordList()
    (§
        return wordList;
    )

    ;;;
     ; Convert mnemonic word list to seed.
     ;;
#_public
#_static
    byte[] toSeed(List<String> words, String passphrase)
    (§
        ;; To create binary seed from mnemonic, we use PBKDF2 function with mnemonic sentence (in UTF-8) used as a password
        ;; and string "mnemonic" + passphrase (again in UTF-8) used as a salt.  Iteration count is set to 4096 and HMAC-SHA512
        ;; is used as a pseudo-random function.  Desired length of the derived key is 512 bits (= 64 bytes).

        String pass = Utils.SPACE_JOINER.join(words);
        String salt = "mnemonic" + passphrase;

#_final
        Stopwatch watch = Stopwatch.createStarted();
        byte[] seed = PBKDF2SHA512.derive(pass, salt, PBKDF2_ROUNDS, 64);
        watch.stop();
        log.info("PBKDF2 took {}", watch);
        return seed;
    )

    ;;;
     ; Convert mnemonic word list to original entropy value.
     ;;
#_public
    byte[] toEntropy(List<String> words)
        throws MnemonicException.MnemonicLengthException, MnemonicException.MnemonicWordException, MnemonicException.MnemonicChecksumException
    (§
        if (0 < words.size() % 3)
            throw new MnemonicException.MnemonicLengthException("Word list size must be multiple of three words.");

        if (words.size() == 0)
            throw new MnemonicException.MnemonicLengthException("Word list is empty.");

        ;; Look up all the words in the list and construct the concatenation of the original entropy and the checksum.

        int concatLenBits = words.size() * 11;
        boolean[] concatBits = new boolean[concatLenBits];
        int wordindex = 0;
        for (String word : words)
        (§
            ;; Find the words index in the wordlist.
            int ndx = Collections.binarySearch(this.wordList, word);
            if (ndx < 0)
                throw new MnemonicException.MnemonicWordException(word);

            ;; Set the next 11 bits to the value of the index.
            for (int i = 0; i < 11; ++i)
                concatBits[(wordindex * 11) + i] = ((ndx & (1 << (10 - i))) != 0);
            ++wordindex;
        )

        int checksumLengthBits = concatLenBits / 33;
        int entropyLengthBits = concatLenBits - checksumLengthBits;

        ;; Extract original entropy as bytes.
        byte[] entropy = new byte[entropyLengthBits / 8];
        for (int i = 0; i < entropy.length; ++i)
            for (int j = 0; j < 8; ++j)
                if (concatBits[(i * 8) + j])
                    entropy[i] |= 1 << (7 - j);

        ;; Take the digest of the entropy.
        byte[] hash = Sha256Hash.hash(entropy);
        boolean[] hashBits = bytesToBits(hash);

        ;; Check all the checksum bits.
        for (int i = 0; i < checksumLengthBits; ++i)
            if (concatBits[entropyLengthBits + i] != hashBits[i])
                throw new MnemonicException.MnemonicChecksumException();

        return entropy;
    )

    ;;;
     ; Convert entropy data to mnemonic word list.
     ;;
#_public
    List<String> toMnemonic(byte[] entropy)
        throws MnemonicException.MnemonicLengthException
    (§
        if (0 < entropy.length % 4)
            throw new MnemonicException.MnemonicLengthException("Entropy length not multiple of 32 bits.");

        if (entropy.length == 0)
            throw new MnemonicException.MnemonicLengthException("Entropy is empty.");

        ;; We take initial entropy of ENT bits and compute its checksum by taking first ENT / 32 bits of its SHA256 hash.

        byte[] hash = Sha256Hash.hash(entropy);
        boolean[] hashBits = bytesToBits(hash);

        boolean[] entropyBits = bytesToBits(entropy);
        int checksumLengthBits = entropyBits.length / 32;

        ;; We append these bits to the end of the initial entropy.
        boolean[] concatBits = new boolean[entropyBits.length + checksumLengthBits];
        System.arraycopy(entropyBits, 0, concatBits, 0, entropyBits.length);
        System.arraycopy(hashBits, 0, concatBits, entropyBits.length, checksumLengthBits);

        ;; Next we take these concatenated bits and split them into groups of 11 bits.  Each group encodes number from 0-2047
        ;; which is a position in a wordlist.  We convert numbers into words and use joined words as mnemonic sentence.

        ArrayList<String> words = new ArrayList<>();
        int nwords = concatBits.length / 11;
        for (int i = 0; i < nwords; ++i)
        (§
            int index = 0;
            for (int j = 0; j < 11; ++j)
            (§
                index <<= 1;
                if (concatBits[(i * 11) + j])
                    index |= 0x1;
            )
            words.add(this.wordList.get(index));
        )

        return words;
    )

    ;;;
     ; Check to see if a mnemonic word list is valid.
     ;;
#_public
    void check(List<String> words)
        throws MnemonicException
    (§
        toEntropy(words);
    )

#_private
#_static
    boolean[] bytesToBits(byte[] data)
    (§
        boolean[] bits = new boolean[data.length * 8];
        for (int i = 0; i < data.length; ++i)
            for (int j = 0; j < 8; ++j)
                bits[(i * 8) + j] = ((data[i] & (1 << (7 - j))) != 0);
        return bits;
    )
)

(ns org.bitcoinj.crypto #_"MnemonicException"
)

;;;
 ; Exceptions thrown by the MnemonicCode module.
 ;;
#_public
class MnemonicException extends Exception
(§
#_public
    MnemonicException()
    (§
        super();
    )

#_public
    MnemonicException(String msg)
    (§
        super(msg);
    )

    ;;;
     ; Thrown when an argument to MnemonicCode is the wrong length.
     ;;
#_public
#_static
    class MnemonicLengthException extends MnemonicException
    (§
#_public
        MnemonicLengthException(String msg)
        (§
            super(msg);
        )
    )

    ;;;
     ; Thrown when a list of MnemonicCode words fails the checksum check.
     ;;
#_public
#_static
    class MnemonicChecksumException extends MnemonicException
    (§
#_public
        MnemonicChecksumException()
        (§
            super();
        )
    )

    ;;;
     ; Thrown when a word is encountered which is not in the MnemonicCode's word list.
     ;;
#_public
#_static
    class MnemonicWordException extends MnemonicException
    (§
        ;;; Contains the word that was not found in the word list. ;;
#_public
#_final
        String badWord;

#_public
        MnemonicWordException(String badWord)
        (§
            super();
            this.badWord = badWord;
        )
    )
)

(ns org.bitcoinj.crypto #_"PBKDF2SHA512"
    (:import [java.io ByteArrayOutputStream]
             [java.nio ByteBuffer ByteOrder]
             [javax.crypto Mac]
             [javax.crypto.spec SecretKeySpec]))

;;;
 ; <p>This is a clean-room implementation of PBKDF2 using RFC 2898 as a reference.</p>
 ;
 ; <p>RFC 2898: http://tools.ietf.org/html/rfc2898#section-5.2</p>
 ;
 ; <p>This code passes all RFC 6070 test vectors: http://tools.ietf.org/html/rfc6070</p>
 ;
 ; <p>http://cryptofreek.org/2012/11/29/pbkdf2-pure-java-implementation/<br>
 ; Modified to use SHA-512 - Ken Sedgwick ken@bonsai.com</p>
 ;;
#_public
class PBKDF2SHA512
(§
#_public
#_static
    byte[] derive(String P, String S, int c, int dkLen)
    (§
        ByteArrayOutputStream baos = new ByteArrayOutputStream();

        try
        (§
            int hLen = 20;

            if (((Math.pow(2, 32)) - 1) * hLen < dkLen)
                throw new IllegalArgumentException("derived key too long");

            int l = (int)Math.ceil((double)dkLen / (double)hLen);
         ;; int r = dkLen - (l - 1) * hLen;

            for (int i = 1; i <= l; i++)
            (§
                byte[] T = F(P, S, c, i);
                baos.write(T);
            )
        )
        catch (Exception e)
        (§
            throw new RuntimeException(e);
        )

        byte[] baDerived = new byte[dkLen];
        System.arraycopy(baos.toByteArray(), 0, baDerived, 0, baDerived.length);

        return baDerived;
    )

#_private
#_static
    byte[] F(String P, String S, int c, int i)
        throws Exception
    (§
        byte[] U_LAST = nil;
        byte[] U_XOR = nil;

        SecretKeySpec key = new SecretKeySpec(P.getBytes("UTF-8"), "HmacSHA512");
        Mac mac = Mac.getInstance(key.getAlgorithm());
        mac.init(key);

        for (int j = 0; j < c; j++)
        (§
            if (j == 0)
            (§
                byte[] baS = S.getBytes("UTF-8");
                byte[] baI = INT(i);
                byte[] baU = new byte[baS.length + baI.length];

                System.arraycopy(baS, 0, baU, 0, baS.length);
                System.arraycopy(baI, 0, baU, baS.length, baI.length);

                U_XOR = mac.doFinal(baU);
                U_LAST = U_XOR;
                mac.reset();
            )
            else
            (§
                byte[] baU = mac.doFinal(U_LAST);
                mac.reset();

                for (int k = 0; k < U_XOR.length; k++)
                (§
                    U_XOR[k] = (byte)(U_XOR[k] ^ baU[k]);
                )

                U_LAST = baU;
            )
        )

        return U_XOR;
    )

#_private
#_static
    byte[] INT(int i)
    (§
        ByteBuffer bb = ByteBuffer.allocate(4);
        bb.order(ByteOrder.BIG_ENDIAN);
        bb.putInt(i);

        return bb.array();
    )
)

(ns org.bitcoinj.crypto #_"TransactionSignature"
    (:import [java.io ByteArrayOutputStream IOException]
             [java.math BigInteger])
    (:import [com.google.common.base Preconditions])
  #_(:require [org.bitcoinj.core ECKey Transaction VerificationException]
             [org.bitcoinj.core.Transaction SigHash]))

;;;
 ; A TransactionSignature wraps an {@link org.bitcoinj.core.ECKey.ECDSASignature} and adds methods for handling
 ; the additional SIGHASH mode byte that is used.
 ;;
#_public
class TransactionSignature extends ECKey.ECDSASignature
(§
    ;;;
     ; A byte that controls which parts of a transaction are signed.  This is exposed because signatures
     ; parsed off the wire may have sighash flags that aren't "normal" serializations of the enum values.
     ; Because Bitcoin Core works via bit testing, we must not lose the exact value when round-tripping
     ; otherwise we'll fail to verify signature hashes.
     ;;
#_public
#_final
    int sighashFlags;

    ;;; Constructs a signature with the given components and SIGHASH_ALL. ;;
#_public
    TransactionSignature(BigInteger r, BigInteger s)
    (§
        this(r, s, Transaction.SigHash.ALL.value);
    )

    ;;; Constructs a signature with the given components and raw sighash flag bytes (needed for rule compatibility). ;;
#_public
    TransactionSignature(BigInteger r, BigInteger s, int sighashFlags)
    (§
        super(r, s);
        this.sighashFlags = sighashFlags;
    )

    ;;; Constructs a transaction signature based on the ECDSA signature. ;;
#_public
    TransactionSignature(ECKey.ECDSASignature signature, Transaction.SigHash mode, boolean anyoneCanPay)
    (§
        super(signature.r, signature.s);
        sighashFlags = calcSigHashValue(mode, anyoneCanPay);
    )

    ;;;
     ; Returns a dummy invalid signature whose R/S values are set such that they will take up the same number of
     ; encoded bytes as a real signature.  This can be useful when you want to fill out a transaction to be of
     ; the right size (e.g. for fee calculations) but don't have the requisite signing key yet and will fill out
     ; the real signature later.
     ;;
#_public
#_static
    TransactionSignature dummy()
    (§
        BigInteger val = ECKey.HALF_CURVE_ORDER;
        return new TransactionSignature(val, val);
    )

    ;;; Calculates the byte used in the protocol to represent the combination of mode and anyoneCanPay. ;;
#_public
#_static
    int calcSigHashValue(Transaction.SigHash mode, boolean anyoneCanPay)
    (§
        ;; Enforce compatibility since this code was made before the SigHash enum was updated.
        Preconditions.checkArgument(SigHash.ALL == mode || SigHash.NONE == mode || SigHash.SINGLE == mode);

        int sighashFlags = mode.value;
        if (anyoneCanPay)
            sighashFlags |= Transaction.SigHash.ANYONECANPAY.value;
        return sighashFlags;
    )

    ;;;
     ; Returns true if the given signature is has canonical encoding, and will thus be accepted as standard by
     ; Bitcoin Core.  DER and the SIGHASH encoding allow for quite some flexibility in how the same structures
     ; are encoded, and this can open up novel attacks in which a man in the middle takes a transaction and then
     ; changes its signature such that the transaction hash is different but it's still valid.  This can confuse
     ; wallets and generally violates people's mental model of how Bitcoin should work, thus non-canonical
     ; signatures are now not relayed by default.
     ;;
#_public
#_static
    boolean isEncodingCanonical(byte[] signature)
    (§
        ;; See Bitcoin Core's IsCanonicalSignature, https://bitcointalk.org/index.php?topic=8392.msg127623#msg127623
        ;; A canonical signature exists of: <30> <total len> <02> <len R> <R> <02> <len S> <S> <hashtype>
        ;; Where R and S are not negative (their first byte has its highest bit not set), and not
        ;; excessively padded (do not start with a 0 byte, unless an otherwise negative number follows,
        ;; in which case a single 0 byte is necessary and even required).
        if (signature.length < 9 || 73 < signature.length)
            return false;

        int hashType = (signature[signature.length-1] & 0xff) & ~Transaction.SigHash.ANYONECANPAY.value; ;; mask the byte to prevent sign-extension hurting us
        if (hashType < Transaction.SigHash.ALL.value || Transaction.SigHash.SINGLE.value < hashType)
            return false;

        ;;                   "wrong type"                  "wrong length marker"
        if ((signature[0] & 0xff) != 0x30 || (signature[1] & 0xff) != signature.length - 3)
            return false;

        int lenR = signature[3] & 0xff;
        if (signature.length <= 5 + lenR || lenR == 0)
            return false;
        int lenS = signature[5 + lenR] & 0xff;
        if (lenR + lenS + 7 != signature.length || lenS == 0)
            return false;

        ;;    R value type mismatch          R value negative
        if (signature[4 - 2] != 0x02 || (signature[4] & 0x80) == 0x80)
            return false;
        if (1 < lenR && signature[4] == 0x00 && (signature[4 + 1] & 0x80) != 0x80)
            return false; ;; R value excessively padded

        ;;       S value type mismatch                    S value negative
        if (signature[6 + lenR - 2] != 0x02 || (signature[6 + lenR] & 0x80) == 0x80)
            return false;
        if (1 < lenS && signature[6 + lenR] == 0x00 && (signature[6 + lenR + 1] & 0x80) != 0x80)
            return false; ;; S value excessively padded

        return true;
    )

#_public
    boolean anyoneCanPay()
    (§
        return ((sighashFlags & Transaction.SigHash.ANYONECANPAY.value) != 0);
    )

#_public
    Transaction.SigHash sigHashMode()
    (§
#_final
        int mode = sighashFlags & 0x1f;

        if (mode == Transaction.SigHash.NONE.value)
            return Transaction.SigHash.NONE;
        if (mode == Transaction.SigHash.SINGLE.value)
            return Transaction.SigHash.SINGLE;

        return Transaction.SigHash.ALL;
    )

    ;;;
     ; What we get back from the signer are the two components of a signature, r and s.  To get a flat byte stream
     ; of the type used by Bitcoin we have to encode them using DER encoding, which is just a way to pack the two
     ; components into a structure, and then we append a byte to the end for the sighash flags.
     ;;
#_public
    byte[] encodeToBitcoin()
    (§
        try
        (§
            ByteArrayOutputStream bos = derByteStream();
            bos.write(sighashFlags);
            return bos.toByteArray();
        )
        catch (IOException e)
        (§
            throw new RuntimeException(e); ;; Cannot happen.
        )
    )

#_override
#_public
    ECKey.ECDSASignature toCanonicalised()
    (§
        return new TransactionSignature(super.toCanonicalised(), sigHashMode(), anyoneCanPay());
    )

    ;;;
     ; Returns a decoded signature.
     ;
     ; @param requireCanonicalEncoding if the encoding of the signature must be canonical.
     ; @throws RuntimeException if the signature is invalid or unparseable in some way.
     ; @deprecated use {@link #decodeFromBitcoin(byte[], boolean, boolean)} instead.
     ;;
#_deprecated
#_public
#_static
    TransactionSignature decodeFromBitcoin(byte[] bytes, boolean requireCanonicalEncoding)
        throws VerificationException
    (§
        return decodeFromBitcoin(bytes, requireCanonicalEncoding, false);
    )

    ;;;
     ; Returns a decoded signature.
     ;
     ; @param requireCanonicalEncoding if the encoding of the signature must be canonical.
     ; @param requireCanonicalSValue if the S-value must be canonical (below half the order of the curve).
     ; @throws RuntimeException if the signature is invalid or unparseable in some way.
     ;;
#_public
#_static
    TransactionSignature decodeFromBitcoin(byte[] bytes, boolean requireCanonicalEncoding, boolean requireCanonicalSValue)
        throws VerificationException
    (§
        ;; Bitcoin encoding is DER signature + sighash byte.
        if (requireCanonicalEncoding && !isEncodingCanonical(bytes))
            throw new VerificationException("Signature encoding is not canonical.");

        ECKey.ECDSASignature sig;
        try
        (§
            sig = ECKey.ECDSASignature.decodeFromDER(bytes);
        )
        catch (IllegalArgumentException e)
        (§
            throw new VerificationException("Could not decode DER", e);
        )
        if (requireCanonicalSValue && !sig.isCanonical())
            throw new VerificationException("S-value is not canonical.");

        ;; In Bitcoin, any value of the final byte is valid, but not necessarily canonical.  See javadocs
        ;; for isEncodingCanonical to learn more about this.  So we must store the exact byte found.
        return new TransactionSignature(sig.r, sig.s, bytes[bytes.length - 1]);
    )
)

(ns org.bitcoinj.kits #_"WalletAppKit"
    (:import #_[java.io *]
             #_[java.net *]
             #_[java.nio.channels *]
             #_[java.util *]
             #_[java.util.concurrent *])
    (:import [com.google.common.base Preconditions]
             #_[com.google.common.collect *]
             #_[com.google.common.util.concurrent *]
             #_[org.slf4j *])
  #_(:require #_[org.bitcoinj.core.listeners *]
             #_[org.bitcoinj.core *]
             #_[org.bitcoinj.net.discovery *]
             #_[org.bitcoinj.store *]
             #_[org.bitcoinj.wallet *]))

;;;
 ; <p>Utility class that wraps the boilerplate needed to set up a new SPV bitcoinj app.  Instantiate it with a directory
 ; and file prefix, optionally configure a few things, then use startAsync and optionally awaitRunning.  The object will
 ; construct and configure a {@link BlockChain}, {@link SPVBlockStore}, {@link Wallet} and {@link PeerGroup}.  Depending
 ; on the value of the blockingStartup property, startup will be considered complete once the block chain has fully
 ; synchronized, so it can take a while.</p>
 ;
 ; <p>To add listeners and modify the objects that are constructed, you can either do that by overriding the
 ; {@link #onSetupCompleted()} method (which will run on a background thread) and make your changes there,
 ; or by waiting for the service to start and then accessing the objects from wherever you want.  However, you cannot
 ; access the objects this class creates until startup is complete.</p>
 ;
 ; <p>The asynchronous design of this class may seem puzzling (just use {@link #awaitRunning()} if you don't want that).
 ; It is to make it easier to fit bitcoinj into GUI apps, which require a high degree of responsiveness on their main
 ; thread which handles all the animation and user interaction.  Even when blockingStart is false, initializing bitcoinj
 ; means doing potentially blocking file IO, generating keys and other potentially intensive operations.  By running it
 ; on a background thread, there's no risk of accidentally causing UI lag.</p>
 ;
 ; <p>Note that {@link #awaitRunning()} can throw an unchecked {@link java.lang.IllegalStateException}
 ; if anything goes wrong during startup - you should probably handle it and use {@link Exception#getCause()} to figure
 ; out what went wrong more precisely.  Same thing if you just use the {@link #startAsync()} method.</p>
 ;;
#_public
class WalletAppKit extends AbstractIdleService
(§
#_protected
#_static
#_final
    Logger log = LoggerFactory.getLogger(WalletAppKit.class);

#_protected
#_final
    String filePrefix;
#_protected
#_final
    NetworkParameters params;
#_protected
#_volatile
    BlockChain vChain;
#_protected
#_volatile
    BlockStore vStore;
#_protected
#_volatile
    Wallet vWallet;
#_protected
#_volatile
    PeerGroup vPeerGroup;

#_protected
#_final
    File directory;
#_protected
#_volatile
    File vWalletFile;

#_protected
    boolean useAutoSave = true;
#_protected
    PeerAddress[] peerAddresses;
#_protected
    DownloadProgressTracker downloadListener;
#_protected
    boolean autoStop = true;
#_protected
    InputStream checkpoints;
#_protected
    boolean blockingStartup = true;
#_protected
    String userAgent, version;
#_protected
    WalletProtobufSerializer.WalletFactory walletFactory;
#_nilable
#_protected
    DeterministicSeed restoreFromSeed;
#_nilable
#_protected
    PeerDiscovery discovery;

#_protected
#_volatile
    Context context;

    ;;;
     ; Creates a new WalletAppKit, with a newly created {@link Context}.  Files will be stored in the given directory.
     ;;
#_public
    WalletAppKit(NetworkParameters params, File directory, String filePrefix)
    (§
        this(new Context(params), directory, filePrefix);
    )

    ;;;
     ; Creates a new WalletAppKit, with the given {@link Context}.  Files will be stored in the given directory.
     ;;
#_public
    WalletAppKit(Context context, File directory, String filePrefix)
    (§
        this.context = context;
        this.params = Preconditions.checkNotNull(context.getParams());
        this.directory = Preconditions.checkNotNull(directory);
        this.filePrefix = Preconditions.checkNotNull(filePrefix);
    )

    ;;; Will only connect to the given addresses.  Cannot be called after startup. ;;
#_public
    WalletAppKit setPeerNodes(PeerAddress... addresses)
    (§
        Preconditions.checkState(state() == State.NEW, "Cannot call after startup");
        this.peerAddresses = addresses;
        return this;
    )

    ;;; Will only connect to localhost.  Cannot be called after startup. ;;
#_public
    WalletAppKit connectToLocalHost()
    (§
        try
        (§
#_final
            InetAddress localHost = InetAddress.getLocalHost();
            return setPeerNodes(new PeerAddress(params, localHost, params.getPort()));
        )
        catch (UnknownHostException e)
        (§
            ;; Borked machine with no loopback adapter configured properly.
            throw new RuntimeException(e);
        )
    )

    ;;; If true, the wallet will save itself to disk automatically whenever it changes. ;;
#_public
    WalletAppKit setAutoSave(boolean value)
    (§
        Preconditions.checkState(state() == State.NEW, "Cannot call after startup");
        useAutoSave = value;
        return this;
    )

    ;;;
     ; If you want to learn about the sync process, you can provide a listener here.  For instance,
     ; a {@link org.bitcoinj.core.DownloadProgressTracker} is a good choice.  This has no effect unless
     ; setBlockingStartup(false) has been called too, due to some missing implementation code.
     ;;
#_public
    WalletAppKit setDownloadListener(DownloadProgressTracker listener)
    (§
        this.downloadListener = listener;
        return this;
    )

    ;;; If true, will register a shutdown hook to stop the library.  Defaults to true. ;;
#_public
    WalletAppKit setAutoStop(boolean autoStop)
    (§
        this.autoStop = autoStop;
        return this;
    )

    ;;;
     ; If set, the file is expected to contain a checkpoints file calculated with BuildCheckpoints.
     ; It makes initial block sync faster for new users - please refer to the documentation on the
     ; bitcoinj website (https://bitcoinj.github.io/speeding-up-chain-sync) for further details.
     ;;
#_public
    WalletAppKit setCheckpoints(InputStream checkpoints)
    (§
        if (this.checkpoints != nil)
            Utils.closeUnchecked(this.checkpoints);
        this.checkpoints = Preconditions.checkNotNull(checkpoints);
        return this;
    )

    ;;;
     ; If true (the default) then the startup of this service won't be considered complete until the network has been
     ; brought up, peer connections established and the block chain synchronised.  Therefore {@link #awaitRunning()} can
     ; potentially take a very long time.  If false, then startup is considered complete once the network activity
     ; begins and peer connections/block chain sync will continue in the background.
     ;;
#_public
    WalletAppKit setBlockingStartup(boolean blockingStartup)
    (§
        this.blockingStartup = blockingStartup;
        return this;
    )

    ;;;
     ; Sets the string that will appear in the subver field of the version message.
     ; @param userAgent A short string that should be the name of your app, e.g. "My Wallet".
     ; @param version A short string that contains the version number, e.g. "1.0-BETA".
     ;;
#_public
    WalletAppKit setUserAgent(String userAgent, String version)
    (§
        this.userAgent = Preconditions.checkNotNull(userAgent);
        this.version = Preconditions.checkNotNull(version);
        return this;
    )

    ;;;
     ; Sets a wallet factory which will be used when the kit creates a new wallet.
     ;;
#_public
    WalletAppKit setWalletFactory(WalletProtobufSerializer.WalletFactory walletFactory)
    (§
        this.walletFactory = walletFactory;
        return this;
    )

    ;;;
     ; If a seed is set here then any existing wallet that matches the file name will be renamed to a backup name,
     ; the chain file will be deleted, and the wallet object will be instantiated with the given seed instead of
     ; a fresh one being created.  This is intended for restoring a wallet from the original seed.  To implement
     ; restore, you would shut down the existing appkit, if any, then recreate it with the seed given by the user,
     ; then start up the new kit.  The next time your app starts it should work as normal (that is, don't keep
     ; calling this each time).
     ;;
#_public
    WalletAppKit restoreWalletFromSeed(DeterministicSeed seed)
    (§
        this.restoreFromSeed = seed;
        return this;
    )

    ;;;
     ; Sets the peer discovery class to use.  If none is provided then DNS is used, which is a reasonable default.
     ;;
#_public
    WalletAppKit setDiscovery(#_nilable PeerDiscovery discovery)
    (§
        this.discovery = discovery;
        return this;
    )

    ;;;
     ; Override this to use a {@link BlockStore} that isn't the default of {@link SPVBlockStore}.
     ;;
#_protected
    BlockStore provideBlockStore(File file)
        throws BlockStoreException
    (§
        return new SPVBlockStore(params, file);
    )

    ;;;
     ; This method is invoked on a background thread after all objects are initialised, but before the peer group
     ; or block chain download is started.  You can tweak the objects configuration here.
     ;;
#_protected
    void onSetupCompleted()
    (§
    )

    ;;;
     ; Tests to see if the spvchain file has an operating system file lock on it.  Useful for checking if your app
     ; is already running.  If another copy of your app is running and you start the appkit anyway, an exception will
     ; be thrown during the startup process.  Returns false if the chain file does not exist or is a directory.
     ;;
#_public
    boolean isChainFileLocked()
        throws IOException
    (§
        RandomAccessFile file2 = nil;
        try
        (§
            File file = new File(directory, filePrefix + ".spvchain");
            if (!file.exists())
                return false;
            if (file.isDirectory())
                return false;
            file2 = new RandomAccessFile(file, "rw");
            FileLock lock = file2.getChannel().tryLock();
            if (lock == nil)
                return true;
            lock.release();
            return false;
        )
        finally
        (§
            if (file2 != nil)
                file2.close();
        )
    )

#_override
#_protected
    void startUp()
        throws Exception
    (§
        ;; Runs in a separate thread.
        Context.propagate(context);
        if (!directory.exists() && !directory.mkdirs())
            throw new IOException("Could not create directory " + directory.getAbsolutePath());

        log.info("Starting up with directory = {}", directory);
        try
        (§
            File chainFile = new File(directory, filePrefix + ".spvchain");
            boolean chainFileExists = chainFile.exists();
            vWalletFile = new File(directory, filePrefix + ".wallet");
            boolean shouldReplayWallet = ((vWalletFile.exists() && !chainFileExists) || restoreFromSeed != nil);
            vWallet = createOrLoadWallet(shouldReplayWallet);

            ;; Initiate Bitcoin network objects (block store, blockchain and peer group).
            vStore = provideBlockStore(chainFile);
            if (!chainFileExists || restoreFromSeed != nil)
            (§
                if (checkpoints == nil && !Utils.isAndroidRuntime())
                    checkpoints = CheckpointManager.openStream(params);

                if (checkpoints != nil)
                (§
                    ;; Initialize the chain file with a checkpoint to speed up first-run sync.
                    long time;
                    if (restoreFromSeed != nil)
                    (§
                        time = restoreFromSeed.getCreationTimeSeconds();
                        if (chainFileExists)
                        (§
                            log.info("Deleting the chain file in preparation from restore.");
                            vStore.close();
                            if (!chainFile.delete())
                                throw new IOException("Failed to delete chain file in preparation for restore.");

                            vStore = new SPVBlockStore(params, chainFile);
                        )
                    )
                    else
                    (§
                        time = vWallet.getEarliestKeyCreationTime();
                    )
                    if (0 < time)
                        CheckpointManager.checkpoint(params, checkpoints, vStore, time);
                    else
                        log.warn("Creating a new uncheckpointed block store due to a wallet with a creation time of zero: this will result in a very slow chain sync");
                )
                else if (chainFileExists)
                (§
                    log.info("Deleting the chain file in preparation from restore.");
                    vStore.close();
                    if (!chainFile.delete())
                        throw new IOException("Failed to delete chain file in preparation for restore.");

                    vStore = new SPVBlockStore(params, chainFile);
                )
            )
            vChain = new BlockChain(params, vStore);
            vPeerGroup = createPeerGroup();
            if (this.userAgent != nil)
                vPeerGroup.setUserAgent(userAgent, version);

            ;; Set up peer addresses or discovery first, so if wallet extensions try to broadcast a transaction
            ;; before we're actually connected the broadcast waits for an appropriate number of connections.
            if (peerAddresses != nil)
            (§
                for (PeerAddress addr : peerAddresses)
                    vPeerGroup.addAddress(addr);
                vPeerGroup.setMaxConnections(peerAddresses.length);
                peerAddresses = nil;
            )
            else
            (§
                vPeerGroup.addPeerDiscovery((discovery != nil) ? discovery : new DnsDiscovery(params));
            )
            vChain.addWallet(vWallet);
            vPeerGroup.addWallet(vWallet);
            onSetupCompleted();

            if (blockingStartup)
            (§
                vPeerGroup.start();
                ;; Make sure we shut down cleanly.
                installShutdownHook();

                ;; TODO: Be able to use the provided download listener when doing a blocking startup.
#_final
                DownloadProgressTracker listener = new DownloadProgressTracker();
                vPeerGroup.startBlockChainDownload(listener);
                listener.await();
            )
            else
            (§
                Futures.addCallback(vPeerGroup.startAsync(), new FutureCallback()
                (§
#_override
#_public
                    void onSuccess(#_nilable Object result)
                    (§
#_final
                        DownloadProgressTracker l = (downloadListener != nil) ? downloadListener : new DownloadProgressTracker();
                        vPeerGroup.startBlockChainDownload(l);
                    )

#_override
#_public
                    void onFailure(Throwable t)
                    (§
                        throw new RuntimeException(t);
                    )
                ));
            )
        )
        catch (BlockStoreException e)
        (§
            throw new IOException(e);
        )
    )

#_private
    Wallet createOrLoadWallet(boolean shouldReplayWallet)
        throws Exception
    (§
        Wallet wallet;

        maybeMoveOldWalletOutOfTheWay();

        if (vWalletFile.exists())
        (§
            wallet = loadWallet(shouldReplayWallet);
        )
        else
        (§
            wallet = createWallet();
            wallet.freshReceiveKey();

            ;; Currently the only way we can be sure that an extension is aware of its containing wallet is
            ;; by deserializing the extension.
            ;; Hence, we first save and then load wallet to ensure any extensions are correctly initialized.
            wallet.saveToFile(vWalletFile);
            wallet = loadWallet(false);
        )

        if (useAutoSave)
            this.setupAutoSave(wallet);

        return wallet;
    )

#_protected
    void setupAutoSave(Wallet wallet)
    (§
        wallet.autosaveToFile(vWalletFile, 5, TimeUnit.SECONDS, nil);
    )

#_private
    Wallet loadWallet(boolean shouldReplayWallet)
        throws Exception
    (§
        Wallet wallet;
        FileInputStream walletStream = new FileInputStream(vWalletFile);
        try
        (§
            Protos.Wallet proto = WalletProtobufSerializer.parseToProto(walletStream);
#_final
            WalletProtobufSerializer serializer;
            if (walletFactory != nil)
                serializer = new WalletProtobufSerializer(walletFactory);
            else
                serializer = new WalletProtobufSerializer();
            wallet = serializer.readWallet(params, proto);
            if (shouldReplayWallet)
                wallet.reset();
        )
        finally
        (§
            walletStream.close();
        )
        return wallet;
    )

#_protected
    Wallet createWallet()
    (§
        KeyChainGroup kcg;
        if (restoreFromSeed != nil)
            kcg = new KeyChainGroup(params, restoreFromSeed);
        else
            kcg = new KeyChainGroup(params);
        return (walletFactory != nil) ? walletFactory.create(params, kcg) : new Wallet(params, kcg); ;; default
    )

#_private
    void maybeMoveOldWalletOutOfTheWay()
    (§
        if (restoreFromSeed == nil)
            return;
        if (!vWalletFile.exists())
            return;

        int counter = 1;
        File newName;
        do
        (§
            newName = new File(vWalletFile.getParent(), "Backup " + counter + " for " + vWalletFile.getName());
            counter++;
        )
        while (newName.exists());

        log.info("Renaming old wallet file {} to {}", vWalletFile, newName);

        ;; This should not happen unless something is really messed up.
        if (!vWalletFile.renameTo(newName))
            throw new RuntimeException("Failed to rename wallet for restore");
    )

#_protected
    PeerGroup createPeerGroup()
        throws TimeoutException
    (§
        return new PeerGroup(params, vChain);
    )

#_private
    void installShutdownHook()
    (§
        if (autoStop)
            Runtime.getRuntime().addShutdownHook(new Thread()
            (§
#_override
#_public
                void run()
                (§
                    try
                    (§
                        WalletAppKit.this.stopAsync();
                        WalletAppKit.this.awaitTerminated();
                    )
                    catch (Exception e)
                    (§
                        throw new RuntimeException(e);
                    )
                )
            ));
    )

#_override
#_protected
    void shutDown()
        throws Exception
    (§
        ;; Runs in a separate thread.
        try
        (§
            Context.propagate(context);
            vPeerGroup.stop();
            vWallet.saveToFile(vWalletFile);
            vStore.close();

            vPeerGroup = nil;
            vWallet = nil;
            vStore = nil;
            vChain = nil;
        )
        catch (BlockStoreException e)
        (§
            throw new IOException(e);
        )
    )

#_public
    NetworkParameters params()
    (§
        return params;
    )

#_public
    BlockChain chain()
    (§
        Preconditions.checkState(state() == State.STARTING || state() == State.RUNNING, "Cannot call until startup is complete");
        return vChain;
    )

#_public
    BlockStore store()
    (§
        Preconditions.checkState(state() == State.STARTING || state() == State.RUNNING, "Cannot call until startup is complete");
        return vStore;
    )

#_public
    Wallet wallet()
    (§
        Preconditions.checkState(state() == State.STARTING || state() == State.RUNNING, "Cannot call until startup is complete");
        return vWallet;
    )

#_public
    PeerGroup peerGroup()
    (§
        Preconditions.checkState(state() == State.STARTING || state() == State.RUNNING, "Cannot call until startup is complete");
        return vPeerGroup;
    )

#_public
    File directory()
    (§
        return directory;
    )
)

(ns org.bitcoinj.net #_"AbstractTimeoutHandler"
    (:import [java.util Timer TimerTask]))

;;;
 ; <p>A base class which provides basic support for socket timeouts.  It is used instead of integrating timeouts into the
 ; NIO select thread both for simplicity and to keep code shared between NIO and blocking sockets as much as possible.
 ; </p>
 ;;
#_public
#_abstract
class AbstractTimeoutHandler
(§
    ;; TimerTask and timeout value which are added to a timer to kill the connection on timeout.
#_private
    TimerTask timeoutTask;
#_private
    long timeoutMillis = 0;
#_private
    boolean timeoutEnabled = true;

    ;; A timer which manages expiring channels as their timeouts occur (if configured).
#_private
#_static
#_final
    Timer timeoutTimer = new Timer("AbstractTimeoutHandler timeouts", true);

    ;;;
     ; <p>Enables or disables the timeout entirely.  This may be useful if you want to store the timeout value
     ; but wish to temporarily disable/enable timeouts.</p>
     ;
     ; <p>The default is for timeoutEnabled to be true but timeoutMillis to be set to 0 (i.e. disabled).</p>
     ;
     ; <p>This call will reset the current progress towards the timeout.</p>
     ;;
#_public
#_synchronized
#_final
    void setTimeoutEnabled(boolean timeoutEnabled)
    (§
        this.timeoutEnabled = timeoutEnabled;
        resetTimeout();
    )

    ;;;
     ; <p>Sets the receive timeout to the given number of milliseconds, automatically killing the connection
     ; if no messages are received for this long.</p>
     ;
     ; <p>A timeout of 0 is interpreted as no timeout.</p>
     ;
     ; <p>The default is for timeoutEnabled to be true but timeoutMillis to be set to 0 (i.e. disabled).</p>
     ;
     ; <p>This call will reset the current progress towards the timeout.</p>
     ;;
#_public
#_synchronized
#_final
    void setSocketTimeout(int timeoutMillis)
    (§
        this.timeoutMillis = timeoutMillis;
        resetTimeout();
    )

    ;;;
     ; Resets the current progress towards timeout to 0.
     ;;
#_protected
#_synchronized
    void resetTimeout()
    (§
        if (timeoutTask != nil)
            timeoutTask.cancel();
        if (timeoutMillis == 0 || !timeoutEnabled)
            return;

        timeoutTask = new TimerTask()
        (§
#_override
#_public
            void run()
            (§
                timeoutOccurred();
            )
        );
        timeoutTimer.schedule(timeoutTask, timeoutMillis);
    )

#_protected
#_abstract
    void timeoutOccurred();
)

(ns org.bitcoinj.net #_"BlockingClient"
    (:import #_[java.io *]
             #_[java.net *]
             #_[java.nio *]
             #_[java.util *]
             #_[javax.net *])
    (:import [com.google.common.base Preconditions]
             #_[com.google.common.util.concurrent *]
             #_[org.slf4j *])
  #_(:require #_[org.bitcoinj.core *]))

;;;
 ; <p>Creates a simple connection to a server using a {@link StreamConnection} to process data.</p>
 ;
 ; <p>Generally, using {@link NioClient} and {@link NioClientManager} should be preferred over {@link BlockingClient}
 ; and {@link BlockingClientManager}, unless you wish to connect over a proxy or use some other network settings that
 ; cannot be set using NIO.</p>
 ;;
#_public
class BlockingClient implements MessageWriteTarget
(§
#_private
#_static
#_final
    org.slf4j.Logger log = LoggerFactory.getLogger(BlockingClient.class);

#_private
#_static
#_final
    int BUFFER_SIZE_LOWER_BOUND = 4096;
#_private
#_static
#_final
    int BUFFER_SIZE_UPPER_BOUND = 65536;

#_private
    Socket socket;
#_private
#_volatile
    boolean vCloseRequested = false;
#_private
    SettableFuture<SocketAddress> connectFuture;

    ;;;
     ; <p>Creates a new client to the given server address using the given {@link StreamConnection} to decode the data.
     ; The given connection <b>MUST</b> be unique to this object.  This does not block while waiting for the connection
     ; to open, but will call either the {@link StreamConnection#connectionOpened()} or
     ; {@link StreamConnection#connectionClosed()} callback on the created network event processing thread.</p>
     ;
     ; @param connectTimeoutMillis The connect timeout set on the connection (in milliseconds).
     ;                             0 is interpreted as no timeout.
     ; @param socketFactory An object that creates {@link Socket} objects on demand, which may be customised to control
     ;                      how this client connects to the internet.  If not sure, use SocketFactory.getDefault().
     ; @param clientSet A set which this object will add itself to after initialization, and then remove itself from.
     ;;
#_public
    BlockingClient(final SocketAddress serverAddress, final StreamConnection connection, final int connectTimeoutMillis, final SocketFactory socketFactory, #_nilable final Set<BlockingClient> clientSet)
        throws IOException
    (§
        connectFuture = SettableFuture.create();
        ;; Try to fit at least one message in the network buffer, but place an upper and lower limit on its size to make
        ;; sure it doesnt get too large or have to call read too often.
        connection.setWriteTarget(this);
        socket = socketFactory.createSocket();
#_final
        Context context = Context.get();
        Thread t = new Thread()
        (§
#_override
#_public
            void run()
            (§
                Context.propagate(context);
                if (clientSet != nil)
                    clientSet.add(BlockingClient.this);
                try
                (§
                    socket.connect(serverAddress, connectTimeoutMillis);
                    connection.connectionOpened();
                    connectFuture.set(serverAddress);
                    InputStream stream = socket.getInputStream();
                    runReadLoop(stream, connection);
                )
                catch (Exception e)
                (§
                    if (!vCloseRequested)
                    (§
                        log.error("Error trying to open/read from connection: {}: {}", serverAddress, e.getMessage());
                        connectFuture.setException(e);
                    )
                )
                finally
                (§
                    try
                    (§
                        socket.close();
                    )
                    catch (IOException e1)
                    (§
                        ;; At this point there isn't much we can do, and we can probably assume the channel is closed.
                    )
                    if (clientSet != nil)
                        clientSet.remove(BlockingClient.this);
                    connection.connectionClosed();
                )
            )
        );
        t.setName("BlockingClient network thread for " + serverAddress);
        t.setDaemon(true);
        t.start();
    )

    ;;;
     ; A blocking call that never returns, except by throwing an exception.  It reads bytes from the input stream
     ; and feeds them to the provided {@link StreamConnection}, for example, a {@link Peer}.
     ;;
#_public
#_static
    void runReadLoop(InputStream stream, StreamConnection connection)
        throws Exception
    (§
        ByteBuffer dbuf = ByteBuffer.allocateDirect(Math.min(Math.max(connection.getMaxMessageSize(), BUFFER_SIZE_LOWER_BOUND), BUFFER_SIZE_UPPER_BOUND));
        byte[] readBuff = new byte[dbuf.capacity()];
        while (true)
        (§
            ;; TODO: Kill the message duplication here.
            Preconditions.checkState(0 < dbuf.remaining() && dbuf.remaining() <= readBuff.length);
            int read = stream.read(readBuff, 0, Math.max(1, Math.min(dbuf.remaining(), stream.available())));
            if (read == -1)
                return;

            dbuf.put(readBuff, 0, read);
            ;; "flip" the buffer - setting the limit to the current position and setting position to 0
            dbuf.flip();
            ;; Use connection.receiveBytes's return value as a double-check that it stopped reading at the right location.
            int bytesConsumed = connection.receiveBytes(dbuf);
            Preconditions.checkState(dbuf.position() == bytesConsumed);
            ;; Now drop the bytes which were read by compacting dbuf (resetting limit and keeping relative position).
            dbuf.compact();
        )
    )

    ;;;
     ; Closes the connection to the server, triggering the {@link StreamConnection#connectionClosed()}
     ; event on the network-handling thread where all callbacks occur.
     ;;
#_override
#_public
    void closeConnection()
    (§
        ;; Closes the channel, triggering an exception in the network-handling thread triggering connectionClosed().
        try
        (§
            vCloseRequested = true;
            socket.close();
        )
        catch (IOException e)
        (§
            throw new RuntimeException(e);
        )
    )

#_override
#_public
#_synchronized
    void writeBytes(byte[] message)
        throws IOException
    (§
        try
        (§
            OutputStream stream = socket.getOutputStream();
            stream.write(message);
            stream.flush();
        )
        catch (IOException e)
        (§
            log.error("Error writing message to connection, closing connection", e);
            closeConnection();
            throw e;
        )
    )

    ;;; Returns a future that completes once connection has occurred at the socket level or with an exception if failed to connect. ;;
#_public
    ListenableFuture<SocketAddress> getConnectFuture()
    (§
        return connectFuture;
    )
)

(ns org.bitcoinj.net #_"BlockingClientManager"
    (:import [java.io IOException]
             [java.net SocketAddress]
             [java.util Collections HashSet Iterator Set]
             [javax.net SocketFactory])
    (:import [com.google.common.base Preconditions]
             [com.google.common.util.concurrent AbstractIdleService ListenableFuture]))

;;;
 ; <p>A thin wrapper around a set of {@link BlockingClient}s.</p>
 ;
 ; <p>Generally, using {@link NioClient} and {@link NioClientManager} should be preferred over {@link BlockingClient}
 ; and {@link BlockingClientManager} as they scale significantly better, unless you wish to connect over a proxy or use
 ; some other network settings that cannot be set using NIO.</p>
 ;;
#_public
class BlockingClientManager extends AbstractIdleService implements ClientConnectionManager
(§
#_private
#_final
    SocketFactory socketFactory;
#_private
#_final
    Set<BlockingClient> clients = Collections.synchronizedSet(new HashSet<BlockingClient>());

#_private
    int connectTimeoutMillis = 1000;

#_public
    BlockingClientManager()
    (§
        socketFactory = SocketFactory.getDefault();
    )

    ;;;
     ; Creates a blocking client manager that will obtain sockets from the given factory.
     ; Useful for customising how bitcoinj connects to the P2P network.
     ;;
#_public
    BlockingClientManager(SocketFactory socketFactory)
    (§
        this.socketFactory = Preconditions.checkNotNull(socketFactory);
    )

#_override
#_public
    ListenableFuture<SocketAddress> openConnection(SocketAddress serverAddress, StreamConnection connection)
    (§
        try
        (§
            if (!isRunning())
                throw new IllegalStateException();

            return new BlockingClient(serverAddress, connection, connectTimeoutMillis, socketFactory, clients).getConnectFuture();
        )
        catch (IOException e)
        (§
            throw new RuntimeException(e); ;; This should only happen if we are, e.g. out of system resources.
        )
    )

    ;;; Sets the number of milliseconds to wait before giving up on a connect attempt. ;;
#_public
    void setConnectTimeoutMillis(int connectTimeoutMillis)
    (§
        this.connectTimeoutMillis = connectTimeoutMillis;
    )

#_override
#_protected
    void startUp()
        throws Exception
    (§
    )

#_override
#_protected
    void shutDown()
        throws Exception
    (§
#_synchronized
        (clients)
        (§
            for (BlockingClient client : clients)
                client.closeConnection();
        )
    )

#_override
#_public
    int getConnectedClientCount()
    (§
        return clients.size();
    )

#_override
#_public
    void closeConnections(int n)
    (§
        if (!isRunning())
            throw new IllegalStateException();

#_synchronized
        (clients)
        (§
            Iterator<BlockingClient> it = clients.iterator();
            while (0 < n-- && it.hasNext())
                it.next().closeConnection();
        )
    )
)

(ns org.bitcoinj.net #_"ClientConnectionManager"
    (:import [java.net SocketAddress])
    (:import [com.google.common.util.concurrent ListenableFuture Service]))

;;;
 ; <p>A generic interface for an object which keeps track of a set of open client connections, creates new ones and
 ; ensures they are serviced properly.</p>
 ;
 ; <p>When the service is {@link com.google.common.util.concurrent.Service#stop()}ed, all connections will be closed
 ; and the appropriate connectionClosed() calls must be made.</p>
 ;;
#_public
interface ClientConnectionManager extends Service
(§
    ;;;
     ; Creates a new connection to the given address, with the given connection used to handle incoming data.  Any errors
     ; that occur during connection will be returned in the given future, including errors that can occur immediately.
     ;;
    ListenableFuture<SocketAddress> openConnection(SocketAddress serverAddress, StreamConnection connection);

    ;;; Gets the number of connected peers. ;;
    int getConnectedClientCount();

    ;;; Closes n peer connections. ;;
    void closeConnections(int n);
)

(ns org.bitcoinj.net #_"ConnectionHandler"
    (:import [java.io IOException]
             [java.nio ByteBuffer]
             [java.nio.channels CancelledKeyException SelectionKey SocketChannel]
             [java.util Arrays Iterator LinkedList Set]
             [java.util.concurrent.locks ReentrantLock]
             [javax.annotation.concurrent GuardedBy])
    (:import [com.google.common.base Preconditions Throwables]
             [org.slf4j LoggerFactory])
  #_(:require [org.bitcoinj.core Message]
             [org.bitcoinj.utils Threading]))

;; TODO: The locking in all this class is horrible and not really necessary.  We should just run all network stuff on one thread.

;;;
 ; A simple NIO MessageWriteTarget which handles all the business logic of a connection (reading+writing bytes).
 ; Used only by the NioClient and NioServer classes.
 ;;
class ConnectionHandler implements MessageWriteTarget
(§
#_private
#_static
#_final
    org.slf4j.Logger log = LoggerFactory.getLogger(ConnectionHandler.class);

#_private
#_static
#_final
    int BUFFER_SIZE_LOWER_BOUND = 4096;
#_private
#_static
#_final
    int BUFFER_SIZE_UPPER_BOUND = 65536;

#_private
#_static
#_final
    int OUTBOUND_BUFFER_BYTE_COUNT = Message.MAX_SIZE + 24; ;; 24 byte message header

    ;; We lock when touching local flags and when writing data, but NEVER when calling any methods which leave
    ;; this class into non-Java classes.
#_private
#_final
    ReentrantLock lock = Threading.lock("nioConnectionHandler");
#_guarded-by("lock")
#_private
#_final
    ByteBuffer readBuff;
#_guarded-by("lock")
#_private
#_final
    SocketChannel channel;
#_guarded-by("lock")
#_private
#_final
    SelectionKey key;
#_guarded-by("lock")
    StreamConnection connection;
#_guarded-by("lock")
#_private
    boolean closeCalled = false;

#_guarded-by("lock")
#_private
    long bytesToWriteRemaining = 0;
#_guarded-by("lock")
#_private
#_final
    LinkedList<ByteBuffer> bytesToWrite = new LinkedList<>();

#_private
    Set<ConnectionHandler> connectedHandlers;

#_public
    ConnectionHandler(StreamConnectionFactory connectionFactory, SelectionKey key)
        throws IOException
    (§
        this(connectionFactory.getNewConnection(((SocketChannel)key.channel()).socket().getInetAddress(), ((SocketChannel)key.channel()).socket().getPort()), key);
        if (connection == nil)
            throw new IOException("Parser factory.getNewConnection returned nil");
    )

#_private
    ConnectionHandler(#_nilable StreamConnection connection, SelectionKey key)
    (§
        this.key = key;
        this.channel = Preconditions.checkNotNull(((SocketChannel)key.channel()));
        if (connection == nil)
        (§
            readBuff = nil;
            return;
        )

        this.connection = connection;
        readBuff = ByteBuffer.allocateDirect(Math.min(Math.max(connection.getMaxMessageSize(), BUFFER_SIZE_LOWER_BOUND), BUFFER_SIZE_UPPER_BOUND));
        connection.setWriteTarget(this); ;; May callback into us (e.g. closeConnection() now).
        connectedHandlers = nil;
    )

#_public
    ConnectionHandler(StreamConnection connection, SelectionKey key, Set<ConnectionHandler> connectedHandlers)
    (§
        this(Preconditions.checkNotNull(connection), key);

        ;; closeConnection() may have already happened because we invoked the other c'tor above, which called
        ;; connection.setWriteTarget which might have re-entered already.  In this case we shouldn't add ourselves
        ;; to the connectedHandlers set.
        lock.lock();
        try
        (§
            this.connectedHandlers = connectedHandlers;
            if (!closeCalled)
                Preconditions.checkState(this.connectedHandlers.add(this));
        )
        finally
        (§
            lock.unlock();
        )
    )

#_guarded-by("lock")
#_private
    void setWriteOps()
    (§
        ;; Make sure we are registered to get updated when writing is available again.
        key.interestOps(key.interestOps() | SelectionKey.OP_WRITE);
        ;; Refresh the selector to make sure it gets the new interestOps.
        key.selector().wakeup();
    )

    ;; Tries to write any outstanding write bytes, runs in any thread (possibly unlocked).
#_private
    void tryWriteBytes()
        throws IOException
    (§
        lock.lock();
        try
        (§
            ;; Iterate through the outbound ByteBuff queue, pushing as much as possible into the OS' network buffer.
            Iterator<ByteBuffer> bytesIterator = bytesToWrite.iterator();
            while (bytesIterator.hasNext())
            (§
                ByteBuffer buff = bytesIterator.next();
                bytesToWriteRemaining -= channel.write(buff);
                if (!buff.hasRemaining())
                    bytesIterator.remove();
                else
                (§
                    setWriteOps();
                    break;
                )
            )
            ;; If we are done writing, clear the OP_WRITE interestOps.
            if (bytesToWrite.isEmpty())
                key.interestOps(key.interestOps() & ~SelectionKey.OP_WRITE);
            ;; Don't bother waking up the selector here, since we're just removing an op, not adding.
        )
        finally
        (§
            lock.unlock();
        )
    )

#_override
#_public
    void writeBytes(byte[] message)
        throws IOException
    (§
        boolean andUnlock = true;
        lock.lock();
        try
        (§
            ;; Network buffers are not unlimited (and are often smaller than some messages we may wish to send), and
            ;; thus we have to buffer outbound messages sometimes.  To do this, we use a queue of ByteBuffers and just
            ;; append to it when we want to send a message.  We then let tryWriteBytes() either send the message or
            ;; register our SelectionKey to wakeup when we have free outbound buffer space available.
            if (OUTBOUND_BUFFER_BYTE_COUNT < bytesToWriteRemaining + message.length)
                throw new IOException("Outbound buffer overflowed");

            ;; Just dump the message onto the write buffer and call tryWriteBytes.
            ;; TODO: Kill the needless message duplication when the write completes right away.
            bytesToWrite.offer(ByteBuffer.wrap(Arrays.copyOf(message, message.length)));
            bytesToWriteRemaining += message.length;
            setWriteOps();
        )
        catch (IOException e)
        (§
            lock.unlock();
            andUnlock = false;
            log.warn("Error writing message to connection, closing connection", e);
            closeConnection();
            throw e;
        )
        catch (CancelledKeyException e)
        (§
            lock.unlock();
            andUnlock = false;
            log.warn("Error writing message to connection, closing connection", e);
            closeConnection();
            throw new IOException(e);
        )
        finally
        (§
            if (andUnlock)
                lock.unlock();
        )
    )

    ;; May NOT be called with lock held.
#_override
#_public
    void closeConnection()
    (§
        Preconditions.checkState(!lock.isHeldByCurrentThread());
        try
        (§
            channel.close();
        )
        catch (IOException e)
        (§
            throw new RuntimeException(e);
        )
        connectionClosed();
    )

#_private
    void connectionClosed()
    (§
        boolean callClosed = false;
        lock.lock();
        try
        (§
            callClosed = !closeCalled;
            closeCalled = true;
        )
        finally
        (§
            lock.unlock();
        )
        if (callClosed)
        (§
            Preconditions.checkState(connectedHandlers == nil || connectedHandlers.remove(this));
            connection.connectionClosed();
        )
    )

    ;; Handle a SelectionKey which was selected.
    ;; Runs unlocked as the caller is single-threaded (or if not, should enforce that handleKey is only called
    ;; atomically for a given ConnectionHandler).
#_public
#_static
    void handleKey(SelectionKey key)
    (§
        ConnectionHandler handler = (ConnectionHandler)key.attachment();
        try
        (§
            if (handler == nil)
                return;
            if (!key.isValid())
            (§
                handler.closeConnection(); ;; Key has been cancelled, make sure the socket gets closed.
                return;
            )
            if (key.isReadable())
            (§
                ;; Do a socket read and invoke the connection's receiveBytes message.
                int read = handler.channel.read(handler.readBuff);
                if (read == 0)
                    return; ;; Was probably waiting on a write.
                else if (read == -1) ;; Socket was closed.
                (§
                    key.cancel();
                    handler.closeConnection();
                    return;
                )
                ;; "flip" the buffer - setting the limit to the current position and setting position to 0
                handler.readBuff.flip();
                ;; Use connection.receiveBytes's return value as a check that it stopped reading at the right location.
                int bytesConsumed = Preconditions.checkNotNull(handler.connection).receiveBytes(handler.readBuff);
                Preconditions.checkState(handler.readBuff.position() == bytesConsumed);
                ;; Now drop the bytes which were read by compacting readBuff (resetting limit and keeping relative position).
                handler.readBuff.compact();
            )
            if (key.isWritable())
                handler.tryWriteBytes();
        )
        catch (Exception e)
        (§
            ;; This can happen e.g. if the channel closes while the thread is about to get killed
            ;; (ClosedByInterruptException), or if handler.connection.receiveBytes throws something.
            Throwable t = Throwables.getRootCause(e);
            log.warn("Error handling SelectionKey: {} {}", t.getClass().getName(), (t.getMessage() != nil) ? t.getMessage() : "", e);
            handler.closeConnection();
        )
    )
)

(ns org.bitcoinj.net #_"FilterMerger"
    (:import [java.util LinkedList])
    (:import [com.google.common.collect ImmutableList Lists])
  #_(:require [org.bitcoinj.core BloomFilter PeerFilterProvider]))

;;;
 ; <p>A reusable object that will calculate, given a list of {@link org.bitcoinj.core.PeerFilterProvider}s, a merged
 ; {@link org.bitcoinj.core.BloomFilter} and earliest key time for all of them.
 ; Used by the {@link org.bitcoinj.core.PeerGroup} class internally.</p>
 ;
 ; <p>Thread safety: threading here can be complicated.  Each filter provider is given a begin event, which may acquire
 ; a lock (and is guaranteed to receive an end event).  This class is mostly thread unsafe and is meant to be used from
 ; a single thread only, PeerGroup ensures this by only accessing it from the dedicated PeerGroup thread.  PeerGroup
 ; does not hold any locks whilst this object is used, relying on the single thread to prevent multiple filters being
 ; calculated in parallel, thus a filter provider can do things like make blocking calls into PeerGroup from a separate
 ; thread.  However the bloomFilterFPRate property IS thread safe, for convenience.</p>
 ;;
#_public
class FilterMerger
(§
    ;; We use a constant tweak to avoid giving up privacy when we regenerate our filter with new keys.
#_private
#_final
    long bloomFilterTweak = (long)(Math.random() * Long.MAX_VALUE);

#_private
#_volatile
    double vBloomFilterFPRate;
#_private
    int lastBloomFilterElementCount;
#_private
    BloomFilter lastFilter;

#_public
    FilterMerger(double bloomFilterFPRate)
    (§
        this.vBloomFilterFPRate = bloomFilterFPRate;
    )

#_public
#_static
    class Result
    (§
#_public
        BloomFilter filter;
#_public
        long earliestKeyTimeSecs;
#_public
        boolean changed;
    )

#_public
    Result calculate(ImmutableList<PeerFilterProvider> providers)
    (§
        LinkedList<PeerFilterProvider> begunProviders = Lists.newLinkedList();
        try
        (§
            ;; All providers must be in a consistent, unchanging state because the filter is a merged one that's
            ;; large enough for all providers elements: if a provider were to get more elements in the middle of the
            ;; calculation, we might assert or calculate the filter wrongly.  Most providers use a lock here but
            ;; snapshotting required state is also a legitimate strategy.
            for (PeerFilterProvider provider : providers)
            (§
                provider.beginBloomFilterCalculation();
                begunProviders.add(provider);
            )
            Result result = new Result();
            result.earliestKeyTimeSecs = Long.MAX_VALUE;
            int elements = 0;
            boolean requiresUpdateAll = false;
            for (PeerFilterProvider p : providers)
            (§
                result.earliestKeyTimeSecs = Math.min(result.earliestKeyTimeSecs, p.getEarliestKeyCreationTime());
                elements += p.getBloomFilterElementCount();
            )

            if (0 < elements)
            (§
                ;; We stair-step our element count so that we avoid creating a filter with different parameters
                ;; as much as possible as that results in a loss of privacy.
                ;; The constant 100 here is somewhat arbitrary, but makes sense for small to medium wallets -
                ;; it will likely mean we never need to create a filter with different parameters.
                lastBloomFilterElementCount = (lastBloomFilterElementCount < elements) ? elements + 100 : lastBloomFilterElementCount;
                BloomFilter.BloomUpdate bloomFlags = requiresUpdateAll ? BloomFilter.BloomUpdate.UPDATE_ALL : BloomFilter.BloomUpdate.UPDATE_P2PUBKEY_ONLY;
                double fpRate = vBloomFilterFPRate;
                BloomFilter filter = new BloomFilter(lastBloomFilterElementCount, fpRate, bloomFilterTweak, bloomFlags);
                for (PeerFilterProvider p : providers)
                    filter.merge(p.getBloomFilter(lastBloomFilterElementCount, fpRate, bloomFilterTweak));

                result.changed = !filter.equals(lastFilter);
                result.filter = lastFilter = filter;
            )
            ;; Now adjust the earliest key time backwards by a week to handle the case of clock drift.  This can occur
            ;; both in block header timestamps and if the users clock was out of sync when the key was first created
            ;; (to within a small amount of tolerance).
            result.earliestKeyTimeSecs -= 86400 * 7;
            return result;
        )
        finally
        (§
            for (PeerFilterProvider provider : begunProviders)
                provider.endBloomFilterCalculation();
        )
    )

#_public
    void setBloomFilterFPRate(double bloomFilterFPRate)
    (§
        this.vBloomFilterFPRate = bloomFilterFPRate;
    )

#_public
    double getBloomFilterFPRate()
    (§
        return vBloomFilterFPRate;
    )

#_public
    BloomFilter getLastFilter()
    (§
        return lastFilter;
    )
)

(ns org.bitcoinj.net #_"MessageWriteTarget"
    (:import [java.io IOException]))

;;;
 ; A target to which messages can be written/connection can be closed.
 ;;
#_public
interface MessageWriteTarget
(§
    ;;;
     ; Writes the given bytes to the remote server.
     ;;
    void writeBytes(byte[] message)
        throws IOException;
    ;;;
     ; Closes the connection to the server, triggering the {@link StreamConnection#connectionClosed()}
     ; event on the network-handling thread where all callbacks occur.
     ;;
    void closeConnection();
)

(ns org.bitcoinj.net #_"NioClient"
    (:import #_[java.io *]
             #_[java.net *]
             #_[java.nio *])
    (:import #_[com.google.common.base *]
             #_[com.google.common.util.concurrent *]
             #_[org.slf4j *]))

;;;
 ; Creates a simple connection to a server using a {@link StreamConnection} to process data.
 ;;
#_public
class NioClient implements MessageWriteTarget
(§
#_private
#_static
#_final
    Logger log = LoggerFactory.getLogger(NioClient.class);

#_private
#_final
    Handler handler;
#_private
#_final
    NioClientManager manager = new NioClientManager();

    class Handler extends AbstractTimeoutHandler implements StreamConnection
    (§
#_private
#_final
        StreamConnection upstreamConnection;
#_private
        MessageWriteTarget writeTarget;
#_private
        boolean closeOnOpen;
#_private
        boolean closeCalled;

        Handler(StreamConnection upstreamConnection, int connectTimeoutMillis)
        (§
            this.upstreamConnection = upstreamConnection;
            setSocketTimeout(connectTimeoutMillis);
            setTimeoutEnabled(true);
        )

#_override
#_protected
#_synchronized
        void timeoutOccurred()
        (§
            closeOnOpen = true;
            connectionClosed();
        )

#_override
#_public
#_synchronized
        void connectionClosed()
        (§
            manager.stopAsync();
            if (!closeCalled)
            (§
                closeCalled = true;
                upstreamConnection.connectionClosed();
            )
        )

#_override
#_public
#_synchronized
        void connectionOpened()
        (§
            if (!closeOnOpen)
                upstreamConnection.connectionOpened();
        )

#_override
#_public
        int receiveBytes(ByteBuffer buff)
            throws Exception
        (§
            return upstreamConnection.receiveBytes(buff);
        )

#_override
#_public
#_synchronized
        void setWriteTarget(MessageWriteTarget writeTarget)
        (§
            if (closeOnOpen)
                writeTarget.closeConnection();
            else
            (§
                setTimeoutEnabled(false);
                this.writeTarget = writeTarget;
                upstreamConnection.setWriteTarget(writeTarget);
            )
        )

#_override
#_public
        int getMaxMessageSize()
        (§
            return upstreamConnection.getMaxMessageSize();
        )
    )

    ;;;
     ; <p>Creates a new client to the given server address using the given {@link StreamConnection} to decode the data.
     ; The given connection <b>MUST</b> be unique to this object.  This does not block while waiting for the connection
     ; to open, but will call either the {@link StreamConnection#connectionOpened()} or
     ; {@link StreamConnection#connectionClosed()} callback on the created network event processing thread.</p>
     ;
     ; @param connectTimeoutMillis The connect timeout set on the connection (in milliseconds).
                                   0 is interpreted as no timeout.
     ;;
#_public
    NioClient(final SocketAddress serverAddress, final StreamConnection parser, final int connectTimeoutMillis)
        throws IOException
    (§
        manager.startAsync();
        manager.awaitRunning();
        handler = new Handler(parser, connectTimeoutMillis);
        Futures.addCallback(manager.openConnection(serverAddress, handler), new FutureCallback<SocketAddress>()
        (§
#_override
#_public
            void onSuccess(SocketAddress result)
            (§
            )

#_override
#_public
            void onFailure(Throwable t)
            (§
                log.error("Connect to {} failed: {}", serverAddress, Throwables.getRootCause(t));
            )
        ));
    )

#_override
#_public
    void closeConnection()
    (§
        handler.writeTarget.closeConnection();
    )

#_override
#_public
#_synchronized
    void writeBytes(byte[] message)
        throws IOException
    (§
        handler.writeTarget.writeBytes(message);
    )
)

(ns org.bitcoinj.net #_"NioClientManager"
    (:import [java.io IOException]
             [java.net ConnectException SocketAddress]
             #_[java.nio.channels *]
             [java.nio.channels.spi SelectorProvider]
             #_[java.util *]
             #_[java.util.concurrent *])
    (:import [com.google.common.base Throwables]
             #_[com.google.common.util.concurrent *]
             [org.slf4j LoggerFactory])
  #_(:require #_[org.bitcoinj.utils *]))

;;;
 ; A class which manages a set of client connections.  Uses Java NIO to select network events and processes them
 ; in a single network processing thread.
 ;;
#_public
class NioClientManager extends AbstractExecutionThreadService implements ClientConnectionManager
(§
#_private
#_static
#_final
    org.slf4j.Logger log = LoggerFactory.getLogger(NioClientManager.class);

#_private
#_final
    Selector selector;

    class PendingConnect
    (§
        SocketChannel sc;
        StreamConnection connection;
        SocketAddress address;
        SettableFuture<SocketAddress> future = SettableFuture.create();

        PendingConnect(SocketChannel sc, StreamConnection connection, SocketAddress address)
        (§
            this.sc = sc;
            this.connection = connection;
            this.address = address;
        )
    )
#_final
    Queue<PendingConnect> newConnectionChannels = new LinkedBlockingQueue<>();

    ;; Added to/removed from by the individual ConnectionHandler's, thus must by synchronized on its own.
#_private
#_final
    Set<ConnectionHandler> connectedHandlers = Collections.synchronizedSet(new HashSet<ConnectionHandler>());

    ;; Handle a SelectionKey which was selected.
#_private
    void handleKey(SelectionKey key)
        throws IOException
    (§
        ;; We could have a !isValid() key here if the connection is already closed at this point,
        ;; i.e. a client connection which has finished the initial connect process.
        if (key.isValid() && key.isConnectable())
        (§
            ;; Create a ConnectionHandler and hook everything together.
            PendingConnect data = (PendingConnect)key.attachment();
            StreamConnection connection = data.connection;
            SocketChannel sc = (SocketChannel)key.channel();
            ConnectionHandler handler = new ConnectionHandler(connection, key, connectedHandlers);
            try
            (§
                if (sc.finishConnect())
                (§
                    log.info("Connected to {}", sc.socket().getRemoteSocketAddress());
                    key.interestOps((key.interestOps() | SelectionKey.OP_READ) & ~SelectionKey.OP_CONNECT).attach(handler);
                    connection.connectionOpened();
                    data.future.set(data.address);
                )
                else
                (§
                    log.warn("Failed to connect to {}", sc.socket().getRemoteSocketAddress());
                    handler.closeConnection(); ;; Failed to connect for some reason.
                    data.future.setException(new ConnectException("Unknown reason"));
                    data.future = nil;
                )
            )
            catch (Exception e)
            (§
                ;; If e is a CancelledKeyException, there is a race to get to interestOps after finishConnect() which
                ;; may cause this.  Otherwise it may be any arbitrary kind of connection failure.
                ;; Calling sc.socket().getRemoteSocketAddress() here throws an exception, so we can only log the error itself.
                Throwable cause = Throwables.getRootCause(e);
                log.warn("Failed to connect with exception: {}: {}", cause.getClass().getName(), cause.getMessage(), e);
                handler.closeConnection();
                data.future.setException(cause);
                data.future = nil;
            )
        )
        else ;; Process bytes read.
            ConnectionHandler.handleKey(key);
    )

    ;;;
     ; Creates a new client manager which uses Java NIO for socket management.
     ; Uses a single thread to handle all select calls.
     ;;
#_public
    NioClientManager()
    (§
        try
        (§
            selector = SelectorProvider.provider().openSelector();
        )
        catch (IOException e)
        (§
            throw new RuntimeException(e); ;; Shouldn't ever happen.
        )
    )

#_override
#_public
    void run()
    (§
        try
        (§
            Thread.currentThread().setPriority(Thread.MIN_PRIORITY);
            while (isRunning())
            (§
                PendingConnect conn;
                while ((conn = newConnectionChannels.poll()) != nil)
                (§
                    try
                    (§
                        SelectionKey key = conn.sc.register(selector, SelectionKey.OP_CONNECT);
                        key.attach(conn);
                    )
                    catch (ClosedChannelException _)
                    (§
                        log.warn("SocketChannel was closed before it could be registered");
                    )
                )

                selector.select();

                Iterator<SelectionKey> keyIterator = selector.selectedKeys().iterator();
                while (keyIterator.hasNext())
                (§
                    SelectionKey key = keyIterator.next();
                    keyIterator.remove();
                    handleKey(key);
                )
            )
        )
        catch (Exception e)
        (§
            log.warn("Error trying to open/read from connection: ", e);
        )
        finally
        (§
            ;; Go through and close everything, without letting IOExceptions get in our way.
            for (SelectionKey key : selector.keys())
            (§
                try
                (§
                    key.channel().close();
                )
                catch (IOException e)
                (§
                    log.warn("Error closing channel", e);
                )
                key.cancel();
                if (key.attachment() instanceof ConnectionHandler)
                    ConnectionHandler.handleKey(key); ;; Close connection if relevant.
            )
            try
            (§
                selector.close();
            )
            catch (IOException e)
            (§
                log.warn("Error closing client manager selector", e);
            )
        )
    )

#_override
#_public
    ListenableFuture<SocketAddress> openConnection(SocketAddress serverAddress, StreamConnection connection)
    (§
        if (!isRunning())
            throw new IllegalStateException();

        ;; Create a new connection, give it a connection as an attachment.
        try
        (§
            SocketChannel sc = SocketChannel.open();
            sc.configureBlocking(false);
            sc.connect(serverAddress);
            PendingConnect data = new PendingConnect(sc, connection, serverAddress);
            newConnectionChannels.offer(data);
            selector.wakeup();
            return data.future;
        )
        catch (Throwable e)
        (§
            return Futures.immediateFailedFuture(e);
        )
    )

#_override
#_public
    void triggerShutdown()
    (§
        selector.wakeup();
    )

#_override
#_public
    int getConnectedClientCount()
    (§
        return connectedHandlers.size();
    )

#_override
#_public
    void closeConnections(int n)
    (§
        while (0 < n--)
        (§
            ConnectionHandler handler;
#_synchronized
            (connectedHandlers)
            (§
                handler = connectedHandlers.iterator().next();
            )
            if (handler != nil)
                handler.closeConnection(); ;; Removes handler from connectedHandlers before returning.
        )
    )

#_override
#_protected
    Executor executor()
    (§
        return new Executor()
        (§
#_override
#_public
            void execute(Runnable command)
            (§
                new ContextPropagatingThreadFactory("NioClientManager").newThread(command).start();
            )
        );
    )
)

(ns org.bitcoinj.net #_"NioServer"
    (:import [java.io IOException]
             [java.net InetSocketAddress]
             #_[java.nio.channels *]
             [java.nio.channels.spi SelectorProvider]
             [java.util Iterator])
    (:import [com.google.common.annotations VisibleForTesting]
             [com.google.common.base Throwables]
             [com.google.common.util.concurrent AbstractExecutionThreadService]
             [org.slf4j LoggerFactory]))

;;;
 ; Creates a simple server listener which listens for incoming client connections and uses a {@link StreamConnection}
 ; to process data.
 ;;
#_public
class NioServer extends AbstractExecutionThreadService
(§
#_private
#_static
#_final
    org.slf4j.Logger log = LoggerFactory.getLogger(NioServer.class);

#_private
#_final
    StreamConnectionFactory connectionFactory;

#_private
#_final
    ServerSocketChannel sc;
#_testing
#_final
    Selector selector;

    ;; Handle a SelectionKey which was selected.
#_private
    void handleKey(Selector selector, SelectionKey key)
        throws IOException
    (§
        if (key.isValid() && key.isAcceptable())
        (§
            ;; Accept a new connection, give it a stream connection as an attachment.
            SocketChannel newChannel = sc.accept();
            newChannel.configureBlocking(false);
            SelectionKey newKey = newChannel.register(selector, SelectionKey.OP_READ);
            try
            (§
                ConnectionHandler handler = new ConnectionHandler(connectionFactory, newKey);
                newKey.attach(handler);
                handler.connection.connectionOpened();
            )
            catch (IOException e)
            (§
                ;; This can happen if ConnectionHandler's call to get a new handler returned null.
                log.error("Error handling new connection", Throwables.getRootCause(e).getMessage());
                newKey.channel().close();
            )
        )
        else ;; Got a closing channel or a channel to a client connection.
        (§
            ConnectionHandler.handleKey(key);
        )
    )

    ;;;
     ; Creates a new server which is capable of listening for incoming connections and processing client provided data
     ; using {@link StreamConnection}s created by the given {@link StreamConnectionFactory}.
     ;
     ; @throws IOException if there is an issue opening the server socket or binding fails for some reason.
     ;;
#_public
    NioServer(final StreamConnectionFactory connectionFactory, InetSocketAddress bindAddress)
        throws IOException
    (§
        this.connectionFactory = connectionFactory;

        sc = ServerSocketChannel.open();
        sc.configureBlocking(false);
        sc.socket().bind(bindAddress);
        selector = SelectorProvider.provider().openSelector();
        sc.register(selector, SelectionKey.OP_ACCEPT);
    )

#_override
#_protected
    void run()
        throws Exception
    (§
        try
        (§
            while (isRunning())
            (§
                selector.select();

                Iterator<SelectionKey> keyIterator = selector.selectedKeys().iterator();
                while (keyIterator.hasNext())
                (§
                    SelectionKey key = keyIterator.next();
                    keyIterator.remove();

                    handleKey(selector, key);
                )
            )
        )
        catch (Exception e)
        (§
            log.error("Error trying to open/read from connection: {}", e);
        )
        finally
        (§
            ;; Go through and close everything, without letting IOExceptions get in our way.
            for (SelectionKey key : selector.keys())
            (§
                try
                (§
                    key.channel().close();
                )
                catch (IOException e)
                (§
                    log.error("Error closing channel", e);
                )
                try
                (§
                    key.cancel();
                    handleKey(selector, key);
                )
                catch (IOException e)
                (§
                    log.error("Error closing selection key", e);
                )
            )
            try
            (§
                selector.close();
            )
            catch (IOException e)
            (§
                log.error("Error closing server selector", e);
            )
            try
            (§
                sc.close();
            )
            catch (IOException e)
            (§
                log.error("Error closing server channel", e);
            )
        )
    )

    ;;;
     ; Invoked by the Execution service when it's time to stop.
     ; Calling this method directly will NOT stop the service, call
     ; {@link com.google.common.util.concurrent.AbstractExecutionThreadService#stop()} instead.
     ;;
#_override
#_public
    void triggerShutdown()
    (§
        ;; Wake up the selector and let the selection thread break its loop as the ExecutionService !isRunning().
        selector.wakeup();
    )
)

(ns org.bitcoinj.net #_"ProtobufConnection"
    (:import [java.io IOException]
             [java.nio ByteBuffer ByteOrder]
             [java.util.concurrent.atomic AtomicReference]
             [java.util.concurrent.locks ReentrantLock]
             [javax.annotation.concurrent GuardedBy])
    (:import [com.google.common.annotations VisibleForTesting]
             [com.google.common.base Preconditions]
             [com.google.protobuf ByteString MessageLite]
             [org.slf4j Logger LoggerFactory])
  #_(:require [org.bitcoinj.core Utils]
             [org.bitcoinj.utils Threading]))

;;;
 ; <p>A handler which is used in {@link NioServer} and {@link NioClient} to split up incoming data streams
 ; into protobufs and provide an interface for writing protobufs to the connections.</p>
 ;
 ; <p>Messages are encoded with a 4-byte signed integer (big endian) prefix to indicate their length followed
 ; by the serialized protobuf.</p>
 ;;
#_public
class ProtobufConnection<MessageType extends MessageLite> extends AbstractTimeoutHandler implements StreamConnection
(§
#_private
#_static
#_final
    Logger log = LoggerFactory.getLogger(ProtobufConnection.class);

    ;;;
     ; An interface which can be implemented to handle callbacks as new messages are generated and socket events occur.
     ; @param <MessageType> The protobuf type which is used on this socket.
     ;                      This <b>MUST</b> match the MessageType used in the parent {@link ProtobufConnection}.
     ;;
#_public
    interface Listener<MessageType extends MessageLite>
    (§
        ;;; Called when a new protobuf is received from the remote side. ;;
        void messageReceived(ProtobufConnection<MessageType> handler, MessageType msg);
        ;;; Called when the connection is opened and available for writing data to. ;;
        void connectionOpen(ProtobufConnection<MessageType> handler);
        ;;; Called when the connection is closed and no more data should be provided. ;;
        void connectionClosed(ProtobufConnection<MessageType> handler);
    )

    ;; The callback listener.
#_private
#_final
    Listener<MessageType> handler;
    ;; The prototype which is used to deserialize messages.
#_private
#_final
    MessageLite prototype;

    ;; The maximum message size (NOT INCLUDING LENGTH PREFIX).
#_final
    int maxMessageSize;

    ;; A temporary buffer used when the message size is larger than the buffer being used by the network code.
    ;; Because the networking code uses a constant size buffer and we want to allow for very large message sizes, we use
    ;; a smaller network buffer per client and only allocate more memory when we need it to deserialize large messages.
    ;; Though this is not in of itself a DoS protection, it allows for handling more legitimate clients per server and
    ;; attacking clients can be made to timeout/get blocked if they are sending crap to fill buffers.
#_guarded-by("lock")
#_private
    int messageBytesOffset = 0;
#_guarded-by("lock")
#_private
    byte[] messageBytes;
#_private
#_final
    ReentrantLock lock = Threading.lock("ProtobufConnection");

#_testing
#_final
    AtomicReference<MessageWriteTarget> writeTarget = new AtomicReference<>();

    ;;;
     ; Creates a new protobuf handler.
     ;
     ; @param handler The callback listener.
     ; @param prototype The default instance of the message type used in both directions of this channel.
     ;                  This should be the return value from {@link MessageType#getDefaultInstanceForType()}.
     ; @param maxMessageSize The maximum message size (not including the 4-byte length prefix).
     ;                       Note that this has an upper bound of {@link Integer#MAX_VALUE} - 4.
     ; @param timeoutMillis The timeout between messages before the connection is automatically closed.
     ;                      Only enabled after the connection is established.
     ;;
#_public
    ProtobufConnection(Listener<MessageType> handler, MessageType prototype, int maxMessageSize, int timeoutMillis)
    (§
        this.handler = handler;
        this.prototype = prototype;
        this.maxMessageSize = Math.min(maxMessageSize, Integer.MAX_VALUE - 4);
        setTimeoutEnabled(false);
        setSocketTimeout(timeoutMillis);
    )

#_override
#_public
    void setWriteTarget(MessageWriteTarget writeTarget)
    (§
        ;; Only allow it to be set once.
        Preconditions.checkState(this.writeTarget.getAndSet(Preconditions.checkNotNull(writeTarget)) == nil);
    )

#_override
#_public
    int getMaxMessageSize()
    (§
        return maxMessageSize;
    )

    ;;;
     ; Closes this connection, eventually triggering a {@link ProtobufConnection.Listener#connectionClosed()} event.
     ;;
#_public
    void closeConnection()
    (§
        this.writeTarget.get().closeConnection();
    )

#_override
#_protected
    void timeoutOccurred()
    (§
        log.warn("Timeout occurred for " + handler);
        closeConnection();
    )

    ;; Deserializes and provides a listener event (buff must not have the length prefix in it).
    ;; Does set the buffers's position to its limit.
#_suppress("unchecked")
    ;; The warning 'unchecked cast' being suppressed here comes from the build() formally returning
    ;; a MessageLite-derived class that cannot be statically guaranteed to be the MessageType.
#_private
    void deserializeMessage(ByteBuffer buff)
        throws Exception
    (§
        MessageType msg = (MessageType)prototype.newBuilderForType().mergeFrom(ByteString.copyFrom(buff)).build();
        resetTimeout();
        handler.messageReceived(this, msg);
    )

#_override
#_public
    int receiveBytes(ByteBuffer buff)
        throws Exception
    (§
        lock.lock();
        try
        (§
            if (messageBytes != nil)
            (§
                ;; Just keep filling up the currently being worked on message.
                int bytesToGet = Math.min(messageBytes.length - messageBytesOffset, buff.remaining());
                buff.get(messageBytes, messageBytesOffset, bytesToGet);
                messageBytesOffset += bytesToGet;
                if (messageBytesOffset == messageBytes.length)
                (§
                    ;; Filled up our buffer, decode the message.
                    deserializeMessage(ByteBuffer.wrap(messageBytes));
                    messageBytes = nil;
                    if (buff.hasRemaining())
                        return bytesToGet + receiveBytes(buff);
                )
                return bytesToGet;
            )

            ;; If we cant read the length prefix yet, give up.
            if (buff.remaining() < 4)
                return 0;

            ;; Read one integer in big endian.
            buff.order(ByteOrder.BIG_ENDIAN);
#_final
            int len = buff.getInt();

            ;; If length is larger than the maximum message size (or is negative/overflows) throw an exception and close
            ;; the connection.
            if (maxMessageSize < len || len + 4 < 4)
                throw new IllegalStateException("Message too large or length underflowed");

            ;; If the buffer's capacity is less than the next messages length + 4 (length prefix), we must use messageBytes
            ;; as a temporary buffer to store the message.
            if (buff.capacity() < len + 4)
            (§
                messageBytes = new byte[len];
                ;; Now copy all remaining bytes into the new buffer, set messageBytesOffset and tell the caller how many
                ;; bytes we consumed.
                int bytesToRead = buff.remaining();
                buff.get(messageBytes, 0, bytesToRead);
                messageBytesOffset = bytesToRead;
                return bytesToRead + 4;
            )

            ;; Wait until the whole message is available in the buffer.
            if (buff.remaining() < len)
            (§
                ;; Make sure the buffer's position is right at the end.
                buff.position(buff.position() - 4);
                return 0;
            )

            ;; Temporarily limit the buffer to the size of the message, so that the protobuf decode doesn't get messed up.
            int limit = buff.limit();
            buff.limit(buff.position() + len);
            deserializeMessage(buff);
            Preconditions.checkState(buff.remaining() == 0);
            ;; Reset the limit in case we have to recurse.
            buff.limit(limit);

            ;; If there are still bytes remaining, see if we can pull out another message since we won't get called again.
            if (buff.hasRemaining())
                return len + 4 + receiveBytes(buff);
            else
                return len + 4;
        )
        finally
        (§
            lock.unlock();
        )
    )

#_override
#_public
    void connectionClosed()
    (§
        handler.connectionClosed(this);
    )

#_override
#_public
    void connectionOpened()
    (§
        setTimeoutEnabled(true);
        handler.connectionOpen(this);
    )

    ;;;
     ; <p>Writes the given message to the other side of the connection, prefixing it with the proper 4-byte prefix.</p>
     ;
     ; <p>Provides a write-order guarantee.</p>
     ;
     ; @throws IllegalStateException if the encoded message is larger than the maximum message size.
     ;;
#_public
    void write(MessageType msg)
        throws IllegalStateException
    (§
        byte[] messageBytes = msg.toByteArray();
        Preconditions.checkState(messageBytes.length <= maxMessageSize);

        byte[] messageLength = new byte[4];
        Utils.uint32ToByteArrayBE(messageBytes.length, messageLength, 0);
        try
        (§
            MessageWriteTarget target = writeTarget.get();
            target.writeBytes(messageLength);
            target.writeBytes(messageBytes);
        )
        catch (IOException e)
        (§
            closeConnection();
        )
    )
)

(ns org.bitcoinj.net #_"StreamConnection"
    (:import [java.nio ByteBuffer]))

;;;
 ; A generic handler which is used in {@link NioServer}, {@link NioClient} and {@link BlockingClient} to handle incoming
 ; data streams.
 ;;
#_public
interface StreamConnection
(§
    ;;; Called when the connection socket is closed. ;;
    void connectionClosed();

    ;;; Called when the connection socket is first opened. ;;
    void connectionOpened();

    ;;;
     ; <p>Called when new bytes are available from the remote end.  This should only ever be called by the single
     ; writeTarget associated with any given StreamConnection, multiple callers will likely confuse implementations.</p>
     ;
     ; Implementers/callers must follow the following conventions exactly:
     ; <ul>
     ; <li>buff will start with its limit set to the position we can read to and its position set to the location we
     ;     will start reading at (always 0).</li>
     ; <li>May read more than one message (recursively) if there are enough bytes available.</li>
     ; <li>Uses some internal buffering to store message which are larger (incl. their length prefix) than buff's
     ;     capacity(), i.e. it is up to this method to ensure we dont run out of buffer space to decode the next message.</li>
     ; <li>buff will end with its limit the same as it was previously, and its position set to the position up to which
     ;     bytes have been read (the same as its return value).</li>
     ; <li>buff must be at least the size of a Bitcoin header (incl. magic bytes).</li>
     ; </ul>
     ;
     ; @return the amount of bytes consumed which should not be provided again.
     ;;
    int receiveBytes(ByteBuffer buff)
        throws Exception;

    ;;;
     ; Called when this connection is attached to an upstream write target (i.e. a low-level connection handler).
     ; This writeTarget should be stored and used to close the connection or write data to the socket.
     ;;
    void setWriteTarget(MessageWriteTarget writeTarget);

    ;;;
     ; Returns the maximum message size of a message on the socket. This is used in calculating size of buffers
     ; to allocate.
     ;;
    int getMaxMessageSize();
)

(ns org.bitcoinj.net #_"StreamConnectionFactory"
    (:import [java.net InetAddress]))

;;;
 ; A factory which generates new {@link StreamConnection}s when a new connection is opened.
 ;;
#_public
interface StreamConnectionFactory
(§
    ;;;
     ; Returns a new handler or null to have the connection close.
     ; @param inetAddress The client's (IP) address.
     ; @param port The remote port on the client side.
     ;;
#_nilable
    StreamConnection getNewConnection(InetAddress inetAddress, int port);
)

(ns org.bitcoinj.net.discovery #_"DnsDiscovery"
    (:import #_[java.net *]
             #_[java.util *]
             #_[java.util.concurrent *])
  #_(:require #_[org.bitcoinj.core *]
             #_[org.bitcoinj.utils *]))

;;;
 ; <p>Supports peer discovery through DNS.</p>
 ;
 ; <p>Failure to resolve individual host names will not cause an Exception to be thrown.
 ; However, if all hosts passed fail to resolve a PeerDiscoveryException will be thrown during getPeers().</p>
 ;
 ; <p>DNS seeds do not attempt to enumerate every peer on the network.
 ; {@link DnsDiscovery#getPeers(long, java.util.concurrent.TimeUnit)} will return up to 30 random peers
 ; from the set of those returned within the timeout period.  If you want more peers to connect to,
 ; you need to discover them via other means (like addr broadcasts).</p>
 ;;
#_public
class DnsDiscovery extends MultiplexingDiscovery
(§
    ;;;
     ; Supports finding peers through DNS A records.  Community run DNS entry points will be used.
     ;
     ; @param netParams Network parameters to be used for port information.
     ;;
#_public
    DnsDiscovery(NetworkParameters netParams)
    (§
        this(netParams.getDnsSeeds(), netParams);
    )

    ;;;
     ; Supports finding peers through DNS A records.
     ;
     ; @param dnsSeeds Host names to be examined for seed addresses.
     ; @param params Network parameters to be used for port information.
     ;;
#_public
    DnsDiscovery(String[] dnsSeeds, NetworkParameters params)
    (§
        super(params, buildDiscoveries(params, dnsSeeds));
    )

#_private
#_static
    List<PeerDiscovery> buildDiscoveries(NetworkParameters params, String[] seeds)
    (§
        List<PeerDiscovery> discoveries = new ArrayList<>();
        if (seeds != nil)
            for (String seed : seeds)
                discoveries.add(new DnsSeedDiscovery(params, seed));
        return discoveries;
    )

#_override
#_protected
    ExecutorService createExecutor()
    (§
        ;; Attempted workaround for reported bugs on Linux in which gethostbyname does not appear to be properly
        ;; thread safe and can cause segfaults on some libc versions.
        if (System.getProperty("os.name").toLowerCase().contains("linux"))
            return Executors.newSingleThreadExecutor(new ContextPropagatingThreadFactory("DNS seed lookups"));
        else
            return Executors.newFixedThreadPool(seeds.size(), new DaemonThreadFactory("DNS seed lookups"));
    )

    ;;; Implements discovery from a single DNS host. ;;
#_public
#_static
    class DnsSeedDiscovery implements PeerDiscovery
    (§
#_private
#_final
        String hostname;
#_private
#_final
        NetworkParameters params;

#_public
        DnsSeedDiscovery(NetworkParameters params, String hostname)
        (§
            this.hostname = hostname;
            this.params = params;
        )

#_override
#_public
        InetSocketAddress[] getPeers(long services, long timeoutValue, TimeUnit timeoutUnit)
            throws PeerDiscoveryException
        (§
            if (services != 0)
                throw new PeerDiscoveryException("DNS seeds cannot filter by services: " + services);

            try
            (§
                InetAddress[] response = InetAddress.getAllByName(hostname);
                InetSocketAddress[] result = new InetSocketAddress[response.length];
                for (int i = 0; i < response.length; i++)
                    result[i] = new InetSocketAddress(response[i], params.getPort());
                return result;
            )
            catch (UnknownHostException e)
            (§
                throw new PeerDiscoveryException(e);
            )
        )

#_override
#_public
        void shutdown()
        (§
        )

#_override
#_public
        String toString()
        (§
            return hostname;
        )
    )
)

(ns org.bitcoinj.net.discovery #_"MultiplexingDiscovery"
    (:import [java.net InetSocketAddress]
             [java.util ArrayList Collections List]
             #_[java.util.concurrent *])
    (:import [com.google.common.base Preconditions]
             [com.google.common.collect Lists]
             [org.slf4j Logger LoggerFactory])
  #_(:require [org.bitcoinj.core NetworkParameters VersionMessage]
             [org.bitcoinj.net.discovery.DnsDiscovery DnsSeedDiscovery]
             #_[org.bitcoinj.utils *]))

;;;
 ; MultiplexingDiscovery queries multiple PeerDiscovery objects, shuffles their responses and then returns the results,
 ; thus selecting randomly between them and reducing the influence of any particular seed.  Any that don't respond
 ; within the timeout are ignored.  Backends are queried in parallel.  Backends may block.
 ;;
#_public
class MultiplexingDiscovery implements PeerDiscovery
(§
#_private
#_static
#_final
    Logger log = LoggerFactory.getLogger(MultiplexingDiscovery.class);

#_protected
#_final
    List<PeerDiscovery> seeds;
#_protected
#_final
    NetworkParameters netParams;
#_private
#_volatile
    ExecutorService vThreadPool;

    ;;;
     ; Builds a suitable set of peer discoveries.  Will query them in parallel before producing a merged response.
     ; If specific services are required, DNS is not used as the protocol can't handle it.
     ; @param params Network to use.
     ; @param services Required services as a bitmask, e.g. {@link VersionMessage#NODE_NETWORK}.
     ;;
#_public
#_static
    MultiplexingDiscovery forServices(NetworkParameters params, long services)
    (§
        List<PeerDiscovery> discoveries = Lists.newArrayList();
        ;; Also use DNS seeds if there is no specific service requirement.
        if (services == 0)
        (§
            String[] dnsSeeds = params.getDnsSeeds();
            if (dnsSeeds != nil)
                for (String dnsSeed : dnsSeeds)
                    discoveries.add(new DnsSeedDiscovery(params, dnsSeed));
        )
        return new MultiplexingDiscovery(params, discoveries);
    )

    ;;;
     ; Will query the given seeds in parallel before producing a merged response.
     ;;
#_public
    MultiplexingDiscovery(NetworkParameters params, List<PeerDiscovery> seeds)
    (§
        Preconditions.checkArgument(!seeds.isEmpty());

        this.netParams = params;
        this.seeds = seeds;
    )

#_override
#_public
    InetSocketAddress[] getPeers(final long services, final long timeoutValue, final TimeUnit timeoutUnit)
        throws PeerDiscoveryException
    (§
        vThreadPool = createExecutor();
        try
        (§
            List<Callable<InetSocketAddress[]>> tasks = Lists.newArrayList();
            for (final PeerDiscovery seed : seeds)
            (§
                tasks.add(new Callable<InetSocketAddress[]>()
                (§
#_override
#_public
                    InetSocketAddress[] call()
                        throws Exception
                    (§
                        return seed.getPeers(services, timeoutValue,  timeoutUnit);
                    )
                ));
            )
#_final
            List<Future<InetSocketAddress[]>> futures = vThreadPool.invokeAll(tasks, timeoutValue, timeoutUnit);
            ArrayList<InetSocketAddress> addrs = Lists.newArrayList();
            for (int i = 0; i < futures.size(); i++)
            (§
                Future<InetSocketAddress[]> future = futures.get(i);
                if (future.isCancelled())
                (§
                    log.warn("Seed {}: timed out", seeds.get(i));
                    continue; ;; Timed out.
                )
#_final
                InetSocketAddress[] inetAddresses;
                try
                (§
                    inetAddresses = future.get();
                )
                catch (ExecutionException e)
                (§
                    log.warn("Seed {}: failed to look up: {}", seeds.get(i), e.getMessage());
                    continue;
                )
                Collections.addAll(addrs, inetAddresses);
            )
            if (addrs.size() == 0)
                throw new PeerDiscoveryException("No peer discovery returned any results in " + timeoutUnit.toMillis(timeoutValue) + "ms. Check internet connection?");

            Collections.shuffle(addrs);
            vThreadPool.shutdownNow();
            return addrs.toArray(new InetSocketAddress[addrs.size()]);
        )
        catch (InterruptedException e)
        (§
            throw new PeerDiscoveryException(e);
        )
        finally
        (§
            vThreadPool.shutdown();
        )
    )

#_protected
    ExecutorService createExecutor()
    (§
        return Executors.newFixedThreadPool(seeds.size(), new ContextPropagatingThreadFactory("Multiplexing discovery"));
    )

#_override
#_public
    void shutdown()
    (§
        ExecutorService tp = vThreadPool;
        if (tp != nil)
            tp.shutdown();
    )
)

(ns org.bitcoinj.net.discovery #_"PeerDiscovery"
    (:import [java.net InetSocketAddress]
             [java.util.concurrent TimeUnit]))

;;;
 ; A PeerDiscovery object is responsible for finding addresses of other nodes in the Bitcoin P2P network.
 ; Note that the addresses returned may or may not be accepting connections.
 ;;
#_public
interface PeerDiscovery
(§
    ;; TODO: Flesh out this interface a lot more.

    ;;;
     ; Returns an array of addresses.  This method may block.
     ; @param services Required services as a bitmask, e.g. {@link VersionMessage#NODE_NETWORK}.
     ;;
    InetSocketAddress[] getPeers(long services, long timeoutValue, TimeUnit timeoutUnit)
        throws PeerDiscoveryException;

    ;;; Stops any discovery in progress when we want to shut down quickly. ;;
    void shutdown();
)

(ns org.bitcoinj.net.discovery #_"PeerDiscoveryException"
)

#_public
class PeerDiscoveryException extends Exception
(§
#_public
    PeerDiscoveryException()
    (§
        super();
    )

#_public
    PeerDiscoveryException(String message)
    (§
        super(message);
    )

#_public
    PeerDiscoveryException(Throwable arg0)
    (§
        super(arg0);
    )

#_public
    PeerDiscoveryException(String message, Throwable arg0)
    (§
        super(message, arg0);
    )
)

(ns org.bitcoinj.net.discovery #_"SeedPeers"
    (:import [java.net InetAddress InetSocketAddress UnknownHostException]
             [java.util.concurrent TimeUnit])
  #_(:require [org.bitcoinj.core NetworkParameters]))

;;;
 ; SeedPeers stores a pre-determined list of Bitcoin node addresses.  These nodes are selected based on
 ; being active on the network for a long period of time.  The intention is to be a last resort way of finding
 ; a connection to the network, in case IRC and DNS fail.  The list comes from the Bitcoin C++ source code.
 ;;
#_public
class SeedPeers implements PeerDiscovery
(§
#_private
    NetworkParameters params;
#_private
    int[] seedAddrs;
#_private
    int pnseedIndex;

    ;;;
     ; Supports finding peers by IP addresses.
     ;
     ; @param params Network parameters to be used for port information.
     ;;
#_public
    SeedPeers(NetworkParameters params)
    (§
        this(params.getAddrSeeds(), params);
    )

    ;;;
     ; Supports finding peers by IP addresses.
     ;
     ; @param seedAddrs IP addresses for seed addresses.
     ; @param params Network parameters to be used for port information.
     ;;
#_public
    SeedPeers(int[] seedAddrs, NetworkParameters params)
    (§
        this.seedAddrs = seedAddrs;
        this.params = params;
    )

    ;;;
     ; Acts as an iterator, returning the address of each node in the list sequentially.
     ; Once all the list has been iterated, null will be returned for each subsequent query.
     ;
     ; @return InetSocketAddress - the address/port of the next node.
     ; @throws PeerDiscoveryException
     ;;
#_nilable
#_public
    InetSocketAddress getPeer()
        throws PeerDiscoveryException
    (§
        try
        (§
            return nextPeer();
        )
        catch (UnknownHostException e)
        (§
            throw new PeerDiscoveryException(e);
        )
    )

#_nilable
#_private
    InetSocketAddress nextPeer()
        throws UnknownHostException, PeerDiscoveryException
    (§
        if (seedAddrs == nil || seedAddrs.length == 0)
            throw new PeerDiscoveryException("No IP address seeds configured; unable to find any peers");

        if (seedAddrs.length <= pnseedIndex)
            return nil;

        return new InetSocketAddress(convertAddress(seedAddrs[pnseedIndex++]), params.getPort());
    )

    ;;;
     ; Returns an array containing all the Bitcoin nodes within the list.
     ;;
#_override
#_public
    InetSocketAddress[] getPeers(long services, long timeoutValue, TimeUnit timeoutUnit)
        throws PeerDiscoveryException
    (§
        if (services != 0)
            throw new PeerDiscoveryException("Pre-determined peers cannot be filtered by services: " + services);

        try
        (§
            return allPeers();
        )
        catch (UnknownHostException e)
        (§
            throw new PeerDiscoveryException(e);
        )
    )

#_private
    InetSocketAddress[] allPeers()
        throws UnknownHostException
    (§
        InetSocketAddress[] addresses = new InetSocketAddress[seedAddrs.length];
        for (int i = 0; i < seedAddrs.length; ++i)
            addresses[i] = new InetSocketAddress(convertAddress(seedAddrs[i]), params.getPort());
        return addresses;
    )

#_private
    InetAddress convertAddress(int seed)
        throws UnknownHostException
    (§
        byte[] v4addr = new byte[4];
        v4addr[0] = (byte)(0xff & seed);
        v4addr[1] = (byte)(0xff & (seed >> 8));
        v4addr[2] = (byte)(0xff & (seed >> 16));
        v4addr[3] = (byte)(0xff & (seed >> 24));
        return InetAddress.getByAddress(v4addr);
    )

#_override
#_public
    void shutdown()
    (§
    )
)

(ns org.bitcoinj.params #_"AbstractBitcoinNetParams"
    (:import [java.math BigInteger]
             [java.util.concurrent TimeUnit])
    (:import [com.google.common.base Preconditions Stopwatch]
             [org.slf4j Logger LoggerFactory])
  #_(:require [org.bitcoinj.core BitcoinSerializer Block Coin NetworkParameters Sha256Hash StoredBlock Transaction Utils VerificationException]
             [org.bitcoinj.utils MonetaryFormat]
             [org.bitcoinj.store BlockStore BlockStoreException]))

;;;
 ; Parameters for Bitcoin-like networks.
 ;;
#_public
#_abstract
class AbstractBitcoinNetParams extends NetworkParameters
(§
    ;;;
     ; Scheme part for Bitcoin URIs.
     ;;
#_public
#_static
#_final
    String BITCOIN_SCHEME = "bitcoin";
#_public
#_static
#_final
    int REWARD_HALVING_INTERVAL = 210000;

#_private
#_static
#_final
    Logger log = LoggerFactory.getLogger(AbstractBitcoinNetParams.class);

#_public
    AbstractBitcoinNetParams()
    (§
        super();
    )

    ;;;
     ; Checks if we are at a reward halving point.
     ; @param height The height of the previous stored block.
     ; @return if this is a reward halving point.
     ;;
#_public
#_final
    boolean isRewardHalvingPoint(final int height)
    (§
        return (((height + 1) % REWARD_HALVING_INTERVAL) == 0);
    )

    ;;;
     ; Checks if we are at a difficulty transition point.
     ; @param height The height of the previous stored block.
     ; @return if this is a difficulty transition point.
     ;;
#_public
#_final
    boolean isDifficultyTransitionPoint(final int height)
    (§
        return (((height + 1) % this.getInterval()) == 0);
    )

#_override
#_public
    void checkDifficultyTransitions(final StoredBlock storedPrev, final Block nextBlock, final BlockStore blockStore)
        throws VerificationException, BlockStoreException
    (§
#_final
        Block prev = storedPrev.getHeader();

        ;; Is this supposed to be a difficulty transition point?
        if (!isDifficultyTransitionPoint(storedPrev.getHeight()))
        (§
            ;; No ... so check the difficulty didn't actually change.
            if (nextBlock.getDifficultyTarget() != prev.getDifficultyTarget())
                throw new VerificationException("Unexpected change in difficulty at height " + storedPrev.getHeight() + ": "
                        + Long.toHexString(nextBlock.getDifficultyTarget()) + " vs " + Long.toHexString(prev.getDifficultyTarget()));
            return;
        )

        ;; We need to find a block far back in the chain.  It's OK that this is expensive because it only occurs every
        ;; two weeks after the initial block chain download.
#_final
        Stopwatch watch = Stopwatch.createStarted();

        Sha256Hash hash = prev.getHash();
        StoredBlock cursor = nil;
#_final
        int interval = this.getInterval();
        for (int i = 0; i < interval; i++)
        (§
            cursor = blockStore.get(hash);
            if (cursor == nil)
            (§
                ;; This should never happen.  If it does, it means we are following an incorrect or busted chain.
                throw new VerificationException("Difficulty transition point but we did not find a way back to the last transition point. Not found: " + hash);
            )
            hash = cursor.getHeader().getPrevBlockHash();
        )
        Preconditions.checkState(cursor != nil && isDifficultyTransitionPoint(cursor.getHeight() - 1), "Didn't arrive at a transition point.");

        watch.stop();
        if (50 < watch.elapsed(TimeUnit.MILLISECONDS))
            log.info("Difficulty transition traversal took {}", watch);

        Block blockIntervalAgo = cursor.getHeader();
        int timespan = (int)(prev.getTimeSeconds() - blockIntervalAgo.getTimeSeconds());
        ;; Limit the adjustment step.
#_final
        int targetTimespan = this.getTargetTimespan();
        if (timespan < targetTimespan / 4)
            timespan = targetTimespan / 4;
        if (timespan > targetTimespan * 4)
            timespan = targetTimespan * 4;

        BigInteger newTarget = Utils.decodeCompactBits(prev.getDifficultyTarget());
        newTarget = newTarget.multiply(BigInteger.valueOf(timespan));
        newTarget = newTarget.divide(BigInteger.valueOf(targetTimespan));

        if (0 < newTarget.compareTo(this.getMaxTarget()))
        (§
            log.info("Difficulty hit proof of work limit: {}", newTarget.toString(16));
            newTarget = this.getMaxTarget();
        )

        int accuracyBytes = (int)(nextBlock.getDifficultyTarget() >>> 24) - 3;
        long receivedTargetCompact = nextBlock.getDifficultyTarget();

        ;; The calculated difficulty is to a higher precision than received, so reduce here.
        BigInteger mask = BigInteger.valueOf(0xffffffL).shiftLeft(accuracyBytes * 8);
        newTarget = newTarget.and(mask);
        long newTargetCompact = Utils.encodeCompactBits(newTarget);

        if (newTargetCompact != receivedTargetCompact)
            throw new VerificationException("Network provided difficulty bits do not match what was calculated: "
                    + Long.toHexString(newTargetCompact) + " vs " + Long.toHexString(receivedTargetCompact));
    )

#_override
#_public
    Coin getMaxMoney()
    (§
        return MAX_MONEY;
    )

#_override
#_public
    Coin getMinNonDustOutput()
    (§
        return Transaction.MIN_NONDUST_OUTPUT;
    )

#_override
#_public
    MonetaryFormat getMonetaryFormat()
    (§
        return new MonetaryFormat();
    )

#_override
#_public
    int getProtocolVersionNum(final ProtocolVersion version)
    (§
        return version.getBitcoinProtocolVersion();
    )

#_override
#_public
    BitcoinSerializer getSerializer(boolean parseRetain)
    (§
        return new BitcoinSerializer(this, parseRetain);
    )

#_override
#_public
    String getUriScheme()
    (§
        return BITCOIN_SCHEME;
    )

#_override
#_public
    boolean hasMaxMoney()
    (§
        return true;
    )
)

(ns org.bitcoinj.params #_"MainNetParams"
    (:import #_[java.net *])
    (:import [com.google.common.base Preconditions])
  #_(:require #_[org.bitcoinj.core *]
             #_[org.bitcoinj.net.discovery *]))

;;;
 ; Parameters for the main production network on which people trade goods and services.
 ;;
#_public
class MainNetParams extends AbstractBitcoinNetParams
(§
#_public
#_static
#_final
    int MAINNET_MAJORITY_WINDOW = 1000;
#_public
#_static
#_final
    int MAINNET_MAJORITY_REJECT_BLOCK_OUTDATED = 950;
#_public
#_static
#_final
    int MAINNET_MAJORITY_ENFORCE_BLOCK_UPGRADE = 750;

#_public
    MainNetParams()
    (§
        super();

        interval = INTERVAL;
        targetTimespan = TARGET_TIMESPAN;
        maxTarget = Utils.decodeCompactBits(0x1d00ffffL);
        addressHeader = 0;
        p2shHeader = 5;
        acceptableAddressCodes = new int[] { addressHeader, p2shHeader };
        port = 8333;
        packetMagic = 0xf9beb4d9L;
        bip32HeaderPub = 0x0488b21e; ;; 4 byte header that serializes in base58 to "xpub"
        bip32HeaderPriv = 0x0488ade4; ;; 4 byte header that serializes in base58 to "xprv"

        majorityEnforceBlockUpgrade = MAINNET_MAJORITY_ENFORCE_BLOCK_UPGRADE;
        majorityRejectBlockOutdated = MAINNET_MAJORITY_REJECT_BLOCK_OUTDATED;
        majorityWindow = MAINNET_MAJORITY_WINDOW;

        genesisBlock.setDifficultyTarget(0x1d00ffffL);
        genesisBlock.setTime(1231006505L);
        genesisBlock.setNonce(2083236893);
        id = ID_MAINNET;
        subsidyDecreaseBlockCount = 210000;
        spendableCoinbaseDepth = 100;
        String genesisHash = genesisBlock.getHashAsString();
        Preconditions.checkState(genesisHash.equals("000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f"), genesisHash);

        ;; This contains (at a minimum) the blocks which are not BIP30 compliant.  BIP30 changed how duplicate
        ;; transactions are handled.  Duplicated transactions could occur in the case where a coinbase had the same
        ;; extraNonce and the same outputs but appeared at different heights, and greatly complicated re-org handling.
        ;; Having these here simplifies block connection logic considerably.
        checkpoints.put(91722, Sha256Hash.wrap("00000000000271a2dc26e7667f8419f2e15416dc6955e5a6c6cdf3f2574dd08e"));
        checkpoints.put(91812, Sha256Hash.wrap("00000000000af0aed4792b1acee3d966af36cf5def14935db8de83d6f9306f2f"));
        checkpoints.put(91842, Sha256Hash.wrap("00000000000a4d0a398161ffc163c503763b1f4360639393e0e4c8e300e0caec"));
        checkpoints.put(91880, Sha256Hash.wrap("00000000000743f190a18c5577a3c2d2a1f610ae9601ac046a38084ccb7cd721"));
        checkpoints.put(200000, Sha256Hash.wrap("000000000000034a7dedef4a161fa058a2d67a173a90155f3a2fe6fc132e0ebf"));

        dnsSeeds = new String[]
        (§
            "seed.bitcoin.sipa.be",          ;; Pieter Wuille
            "dnsseed.bluematt.me",           ;; Matt Corallo
            "dnsseed.bitcoin.dashjr.org",    ;; Luke Dashjr
            "seed.bitcoinstats.com",         ;; Chris Decker
            "seed.bitnodes.io",              ;; Addy Yeow
            "bitseed.xf2.org",               ;; Jeff Garzik
            "seed.bitcoin.jonasschnelli.ch", ;; Jonas Schnelli
        );

        addrSeeds = new int[]
        (§
                0x1ddb1032, 0x6242ce40, 0x52d6a445, 0x2dd7a445, 0x8a53cd47, 0x73263750, 0xda23c257, 0xecd4ed57,
                0x0a40ec59, 0x75dce160, 0x7df76791, 0x89370bad, 0xa4f214ad, 0x767700ae, 0x638b0418, 0x868a1018,
                0xcd9f332e, 0x0129653e, 0xcc92dc3e, 0x96671640, 0x56487e40, 0x5b66f440, 0xb1d01f41, 0xf1dc6041,
                0xc1d12b42, 0x86ba1243, 0x6be4df43, 0x6d4cef43, 0xd18e0644, 0x1ab0b344, 0x6584a345, 0xe7c1a445,
                0x58cea445, 0xc5daa445, 0x21dda445, 0x3d3b5346, 0x13e55347, 0x1080d24a, 0x8e611e4b, 0x81518e4b,
                0x6c839e4b, 0xe2ad0a4c, 0xfbbc0a4c, 0x7f5b6e4c, 0x7244224e, 0x1300554e, 0x20690652, 0x5a48b652,
                0x75c5c752, 0x4335cc54, 0x340fd154, 0x87c07455, 0x087b2b56, 0x8a133a57, 0xac23c257, 0x70374959,
                0xfb63d45b, 0xb9a1685c, 0x180d765c, 0x674f645d, 0x04d3495e, 0x1de44b5e, 0x4ee8a362, 0x0ded1b63,
                0xc1b04b6d, 0x8d921581, 0x97b7ea82, 0x1cf83a8e, 0x91490bad, 0x09dc75ae, 0x9a6d79ae, 0xa26d79ae,
                0x0fd08fae, 0x0f3e3fb2, 0x4f944fb2, 0xcca448b8, 0x3ecd6ab8, 0xa9d5a5bc, 0x8d0119c1, 0x045997d5,
                0xca019dd9, 0x0d526c4d, 0xabf1ba44, 0x66b1ab55, 0x1165f462, 0x3ed7cbad, 0xa38fae6e, 0x3bd2cbad,
                0xd36f0547, 0x20df7840, 0x7a337742, 0x549f8e4b, 0x9062365c, 0xd399f562, 0x2b5274a1, 0x8edfa153,
                0x3bffb347, 0x7074bf58, 0xb74fcbad, 0x5b5a795b, 0x02fa29ce, 0x5a6738d4, 0xe8a1d23e, 0xef98c445,
                0x4b0f494c, 0xa2bc1e56, 0x7694ad63, 0xa4a800c3, 0x05fda6cd, 0x9f22175e, 0x364a795b, 0x536285d5,
                0xac44c9d4, 0x0b06254d, 0x150c2fd4, 0x32a50dcc, 0xfd79ce48, 0xf15cfa53, 0x66c01e60, 0x6bc26661,
                0xc03b47ae, 0x4dda1b81, 0x3285a4c1, 0x883ca96d, 0x35d60a4c, 0xdae09744, 0x2e314d61, 0x84e247cf,
                0x6c814552, 0x3a1cc658, 0x98d8f382, 0xe584cb5b, 0x15e86057, 0x7b01504e, 0xd852dd48, 0x56382f56,
                0x0a5df454, 0xa0d18d18, 0x2e89b148, 0xa79c114c, 0xcbdcd054, 0x5523bc43, 0xa9832640, 0x8a066144,
                0x3894c3bc, 0xab76bf58, 0x6a018ac1, 0xfebf4f43, 0x2f26c658, 0x31102f4e, 0x85e929d5, 0x2a1c175e,
                0xfc6c2cd1, 0x27b04b6d, 0xdf024650, 0x161748b8, 0x28be6580, 0x57be6580, 0x1cee677a, 0xaa6bb742,
                0x9a53964b, 0x0a5a2d4d, 0x2434c658, 0x9a494f57, 0x1ebb0e48, 0xf610b85d, 0x077ecf44, 0x085128bc,
                0x5ba17a18, 0x27ca1b42, 0xf8a00b56, 0xfcd4c257, 0xcf2fc15e, 0xd897e052, 0x4cada04f, 0x2f35f6d5,
                0x382ce8c9, 0xe523984b, 0x3f946846, 0x60c8be43, 0x41da6257, 0xde0be142, 0xae8a544b, 0xeff0c254,
                0x1e0f795b, 0xaeb28890, 0xca16acd9, 0x1e47ddd8, 0x8c8c4829, 0xd27dc747, 0xd53b1663, 0x4096b163,
                0x9c8dd958, 0xcb12f860, 0x9e79305c, 0x40c1a445, 0x4a90c2bc, 0x2c3a464d, 0x2727f23c, 0x30b04b6d,
                0x59024cb8, 0xa091e6ad, 0x31b04b6d, 0xc29d46a6, 0x63934fb2, 0xd9224dbe, 0x9f5910d8, 0x7f530a6b,
                0x752e9c95, 0x65453548, 0xa484be46, 0xce5a1b59, 0x710e0718, 0x46a13d18, 0xdaaf5318, 0xc4a8ff53,
                0x87abaa52, 0xb764cf51, 0xb2025d4a, 0x6d351e41, 0xc035c33e, 0xa432c162, 0x61ef34ae, 0xd16fddbc,
                0x0870e8c1, 0x3070e8c1, 0x9c71e8c1, 0xa4992363, 0x85a1f663, 0x4184e559, 0x18d96ed8, 0x17b8dbd5,
                0x60e7cd18, 0xe5ee104c, 0xab17ac62, 0x1e786e1b, 0x5d23b762, 0xf2388fae, 0x88270360, 0x9e5b3d80,
                0x7da518b2, 0xb5613b45, 0x1ad41f3e, 0xd550854a, 0x8617e9a9, 0x925b229c, 0xf2e92542, 0x47af0544,
                0x73b5a843, 0xb9b7a0ad, 0x03a748d0, 0x0a6ff862, 0x6694df62, 0x3bfac948, 0x8e098f4f, 0x746916c3,
                0x02f38e4f, 0x40bb1243, 0x6a54d162, 0x6008414b, 0xa513794c, 0x514aa343, 0x63781747, 0xdbb6795b,
                0xed065058, 0x42d24b46, 0x1518794c, 0x9b271681, 0x73e4ffad, 0x0654784f, 0x438dc945, 0x641846a6,
                0x2d1b0944, 0x94b59148, 0x8d369558, 0xa5a97662, 0x8b705b42, 0xce9204ae, 0x8d584450, 0x2df61555,
                0xeebff943, 0x2e75fb4d, 0x3ef8fc57, 0x9921135e, 0x8e31042e, 0xb5afad43, 0x89ecedd1, 0x9cfcc047,
                0x8fcd0f4c, 0xbe49f5ad, 0x146a8d45, 0x98669ab8, 0x98d9175e, 0xd1a8e46d, 0x839a3ab8, 0x40a0016c,
                0x6d27c257, 0x977fffad, 0x7baa5d5d, 0x1213be43, 0xb167e5a9, 0x640fe8ca, 0xbc9ea655, 0x0f820a4c,
                0x0f097059, 0x69ac957c, 0x366d8453, 0xb1ba2844, 0x8857f081, 0x70b5be63, 0xc545454b, 0xaf36ded1,
                0xb5a4b052, 0x21f062d1, 0x72ab89b2, 0x74a45318, 0x8312e6bc, 0xb916965f, 0x8aa7c858, 0xfe7effad,
        );
    )

#_private
#_static
    MainNetParams instance;

#_public
#_static
#_synchronized
    MainNetParams get()
    (§
        if (instance == nil)
            instance = new MainNetParams();
        return instance;
    )

#_override
#_public
    String getPaymentProtocolId()
    (§
        return PAYMENT_PROTOCOL_ID_MAINNET;
    )
)

(ns org.bitcoinj.params #_"Networks"
    (:import [java.util Collection Set])
    (:import [com.google.common.collect ImmutableSet Lists])
  #_(:require [org.bitcoinj.core NetworkParameters]))

;;;
 ; Utility class that holds all the registered NetworkParameters types used for Address auto discovery.
 ; By default only MainNetParams and TestNet3Params are used.  If you want to use UnitTestParams, use
 ; the register and unregister the TestNet3Params as they don't have their own address version/type code.
 ;;
#_public
class Networks
(§
    ;;; Registered networks. ;;
#_private
#_static
    Set<? extends NetworkParameters> networks = ImmutableSet.of(TestNet3Params.get(), MainNetParams.get());

#_public
#_static
    Set<? extends NetworkParameters> get()
    (§
        return networks;
    )

#_public
#_static
    void register(NetworkParameters network)
    (§
        register(Lists.newArrayList(network));
    )

#_public
#_static
    void register(Collection<? extends NetworkParameters> networks)
    (§
        ImmutableSet.Builder<NetworkParameters> builder = ImmutableSet.builder();
        builder.addAll(Networks.networks);
        builder.addAll(networks);
        Networks.networks = builder.build();
    )

#_public
#_static
    void unregister(NetworkParameters network)
    (§
        if (networks.contains(network))
        (§
            ImmutableSet.Builder<NetworkParameters> builder = ImmutableSet.builder();

            for (NetworkParameters parameters : networks)
                if (!parameters.equals(network))
                    builder.add(parameters);

            networks = builder.build();
        )
    )
)

(ns org.bitcoinj.params #_"TestNet3Params"
    (:import [java.math BigInteger]
             [java.util Date])
    (:import [com.google.common.base Preconditions])
  #_(:require [org.bitcoinj.core Block NetworkParameters StoredBlock Utils VerificationException]
             [org.bitcoinj.store BlockStore BlockStoreException]))

;;;
 ; Parameters for the testnet, a separate public instance of Bitcoin that has relaxed rules suitable for development
 ; and testing of applications and new Bitcoin versions.
 ;;
#_public
class TestNet3Params extends AbstractBitcoinNetParams
(§
#_public
#_static
#_final
    int TESTNET_MAJORITY_WINDOW = 100;
#_public
#_static
#_final
    int TESTNET_MAJORITY_REJECT_BLOCK_OUTDATED = 75;
#_public
#_static
#_final
    int TESTNET_MAJORITY_ENFORCE_BLOCK_UPGRADE = 51;

#_public
    TestNet3Params()
    (§
        super();

        id = ID_TESTNET;
        packetMagic = 0x0b110907;
        interval = INTERVAL;
        targetTimespan = TARGET_TIMESPAN;
        maxTarget = Utils.decodeCompactBits(0x1d00ffffL);
        port = 18333;
        addressHeader = 111;
        p2shHeader = 196;
        acceptableAddressCodes = new int[] { addressHeader, p2shHeader };
        genesisBlock.setTime(1296688602L);
        genesisBlock.setDifficultyTarget(0x1d00ffffL);
        genesisBlock.setNonce(414098458);
        spendableCoinbaseDepth = 100;
        subsidyDecreaseBlockCount = 210000;
        String genesisHash = genesisBlock.getHashAsString();
        Preconditions.checkState(genesisHash.equals("000000000933ea01ad0ee984209779baaec3ced90fa3f408719526f8d77f4943"));
        alertSigningKey = Utils.HEX.decode("04302390343f91cc401d56d68b123028bf52e5fca1939df127f63c6467cdf9c8e2c14b61104cf817d0b780da337893ecc4aaff1309e536162dabbdb45200ca2b0a");

        dnsSeeds = new String[]
        (§
            "testnet-seed.bitcoin.jonasschnelli.ch", ;; Jonas Schnelli
            "testnet-seed.bluematt.me",              ;; Matt Corallo
            "testnet-seed.bitcoin.petertodd.org",    ;; Peter Todd
            "testnet-seed.bitcoin.schildbach.de",    ;; Andreas Schildbach
        );
        addrSeeds = nil;
        bip32HeaderPub = 0x043587cf;
        bip32HeaderPriv = 0x04358394;

        majorityEnforceBlockUpgrade = TESTNET_MAJORITY_ENFORCE_BLOCK_UPGRADE;
        majorityRejectBlockOutdated = TESTNET_MAJORITY_REJECT_BLOCK_OUTDATED;
        majorityWindow = TESTNET_MAJORITY_WINDOW;
    )

#_private
#_static
    TestNet3Params instance;

#_public
#_static
#_synchronized
    TestNet3Params get()
    (§
        if (instance == nil)
            instance = new TestNet3Params();
        return instance;
    )

#_override
#_public
    String getPaymentProtocolId()
    (§
        return PAYMENT_PROTOCOL_ID_TESTNET;
    )

    ;; February 16th 2012
#_private
#_static
#_final
    Date testnetDiffDate = new Date(1329264000000L);

#_override
#_public
    void checkDifficultyTransitions(final StoredBlock storedPrev, final Block nextBlock, final BlockStore blockStore)
        throws VerificationException, BlockStoreException
    (§
        if (!isDifficultyTransitionPoint(storedPrev.getHeight()) && nextBlock.getTime().after(testnetDiffDate))
        (§
            Block prev = storedPrev.getHeader();

            ;; After 15th February 2012 the rules on the testnet change to avoid people running up the difficulty
            ;; and then leaving, making it too hard to mine a block.  On non-difficulty transition points, easy
            ;; blocks are allowed if there has been a span of 20 minutes without one.
#_final
            long timeDelta = nextBlock.getTimeSeconds() - prev.getTimeSeconds();
            ;; There is an integer underflow bug in bitcoin-qt that means mindiff blocks are accepted when time
            ;; goes backwards.
            if (0 <= timeDelta && timeDelta <= NetworkParameters.TARGET_SPACING * 2)
            (§
                ;; Walk backwards until we find a block that doesn't have the easiest proof of work, then check
                ;; that difficulty is equal to that one.
                StoredBlock cursor = storedPrev;
                while (!cursor.getHeader().equals(getGenesisBlock())
                        && cursor.getHeight() % getInterval() != 0
                        && cursor.getHeader().getDifficultyTargetAsInteger().equals(getMaxTarget()))
                    cursor = cursor.getPrev(blockStore);
                BigInteger cursorTarget = cursor.getHeader().getDifficultyTargetAsInteger();
                BigInteger newTarget = nextBlock.getDifficultyTargetAsInteger();
                if (!cursorTarget.equals(newTarget))
                    throw new VerificationException("Testnet block transition that is not allowed: "
                            + Long.toHexString(cursor.getHeader().getDifficultyTarget()) + " vs " + Long.toHexString(nextBlock.getDifficultyTarget()));
            )
        )
        else
        (§
            super.checkDifficultyTransitions(storedPrev, nextBlock, blockStore);
        )
    )
)

(ns org.bitcoinj.params #_"UnitTestParams"
    (:import [java.math BigInteger])
  #_(:require #_[org.bitcoinj.core *]))

;;;
 ; Network parameters used by the bitcoinj unit tests (and potentially your own).  This lets you solve a block using
 ; {@link org.bitcoinj.core.Block#solve()} by setting difficulty to the easiest possible.
 ;;
#_public
class UnitTestParams extends AbstractBitcoinNetParams
(§
#_public
#_static
#_final
    int UNITNET_MAJORITY_WINDOW = 8;
#_public
#_static
#_final
    int TESTNET_MAJORITY_REJECT_BLOCK_OUTDATED = 6;
#_public
#_static
#_final
    int TESTNET_MAJORITY_ENFORCE_BLOCK_UPGRADE = 4;

#_public
    UnitTestParams()
    (§
        super();

        id = ID_UNITTESTNET;
        packetMagic = 0x0b110907;
        addressHeader = 111;
        p2shHeader = 196;
        acceptableAddressCodes = new int[] { addressHeader, p2shHeader };
        maxTarget = new BigInteger("00ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff", 16);
        genesisBlock.setTime(System.currentTimeMillis() / 1000);
        genesisBlock.setDifficultyTarget(Block.EASIEST_DIFFICULTY_TARGET);
        genesisBlock.solve();
        port = 18333;
        interval = 10;
        targetTimespan = 200000000; ;; 6 years.  Just a very big number.
        spendableCoinbaseDepth = 5;
        subsidyDecreaseBlockCount = 100;
        dnsSeeds = nil;
        addrSeeds = nil;
        bip32HeaderPub = 0x043587cf;
        bip32HeaderPriv = 0x04358394;

        majorityEnforceBlockUpgrade = 3;
        majorityRejectBlockOutdated = 4;
        majorityWindow = 7;
    )

#_private
#_static
    UnitTestParams instance;

#_public
#_static
#_synchronized
    UnitTestParams get()
    (§
        if (instance == nil)
            instance = new UnitTestParams();
        return instance;
    )

#_override
#_public
    String getPaymentProtocolId()
    (§
        return "unittest";
    )
)

(ns org.bitcoinj.script #_"Script"
    (:import [java.io ByteArrayInputStream ByteArrayOutputStream IOException OutputStream]
             [java.math BigInteger]
             [java.security MessageDigest NoSuchAlgorithmException]
             #_[java.util *])
    (:import [com.google.common.base Preconditions]
             [com.google.common.collect Lists]
             [org.slf4j Logger LoggerFactory]
             [org.spongycastle.crypto.digests RIPEMD160Digest])
  #_(:require #_[org.bitcoinj.core *]
             [org.bitcoinj.crypto TransactionSignature]
             #_static #_[org.bitcoinj.script.ScriptOpCodes *]))

;; TODO: Redesign this entire API to be more type safe and organised.

;;;
 ; <p>Programs embedded inside transactions that control redemption of payments.</p>
 ;
 ; <p>Bitcoin transactions don't specify what they do directly.  Instead
 ; <a href="https://en.bitcoin.it/wiki/Script">a small binary stack language</a> is used to define programs that
 ; when evaluated, return whether the transaction "accepts" or rejects the other transactions connected to it.</p>
 ;
 ; <p>In SPV mode, scripts are not run, because that would require all transactions to be available and lightweight
 ; clients don't have that data.  In full mode, this class is used to run the interpreted language.  It also has
 ; static methods for building scripts.</p>
 ;;
#_public
class Script
(§
    ;;; Enumeration to encapsulate the type of this script. ;;
#_public
    enum ScriptType
    (§
        ;; Do NOT change the ordering of the following definitions because their ordinals are stored in databases.
        NO_TYPE,
        P2PKH,
        PUB_KEY,
        P2SH
    )

    ;;; Flags to pass to {@link Script#correctlySpends(Transaction, long, Script, Set)}.
     ; Note currently only P2SH, DERSIG and NULLDUMMY are actually supported.
     ;;
#_public
    enum VerifyFlag
    (§
        P2SH, ;; Enable BIP16-style subscript evaluation.
        STRICTENC, ;; Passing a non-strict-DER signature or one with undefined hashtype to a checksig operation causes script failure.
        DERSIG, ;; Passing a non-strict-DER signature to a checksig operation causes script failure (softfork safe, BIP66 rule 1).
        LOW_S, ;; Passing a non-strict-DER signature or one with S > order/2 to a checksig operation causes script failure.
        NULLDUMMY, ;; Verify dummy stack item consumed by CHECKMULTISIG is of zero-length.
        SIGPUSHONLY, ;; Using a non-push operator in the scriptSig causes script failure (softfork safe, BIP62 rule 2).
        MINIMALDATA, ;; Require minimal encodings for all push operations.
        DISCOURAGE_UPGRADABLE_NOPS, ;; Discourage use of NOPs reserved for upgrades (NOP1-10).
        CLEANSTACK, ;; Require that only a single stack element remains after evaluation.
        CHECKLOCKTIMEVERIFY, ;; Enable CHECKLOCKTIMEVERIFY operation.
        CHECKSEQUENCEVERIFY ;; Enable CHECKSEQUENCEVERIFY operation.
    )
#_public
#_static
#_final
    EnumSet<VerifyFlag> ALL_VERIFY_FLAGS = EnumSet.allOf(VerifyFlag.class);

#_private
#_static
#_final
    Logger log = LoggerFactory.getLogger(Script.class);

#_public
#_static
#_final
    long MAX_SCRIPT_ELEMENT_SIZE = 520; ;; bytes
#_private
#_static
#_final
    int MAX_OPS_PER_SCRIPT = 201;
#_private
#_static
#_final
    int MAX_STACK_SIZE = 1000;
#_private
#_static
#_final
    int MAX_PUBKEYS_PER_MULTISIG = 20;
#_private
#_static
#_final
    int MAX_SCRIPT_SIZE = 10000;
#_public
#_static
#_final
    int SIG_SIZE = 75;
    ;;; Max number of sigops allowed in a standard p2sh redeem script. ;;
#_public
#_static
#_final
    int MAX_P2SH_SIGOPS = 15;

    ;; The program is a set of chunks where each element is either [opcode] or [data, data, data ...].
#_protected
    List<ScriptChunk> chunks;
    ;; Unfortunately, scripts are not ever re-serialized or canonicalized when used in signature hashing.
    ;; Thus we must preserve the exact bytes that we read off the wire, along with the parsed form.
#_protected
    byte[] program;

    ;; Creation time of the associated keys in seconds since the epoch.
#_private
    long creationTimeSeconds;

    ;;; Creates an empty script that serializes to nothing. ;;
#_private
    Script()
    (§
        chunks = Lists.newArrayList();
    )

    ;; Used from ScriptBuilder.
    Script(List<ScriptChunk> chunks)
    (§
        this.chunks = Collections.unmodifiableList(new ArrayList<>(chunks));
        creationTimeSeconds = Utils.currentTimeSeconds();
    )

    ;;;
     ; Construct a Script that copies and wraps the programBytes array.
     ; The array is parsed and checked for syntactic validity.
     ; @param programBytes Array of program bytes from a transaction.
     ;;
#_public
    Script(byte[] programBytes)
        throws ScriptException
    (§
        program = programBytes;
        parse(programBytes);
        creationTimeSeconds = 0;
    )

#_public
    Script(byte[] programBytes, long creationTimeSeconds)
        throws ScriptException
    (§
        program = programBytes;
        parse(programBytes);
        this.creationTimeSeconds = creationTimeSeconds;
    )

#_public
    long getCreationTimeSeconds()
    (§
        return creationTimeSeconds;
    )

#_public
    void setCreationTimeSeconds(long creationTimeSeconds)
    (§
        this.creationTimeSeconds = creationTimeSeconds;
    )

    ;;;
     ; Returns the program opcodes as a string, for example "[1234] DUP HASH160".
     ;;
#_override
#_public
    String toString()
    (§
        return Utils.SPACE_JOINER.join(chunks);
    )

    ;;; Returns the serialized program as a newly created byte array. ;;
#_public
    byte[] getProgram()
    (§
        try
        (§
            ;; Don't round-trip as Bitcoin Core doesn't and it would introduce a mismatch.
            if (program != nil)
                return Arrays.copyOf(program, program.length);

            ByteArrayOutputStream bos = new ByteArrayOutputStream();
            for (ScriptChunk chunk : chunks)
                chunk.write(bos);
            program = bos.toByteArray();
            return program;
        )
        catch (IOException e)
        (§
            throw new RuntimeException(e); ;; Cannot happen.
        )
    )

    ;;; Returns an immutable list of the scripts parsed form.  Each chunk is either an opcode or data element. ;;
#_public
    List<ScriptChunk> getChunks()
    (§
        return Collections.unmodifiableList(chunks);
    )

#_private
#_static
#_final
    ScriptChunk[] STANDARD_TRANSACTION_SCRIPT_CHUNKS =
    (§
        new ScriptChunk(ScriptOpCodes.OP_DUP, nil, 0),
        new ScriptChunk(ScriptOpCodes.OP_HASH160, nil, 1),
        new ScriptChunk(ScriptOpCodes.OP_EQUALVERIFY, nil, 23),
        new ScriptChunk(ScriptOpCodes.OP_CHECKSIG, nil, 24),
    );

    ;;;
     ; <p>To run a script, first we parse it which breaks it up into chunks representing pushes of data
     ; or logical opcodes.  Then we can run the parsed chunks.</p>
     ;
     ; <p>The reason for this split, instead of just interpreting directly, is to make it easier
     ; to reach into a programs structure and pull out bits of data without having to run it.
     ; This is necessary to render the to/from addresses of transactions in a user interface.
     ; Bitcoin Core does something similar.</p>
     ;;
#_private
    void parse(byte[] program)
        throws ScriptException
    (§
        chunks = new ArrayList<>(5); ;; Common size.
        ByteArrayInputStream bis = new ByteArrayInputStream(program);
        int initialSize = bis.available();
        while (0 < bis.available())
        (§
            int startLocationInProgram = initialSize - bis.available();
            int opcode = bis.read();

            long dataToRead = -1;
            if (0 <= opcode && opcode < OP_PUSHDATA1)
            (§
                ;; Read some bytes of data, where how many is the opcode value itself.
                dataToRead = opcode;
            )
            else if (opcode == OP_PUSHDATA1)
            (§
                if (bis.available() < 1)
                    throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "Unexpected end of script");
                dataToRead = bis.read();
            )
            else if (opcode == OP_PUSHDATA2)
            (§
                ;; Read a short, then read that many bytes of data.
                if (bis.available() < 2)
                    throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "Unexpected end of script");
                dataToRead = bis.read() | (bis.read() << 8);
            )
            else if (opcode == OP_PUSHDATA4)
            (§
                ;; Read a uint32, then read that many bytes of data.
                ;; Though this is allowed, because its value cannot be > 520, it should never actually be used.
                if (bis.available() < 4)
                    throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "Unexpected end of script");
                dataToRead = ((long)bis.read()) | (((long)bis.read()) << 8) | (((long)bis.read()) << 16) | (((long)bis.read()) << 24);
            )

            ScriptChunk chunk;
            if (dataToRead == -1)
            (§
                chunk = new ScriptChunk(opcode, nil, startLocationInProgram);
            )
            else
            (§
                if (bis.available() < dataToRead)
                    throw new ScriptException(ScriptError.SCRIPT_ERR_BAD_OPCODE, "Push of data element that is larger than remaining data");

                byte[] data = new byte[(int)dataToRead];
                Preconditions.checkState(dataToRead == 0 || bis.read(data, 0, (int)dataToRead) == dataToRead);
                chunk = new ScriptChunk(opcode, data, startLocationInProgram);
            )
            ;; Save some memory by eliminating redundant copies of the same chunk objects.
            for (ScriptChunk c : STANDARD_TRANSACTION_SCRIPT_CHUNKS)
                if (c.equals(chunk))
                    chunk = c;
            chunks.add(chunk);
        )
    )

    ;;;
     ; Returns true if this script is of the form <pubkey> OP_CHECKSIG.  This form was originally intended for
     ; transactions where the peers talked to each other directly via TCP/IP, but has fallen out of favor with time
     ; due to that mode of operation being susceptible to man-in-the-middle attacks.  It is still used in coinbase
     ; outputs and can be useful more exotic types of transaction, but today most payments are to addresses.
     ;;
#_public
    boolean isSentToRawPubKey()
    (§
        return (chunks.size() == 2 && chunks.get(1).equalsOpCode(OP_CHECKSIG) && !chunks.get(0).isOpCode() && 1 < chunks.get(0).data.length);
    )

    ;;;
     ; Returns true if this script is of the form DUP HASH160 <pubkey hash> EQUALVERIFY CHECKSIG, i.e. payment to an
     ; address like 1VayNert3x1KzbpzMGt2qdqrAThiRovi8.  This form was originally intended for the case where you wish
     ; to send somebody money with a written code because their node is offline, but over time has become the standard
     ; way to make payments due to the short and recognizable base58 form addresses come in.
     ;;
#_public
    boolean isSentToAddress()
    (§
        return chunks.size() == 5 &&
               chunks.get(0).equalsOpCode(OP_DUP) &&
               chunks.get(1).equalsOpCode(OP_HASH160) &&
               chunks.get(2).data.length == Address.LENGTH &&
               chunks.get(3).equalsOpCode(OP_EQUALVERIFY) &&
               chunks.get(4).equalsOpCode(OP_CHECKSIG);
    )

    ;;;
     ; <p>If a program matches the standard template DUP HASH160 &lt;pubkey hash&gt; EQUALVERIFY CHECKSIG,
     ; then this function retrieves the third element.
     ; In this case, this is useful for fetching the destination address of a transaction.</p>
     ;
     ; <p>If a program matches the standard template HASH160 &lt;script hash&gt; EQUAL,
     ; then this function retrieves the second element.
     ; In this case, this is useful for fetching the hash of the redeem script of a transaction.</p>
     ;
     ; <p>Otherwise it throws a ScriptException.</p>
     ;
     ;;
#_public
    byte[] getPubKeyHash()
        throws ScriptException
    (§
        if (isSentToAddress())
            return chunks.get(2).data;
        if (isPayToScriptHash())
            return chunks.get(1).data;

        throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "Script not in the standard scriptPubKey form");
    )

    ;;;
     ; Returns the public key in this script.  If a script contains two constants and nothing else, it is assumed
     ; to be a scriptSig (input) for a pay-to-address output and the second constant is returned (the first is the
     ; signature).  If a script contains a constant and an OP_CHECKSIG opcode, the constant is returned as it is
     ; assumed to be a direct pay-to-key scriptPubKey (output) and the first constant is the public key.
     ;
     ; @throws ScriptException if the script is none of the named forms.
     ;;
#_public
    byte[] getPubKey()
        throws ScriptException
    (§
        if (chunks.size() != 2)
            throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "Script not of right size, expecting 2 but got " + chunks.size());

#_final
        ScriptChunk chunk0 = chunks.get(0);
#_final
        byte[] chunk0data = chunk0.data;
#_final
        ScriptChunk chunk1 = chunks.get(1);
#_final
        byte[] chunk1data = chunk1.data;

        ;; If we have two large constants assume the input to a pay-to-address output.
        if (chunk0data != nil && 2 < chunk0data.length && chunk1data != nil && 2 < chunk1data.length)
            return chunk1data;

        ;; A large constant followed by an OP_CHECKSIG is the key.
        if (chunk1.equalsOpCode(OP_CHECKSIG) && chunk0data != nil && 2 < chunk0data.length)
            return chunk0data;

        throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "Script did not match expected form: " + this);
    )

    ;;;
     ; Retrieves the sender public key from a LOCKTIMEVERIFY transaction.
     ;
     ; @throws ScriptException
     ;;
#_public
    byte[] getCLTVPaymentChannelSenderPubKey()
        throws ScriptException
    (§
        if (isSentToCLTVPaymentChannel())
            return chunks.get(8).data;

        throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "Script not a standard CHECKLOCKTIMVERIFY transaction: " + this);
    )

    ;;;
     ; Retrieves the recipient public key from a LOCKTIMEVERIFY transaction.
     ;
     ; @throws ScriptException
     ;;
#_public
    byte[] getCLTVPaymentChannelRecipientPubKey()
        throws ScriptException
    (§
        if (isSentToCLTVPaymentChannel())
            return chunks.get(1).data;

        throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "Script not a standard CHECKLOCKTIMVERIFY transaction: " + this);
    )

#_public
    BigInteger getCLTVPaymentChannelExpiry()
    (§
        if (isSentToCLTVPaymentChannel())
            return castToBigInteger(chunks.get(4).data, 5, false);

        throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "Script not a standard CHECKLOCKTIMEVERIFY transaction: " + this);
    )

    ;;;
     ; For 2-element [input] scripts assumes that the paid-to-address can be derived from the public key.
     ; The concept of a "from address" isn't well defined in Bitcoin and you should not assume the sender
     ; of a transaction can actually receive coins on it. This method may be removed in future.
     ;;
#_deprecated
#_public
    Address getFromAddress(NetworkParameters params)
        throws ScriptException
    (§
        return new Address(params, Utils.sha256hash160(getPubKey()));
    )

    ;;;
     ; Gets the destination address from this script, if it's in the required form (see getPubKey).
     ;;
#_public
    Address getToAddress(NetworkParameters params)
        throws ScriptException
    (§
        return getToAddress(params, false);
    )

    ;;;
     ; Gets the destination address from this script, if it's in the required form (see getPubKey).
     ;
     ; @param forcePayToPubKey If true, allow payToPubKey to be casted to the corresponding address.
     ;                         This is useful if you prefer showing addresses rather than pubkeys.
     ;;
#_public
    Address getToAddress(NetworkParameters params, boolean forcePayToPubKey)
        throws ScriptException
    (§
        if (isSentToAddress())
            return new Address(params, getPubKeyHash());
        if (isPayToScriptHash())
            return Address.fromP2SHScript(params, this);
        if (forcePayToPubKey && isSentToRawPubKey())
            return ECKey.fromPublicOnly(getPubKey()).toAddress(params);

        throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "Cannot cast this script to a pay-to-address type");
    )

    ;;;
     ; Writes out the given byte buffer to the output stream with the correct opcode prefix.
     ; To write an integer call writeBytes(out, Utils.reverseBytes(Utils.encodeMPI(val, false))).
     ;;
#_public
#_static
    void writeBytes(OutputStream os, byte[] buf)
        throws IOException
    (§
        if (buf.length < OP_PUSHDATA1)
        (§
            os.write(buf.length);
            os.write(buf);
        )
        else if (buf.length < 256)
        (§
            os.write(OP_PUSHDATA1);
            os.write(buf.length);
            os.write(buf);
        )
        else if (buf.length < 65536)
        (§
            os.write(OP_PUSHDATA2);
            os.write(0xff & buf.length);
            os.write(0xff & (buf.length >> 8));
            os.write(buf);
        )
        else
        (§
            throw new RuntimeException("Unimplemented");
        )
    )

    ;;; Creates a program that requires at least N of the given keys to sign, using OP_CHECKMULTISIG. ;;
#_public
#_static
    byte[] createMultiSigOutputScript(int threshold, List<ECKey> pubkeys)
    (§
        Preconditions.checkArgument(0 < threshold);
        Preconditions.checkArgument(threshold <= pubkeys.size());
        Preconditions.checkArgument(pubkeys.size() <= 16); ;; That's the max we can represent with a single opcode.

        if (3 < pubkeys.size())
            log.warn("Creating a multi-signature output that is non-standard: {} pubkeys, should be <= 3", pubkeys.size());

        try
        (§
            ByteArrayOutputStream bits = new ByteArrayOutputStream();
            bits.write(encodeToOpN(threshold));
            for (ECKey key : pubkeys)
                writeBytes(bits, key.getPubKey());
            bits.write(encodeToOpN(pubkeys.size()));
            bits.write(OP_CHECKMULTISIG);
            return bits.toByteArray();
        )
        catch (IOException e)
        (§
            throw new RuntimeException(e); ;; Cannot happen.
        )
    )

#_public
#_static
    byte[] createInputScript(byte[] signature, byte[] pubkey)
    (§
        try
        (§
            ;; TODO: Do this by creating a Script *first* then having the script reassemble itself into bytes.
            ByteArrayOutputStream bits = new UnsafeByteArrayOutputStream(signature.length + pubkey.length + 2);
            writeBytes(bits, signature);
            writeBytes(bits, pubkey);
            return bits.toByteArray();
        )
        catch (IOException e)
        (§
            throw new RuntimeException(e);
        )
    )

#_public
#_static
    byte[] createInputScript(byte[] signature)
    (§
        try
        (§
            ;; TODO: Do this by creating a Script *first* then having the script reassemble itself into bytes.
            ByteArrayOutputStream bits = new UnsafeByteArrayOutputStream(signature.length + 2);
            writeBytes(bits, signature);
            return bits.toByteArray();
        )
        catch (IOException e)
        (§
            throw new RuntimeException(e);
        )
    )

    ;;;
     ; Creates an incomplete scriptSig that, once filled with signatures, can redeem output containing this scriptPubKey.
     ; Instead of the signatures resulting script has OP_0.
     ; Having incomplete input script allows to pass around partially signed tx.
     ; It is expected that this program later on will be updated with proper signatures.
     ;;
#_public
    Script createEmptyInputScript(#_nilable ECKey key, #_nilable Script redeemScript)
    (§
        if (isSentToAddress())
        (§
            Preconditions.checkArgument(key != nil, "Key required to create pay-to-address input script");
            return ScriptBuilder.createInputScript(nil, key);
        )

        if (isSentToRawPubKey())
            return ScriptBuilder.createInputScript(nil);

        if (isPayToScriptHash())
        (§
            Preconditions.checkArgument(redeemScript != nil, "Redeem script required to create P2SH input script");
            return ScriptBuilder.createP2SHMultiSigInputScript(nil, redeemScript);
        )

        throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "Do not understand script type: " + this);
    )

    ;;;
     ; Returns a copy of the given scriptSig with the signature inserted in the given position.
     ;;
#_public
    Script getScriptSigWithSignature(Script scriptSig, byte[] sigBytes, int index)
    (§
        int sigsPrefixCount = 0;
        int sigsSuffixCount = 0;
        if (isPayToScriptHash())
        (§
            sigsPrefixCount = 1; ;; OP_0 <sig>* <redeemScript>
            sigsSuffixCount = 1;
        )
        else if (isSentToMultiSig())
        (§
            sigsPrefixCount = 1; ;; OP_0 <sig>*
        )
        else if (isSentToAddress())
        (§
            sigsSuffixCount = 1; ;; <sig> <pubkey>
        )
        return ScriptBuilder.updateScriptWithSignature(scriptSig, sigBytes, index, sigsPrefixCount, sigsSuffixCount);
    )

    ;;;
     ; Returns the index where a signature by the key should be inserted.
     ; Only applicable to a P2SH scriptSig.
     ;;
#_public
    int getSigInsertionIndex(Sha256Hash hash, ECKey signingKey)
    (§
        ;; Iterate over existing signatures, skipping the initial OP_0, the final redeem script
        ;; and any placeholder OP_0 sigs.
        List<ScriptChunk> existingChunks = chunks.subList(1, chunks.size() - 1);
        ScriptChunk redeemScriptChunk = chunks.get(chunks.size() - 1);
        Preconditions.checkNotNull(redeemScriptChunk.data);
        Script redeemScript = new Script(redeemScriptChunk.data);

        int sigCount = 0;
        int myIndex = redeemScript.findKeyInRedeem(signingKey);
        for (ScriptChunk chunk : existingChunks)
        (§
            if (chunk.opcode == OP_0)
            (§
                ;; OP_0, skip
            )
            else
            (§
                Preconditions.checkNotNull(chunk.data);
                if (myIndex < redeemScript.findSigInRedeem(chunk.data, hash))
                    return sigCount;
                sigCount++;
            )
        )
        return sigCount;
    )

#_private
    int findKeyInRedeem(ECKey key)
    (§
        Preconditions.checkArgument(chunks.get(0).isOpCode()); ;; P2SH scriptSig

        int numKeys = Script.decodeFromOpN(chunks.get(chunks.size() - 2).opcode);
        for (int i = 0; i < numKeys; i++)
            if (Arrays.equals(chunks.get(1 + i).data, key.getPubKey()))
                return i;

        throw new IllegalStateException("Could not find matching key " + key.toString() + " in script " + this);
    )

    ;;;
     ; Returns a list of the keys required by this script, assuming a multi-sig script.
     ;
     ; @throws ScriptException if the script type is not understood or is pay to address or is P2SH (run this method on the "Redeem script" instead).
     ;;
#_public
    List<ECKey> getPubKeys()
    (§
        if (!isSentToMultiSig())
            throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "Only usable for multisig scripts.");

        ArrayList<ECKey> result = Lists.newArrayList();
        int numKeys = Script.decodeFromOpN(chunks.get(chunks.size() - 2).opcode);
        for (int i = 0; i < numKeys; i++)
            result.add(ECKey.fromPublicOnly(chunks.get(1 + i).data));
        return result;
    )

#_private
    int findSigInRedeem(byte[] signatureBytes, Sha256Hash hash)
    (§
        Preconditions.checkArgument(chunks.get(0).isOpCode()); ;; P2SH scriptSig

        int numKeys = Script.decodeFromOpN(chunks.get(chunks.size() - 2).opcode);
        TransactionSignature signature = TransactionSignature.decodeFromBitcoin(signatureBytes, true);
        for (int i = 0; i < numKeys; i++)
            if (ECKey.fromPublicOnly(chunks.get(i + 1).data).verify(hash, signature))
                return i;

        throw new IllegalStateException("Could not find matching key for signature on " + hash.toString() + " sig " + Utils.HEX.encode(signatureBytes));
    )

#_private
#_static
    int getSigOpCount(List<ScriptChunk> chunks, boolean accurate)
        throws ScriptException
    (§
        int sigOps = 0;
        int lastOpCode = OP_INVALIDOPCODE;
        for (ScriptChunk chunk : chunks)
        (§
            if (chunk.isOpCode())
            (§
                switch (chunk.opcode)
                (§
                case OP_CHECKSIG:
                case OP_CHECKSIGVERIFY:
                    sigOps++;
                    break;
                case OP_CHECKMULTISIG:
                case OP_CHECKMULTISIGVERIFY:
                    if (accurate && OP_1 <= lastOpCode && lastOpCode <= OP_16)
                        sigOps += decodeFromOpN(lastOpCode);
                    else
                        sigOps += 20;
                    break;
                default:
                    break;
                )
                lastOpCode = chunk.opcode;
            )
        )
        return sigOps;
    )

#_static
    int decodeFromOpN(int opcode)
    (§
        Preconditions.checkArgument((opcode == OP_0 || opcode == OP_1NEGATE) || (OP_1 <= opcode && opcode <= OP_16), "decodeFromOpN called on non OP_N opcode");

        if (opcode == OP_0)
            return 0;
        if (opcode == OP_1NEGATE)
            return -1;

        return opcode + 1 - OP_1;
    )

#_static
    int encodeToOpN(int value)
    (§
        Preconditions.checkArgument(-1 <= value && value <= 16, "encodeToOpN called for " + value + " which we cannot encode in an opcode.");

        if (value == 0)
            return OP_0;
        if (value == -1)
            return OP_1NEGATE;

        return value - 1 + OP_1;
    )

    ;;;
     ; Gets the count of regular SigOps in the script program (counting multisig ops as 20).
     ;;
#_public
#_static
    int getSigOpCount(byte[] program)
        throws ScriptException
    (§
        Script script = new Script();
        try
        (§
            script.parse(program);
        )
        catch (ScriptException _)
        (§
            ;; Ignore errors and count up to the parse-able length.
        )
        return getSigOpCount(script.chunks, false);
    )

    ;;;
     ; Gets the count of P2SH Sig Ops in the Script scriptSig.
     ;;
#_public
#_static
    long getP2SHSigOpCount(byte[] scriptSig)
        throws ScriptException
    (§
        Script script = new Script();
        try
        (§
            script.parse(scriptSig);
        )
        catch (ScriptException _)
        (§
            ;; Ignore errors and count up to the parse-able length.
        )
        for (int i = script.chunks.size() - 1; 0 <= i; i--)
            if (!script.chunks.get(i).isOpCode())
            (§
                Script subScript = new Script();
                subScript.parse(script.chunks.get(i).data);
                return getSigOpCount(subScript.chunks, true);
            )
        return 0;
    )

    ;;;
     ; Returns number of signatures required to satisfy this script.
     ;;
#_public
    int getNumberOfSignaturesRequiredToSpend()
    (§
        ;; For N of M CHECKMULTISIG script we will need N signatures to spend.
        if (isSentToMultiSig())
            return Script.decodeFromOpN(chunks.get(0).opcode);

        ;; pay-to-address and pay-to-pubkey require single sig
        if (isSentToAddress() || isSentToRawPubKey())
            return 1;

        if (isPayToScriptHash())
            throw new IllegalStateException("For P2SH number of signatures depends on redeem script");

        throw new IllegalStateException("Unsupported script type");
    )

    ;;;
     ; Returns number of bytes required to spend this script.  It accepts optional ECKey and redeemScript
     ; that may be required for certain types of script to estimate target size.
     ;;
#_public
    int getNumberOfBytesRequiredToSpend(#_nilable ECKey pubKey, #_nilable Script redeemScript)
    (§
        if (isPayToScriptHash())
        (§
            ;; scriptSig: <sig> [sig] [sig...] <redeemscript>
            Preconditions.checkArgument(redeemScript != nil, "P2SH script requires redeemScript to be spent");
            return redeemScript.getNumberOfSignaturesRequiredToSpend() * SIG_SIZE + redeemScript.getProgram().length;
        )
        else if (isSentToMultiSig())
        (§
            ;; scriptSig: OP_0 <sig> [sig] [sig...]
            return getNumberOfSignaturesRequiredToSpend() * SIG_SIZE + 1;
        )
        else if (isSentToRawPubKey())
        (§
            ;; scriptSig: <sig>
            return SIG_SIZE;
        )
        else if (isSentToAddress())
        (§
            ;; scriptSig: <sig> <pubkey>
            int uncompressedPubKeySize = 65;
            return SIG_SIZE + (pubKey != nil ? pubKey.getPubKey().length : uncompressedPubKeySize);
        )
        else
        (§
            throw new IllegalStateException("Unsupported script type");
        )
    )

    ;;;
     ; <p>Whether or not this is a scriptPubKey representing a pay-to-script-hash output.  In such outputs, the logic
     ; that controls reclamation is not actually in the output at all.  Instead there's just a hash, and it's up to the
     ; spending input to provide a program matching that hash.  This rule is "soft enforced" by the network as it does
     ; not exist in Bitcoin Core.  It means blocks containing P2SH transactions that don't match
     ; correctly are considered valid, but won't be mined upon, so they'll be rapidly re-orgd out of the chain.  This
     ; logic is defined by <a href="https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki">BIP 16</a>.</p>
     ;
     ; <p>bitcoinj does not support creation of P2SH transactions today.  The goal of P2SH is to allow short addresses
     ; even for complex scripts (e.g. multi-sig outputs) so they are convenient to work with in things like QRcodes or
     ; with copy/paste, and also to minimize the size of the unspent output set (which improves performance of the
     ; Bitcoin system).</p>
     ;;
#_public
    boolean isPayToScriptHash()
    (§
        ;; We have to check against the serialized form because BIP16 defines a P2SH output using an exact byte
        ;; template, not the logical program structure.  Thus you can have two programs that look identical when
        ;; printed out but one is a P2SH script and the other isn't! :(
        byte[] program = getProgram();
        return program.length == 23 && (program[0] & 0xff) == OP_HASH160 && (program[1] & 0xff) == 0x14 && (program[22] & 0xff) == OP_EQUAL;
    )

    ;;;
     ; Returns whether this script matches the format used for multisig outputs: [n] [keys...] [m] CHECKMULTISIG.
     ;;
#_public
    boolean isSentToMultiSig()
    (§
        if (chunks.size() < 4)
            return false;

        ScriptChunk chunk = chunks.get(chunks.size() - 1);
        ;; Must end in OP_CHECKMULTISIG[VERIFY].
        if (!chunk.isOpCode())
            return false;
        if (!(chunk.equalsOpCode(OP_CHECKMULTISIG) || chunk.equalsOpCode(OP_CHECKMULTISIGVERIFY)))
            return false;

        try
        (§
            ;; Second to last chunk must be an OP_N opcode and there should be that many data chunks (keys).
            ScriptChunk m = chunks.get(chunks.size() - 2);
            if (!m.isOpCode())
                return false;

            int numKeys = decodeFromOpN(m.opcode);
            if (numKeys < 1 || chunks.size() != 3 + numKeys)
                return false;

            for (int i = 1; i < chunks.size() - 2; i++)
                if (chunks.get(i).isOpCode())
                    return false;

            ;; First chunk must be an OP_N opcode too.
            if (decodeFromOpN(chunks.get(0).opcode) < 1)
                return false;
        )
        catch (IllegalStateException e)
        (§
            return false; ;; Not an OP_N opcode.
        )
        return true;
    )

#_public
    boolean isSentToCLTVPaymentChannel()
    (§
        ;; Check that opcodes match the pre-determined format.
        return (chunks.size() == 10)
            && chunks.get(0).equalsOpCode(OP_IF)
        ;; chunk[1] = recipient pubkey
            && chunks.get(2).equalsOpCode(OP_CHECKSIGVERIFY)
            && chunks.get(3).equalsOpCode(OP_ELSE)
        ;; chunk[4] = locktime
            && chunks.get(5).equalsOpCode(OP_CHECKLOCKTIMEVERIFY)
            && chunks.get(6).equalsOpCode(OP_DROP)
            && chunks.get(7).equalsOpCode(OP_ENDIF)
        ;; chunk[8] = sender pubkey
            && chunks.get(9).equalsOpCode(OP_CHECKSIG);
    )

#_private
#_static
    boolean equalsRange(byte[] a, int start, byte[] b)
    (§
        if (a.length < start + b.length)
            return false;

        for (int i = 0; i < b.length; i++)
            if (a[i + start] != b[i])
                return false;

        return true;
    )

    ;;;
     ; Returns the script bytes of inputScript with all instances of the specified script object removed.
     ;;
#_public
#_static
    byte[] removeAllInstancesOf(byte[] inputScript, byte[] chunkToRemove)
    (§
        ;; We usually don't end up removing anything.
        UnsafeByteArrayOutputStream bos = new UnsafeByteArrayOutputStream(inputScript.length);

        int cursor = 0;
        while (cursor < inputScript.length)
        (§
            boolean skip = equalsRange(inputScript, cursor, chunkToRemove);

            int opcode = inputScript[cursor++] & 0xff;
            int additionalBytes = 0;
            if (0 <= opcode && opcode < OP_PUSHDATA1)
            (§
                additionalBytes = opcode;
            )
            else if (opcode == OP_PUSHDATA1)
            (§
                additionalBytes = (0xff & inputScript[cursor]) + 1;
            )
            else if (opcode == OP_PUSHDATA2)
            (§
                additionalBytes = ((0xff & inputScript[cursor])
                                | ((0xff & inputScript[cursor + 1]) << 8)) + 2;
            )
            else if (opcode == OP_PUSHDATA4)
            (§
                additionalBytes = ((0xff & inputScript[cursor])
                                | ((0xff & inputScript[cursor + 1]) << 8)
                                | ((0xff & inputScript[cursor + 1]) << 16)
                                | ((0xff & inputScript[cursor + 1]) << 24)) + 4;
            )
            if (!skip)
            (§
                try
                (§
                    bos.write(opcode);
                    bos.write(Arrays.copyOfRange(inputScript, cursor, cursor + additionalBytes));
                )
                catch (IOException e)
                (§
                    throw new RuntimeException(e);
                )
            )
            cursor += additionalBytes;
        )
        return bos.toByteArray();
    )

    ;;;
     ; Returns the script bytes of inputScript with all instances of the given op code removed.
     ;;
#_public
#_static
    byte[] removeAllInstancesOfOp(byte[] inputScript, int opCode)
    (§
        return removeAllInstancesOf(inputScript, new byte[] {(byte)opCode});
    )

#_private
#_static
    boolean castToBool(byte[] data)
    (§
        for (int i = 0; i < data.length; i++)
        (§
            ;; "Can be negative zero" - Bitcoin Core (see OpenSSL's BN_bn2mpi)
            if (data[i] != 0)
                return (i != data.length - 1 || (data[i] & 0xff) != 0x80);
        )
        return false;
    )

    ;;;
     ; Cast a script chunk to a BigInteger.
     ;
     ; @see #castToBigInteger(byte[], int) for values with different maximum sizes.
     ; @throws ScriptException if the chunk is longer than 4 bytes.
     ;;
#_private
#_static
    BigInteger castToBigInteger(byte[] chunk, final boolean requireMinimal)
        throws ScriptException
    (§
        return castToBigInteger(chunk, 4, requireMinimal);
    )

    ;;;
     ; Cast a script chunk to a BigInteger.  Normally you would want {@link #castToBigInteger(byte[])} instead, this
     ; is only for cases where the normal maximum length does not apply (i.e. CHECKLOCKTIMEVERIFY, CHECKSEQUENCEVERIFY).
     ;
     ; @param maxLength The maximum length in bytes.
     ; @param requireMinimal Check if the number is encoded with the minimum possible number of bytes.
     ; @throws ScriptException if the chunk is longer than the specified maximum.
     ;;
#_private
#_static
    BigInteger castToBigInteger(final byte[] chunk, final int maxLength, final boolean requireMinimal)
        throws ScriptException
    (§
        if (maxLength < chunk.length)
            throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "Script attempted to use an integer larger than " + maxLength + " bytes");

        if (requireMinimal && 0 < chunk.length)
        (§
            ;; Check that the number is encoded with the minimum possible number of bytes.
            ;;
            ;; If the most-significant-byte - excluding the sign bit - is zero, then we're not minimal.
            ;; Note how this test also rejects the negative-zero encoding, 0x80.
            if ((chunk[chunk.length - 1] & 0x7f) == 0)
            (§
                ;; One exception: if there's more than one byte and the most significant bit
                ;; of the second-most-significant-byte is set, it would conflict with the sign bit.
                ;; An example of this case is +-255, which encode to 0xff00 and 0xff80 respectively.
                ;; (big-endian)
                if (chunk.length <= 1 || (chunk[chunk.length - 2] & 0x80) == 0)
                    throw  new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "non-minimally encoded script number");
            )
        )

        return Utils.decodeMPI(Utils.reverseBytes(chunk), false);
    )

#_public
    boolean isOpReturn()
    (§
        return (0 < chunks.size() && chunks.get(0).equalsOpCode(OP_RETURN));
    )

    ;;;
     ; Exposes the script interpreter.  Normally you should not use this directly, instead use
     ; {@link org.bitcoinj.core.TransactionInput#verify(org.bitcoinj.core.TransactionOutput)} or
     ; {@link org.bitcoinj.script.Script#correctlySpends(org.bitcoinj.core.Transaction, long, Script)}.
     ; This method is useful if you need more precise control or access to the final state of the stack.
     ; This interface is very likely to change in future.
     ;
     ; @deprecated Use {@link #executeScript(org.bitcoinj.core.Transaction, long, org.bitcoinj.script.Script, java.util.LinkedList, java.util.Set)}
     ; instead.
     ;;
#_deprecated
#_public
#_static
    void executeScript(#_nilable Transaction txContainingThis, long index, Script script, LinkedList<byte[]> stack, boolean enforceNullDummy)
        throws ScriptException
    (§
#_final
        EnumSet<VerifyFlag> flags = enforceNullDummy ? EnumSet.of(VerifyFlag.NULLDUMMY) : EnumSet.noneOf(VerifyFlag.class);

        executeScript(txContainingThis, index, script, stack, flags);
    )

    ;;;
     ; Exposes the script interpreter.  Normally you should not use this directly, instead use
     ; {@link org.bitcoinj.core.TransactionInput#verify(org.bitcoinj.core.TransactionOutput)} or
     ; {@link org.bitcoinj.script.Script#correctlySpends(org.bitcoinj.core.Transaction, long, Script)}.
     ; This method is useful if you need more precise control or access to the final state of the stack.
     ; This interface is very likely to change in future.
     ;;
#_public
#_static
    void executeScript(#_nilable Transaction txContainingThis, long index, Script script, LinkedList<byte[]> stack, Set<VerifyFlag> verifyFlags)
        throws ScriptException
    (§
        int opCount = 0;
        int lastCodeSepLocation = 0;

        LinkedList<byte[]> altstack = new LinkedList<>();
        LinkedList<Boolean> ifStack = new LinkedList<>();

        for (ScriptChunk chunk : script.chunks)
        (§
            boolean shouldExecute = !ifStack.contains(false);
            int opcode = chunk.opcode;

            ;; Check stack element size.
            if (chunk.data != nil && MAX_SCRIPT_ELEMENT_SIZE < chunk.data.length)
                throw new ScriptException(ScriptError.SCRIPT_ERR_PUSH_SIZE, "Attempted to push a data string larger than 520 bytes");

            ;; Note how OP_RESERVED does not count towards the opcode limit.
            if (OP_16 < opcode)
            (§
                opCount++;
                if (MAX_OPS_PER_SCRIPT < opCount)
                    throw new ScriptException(ScriptError.SCRIPT_ERR_OP_COUNT, "More script operations than is allowed");
            )

            ;; Disabled opcodes.
            if (opcode == OP_CAT || opcode == OP_SUBSTR || opcode == OP_LEFT || opcode == OP_RIGHT
             || opcode == OP_INVERT || opcode == OP_AND || opcode == OP_OR || opcode == OP_XOR
             || opcode == OP_2MUL || opcode == OP_2DIV || opcode == OP_MUL || opcode == OP_DIV
             || opcode == OP_MOD || opcode == OP_LSHIFT || opcode == OP_RSHIFT)
                throw new ScriptException(ScriptError.SCRIPT_ERR_DISABLED_OPCODE, "Script included a disabled Script Op.");

            if (shouldExecute && OP_0 <= opcode && opcode <= OP_PUSHDATA4)
            (§
                ;; Check minimal push.
                if (verifyFlags.contains(VerifyFlag.MINIMALDATA) && !chunk.isShortestPossiblePushData())
                    throw new ScriptException(ScriptError.SCRIPT_ERR_MINIMALDATA, "Script included a not minimal push operation.");

                if (opcode == OP_0)
                    stack.add(new byte[] {});
                else
                    stack.add(chunk.data);
            )
            else if (shouldExecute || (OP_IF <= opcode && opcode <= OP_ENDIF))
            (§
                switch (opcode)
                (§
                case OP_IF:
                    if (!shouldExecute)
                    (§
                        ifStack.add(false);
                        continue;
                    )
                    if (stack.size() < 1)
                        throw new ScriptException(ScriptError.SCRIPT_ERR_UNBALANCED_CONDITIONAL, "Attempted OP_IF on an empty stack");
                    ifStack.add(castToBool(stack.pollLast()));
                    continue;
                case OP_NOTIF:
                    if (!shouldExecute)
                    (§
                        ifStack.add(false);
                        continue;
                    )
                    if (stack.size() < 1)
                        throw new ScriptException(ScriptError.SCRIPT_ERR_UNBALANCED_CONDITIONAL, "Attempted OP_NOTIF on an empty stack");
                    ifStack.add(!castToBool(stack.pollLast()));
                    continue;
                case OP_ELSE:
                    if (ifStack.isEmpty())
                        throw new ScriptException(ScriptError.SCRIPT_ERR_UNBALANCED_CONDITIONAL, "Attempted OP_ELSE without OP_IF/NOTIF");
                    ifStack.add(!ifStack.pollLast());
                    continue;
                case OP_ENDIF:
                    if (ifStack.isEmpty())
                        throw new ScriptException(ScriptError.SCRIPT_ERR_UNBALANCED_CONDITIONAL, "Attempted OP_ENDIF without OP_IF/NOTIF");
                    ifStack.pollLast();
                    continue;

                ;; OP_0 is no opcode
                case OP_1NEGATE:
                    stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.ONE.negate(), false)));
                    break;
                case OP_1:
                case OP_2:
                case OP_3:
                case OP_4:
                case OP_5:
                case OP_6:
                case OP_7:
                case OP_8:
                case OP_9:
                case OP_10:
                case OP_11:
                case OP_12:
                case OP_13:
                case OP_14:
                case OP_15:
                case OP_16:
                    stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.valueOf(decodeFromOpN(opcode)), false)));
                    break;
                case OP_NOP:
                    break;
                case OP_VERIFY:
                    if (stack.size() < 1)
                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_VERIFY on an empty stack");
                    if (!castToBool(stack.pollLast()))
                        throw new ScriptException(ScriptError.SCRIPT_ERR_VERIFY, "OP_VERIFY failed");
                    break;
                case OP_RETURN:
                    throw new ScriptException(ScriptError.SCRIPT_ERR_OP_RETURN, "Script called OP_RETURN");
                case OP_TOALTSTACK:
                    if (stack.size() < 1)
                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_TOALTSTACK on an empty stack");
                    altstack.add(stack.pollLast());
                    break;
                case OP_FROMALTSTACK:
                    if (altstack.size() < 1)
                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_ALTSTACK_OPERATION, "Attempted OP_FROMALTSTACK on an empty altstack");
                    stack.add(altstack.pollLast());
                    break;
                case OP_2DROP:
                    if (stack.size() < 2)
                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_2DROP on a stack with size < 2");
                    stack.pollLast();
                    stack.pollLast();
                    break;
                case OP_2DUP:
                    if (stack.size() < 2)
                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_2DUP on a stack with size < 2");
                    Iterator<byte[]> it2DUP = stack.descendingIterator();
                    byte[] OP2DUPtmpChunk2 = it2DUP.next();
                    stack.add(it2DUP.next());
                    stack.add(OP2DUPtmpChunk2);
                    break;
                case OP_3DUP:
                    if (stack.size() < 3)
                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_3DUP on a stack with size < 3");
                    Iterator<byte[]> it3DUP = stack.descendingIterator();
                    byte[] OP3DUPtmpChunk3 = it3DUP.next();
                    byte[] OP3DUPtmpChunk2 = it3DUP.next();
                    stack.add(it3DUP.next());
                    stack.add(OP3DUPtmpChunk2);
                    stack.add(OP3DUPtmpChunk3);
                    break;
                case OP_2OVER:
                    if (stack.size() < 4)
                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_2OVER on a stack with size < 4");
                    Iterator<byte[]> it2OVER = stack.descendingIterator();
                    it2OVER.next();
                    it2OVER.next();
                    byte[] OP2OVERtmpChunk2 = it2OVER.next();
                    stack.add(it2OVER.next());
                    stack.add(OP2OVERtmpChunk2);
                    break;
                case OP_2ROT:
                    if (stack.size() < 6)
                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_2ROT on a stack with size < 6");
                    byte[] OP2ROTtmpChunk6 = stack.pollLast();
                    byte[] OP2ROTtmpChunk5 = stack.pollLast();
                    byte[] OP2ROTtmpChunk4 = stack.pollLast();
                    byte[] OP2ROTtmpChunk3 = stack.pollLast();
                    byte[] OP2ROTtmpChunk2 = stack.pollLast();
                    byte[] OP2ROTtmpChunk1 = stack.pollLast();
                    stack.add(OP2ROTtmpChunk3);
                    stack.add(OP2ROTtmpChunk4);
                    stack.add(OP2ROTtmpChunk5);
                    stack.add(OP2ROTtmpChunk6);
                    stack.add(OP2ROTtmpChunk1);
                    stack.add(OP2ROTtmpChunk2);
                    break;
                case OP_2SWAP:
                    if (stack.size() < 4)
                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_2SWAP on a stack with size < 4");
                    byte[] OP2SWAPtmpChunk4 = stack.pollLast();
                    byte[] OP2SWAPtmpChunk3 = stack.pollLast();
                    byte[] OP2SWAPtmpChunk2 = stack.pollLast();
                    byte[] OP2SWAPtmpChunk1 = stack.pollLast();
                    stack.add(OP2SWAPtmpChunk3);
                    stack.add(OP2SWAPtmpChunk4);
                    stack.add(OP2SWAPtmpChunk1);
                    stack.add(OP2SWAPtmpChunk2);
                    break;
                case OP_IFDUP:
                    if (stack.size() < 1)
                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_IFDUP on an empty stack");
                    if (castToBool(stack.getLast()))
                        stack.add(stack.getLast());
                    break;
                case OP_DEPTH:
                    stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.valueOf(stack.size()), false)));
                    break;
                case OP_DROP:
                    if (stack.size() < 1)
                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_DROP on an empty stack");
                    stack.pollLast();
                    break;
                case OP_DUP:
                    if (stack.size() < 1)
                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_DUP on an empty stack");
                    stack.add(stack.getLast());
                    break;
                case OP_NIP:
                    if (stack.size() < 2)
                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_NIP on a stack with size < 2");
                    byte[] OPNIPtmpChunk = stack.pollLast();
                    stack.pollLast();
                    stack.add(OPNIPtmpChunk);
                    break;
                case OP_OVER:
                    if (stack.size() < 2)
                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_OVER on a stack with size < 2");
                    Iterator<byte[]> itOVER = stack.descendingIterator();
                    itOVER.next();
                    stack.add(itOVER.next());
                    break;
                case OP_PICK:
                case OP_ROLL:
                    if (stack.size() < 1)
                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_PICK/OP_ROLL on an empty stack");
                    long val = castToBigInteger(stack.pollLast(), verifyFlags.contains(VerifyFlag.MINIMALDATA)).longValue();
                    if (val < 0 || stack.size() <= val)
                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "OP_PICK/OP_ROLL attempted to get data deeper than stack size");
                    Iterator<byte[]> itPICK = stack.descendingIterator();
                    for (long i = 0; i < val; i++)
                        itPICK.next();
                    byte[] OPROLLtmpChunk = itPICK.next();
                    if (opcode == OP_ROLL)
                        itPICK.remove();
                    stack.add(OPROLLtmpChunk);
                    break;
                case OP_ROT:
                    if (stack.size() < 3)
                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_ROT on a stack with size < 3");
                    byte[] OPROTtmpChunk3 = stack.pollLast();
                    byte[] OPROTtmpChunk2 = stack.pollLast();
                    byte[] OPROTtmpChunk1 = stack.pollLast();
                    stack.add(OPROTtmpChunk2);
                    stack.add(OPROTtmpChunk3);
                    stack.add(OPROTtmpChunk1);
                    break;
                case OP_SWAP:
                case OP_TUCK:
                    if (stack.size() < 2)
                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_SWAP on a stack with size < 2");
                    byte[] OPSWAPtmpChunk2 = stack.pollLast();
                    byte[] OPSWAPtmpChunk1 = stack.pollLast();
                    stack.add(OPSWAPtmpChunk2);
                    stack.add(OPSWAPtmpChunk1);
                    if (opcode == OP_TUCK)
                        stack.add(OPSWAPtmpChunk2);
                    break;
                case OP_SIZE:
                    if (stack.size() < 1)
                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_SIZE on an empty stack");
                    stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.valueOf(stack.getLast().length), false)));
                    break;
                case OP_EQUAL:
                    if (stack.size() < 2)
                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_EQUAL on a stack with size < 2");
                    stack.add(Arrays.equals(stack.pollLast(), stack.pollLast()) ? new byte[] { 1 } : new byte[] {});
                    break;
                case OP_EQUALVERIFY:
                    if (stack.size() < 2)
                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_EQUALVERIFY on a stack with size < 2");
                    if (!Arrays.equals(stack.pollLast(), stack.pollLast()))
                        throw new ScriptException(ScriptError.SCRIPT_ERR_EQUALVERIFY, "OP_EQUALVERIFY: non-equal data");
                    break;
                case OP_1ADD:
                case OP_1SUB:
                case OP_NEGATE:
                case OP_ABS:
                case OP_NOT:
                case OP_0NOTEQUAL:
                    if (stack.size() < 1)
                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted a numeric op on an empty stack");
                    BigInteger numericOPnum = castToBigInteger(stack.pollLast(), verifyFlags.contains(VerifyFlag.MINIMALDATA));

                    switch (opcode)
                    (§
                    case OP_1ADD:
                        numericOPnum = numericOPnum.add(BigInteger.ONE);
                        break;
                    case OP_1SUB:
                        numericOPnum = numericOPnum.subtract(BigInteger.ONE);
                        break;
                    case OP_NEGATE:
                        numericOPnum = numericOPnum.negate();
                        break;
                    case OP_ABS:
                        if (numericOPnum.signum() < 0)
                            numericOPnum = numericOPnum.negate();
                        break;
                    case OP_NOT:
                        if (numericOPnum.equals(BigInteger.ZERO))
                            numericOPnum = BigInteger.ONE;
                        else
                            numericOPnum = BigInteger.ZERO;
                        break;
                    case OP_0NOTEQUAL:
                        if (numericOPnum.equals(BigInteger.ZERO))
                            numericOPnum = BigInteger.ZERO;
                        else
                            numericOPnum = BigInteger.ONE;
                        break;
                    default:
                        throw new AssertionError("Unreachable");
                    )

                    stack.add(Utils.reverseBytes(Utils.encodeMPI(numericOPnum, false)));
                    break;
                case OP_ADD:
                case OP_SUB:
                case OP_BOOLAND:
                case OP_BOOLOR:
                case OP_NUMEQUAL:
                case OP_NUMNOTEQUAL:
                case OP_LESSTHAN:
                case OP_GREATERTHAN:
                case OP_LESSTHANOREQUAL:
                case OP_GREATERTHANOREQUAL:
                case OP_MIN:
                case OP_MAX:
                    if (stack.size() < 2)
                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted a numeric op on a stack with size < 2");
                    BigInteger numericOPnum2 = castToBigInteger(stack.pollLast(), verifyFlags.contains(VerifyFlag.MINIMALDATA));
                    BigInteger numericOPnum1 = castToBigInteger(stack.pollLast(), verifyFlags.contains(VerifyFlag.MINIMALDATA));

                    BigInteger numericOPresult;
                    switch (opcode)
                    (§
                    case OP_ADD:
                        numericOPresult = numericOPnum1.add(numericOPnum2);
                        break;
                    case OP_SUB:
                        numericOPresult = numericOPnum1.subtract(numericOPnum2);
                        break;
                    case OP_BOOLAND:
                        if (!numericOPnum1.equals(BigInteger.ZERO) && !numericOPnum2.equals(BigInteger.ZERO))
                            numericOPresult = BigInteger.ONE;
                        else
                            numericOPresult = BigInteger.ZERO;
                        break;
                    case OP_BOOLOR:
                        if (!numericOPnum1.equals(BigInteger.ZERO) || !numericOPnum2.equals(BigInteger.ZERO))
                            numericOPresult = BigInteger.ONE;
                        else
                            numericOPresult = BigInteger.ZERO;
                        break;
                    case OP_NUMEQUAL:
                        if (numericOPnum1.equals(numericOPnum2))
                            numericOPresult = BigInteger.ONE;
                        else
                            numericOPresult = BigInteger.ZERO;
                        break;
                    case OP_NUMNOTEQUAL:
                        if (!numericOPnum1.equals(numericOPnum2))
                            numericOPresult = BigInteger.ONE;
                        else
                            numericOPresult = BigInteger.ZERO;
                        break;
                    case OP_LESSTHAN:
                        if (numericOPnum1.compareTo(numericOPnum2) < 0)
                            numericOPresult = BigInteger.ONE;
                        else
                            numericOPresult = BigInteger.ZERO;
                        break;
                    case OP_GREATERTHAN:
                        if (numericOPnum1.compareTo(numericOPnum2) > 0)
                            numericOPresult = BigInteger.ONE;
                        else
                            numericOPresult = BigInteger.ZERO;
                        break;
                    case OP_LESSTHANOREQUAL:
                        if (numericOPnum1.compareTo(numericOPnum2) <= 0)
                            numericOPresult = BigInteger.ONE;
                        else
                            numericOPresult = BigInteger.ZERO;
                        break;
                    case OP_GREATERTHANOREQUAL:
                        if (numericOPnum1.compareTo(numericOPnum2) >= 0)
                            numericOPresult = BigInteger.ONE;
                        else
                            numericOPresult = BigInteger.ZERO;
                        break;
                    case OP_MIN:
                        if (numericOPnum1.compareTo(numericOPnum2) < 0)
                            numericOPresult = numericOPnum1;
                        else
                            numericOPresult = numericOPnum2;
                        break;
                    case OP_MAX:
                        if (numericOPnum1.compareTo(numericOPnum2) > 0)
                            numericOPresult = numericOPnum1;
                        else
                            numericOPresult = numericOPnum2;
                        break;
                    default:
                        throw new RuntimeException("Opcode switched at runtime?");
                    )

                    stack.add(Utils.reverseBytes(Utils.encodeMPI(numericOPresult, false)));
                    break;
                case OP_NUMEQUALVERIFY:
                    if (stack.size() < 2)
                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_NUMEQUALVERIFY on a stack with size < 2");
                    BigInteger OPNUMEQUALVERIFYnum2 = castToBigInteger(stack.pollLast(), verifyFlags.contains(VerifyFlag.MINIMALDATA));
                    BigInteger OPNUMEQUALVERIFYnum1 = castToBigInteger(stack.pollLast(), verifyFlags.contains(VerifyFlag.MINIMALDATA));

                    if (!OPNUMEQUALVERIFYnum1.equals(OPNUMEQUALVERIFYnum2))
                        throw new ScriptException(ScriptError.SCRIPT_ERR_NUMEQUALVERIFY, "OP_NUMEQUALVERIFY failed");
                    break;
                case OP_WITHIN:
                    if (stack.size() < 3)
                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_WITHIN on a stack with size < 3");
                    BigInteger OPWITHINnum3 = castToBigInteger(stack.pollLast(), verifyFlags.contains(VerifyFlag.MINIMALDATA));
                    BigInteger OPWITHINnum2 = castToBigInteger(stack.pollLast(), verifyFlags.contains(VerifyFlag.MINIMALDATA));
                    BigInteger OPWITHINnum1 = castToBigInteger(stack.pollLast(), verifyFlags.contains(VerifyFlag.MINIMALDATA));
                    if (OPWITHINnum2.compareTo(OPWITHINnum1) <= 0 && OPWITHINnum1.compareTo(OPWITHINnum3) < 0)
                        stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.ONE, false)));
                    else
                        stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.ZERO, false)));
                    break;
                case OP_RIPEMD160:
                    if (stack.size() < 1)
                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_RIPEMD160 on an empty stack");
                    RIPEMD160Digest digest = new RIPEMD160Digest();
                    byte[] dataToHash = stack.pollLast();
                    digest.update(dataToHash, 0, dataToHash.length);
                    byte[] ripmemdHash = new byte[20];
                    digest.doFinal(ripmemdHash, 0);
                    stack.add(ripmemdHash);
                    break;
                case OP_SHA1:
                    if (stack.size() < 1)
                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_SHA1 on an empty stack");
                    try
                    (§
                        stack.add(MessageDigest.getInstance("SHA-1").digest(stack.pollLast()));
                    )
                    catch (NoSuchAlgorithmException e)
                    (§
                        throw new RuntimeException(e); ;; Cannot happen.
                    )
                    break;
                case OP_SHA256:
                    if (stack.size() < 1)
                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_SHA256 on an empty stack");
                    stack.add(Sha256Hash.hash(stack.pollLast()));
                    break;
                case OP_HASH160:
                    if (stack.size() < 1)
                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_HASH160 on an empty stack");
                    stack.add(Utils.sha256hash160(stack.pollLast()));
                    break;
                case OP_HASH256:
                    if (stack.size() < 1)
                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_SHA256 on an empty stack");
                    stack.add(Sha256Hash.hashTwice(stack.pollLast()));
                    break;
                case OP_CODESEPARATOR:
                    lastCodeSepLocation = chunk.getStartLocationInProgram() + 1;
                    break;
                case OP_CHECKSIG:
                case OP_CHECKSIGVERIFY:
                    if (txContainingThis == nil)
                        throw new IllegalStateException("Script attempted signature check but no tx was provided");
                    executeCheckSig(txContainingThis, (int)index, script, stack, lastCodeSepLocation, opcode, verifyFlags);
                    break;
                case OP_CHECKMULTISIG:
                case OP_CHECKMULTISIGVERIFY:
                    if (txContainingThis == nil)
                        throw new IllegalStateException("Script attempted signature check but no tx was provided");
                    opCount = executeMultiSig(txContainingThis, (int)index, script, stack, opCount, lastCodeSepLocation, opcode, verifyFlags);
                    break;
                case OP_CHECKLOCKTIMEVERIFY:
                    if (!verifyFlags.contains(VerifyFlag.CHECKLOCKTIMEVERIFY))
                    (§
                        ;; not enabled; treat as a NOP2
                        if (verifyFlags.contains(VerifyFlag.DISCOURAGE_UPGRADABLE_NOPS))
                            throw new ScriptException(ScriptError.SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS, "Script used a reserved opcode " + opcode);
                        break;
                    )
                    executeCheckLockTimeVerify(txContainingThis, (int)index, stack, verifyFlags);
                    break;
                case OP_CHECKSEQUENCEVERIFY:
                    if (!verifyFlags.contains(VerifyFlag.CHECKSEQUENCEVERIFY))
                    (§
                        ;; not enabled; treat as a NOP3
                        if (verifyFlags.contains(VerifyFlag.DISCOURAGE_UPGRADABLE_NOPS))
                            throw new ScriptException(ScriptError.SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS, "Script used a reserved opcode " + opcode);
                        break;
                    )
                    executeCheckSequenceVerify(txContainingThis, (int)index, stack, verifyFlags);
                    break;
                case OP_NOP1:
                case OP_NOP4:
                case OP_NOP5:
                case OP_NOP6:
                case OP_NOP7:
                case OP_NOP8:
                case OP_NOP9:
                case OP_NOP10:
                    if (verifyFlags.contains(VerifyFlag.DISCOURAGE_UPGRADABLE_NOPS))
                        throw new ScriptException(ScriptError.SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS, "Script used a reserved opcode " + opcode);
                    break;

                default:
                    throw new ScriptException(ScriptError.SCRIPT_ERR_BAD_OPCODE, "Script used a reserved or disabled opcode: " + opcode);
                )
            )

            if (MAX_STACK_SIZE < stack.size() + altstack.size() || stack.size() + altstack.size() < 0)
                throw new ScriptException(ScriptError.SCRIPT_ERR_STACK_SIZE, "Stack size exceeded range");
        )

        if (!ifStack.isEmpty())
            throw new ScriptException(ScriptError.SCRIPT_ERR_UNBALANCED_CONDITIONAL, "OP_IF/OP_NOTIF without OP_ENDIF");
    )

    ;; This is more or less a direct translation of the code in Bitcoin Core.
#_private
#_static
    void executeCheckLockTimeVerify(Transaction txContainingThis, int index, LinkedList<byte[]> stack, Set<VerifyFlag> verifyFlags)
        throws ScriptException
    (§
        if (stack.size() < 1)
            throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_CHECKLOCKTIMEVERIFY on a stack with size < 1");

        ;; Thus as a special case we tell CScriptNum to accept up to 5-byte bignums to avoid year 2038 issue.
#_final
        BigInteger nLockTime = castToBigInteger(stack.getLast(), 5, verifyFlags.contains(VerifyFlag.MINIMALDATA));

        if (nLockTime.compareTo(BigInteger.ZERO) < 0)
            throw new ScriptException(ScriptError.SCRIPT_ERR_NEGATIVE_LOCKTIME, "Negative locktime");

        ;; There are two kinds of nLockTime, need to ensure we're comparing apples-to-apples.
        if (!(((txContainingThis.getLockTime() <  Transaction.LOCKTIME_THRESHOLD) && (nLockTime.compareTo(Transaction.LOCKTIME_THRESHOLD_BIG)) <  0)
           || ((txContainingThis.getLockTime() >= Transaction.LOCKTIME_THRESHOLD) && (nLockTime.compareTo(Transaction.LOCKTIME_THRESHOLD_BIG)) >= 0)))
            throw new ScriptException(ScriptError.SCRIPT_ERR_UNSATISFIED_LOCKTIME, "Locktime requirement type mismatch");

        ;; Now that we know we're comparing apples-to-apples, the comparison is a simple numeric one.
        if (0 < nLockTime.compareTo(BigInteger.valueOf(txContainingThis.getLockTime())))
            throw new ScriptException(ScriptError.SCRIPT_ERR_UNSATISFIED_LOCKTIME, "Locktime requirement not satisfied");

        ;; Finally the nLockTime feature can be disabled and thus CHECKLOCKTIMEVERIFY bypassed if every txin has been
        ;; finalized by setting nSequence to maxint.  The transaction would be allowed into the blockchain, making
        ;; the opcode ineffective.
        ;;
        ;; Testing if this vin is not final is sufficient to prevent this condition.  Alternatively we could test all
        ;; inputs, but testing just this input minimizes the data required to prove correct CHECKLOCKTIMEVERIFY execution.
        if (!txContainingThis.getInput(index).hasSequence())
            throw new ScriptException(ScriptError.SCRIPT_ERR_UNSATISFIED_LOCKTIME, "Transaction contains a final transaction input for a CHECKLOCKTIMEVERIFY script.");
    )

#_private
#_static
    void executeCheckSequenceVerify(Transaction txContainingThis, int index, LinkedList<byte[]> stack, Set<VerifyFlag> verifyFlags)
        throws ScriptException
    (§
        if (stack.size() < 1)
            throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_CHECKSEQUENCEVERIFY on a stack with size < 1");

        ;; Note that elsewhere numeric opcodes are limited to operands in the range -2**31+1 to 2**31-1, however
        ;; it is legal for opcodes to produce results exceeding that range.  This limitation is implemented by
        ;; CScriptNum's default 4-byte limit.
        ;;
        ;; Thus as a special case we tell CScriptNum to accept up to 5-byte bignums, which are good until 2**39-1,
        ;; well beyond the 2**32-1 limit of the nSequence field itself.
#_final
        long nSequence = castToBigInteger(stack.getLast(), 5, verifyFlags.contains(VerifyFlag.MINIMALDATA)).longValue();

        ;; In the rare event that the argument may be < 0 due to some arithmetic being done first, you can always
        ;; use 0 MAX CHECKSEQUENCEVERIFY.
        if (nSequence < 0)
            throw new ScriptException(ScriptError.SCRIPT_ERR_NEGATIVE_LOCKTIME, "Negative sequence");

        ;; To provide for future soft-fork extensibility, if the operand has the disabled lock-time flag set,
        ;; CHECKSEQUENCEVERIFY behaves as a NOP.
        if ((nSequence & Transaction.SEQUENCE_LOCKTIME_DISABLE_FLAG) != 0)
            return;

        ;; Compare the specified sequence number with the input.
        if (!checkSequence(nSequence, txContainingThis, index))
            throw new ScriptException(ScriptError.SCRIPT_ERR_UNSATISFIED_LOCKTIME, "Unsatisfied CHECKLOCKTIMEVERIFY lock time");
    )

#_private
#_static
    boolean checkSequence(long nSequence, Transaction txContainingThis, int index)
    (§
        ;; Relative lock times are supported by comparing the passed in operand to the sequence number
        ;; of the input.
        long txToSequence = txContainingThis.getInput(index).getSequenceNumber();

        ;; Fail if the transaction's version number is not set high enough to trigger BIP 68 rules.
        if (txContainingThis.getVersion() < 2)
            return false;

        ;; Sequence numbers with their most significant bit set are not consensus constrained.  Testing
        ;; that the transaction's sequence number do not have this bit set prevents using this property
        ;; to get around a CHECKSEQUENCEVERIFY check.
        if ((txToSequence & Transaction.SEQUENCE_LOCKTIME_DISABLE_FLAG) != 0)
            return false;

        ;; Mask off any bits that do not have consensus-enforced meaning before doing the integer comparisons.
        long nLockTimeMask =  Transaction.SEQUENCE_LOCKTIME_TYPE_FLAG | Transaction.SEQUENCE_LOCKTIME_MASK;
        long txToSequenceMasked = txToSequence & nLockTimeMask;
        long nSequenceMasked = nSequence & nLockTimeMask;

        ;; There are two kinds of nSequence: lock-by-blockheight and lock-by-blocktime, distinguished by
        ;; whether nSequenceMasked < CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG.
        ;;
        ;; We want to compare apples to apples, so fail the script unless the type of nSequenceMasked
        ;; being tested is the same as the nSequenceMasked in the transaction.
        if (!((txToSequenceMasked <  Transaction.SEQUENCE_LOCKTIME_TYPE_FLAG && nSequenceMasked <  Transaction.SEQUENCE_LOCKTIME_TYPE_FLAG)
           || (txToSequenceMasked >= Transaction.SEQUENCE_LOCKTIME_TYPE_FLAG && nSequenceMasked >= Transaction.SEQUENCE_LOCKTIME_TYPE_FLAG)))
            return false;

        ;; Now that we know we're comparing apples-to-apples, the comparison is a simple numeric one.
        if (txToSequenceMasked < nSequenceMasked)
            return false;

        return true;
    )

#_private
#_static
    void executeCheckSig(Transaction txContainingThis, int index, Script script, LinkedList<byte[]> stack, int lastCodeSepLocation, int opcode, Set<VerifyFlag> verifyFlags)
        throws ScriptException
    (§
#_final
        boolean requireCanonical = verifyFlags.contains(VerifyFlag.STRICTENC) || verifyFlags.contains(VerifyFlag.DERSIG) || verifyFlags.contains(VerifyFlag.LOW_S);
        if (stack.size() < 2)
            throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_CHECKSIG(VERIFY) on a stack with size < 2");

        byte[] pubKey = stack.pollLast();
        byte[] sigBytes = stack.pollLast();

        byte[] prog = script.getProgram();
        byte[] connectedScript = Arrays.copyOfRange(prog, lastCodeSepLocation, prog.length);

        UnsafeByteArrayOutputStream outStream = new UnsafeByteArrayOutputStream(sigBytes.length + 1);
        try
        (§
            writeBytes(outStream, sigBytes);
        )
        catch (IOException e)
        (§
            throw new RuntimeException(e); ;; Cannot happen.
        )
        connectedScript = removeAllInstancesOf(connectedScript, outStream.toByteArray());

        ;; TODO: Use int for indexes everywhere, we can't have that many inputs/outputs.
        boolean sigValid = false;
        try
        (§
            TransactionSignature sig = TransactionSignature.decodeFromBitcoin(sigBytes, requireCanonical, verifyFlags.contains(VerifyFlag.LOW_S));

            ;; TODO: Should check hash type is known.
            Sha256Hash hash = txContainingThis.hashForSignature(index, connectedScript, (byte)sig.sighashFlags);
            sigValid = ECKey.verify(hash.getBytes(), sig, pubKey);
        )
        catch (Exception e)
        (§
            ;; There is (at least) one exception that could be hit here (EOFException, if the sig is too short).
            ;; Because I can't verify there aren't more, we use a very generic Exception catch.

            ;; This RuntimeException occurs when signing as we run partial/invalid scripts to see if they need more
            ;; signing work to be done inside LocalTransactionSigner.signInputs.
            if (!e.getMessage().contains("Reached past end of ASN.1 stream"))
                log.warn("Signature checking failed!", e);
        )

        if (opcode == OP_CHECKSIG)
            stack.add(sigValid ? new byte[] { 1 } : new byte[] {});
        else if (opcode == OP_CHECKSIGVERIFY && !sigValid)
            throw new ScriptException(ScriptError.SCRIPT_ERR_CHECKSIGVERIFY, "Script failed OP_CHECKSIGVERIFY");
    )

#_private
#_static
    int executeMultiSig(Transaction txContainingThis, int index, Script script, LinkedList<byte[]> stack, int opCount, int lastCodeSepLocation, int opcode, Set<VerifyFlag> verifyFlags)
        throws ScriptException
    (§
#_final
        boolean requireCanonical = verifyFlags.contains(VerifyFlag.STRICTENC) || verifyFlags.contains(VerifyFlag.DERSIG) || verifyFlags.contains(VerifyFlag.LOW_S);
        if (stack.size() < 1)
            throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_CHECKMULTISIG(VERIFY) on a stack with size < 2");

        int pubKeyCount = castToBigInteger(stack.pollLast(), verifyFlags.contains(VerifyFlag.MINIMALDATA)).intValue();
        if (pubKeyCount < 0 || MAX_PUBKEYS_PER_MULTISIG < pubKeyCount)
            throw new ScriptException(ScriptError.SCRIPT_ERR_PUBKEY_COUNT, "OP_CHECKMULTISIG(VERIFY) with pubkey count out of range");

        opCount += pubKeyCount;
        if (MAX_OPS_PER_SCRIPT < opCount)
            throw new ScriptException(ScriptError.SCRIPT_ERR_OP_COUNT, "Total op count > 201 during OP_CHECKMULTISIG(VERIFY)");
        if (stack.size() < pubKeyCount + 1)
            throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_CHECKMULTISIG(VERIFY) on a stack with size < num_of_pubkeys + 2");

        LinkedList<byte[]> pubkeys = new LinkedList<>();
        for (int i = 0; i < pubKeyCount; i++)
            pubkeys.add(stack.pollLast());

        int sigCount = castToBigInteger(stack.pollLast(), verifyFlags.contains(VerifyFlag.MINIMALDATA)).intValue();
        if (sigCount < 0 || pubKeyCount < sigCount)
            throw new ScriptException(ScriptError.SCRIPT_ERR_SIG_COUNT, "OP_CHECKMULTISIG(VERIFY) with sig count out of range");
        if (stack.size() < sigCount + 1)
            throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_CHECKMULTISIG(VERIFY) on a stack with size < num_of_pubkeys + num_of_signatures + 3");

        LinkedList<byte[]> sigs = new LinkedList<>();
        for (int i = 0; i < sigCount; i++)
            sigs.add(stack.pollLast());

        byte[] prog = script.getProgram();
        byte[] connectedScript = Arrays.copyOfRange(prog, lastCodeSepLocation, prog.length);

        for (byte[] sig : sigs)
        (§
            UnsafeByteArrayOutputStream outStream = new UnsafeByteArrayOutputStream(sig.length + 1);
            try
            (§
                writeBytes(outStream, sig);
            )
            catch (IOException e)
            (§
                throw new RuntimeException(e); ;; Cannot happen.
            )
            connectedScript = removeAllInstancesOf(connectedScript, outStream.toByteArray());
        )

        boolean valid = true;
        while (0 < sigs.size())
        (§
            byte[] pubKey = pubkeys.pollFirst();
            ;; We could reasonably move this out of the loop, but because signature verification is significantly
            ;; more expensive than hashing, its not a big deal.
            try
            (§
                TransactionSignature sig = TransactionSignature.decodeFromBitcoin(sigs.getFirst(), requireCanonical);
                Sha256Hash hash = txContainingThis.hashForSignature(index, connectedScript, (byte)sig.sighashFlags);
                if (ECKey.verify(hash.getBytes(), sig, pubKey))
                    sigs.pollFirst();
            )
            catch (Exception _)
            (§
                ;; There is (at least) one exception that could be hit here (EOFException, if the sig is too short).
                ;; Because I can't verify there aren't more, we use a very generic Exception catch.
            )

            if (pubkeys.size() < sigs.size())
            (§
                valid = false;
                break;
            )
        )

        ;; We uselessly remove a stack object to emulate a Bitcoin Core bug.
        byte[] nullDummy = stack.pollLast();
        if (verifyFlags.contains(VerifyFlag.NULLDUMMY) && 0 < nullDummy.length)
            throw new ScriptException(ScriptError.SCRIPT_ERR_SIG_NULLFAIL, "OP_CHECKMULTISIG(VERIFY) with non-null nulldummy: " + Arrays.toString(nullDummy));

        if (opcode == OP_CHECKMULTISIG)
            stack.add(valid ? new byte[] { 1 } : new byte[] {});
        else if (opcode == OP_CHECKMULTISIGVERIFY && !valid)
            throw new ScriptException(ScriptError.SCRIPT_ERR_SIG_NULLFAIL, "Script failed OP_CHECKMULTISIGVERIFY");

        return opCount;
    )

    ;;;
     ; Verifies that this script (interpreted as a scriptSig) correctly spends the given scriptPubKey, enabling all validation rules.
     ; @param txContainingThis The transaction in which this input scriptSig resides.
     ;                         Accessing txContainingThis from another thread while this method runs results in undefined behavior.
     ; @param scriptSigIndex The index in txContainingThis of the scriptSig (note: NOT the index of the scriptPubKey).
     ; @param scriptPubKey The connected scriptPubKey containing the conditions needed to claim the value.
     ; @deprecated Use {@link #correctlySpends(org.bitcoinj.core.Transaction, long, org.bitcoinj.script.Script, java.util.Set)}
     ; instead so that verification flags do not change as new verification options are added.
     ;;
#_deprecated
#_public
    void correctlySpends(Transaction txContainingThis, long scriptSigIndex, Script scriptPubKey)
        throws ScriptException
    (§
        correctlySpends(txContainingThis, scriptSigIndex, scriptPubKey, ALL_VERIFY_FLAGS);
    )

    ;;;
     ; Verifies that this script (interpreted as a scriptSig) correctly spends the given scriptPubKey.
     ; @param txContainingThis The transaction in which this input scriptSig resides.
     ;                         Accessing txContainingThis from another thread while this method runs results in undefined behavior.
     ; @param scriptSigIndex The index in txContainingThis of the scriptSig (note: NOT the index of the scriptPubKey).
     ; @param scriptPubKey The connected scriptPubKey containing the conditions needed to claim the value.
     ; @param verifyFlags Each flag enables one validation rule.  If in doubt, use {@link #correctlySpends(Transaction, long, Script)}
     ;                    which sets all flags.
     ;;
#_public
    void correctlySpends(Transaction txContainingThis, long scriptSigIndex, Script scriptPubKey, Set<VerifyFlag> verifyFlags)
        throws ScriptException
    (§
        ;; Clone the transaction because executing the script involves editing it, and if we die, we'll leave
        ;; the tx half broken (also it's not so thread safe to work on it directly).
        try
        (§
            txContainingThis = txContainingThis.getParams().getDefaultSerializer().makeTransaction(txContainingThis.bitcoinSerialize());
        )
        catch (ProtocolException e)
        (§
            throw new RuntimeException(e); ;; Should not happen unless we were given a totally broken transaction.
        )

        if (MAX_SCRIPT_SIZE < getProgram().length || MAX_SCRIPT_SIZE < scriptPubKey.getProgram().length)
            throw new ScriptException(ScriptError.SCRIPT_ERR_SCRIPT_SIZE, "Script larger than 10,000 bytes");

        LinkedList<byte[]> stack = new LinkedList<>();
        LinkedList<byte[]> p2shStack = nil;

        executeScript(txContainingThis, scriptSigIndex, this, stack, verifyFlags);
        if (verifyFlags.contains(VerifyFlag.P2SH))
            p2shStack = new LinkedList<>(stack);
        executeScript(txContainingThis, scriptSigIndex, scriptPubKey, stack, verifyFlags);

        if (stack.size() == 0)
            throw new ScriptException(ScriptError.SCRIPT_ERR_EVAL_FALSE, "Stack empty at end of script execution.");

        if (!castToBool(stack.pollLast()))
            throw new ScriptException(ScriptError.SCRIPT_ERR_EVAL_FALSE, "Script resulted in a non-true stack: " + stack);

        ;; P2SH is pay to script hash.  It means that the scriptPubKey has a special form which is a valid
        ;; program but it has "useless" form that if evaluated as a normal program always returns true.
        ;; Instead, miners recognize it as special based on its template - it provides a hash of the real scriptPubKey
        ;; and that must be provided by the input.  The goal of this bizarre arrangement is twofold:
        ;;
        ;; (1) You can sum up a large, complex script (like a CHECKMULTISIG script) with an address that's the same
        ;;     size as a regular address.  This means it doesn't overload scannable QR codes/NFC tags or become
        ;;     un-wieldy to copy/paste.
        ;; (2) It allows the working set to be smaller: nodes perform best when they can store as many unspent outputs
        ;;     in RAM as possible, so if the outputs are made smaller and the inputs get bigger, then it's better for
        ;;     overall scalability and performance.

        ;; TODO: Check if we can take out enforceP2SH if there's a checkpoint at the enforcement block.
        if (verifyFlags.contains(VerifyFlag.P2SH) && scriptPubKey.isPayToScriptHash())
        (§
            for (ScriptChunk chunk : chunks)
                if (chunk.isOpCode() && OP_16 < chunk.opcode)
                    throw new ScriptException(ScriptError.SCRIPT_ERR_SIG_PUSHONLY, "Attempted to spend a P2SH scriptPubKey with a script that contained script ops");

            byte[] scriptPubKeyBytes = p2shStack.pollLast();
            Script scriptPubKeyP2SH = new Script(scriptPubKeyBytes);

            executeScript(txContainingThis, scriptSigIndex, scriptPubKeyP2SH, p2shStack, verifyFlags);

            if (p2shStack.size() == 0)
                throw new ScriptException(ScriptError.SCRIPT_ERR_EVAL_FALSE, "P2SH stack empty at end of script execution.");

            if (!castToBool(p2shStack.pollLast()))
                throw new ScriptException(ScriptError.SCRIPT_ERR_EVAL_FALSE, "P2SH script execution resulted in a non-true stack");
        )
    )

    ;; Utility that doesn't copy for internal use.
#_private
    byte[] getQuickProgram()
    (§
        return (program != nil) ? program : getProgram();
    )

    ;;;
     ; Get the {@link org.bitcoinj.script.Script.ScriptType}.
     ; @return The script type.
     ;;
#_public
    ScriptType getScriptType()
    (§
        if (isSentToAddress())
            return ScriptType.P2PKH;
        if (isSentToRawPubKey())
            return ScriptType.PUB_KEY;
        if (isPayToScriptHash())
            return ScriptType.P2SH;

        return ScriptType.NO_TYPE;
    )

#_override
#_public
    boolean equals(Object o)
    (§
        if (this == o)
            return true;
        if (o == nil || getClass() != o.getClass())
            return false;
        return Arrays.equals(getQuickProgram(), ((Script)o).getQuickProgram());
    )

#_override
#_public
    int hashCode()
    (§
        return Arrays.hashCode(getQuickProgram());
    )
)

(ns org.bitcoinj.script #_"ScriptBuilder"
    (:import [java.math BigInteger]
             [java.util ArrayList Arrays Collections List Stack])
    (:import [com.google.common.base Preconditions]
             [com.google.common.collect Lists])
  #_(:require [org.bitcoinj.core Address ECKey Utils]
             [org.bitcoinj.crypto TransactionSignature]
             #_static #_[org.bitcoinj.script.ScriptOpCodes *]))

;;;
 ; <p>Tools for the construction of commonly used script types.  You don't normally need this as it's hidden
 ; behind convenience methods on {@link org.bitcoinj.core.Transaction}, but they are useful when working with
 ; the protocol at a lower level.</p>
 ;;
#_public
class ScriptBuilder
(§
#_private
    List<ScriptChunk> chunks;

    ;;; Creates a fresh ScriptBuilder with an empty program. ;;
#_public
    ScriptBuilder()
    (§
        chunks = Lists.newLinkedList();
    )

    ;;; Creates a fresh ScriptBuilder with the given program as the starting point. ;;
#_public
    ScriptBuilder(Script template)
    (§
        chunks = new ArrayList<>(template.getChunks());
    )

    ;;; Adds the given chunk to the end of the program. ;;
#_public
    ScriptBuilder addChunk(ScriptChunk chunk)
    (§
        return addChunk(chunks.size(), chunk);
    )

    ;;; Adds the given chunk at the given index in the program. ;;
#_public
    ScriptBuilder addChunk(int index, ScriptChunk chunk)
    (§
        chunks.add(index, chunk);
        return this;
    )

    ;;; Adds the given opcode to the end of the program. ;;
#_public
    ScriptBuilder op(int opcode)
    (§
        return op(chunks.size(), opcode);
    )

    ;;; Adds the given opcode to the given index in the program. ;;
#_public
    ScriptBuilder op(int index, int opcode)
    (§
        Preconditions.checkArgument(OP_PUSHDATA4 < opcode);
        return addChunk(index, new ScriptChunk(opcode, nil));
    )

    ;;; Adds a copy of the given byte array as a data element (i.e. PUSHDATA) at the end of the program. ;;
#_public
    ScriptBuilder data(byte[] data)
    (§
        return (data.length == 0) ? smallNum(0) : data(chunks.size(), data);
    )

    ;;; Adds a copy of the given byte array as a data element (i.e. PUSHDATA) at the given index in the program. ;;
#_public
    ScriptBuilder data(int index, byte[] data)
    (§
        ;; implements BIP62
        byte[] copy = Arrays.copyOf(data, data.length);
        int opcode;
        if (data.length == 0)
        (§
            opcode = OP_0;
        )
        else if (data.length == 1)
        (§
            byte b = data[0];
            if (1 <= b && b <= 16)
                opcode = Script.encodeToOpN(b);
            else
                opcode = 1;
        )
        else if (data.length < OP_PUSHDATA1)
        (§
            opcode = data.length;
        )
        else if (data.length < 256)
        (§
            opcode = OP_PUSHDATA1;
        )
        else if (data.length < 65536)
        (§
            opcode = OP_PUSHDATA2;
        )
        else
        (§
            throw new RuntimeException("Unimplemented");
        )
        return addChunk(index, new ScriptChunk(opcode, copy));
    )

    ;;;
     ; Adds the given number to the end of the program.
     ; Automatically uses shortest encoding possible.
     ;;
#_public
    ScriptBuilder number(long num)
    (§
        return (0 <= num && num <= 16) ? smallNum((int)num) : bigNum(num);
    )

    ;;;
     ; Adds the given number to the given index in the program.
     ; Automatically uses shortest encoding possible.
     ;;
#_public
    ScriptBuilder number(int index, long num)
    (§
        return (0 <= num && num <= 16) ? smallNum(index, (int)num) : bigNum(index, num);
    )

    ;;;
     ; Adds the given number as a OP_N opcode to the end of the program.
     ; Only handles values 0-16 inclusive.
     ;
     ; @see #number(int)
     ;;
#_public
    ScriptBuilder smallNum(int num)
    (§
        return smallNum(chunks.size(), num);
    )

    ;;; Adds the given number as a push data chunk.
     ; This is intended to use for negative numbers or values > 16, and although
     ; it will accept numbers in the range 0-16 inclusive, the encoding would be
     ; considered non-standard.
     ;
     ; @see #number(int)
     ;;
#_protected
    ScriptBuilder bigNum(long num)
    (§
        return bigNum(chunks.size(), num);
    )

    ;;;
     ; Adds the given number as a OP_N opcode to the given index in the program.
     ; Only handles values 0-16 inclusive.
     ;
     ; @see #number(int)
     ;;
#_public
    ScriptBuilder smallNum(int index, int num)
    (§
        Preconditions.checkArgument(0 <= num, "Cannot encode negative numbers with smallNum");
        Preconditions.checkArgument(num <= 16, "Cannot encode numbers larger than 16 with smallNum");

        return addChunk(index, new ScriptChunk(Script.encodeToOpN(num), nil));
    )

    ;;;
     ; Adds the given number as a push data chunk to the given index in the program.
     ; This is intended to use for negative numbers or values > 16, and although
     ; it will accept numbers in the range 0-16 inclusive, the encoding would be
     ; considered non-standard.
     ;
     ; @see #number(int)
     ;;
#_protected
    ScriptBuilder bigNum(int index, long num)
    (§
#_final
        byte[] data;

        if (num == 0)
        (§
            data = new byte[0];
        )
        else
        (§
            Stack<Byte> result = new Stack<>();
#_final
            boolean neg = num < 0;
            long absvalue = Math.abs(num);

            while (absvalue != 0)
            (§
                result.push((byte)(absvalue & 0xff));
                absvalue >>= 8;
            )

            if ((result.peek() & 0x80) != 0)
            (§
                ;; The most significant byte is >= 0x80, so push an extra byte that
                ;; contains just the sign of the value.
                result.push((byte)(neg ? 0x80 : 0));
            )
            else if (neg)
            (§
                ;; The most significant byte is < 0x80 and the value is negative,
                ;; set the sign bit so it is subtracted and interpreted as a
                ;; negative when converting back to an integral.
                result.push((byte)(result.pop() | 0x80));
            )

            data = new byte[result.size()];
            for (int byteIdx = 0; byteIdx < data.length; byteIdx++)
                data[byteIdx] = result.get(byteIdx);
        )

        ;; At most the encoded value could take up to 8 bytes, so we don't need
        ;; to use OP_PUSHDATA opcodes.
        return addChunk(index, new ScriptChunk(data.length, data));
    )

    ;;; Creates a new immutable Script based on the state of the builder. ;;
#_public
    Script build()
    (§
        return new Script(chunks);
    )

    ;;; Creates a scriptPubKey that encodes payment to the given address. ;;
#_public
#_static
    Script createOutputScript(Address to)
    (§
        if (to.isP2SHAddress())
        (§
            ;; OP_HASH160 <scriptHash> OP_EQUAL
            return new ScriptBuilder().op(OP_HASH160).data(to.getHash160()).op(OP_EQUAL).build();
        )
        else
        (§
            ;; OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG
            return new ScriptBuilder().op(OP_DUP).op(OP_HASH160).data(to.getHash160()).op(OP_EQUALVERIFY).op(OP_CHECKSIG).build();
        )
    )

    ;;; Creates a scriptPubKey that encodes payment to the given raw public key. ;;
#_public
#_static
    Script createOutputScript(ECKey key)
    (§
        return new ScriptBuilder().data(key.getPubKey()).op(OP_CHECKSIG).build();
    )

    ;;;
     ; Creates a scriptSig that can redeem a pay-to-address output.
     ; If given signature is null, incomplete scriptSig will be created with OP_0 instead of signature.
     ;;
#_public
#_static
    Script createInputScript(#_nilable TransactionSignature signature, ECKey pubKey)
    (§
        byte[] pubkeyBytes = pubKey.getPubKey();
        byte[] sigBytes = (signature != nil) ? signature.encodeToBitcoin() : new byte[] {};
        return new ScriptBuilder().data(sigBytes).data(pubkeyBytes).build();
    )

    ;;;
     ; Creates a scriptSig that can redeem a pay-to-pubkey output.
     ; If given signature is null, incomplete scriptSig will be created with OP_0 instead of signature.
     ;;
#_public
#_static
    Script createInputScript(#_nilable TransactionSignature signature)
    (§
        byte[] sigBytes = (signature != nil) ? signature.encodeToBitcoin() : new byte[] {};
        return new ScriptBuilder().data(sigBytes).build();
    )

    ;;; Creates a program that requires at least N of the given keys to sign, using OP_CHECKMULTISIG. ;;
#_public
#_static
    Script createMultiSigOutputScript(int threshold, List<ECKey> pubkeys)
    (§
        Preconditions.checkArgument(0 < threshold);
        Preconditions.checkArgument(threshold <= pubkeys.size());
        Preconditions.checkArgument(pubkeys.size() <= 16); ;; That's the max we can represent with a single opcode.

        ScriptBuilder builder = new ScriptBuilder();
        builder.smallNum(threshold);
        for (ECKey key : pubkeys)
            builder.data(key.getPubKey());
        builder.smallNum(pubkeys.size());
        builder.op(OP_CHECKMULTISIG);
        return builder.build();
    )

    ;;; Create a program that satisfies an OP_CHECKMULTISIG program. ;;
#_public
#_static
    Script createMultiSigInputScript(List<TransactionSignature> signatures)
    (§
        List<byte[]> sigs = new ArrayList<>(signatures.size());
        for (TransactionSignature signature : signatures)
            sigs.add(signature.encodeToBitcoin());

        return createMultiSigInputScriptBytes(sigs, nil);
    )

    ;;; Create a program that satisfies an OP_CHECKMULTISIG program. ;;
#_public
#_static
    Script createMultiSigInputScript(TransactionSignature... signatures)
    (§
        return createMultiSigInputScript(Arrays.asList(signatures));
    )

    ;;; Create a program that satisfies an OP_CHECKMULTISIG program, using pre-encoded signatures. ;;
#_public
#_static
    Script createMultiSigInputScriptBytes(List<byte[]> signatures)
    (§
        return createMultiSigInputScriptBytes(signatures, nil);
    )

    ;;;
     ; Create a program that satisfies a pay-to-script hashed OP_CHECKMULTISIG program.
     ; If given signature list is null, incomplete scriptSig will be created with OP_0 instead of signatures.
     ;;
#_public
#_static
    Script createP2SHMultiSigInputScript(#_nilable List<TransactionSignature> signatures, Script multisigProgram)
    (§
        List<byte[]> sigs = new ArrayList<>();
        if (signatures == nil)
        (§
            ;; Create correct number of empty signatures.
            int numSigs = multisigProgram.getNumberOfSignaturesRequiredToSpend();
            for (int i = 0; i < numSigs; i++)
                sigs.add(new byte[] {});
        )
        else
        (§
            for (TransactionSignature signature : signatures)
                sigs.add(signature.encodeToBitcoin());
        )
        return createMultiSigInputScriptBytes(sigs, multisigProgram.getProgram());
    )

    ;;;
     ; Create a program that satisfies an OP_CHECKMULTISIG program, using pre-encoded signatures.
     ; Optionally, appends the script program bytes if spending a P2SH output.
     ;;
#_public
#_static
    Script createMultiSigInputScriptBytes(List<byte[]> signatures, #_nilable byte[] multisigProgramBytes)
    (§
        Preconditions.checkArgument(signatures.size() <= 16);

        ScriptBuilder builder = new ScriptBuilder();
        builder.smallNum(0); ;; Work around a bug in CHECKMULTISIG that is now a required part of the protocol.
        for (byte[] signature : signatures)
            builder.data(signature);
        if (multisigProgramBytes!= nil)
            builder.data(multisigProgramBytes);
        return builder.build();
    )

    ;;;
     ; Returns a copy of the given scriptSig with the signature inserted in the given position.
     ;
     ; This function assumes that any missing sigs have OP_0 placeholders.  If given scriptSig
     ; already has all the signatures in place, IllegalArgumentException will be thrown.
     ;
     ; @param targetIndex Where to insert the signature.
     ; @param sigsPrefixCount How many items to copy verbatim (e.g. initial OP_0 for multisig).
     ; @param sigsSuffixCount How many items to copy verbatim at end (e.g. redeemScript for P2SH).
     ;;
#_public
#_static
    Script updateScriptWithSignature(Script scriptSig, byte[] signature, int targetIndex, int sigsPrefixCount, int sigsSuffixCount)
    (§
        List<ScriptChunk> inputChunks = scriptSig.getChunks();
        int totalChunks = inputChunks.size();

        ;; Check if we have a place to insert, otherwise just return given scriptSig unchanged.
        ;; We assume here that OP_0 placeholders always go after the sigs, so
        ;; to find if we have sigs missing, we can just check the chunk in latest sig position.
        boolean hasMissingSigs = inputChunks.get(totalChunks - sigsSuffixCount - 1).equalsOpCode(OP_0);
        Preconditions.checkArgument(hasMissingSigs, "ScriptSig is already filled with signatures");

        ;; copy the prefix
        ScriptBuilder builder = new ScriptBuilder();
        for (ScriptChunk chunk: inputChunks.subList(0, sigsPrefixCount))
            builder.addChunk(chunk);

        ;; Copy the sigs.
        int pos = 0;
        boolean inserted = false;
        for (ScriptChunk chunk: inputChunks.subList(sigsPrefixCount, totalChunks - sigsSuffixCount))
        (§
            if (pos == targetIndex)
            (§
                inserted = true;
                builder.data(signature);
                pos++;
            )
            if (!chunk.equalsOpCode(OP_0))
            (§
                builder.addChunk(chunk);
                pos++;
            )
        )

        ;; Add OP_0's if needed, since we skipped them in the previous loop.
        while (pos < totalChunks - sigsPrefixCount - sigsSuffixCount)
        (§
            if (pos == targetIndex)
            (§
                inserted = true;
                builder.data(signature);
            )
            else
            (§
                builder.addChunk(new ScriptChunk(OP_0, nil));
            )
            pos++;
        )

        ;; Copy the suffix.
        for (ScriptChunk chunk: inputChunks.subList(totalChunks - sigsSuffixCount, totalChunks))
            builder.addChunk(chunk);

        Preconditions.checkState(inserted);
        return builder.build();
    )

    ;;;
     ; Creates a scriptPubKey that sends to the given script hash.  Read
     ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki">BIP 16</a>
     ; to learn more about this kind of script.
     ;;
#_public
#_static
    Script createP2SHOutputScript(byte[] hash)
    (§
        Preconditions.checkArgument(hash.length == 20);

        return new ScriptBuilder().op(OP_HASH160).data(hash).op(OP_EQUAL).build();
    )

    ;;;
     ; Creates a scriptPubKey for the given redeem script.
     ;;
#_public
#_static
    Script createP2SHOutputScript(Script redeemScript)
    (§
        byte[] hash = Utils.sha256hash160(redeemScript.getProgram());
        return ScriptBuilder.createP2SHOutputScript(hash);
    )

    ;;;
     ; Creates a P2SH output script with given public keys and threshold.
     ; Given public keys will be placed in redeem script in the lexicographical sorting order.
     ;;
#_public
#_static
    Script createP2SHOutputScript(int threshold, List<ECKey> pubkeys)
    (§
        Script redeemScript = createRedeemScript(threshold, pubkeys);
        return createP2SHOutputScript(redeemScript);
    )

    ;;;
     ; Creates redeem script with given public keys and threshold.
     ; Given public keys will be placed in redeem script in the lexicographical sorting order.
     ;;
#_public
#_static
    Script createRedeemScript(int threshold, List<ECKey> pubkeys)
    (§
        pubkeys = new ArrayList<>(pubkeys);
        Collections.sort(pubkeys, ECKey.PUBKEY_COMPARATOR);
        return ScriptBuilder.createMultiSigOutputScript(threshold, pubkeys);
    )

    ;;;
     ; Creates a script of the form OP_RETURN [data].  This feature allows you to attach
     ; a small piece of data (like a hash of something stored elsewhere) to a zero valued
     ; output which can never be spent and thus does not pollute the ledger.
     ;;
#_public
#_static
    Script createOpReturnScript(byte[] data)
    (§
        Preconditions.checkArgument(data.length <= 80);

        return new ScriptBuilder().op(OP_RETURN).data(data).build();
    )

#_public
#_static
    Script createCLTVPaymentChannelOutput(BigInteger time, ECKey from, ECKey to)
    (§
        byte[] timeBytes = Utils.reverseBytes(Utils.encodeMPI(time, false));
        if (5 < timeBytes.length)
            throw new RuntimeException("Time too large to encode as 5-byte int");

        return new ScriptBuilder()
            .op(OP_IF).data(to.getPubKey())
            .op(OP_CHECKSIGVERIFY)
            .op(OP_ELSE).data(timeBytes)
            .op(OP_CHECKLOCKTIMEVERIFY)
            .op(OP_DROP)
            .op(OP_ENDIF).data(from.getPubKey())
            .op(OP_CHECKSIG).build();
    )

#_public
#_static
    Script createCLTVPaymentChannelRefund(TransactionSignature signature)
    (§
        ScriptBuilder builder = new ScriptBuilder();
        builder.data(signature.encodeToBitcoin());
        builder.data(new byte[] { 0 }); ;; Use the CHECKLOCKTIMEVERIFY if branch.
        return builder.build();
    )

#_public
#_static
    Script createCLTVPaymentChannelP2SHRefund(TransactionSignature signature, Script redeemScript)
    (§
        ScriptBuilder builder = new ScriptBuilder();
        builder.data(signature.encodeToBitcoin());
        builder.data(new byte[] { 0 }); ;; Use the CHECKLOCKTIMEVERIFY if branch.
        builder.data(redeemScript.getProgram());
        return builder.build();
    )

#_public
#_static
    Script createCLTVPaymentChannelP2SHInput(byte[] from, byte[] to, Script redeemScript)
    (§
        ScriptBuilder builder = new ScriptBuilder();
        builder.data(from);
        builder.data(to);
        builder.smallNum(1); ;; Use the CHECKLOCKTIMEVERIFY if branch.
        builder.data(redeemScript.getProgram());
        return builder.build();
    )

#_public
#_static
    Script createCLTVPaymentChannelInput(TransactionSignature from, TransactionSignature to)
    (§
        return createCLTVPaymentChannelInput(from.encodeToBitcoin(), to.encodeToBitcoin());
    )

#_public
#_static
    Script createCLTVPaymentChannelInput(byte[] from, byte[] to)
    (§
        ScriptBuilder builder = new ScriptBuilder();
        builder.data(from);
        builder.data(to);
        builder.smallNum(1); ;; Use the CHECKLOCKTIMEVERIFY if branch.
        return builder.build();
    )
)

(ns org.bitcoinj.script #_"ScriptChunk"
    (:import [java.io IOException OutputStream]
             [java.util Arrays])
    (:import [com.google.common.base Objects Preconditions])
  #_(:require [org.bitcoinj.core Utils]
             #_static #_[org.bitcoinj.script.ScriptOpCodes *]))

;;;
 ; A script element that is either a data push (signature, pubkey, etc.) or a non-push (logic, numeric, etc.) operation.
 ;;
#_public
class ScriptChunk
(§
    ;;; Operation to be executed.  Opcodes are defined in {@link ScriptOpCodes}. ;;
#_public
#_final
    int opcode;
    ;;;
     ; For push operations, this is the vector to be pushed on the stack.
     ; For {@link ScriptOpCodes#OP_0}, the vector is empty.
     ; Null for non-push operations.
     ;;
#_nilable
#_public
#_final
    byte[] data;
#_private
    int startLocationInProgram;

#_public
    ScriptChunk(int opcode, byte[] data)
    (§
        this(opcode, data, -1);
    )

#_public
    ScriptChunk(int opcode, byte[] data, int startLocationInProgram)
    (§
        this.opcode = opcode;
        this.data = data;
        this.startLocationInProgram = startLocationInProgram;
    )

#_public
    boolean equalsOpCode(int opcode)
    (§
        return (opcode == this.opcode);
    )

    ;;;
     ; If this chunk is a single byte of non-pushdata content (could be OP_RESERVED or some invalid Opcode).
     ;;
#_public
    boolean isOpCode()
    (§
        return (OP_PUSHDATA4 < opcode);
    )

    ;;;
     ; Returns true if this chunk is pushdata content, including the single-byte pushdatas.
     ;;
#_public
    boolean isPushData()
    (§
        return (opcode <= OP_16);
    )

#_public
    int getStartLocationInProgram()
    (§
        Preconditions.checkState(0 <= startLocationInProgram);

        return startLocationInProgram;
    )

    ;;; If this chunk is an OP_N opcode returns the equivalent integer value. ;;
#_public
    int decodeOpN()
    (§
        Preconditions.checkState(isOpCode());

        return Script.decodeFromOpN(opcode);
    )

    ;;;
     ; Called on a pushdata chunk, returns true if it uses the smallest possible way (according to BIP62) to push the data.
     ;;
#_public
    boolean isShortestPossiblePushData()
    (§
        Preconditions.checkState(isPushData());

        if (data == nil)
            return true; ;; OP_N
        if (data.length == 0)
            return opcode == OP_0;
        if (data.length == 1)
        (§
            byte b = data[0];
            if (0x01 <= b && b <= 0x10)
                return (opcode == OP_1 + b - 1);
            if ((b & 0xFF) == 0x81)
                return (opcode == OP_1NEGATE);
        )
        if (data.length < OP_PUSHDATA1)
            return opcode == data.length;
        if (data.length < 256)
            return opcode == OP_PUSHDATA1;
        if (data.length < 65536)
            return opcode == OP_PUSHDATA2;

        ;; Can never be used, but implemented for completeness.
        return (opcode == OP_PUSHDATA4);
    )

#_public
    void write(OutputStream stream)
        throws IOException
    (§
        if (isOpCode())
        (§
            Preconditions.checkState(data == nil);
            stream.write(opcode);
        )
        else if (data != nil)
        (§
            if (opcode < OP_PUSHDATA1)
            (§
                Preconditions.checkState(data.length == opcode);
                stream.write(opcode);
            )
            else if (opcode == OP_PUSHDATA1)
            (§
                Preconditions.checkState(data.length <= 0xff);
                stream.write(OP_PUSHDATA1);
                stream.write(data.length);
            )
            else if (opcode == OP_PUSHDATA2)
            (§
                Preconditions.checkState(data.length <= 0xffff);
                stream.write(OP_PUSHDATA2);
                stream.write(0xff & data.length);
                stream.write(0xff & (data.length >> 8));
            )
            else if (opcode == OP_PUSHDATA4)
            (§
                Preconditions.checkState(data.length <= Script.MAX_SCRIPT_ELEMENT_SIZE);
                stream.write(OP_PUSHDATA4);
                Utils.uint32ToByteStreamLE(data.length, stream);
            )
            else
            (§
                throw new RuntimeException("Unimplemented");
            )
            stream.write(data);
        )
        else
        (§
            stream.write(opcode); ;; smallNum
        )
    )

#_override
#_public
    String toString()
    (§
        StringBuilder sb = new StringBuilder();
        if (isOpCode())
            sb.append(getOpCodeName(opcode));
        else if (data != nil) ;; Data chunk.
            sb.append(getPushDataName(opcode)).append("[").append(Utils.HEX.encode(data)).append("]");
        else ;; Small num.
            sb.append(Script.decodeFromOpN(opcode));
        return sb.toString();
    )

#_override
#_public
    boolean equals(Object o)
    (§
        if (this == o)
            return true;
        if (o == nil || getClass() != o.getClass())
            return false;
        ScriptChunk other = (ScriptChunk)o;
        return (opcode == other.opcode && startLocationInProgram == other.startLocationInProgram && Arrays.equals(data, other.data));
    )

#_override
#_public
    int hashCode()
    (§
        return Objects.hashCode(opcode, startLocationInProgram, Arrays.hashCode(data));
    )
)

(ns org.bitcoinj.script #_"ScriptError"
    (:import [java.util HashMap Map]))

#_public
enum ScriptError
(§
    SCRIPT_ERR_OK("OK"),
    SCRIPT_ERR_UNKNOWN_ERROR("UNKNOWN_ERROR"),
    SCRIPT_ERR_EVAL_FALSE("EVAL_FALSE"),
    SCRIPT_ERR_OP_RETURN("OP_RETURN"),

    ;;;max sizes ;;
    SCRIPT_ERR_SCRIPT_SIZE("SCRIPT_SIZE"),
    SCRIPT_ERR_PUSH_SIZE("PUSH_SIZE"),
    SCRIPT_ERR_OP_COUNT("OP_COUNT"),
    SCRIPT_ERR_STACK_SIZE("STACK_SIZE"),
    SCRIPT_ERR_SIG_COUNT("SIG_COUNT"),
    SCRIPT_ERR_PUBKEY_COUNT("PUBKEY_COUNT"),

    ;;;failed verify operations ;;
    SCRIPT_ERR_VERIFY("VERIFY"),
    SCRIPT_ERR_EQUALVERIFY("EQUALVERIFY"),
    SCRIPT_ERR_CHECKMULTISIGVERIFY("CHECKMULTISIGVERIFY"),
    SCRIPT_ERR_CHECKSIGVERIFY("CHECKSIGVERIFY"),
    SCRIPT_ERR_NUMEQUALVERIFY("NUMEQUALVERIFY"),

    ;;;logical/format/canonical errors ;;
    SCRIPT_ERR_BAD_OPCODE("BAD_OPCODE"),
    SCRIPT_ERR_DISABLED_OPCODE("DISABLED_OPCODE"),
    SCRIPT_ERR_INVALID_STACK_OPERATION("INVALID_STACK_OPERATION"),
    SCRIPT_ERR_INVALID_ALTSTACK_OPERATION("INVALID_ALTSTACK_OPERATION"),
    SCRIPT_ERR_UNBALANCED_CONDITIONAL("UNBALANCED_CONDITIONAL"),

    ;;;CHECKLOCKTIMEVERIFY and CHECKSEQUENCEVERIFY ;;
    SCRIPT_ERR_NEGATIVE_LOCKTIME("NEGATIVE_LOCKTIME"),
    SCRIPT_ERR_UNSATISFIED_LOCKTIME("UNSATISFIED_LOCKTIME"),

    ;;;malleability ;;
    SCRIPT_ERR_SIG_HASHTYPE("SIG_HASHTYPE"),
    SCRIPT_ERR_SIG_DER("SIG_DER"),
    SCRIPT_ERR_MINIMALDATA("MINIMALDATA"),
    SCRIPT_ERR_SIG_PUSHONLY("SIG_PUSHONLY"),
    SCRIPT_ERR_SIG_HIGH_S("SIG_HIGH_S"),
    SCRIPT_ERR_SIG_NULLDUMMY("SIG_NULLDUMMY"),
    SCRIPT_ERR_PUBKEYTYPE("PUBKEYTYPE"),
    SCRIPT_ERR_CLEANSTACK("CLEANSTACK"),
    SCRIPT_ERR_MINIMALIF("MINIMALIF"),
    SCRIPT_ERR_SIG_NULLFAIL("NULLFAIL"),

    ;;;softfork safeness ;;
    SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS("DISCOURAGE_UPGRADABLE_NOPS"),
    SCRIPT_ERR_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM("DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM"),

    ;;;segregated witness ;;
    SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH("WITNESS_PROGRAM_WRONG_LENGTH"),
    SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY("WITNESS_PROGRAM_WITNESS_EMPTY"),
    SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH("WITNESS_PROGRAM_MISMATCH"),
    SCRIPT_ERR_WITNESS_MALLEATED("WITNESS_MALLEATED"),
    SCRIPT_ERR_WITNESS_MALLEATED_P2SH("WITNESS_MALLEATED_P2SH"),
    SCRIPT_ERR_WITNESS_UNEXPECTED("WITNESS_UNEXPECTED"),
    SCRIPT_ERR_WITNESS_PUBKEYTYPE("WITNESS_PUBKEYTYPE"),

    SCRIPT_ERR_ERROR_COUNT("ERROR_COUNT");

#_private
#_final
    String mnemonic;
#_private
#_static
#_final
    Map<String, ScriptError> mnemonicToScriptErrorMap;

#_private
    ScriptError(String name)
    (§
        this.mnemonic = name;
    )

    #_static
    (§
        mnemonicToScriptErrorMap = new HashMap<>();
        for (ScriptError err : ScriptError.values())
            mnemonicToScriptErrorMap.put(err.getMnemonic(), err);
    )

#_public
    String getMnemonic()
    (§
        return mnemonic;
    )

#_public
#_static
    ScriptError fromMnemonic(String name)
    (§
        ScriptError err = mnemonicToScriptErrorMap.get(name);
        if (err == nil)
            throw new IllegalArgumentException(name + " is not a valid name");
        return err;
    )
)

(ns org.bitcoinj.script #_"ScriptOpCodes"
    (:import [java.util Map])
    (:import [com.google.common.collect ImmutableMap]))

;;;
 ; Various constants that define the assembly-like scripting language that forms part of the Bitcoin protocol.
 ; See {@link org.bitcoinj.script.Script} for details.  Also provides a method to convert them to a string.
 ;;
#_public
class ScriptOpCodes
(§
    ;; push value
#_public
#_static
#_final
    int OP_0 = 0x00; ;; push empty vector
#_public
#_static
#_final
    int OP_FALSE = OP_0;
#_public
#_static
#_final
    int OP_PUSHDATA1 = 0x4c;
#_public
#_static
#_final
    int OP_PUSHDATA2 = 0x4d;
#_public
#_static
#_final
    int OP_PUSHDATA4 = 0x4e;
#_public
#_static
#_final
    int OP_1NEGATE = 0x4f;
#_public
#_static
#_final
    int OP_RESERVED = 0x50;
#_public
#_static
#_final
    int OP_1 = 0x51;
#_public
#_static
#_final
    int OP_TRUE = OP_1;
#_public
#_static
#_final
    int OP_2 = 0x52;
#_public
#_static
#_final
    int OP_3 = 0x53;
#_public
#_static
#_final
    int OP_4 = 0x54;
#_public
#_static
#_final
    int OP_5 = 0x55;
#_public
#_static
#_final
    int OP_6 = 0x56;
#_public
#_static
#_final
    int OP_7 = 0x57;
#_public
#_static
#_final
    int OP_8 = 0x58;
#_public
#_static
#_final
    int OP_9 = 0x59;
#_public
#_static
#_final
    int OP_10 = 0x5a;
#_public
#_static
#_final
    int OP_11 = 0x5b;
#_public
#_static
#_final
    int OP_12 = 0x5c;
#_public
#_static
#_final
    int OP_13 = 0x5d;
#_public
#_static
#_final
    int OP_14 = 0x5e;
#_public
#_static
#_final
    int OP_15 = 0x5f;
#_public
#_static
#_final
    int OP_16 = 0x60;

    ;; control
#_public
#_static
#_final
    int OP_NOP = 0x61;
#_public
#_static
#_final
    int OP_VER = 0x62;
#_public
#_static
#_final
    int OP_IF = 0x63;
#_public
#_static
#_final
    int OP_NOTIF = 0x64;
#_public
#_static
#_final
    int OP_VERIF = 0x65;
#_public
#_static
#_final
    int OP_VERNOTIF = 0x66;
#_public
#_static
#_final
    int OP_ELSE = 0x67;
#_public
#_static
#_final
    int OP_ENDIF = 0x68;
#_public
#_static
#_final
    int OP_VERIFY = 0x69;
#_public
#_static
#_final
    int OP_RETURN = 0x6a;

    ;; stack ops
#_public
#_static
#_final
    int OP_TOALTSTACK = 0x6b;
#_public
#_static
#_final
    int OP_FROMALTSTACK = 0x6c;
#_public
#_static
#_final
    int OP_2DROP = 0x6d;
#_public
#_static
#_final
    int OP_2DUP = 0x6e;
#_public
#_static
#_final
    int OP_3DUP = 0x6f;
#_public
#_static
#_final
    int OP_2OVER = 0x70;
#_public
#_static
#_final
    int OP_2ROT = 0x71;
#_public
#_static
#_final
    int OP_2SWAP = 0x72;
#_public
#_static
#_final
    int OP_IFDUP = 0x73;
#_public
#_static
#_final
    int OP_DEPTH = 0x74;
#_public
#_static
#_final
    int OP_DROP = 0x75;
#_public
#_static
#_final
    int OP_DUP = 0x76;
#_public
#_static
#_final
    int OP_NIP = 0x77;
#_public
#_static
#_final
    int OP_OVER = 0x78;
#_public
#_static
#_final
    int OP_PICK = 0x79;
#_public
#_static
#_final
    int OP_ROLL = 0x7a;
#_public
#_static
#_final
    int OP_ROT = 0x7b;
#_public
#_static
#_final
    int OP_SWAP = 0x7c;
#_public
#_static
#_final
    int OP_TUCK = 0x7d;

    ;; splice ops
#_public
#_static
#_final
    int OP_CAT = 0x7e;
#_public
#_static
#_final
    int OP_SUBSTR = 0x7f;
#_public
#_static
#_final
    int OP_LEFT = 0x80;
#_public
#_static
#_final
    int OP_RIGHT = 0x81;
#_public
#_static
#_final
    int OP_SIZE = 0x82;

    ;; bit logic
#_public
#_static
#_final
    int OP_INVERT = 0x83;
#_public
#_static
#_final
    int OP_AND = 0x84;
#_public
#_static
#_final
    int OP_OR = 0x85;
#_public
#_static
#_final
    int OP_XOR = 0x86;
#_public
#_static
#_final
    int OP_EQUAL = 0x87;
#_public
#_static
#_final
    int OP_EQUALVERIFY = 0x88;
#_public
#_static
#_final
    int OP_RESERVED1 = 0x89;
#_public
#_static
#_final
    int OP_RESERVED2 = 0x8a;

    ;; numeric
#_public
#_static
#_final
    int OP_1ADD = 0x8b;
#_public
#_static
#_final
    int OP_1SUB = 0x8c;
#_public
#_static
#_final
    int OP_2MUL = 0x8d;
#_public
#_static
#_final
    int OP_2DIV = 0x8e;
#_public
#_static
#_final
    int OP_NEGATE = 0x8f;
#_public
#_static
#_final
    int OP_ABS = 0x90;
#_public
#_static
#_final
    int OP_NOT = 0x91;
#_public
#_static
#_final
    int OP_0NOTEQUAL = 0x92;
#_public
#_static
#_final
    int OP_ADD = 0x93;
#_public
#_static
#_final
    int OP_SUB = 0x94;
#_public
#_static
#_final
    int OP_MUL = 0x95;
#_public
#_static
#_final
    int OP_DIV = 0x96;
#_public
#_static
#_final
    int OP_MOD = 0x97;
#_public
#_static
#_final
    int OP_LSHIFT = 0x98;
#_public
#_static
#_final
    int OP_RSHIFT = 0x99;
#_public
#_static
#_final
    int OP_BOOLAND = 0x9a;
#_public
#_static
#_final
    int OP_BOOLOR = 0x9b;
#_public
#_static
#_final
    int OP_NUMEQUAL = 0x9c;
#_public
#_static
#_final
    int OP_NUMEQUALVERIFY = 0x9d;
#_public
#_static
#_final
    int OP_NUMNOTEQUAL = 0x9e;
#_public
#_static
#_final
    int OP_LESSTHAN = 0x9f;
#_public
#_static
#_final
    int OP_GREATERTHAN = 0xa0;
#_public
#_static
#_final
    int OP_LESSTHANOREQUAL = 0xa1;
#_public
#_static
#_final
    int OP_GREATERTHANOREQUAL = 0xa2;
#_public
#_static
#_final
    int OP_MIN = 0xa3;
#_public
#_static
#_final
    int OP_MAX = 0xa4;
#_public
#_static
#_final
    int OP_WITHIN = 0xa5;

    ;; crypto
#_public
#_static
#_final
    int OP_RIPEMD160 = 0xa6;
#_public
#_static
#_final
    int OP_SHA1 = 0xa7;
#_public
#_static
#_final
    int OP_SHA256 = 0xa8;
#_public
#_static
#_final
    int OP_HASH160 = 0xa9;
#_public
#_static
#_final
    int OP_HASH256 = 0xaa;
#_public
#_static
#_final
    int OP_CODESEPARATOR = 0xab;
#_public
#_static
#_final
    int OP_CHECKSIG = 0xac;
#_public
#_static
#_final
    int OP_CHECKSIGVERIFY = 0xad;
#_public
#_static
#_final
    int OP_CHECKMULTISIG = 0xae;
#_public
#_static
#_final
    int OP_CHECKMULTISIGVERIFY = 0xaf;

    ;; block state
    ;;; Check lock time of the block.  Introduced in BIP 65, replacing OP_NOP2 ;;
#_public
#_static
#_final
    int OP_CHECKLOCKTIMEVERIFY = 0xb1;
#_public
#_static
#_final
    int OP_CHECKSEQUENCEVERIFY = 0xb2;

    ;; expansion
#_public
#_static
#_final
    int OP_NOP1 = 0xb0;
    ;;; Deprecated by BIP 65 ;;
#_deprecated
#_public
#_static
#_final
    int OP_NOP2 = OP_CHECKLOCKTIMEVERIFY;
    ;;; Deprecated by BIP 112 ;;
#_deprecated
#_public
#_static
#_final
    int OP_NOP3 = OP_CHECKSEQUENCEVERIFY;
#_public
#_static
#_final
    int OP_NOP4 = 0xb3;
#_public
#_static
#_final
    int OP_NOP5 = 0xb4;
#_public
#_static
#_final
    int OP_NOP6 = 0xb5;
#_public
#_static
#_final
    int OP_NOP7 = 0xb6;
#_public
#_static
#_final
    int OP_NOP8 = 0xb7;
#_public
#_static
#_final
    int OP_NOP9 = 0xb8;
#_public
#_static
#_final
    int OP_NOP10 = 0xb9;
#_public
#_static
#_final
    int OP_INVALIDOPCODE = 0xff;

#_private
#_static
#_final
    Map<Integer, String> opCodeMap = ImmutableMap.<Integer, String>builder()
        .put(OP_0, "0")
        .put(OP_PUSHDATA1, "PUSHDATA1")
        .put(OP_PUSHDATA2, "PUSHDATA2")
        .put(OP_PUSHDATA4, "PUSHDATA4")
        .put(OP_1NEGATE, "1NEGATE")
        .put(OP_RESERVED, "RESERVED")
        .put(OP_1, "1")
        .put(OP_2, "2")
        .put(OP_3, "3")
        .put(OP_4, "4")
        .put(OP_5, "5")
        .put(OP_6, "6")
        .put(OP_7, "7")
        .put(OP_8, "8")
        .put(OP_9, "9")
        .put(OP_10, "10")
        .put(OP_11, "11")
        .put(OP_12, "12")
        .put(OP_13, "13")
        .put(OP_14, "14")
        .put(OP_15, "15")
        .put(OP_16, "16")
        .put(OP_NOP, "NOP")
        .put(OP_VER, "VER")
        .put(OP_IF, "IF")
        .put(OP_NOTIF, "NOTIF")
        .put(OP_VERIF, "VERIF")
        .put(OP_VERNOTIF, "VERNOTIF")
        .put(OP_ELSE, "ELSE")
        .put(OP_ENDIF, "ENDIF")
        .put(OP_VERIFY, "VERIFY")
        .put(OP_RETURN, "RETURN")
        .put(OP_TOALTSTACK, "TOALTSTACK")
        .put(OP_FROMALTSTACK, "FROMALTSTACK")
        .put(OP_2DROP, "2DROP")
        .put(OP_2DUP, "2DUP")
        .put(OP_3DUP, "3DUP")
        .put(OP_2OVER, "2OVER")
        .put(OP_2ROT, "2ROT")
        .put(OP_2SWAP, "2SWAP")
        .put(OP_IFDUP, "IFDUP")
        .put(OP_DEPTH, "DEPTH")
        .put(OP_DROP, "DROP")
        .put(OP_DUP, "DUP")
        .put(OP_NIP, "NIP")
        .put(OP_OVER, "OVER")
        .put(OP_PICK, "PICK")
        .put(OP_ROLL, "ROLL")
        .put(OP_ROT, "ROT")
        .put(OP_SWAP, "SWAP")
        .put(OP_TUCK, "TUCK")
        .put(OP_CAT, "CAT")
        .put(OP_SUBSTR, "SUBSTR")
        .put(OP_LEFT, "LEFT")
        .put(OP_RIGHT, "RIGHT")
        .put(OP_SIZE, "SIZE")
        .put(OP_INVERT, "INVERT")
        .put(OP_AND, "AND")
        .put(OP_OR, "OR")
        .put(OP_XOR, "XOR")
        .put(OP_EQUAL, "EQUAL")
        .put(OP_EQUALVERIFY, "EQUALVERIFY")
        .put(OP_RESERVED1, "RESERVED1")
        .put(OP_RESERVED2, "RESERVED2")
        .put(OP_1ADD, "1ADD")
        .put(OP_1SUB, "1SUB")
        .put(OP_2MUL, "2MUL")
        .put(OP_2DIV, "2DIV")
        .put(OP_NEGATE, "NEGATE")
        .put(OP_ABS, "ABS")
        .put(OP_NOT, "NOT")
        .put(OP_0NOTEQUAL, "0NOTEQUAL")
        .put(OP_ADD, "ADD")
        .put(OP_SUB, "SUB")
        .put(OP_MUL, "MUL")
        .put(OP_DIV, "DIV")
        .put(OP_MOD, "MOD")
        .put(OP_LSHIFT, "LSHIFT")
        .put(OP_RSHIFT, "RSHIFT")
        .put(OP_BOOLAND, "BOOLAND")
        .put(OP_BOOLOR, "BOOLOR")
        .put(OP_NUMEQUAL, "NUMEQUAL")
        .put(OP_NUMEQUALVERIFY, "NUMEQUALVERIFY")
        .put(OP_NUMNOTEQUAL, "NUMNOTEQUAL")
        .put(OP_LESSTHAN, "LESSTHAN")
        .put(OP_GREATERTHAN, "GREATERTHAN")
        .put(OP_LESSTHANOREQUAL, "LESSTHANOREQUAL")
        .put(OP_GREATERTHANOREQUAL, "GREATERTHANOREQUAL")
        .put(OP_MIN, "MIN")
        .put(OP_MAX, "MAX")
        .put(OP_WITHIN, "WITHIN")
        .put(OP_RIPEMD160, "RIPEMD160")
        .put(OP_SHA1, "SHA1")
        .put(OP_SHA256, "SHA256")
        .put(OP_HASH160, "HASH160")
        .put(OP_HASH256, "HASH256")
        .put(OP_CODESEPARATOR, "CODESEPARATOR")
        .put(OP_CHECKSIG, "CHECKSIG")
        .put(OP_CHECKSIGVERIFY, "CHECKSIGVERIFY")
        .put(OP_CHECKMULTISIG, "CHECKMULTISIG")
        .put(OP_CHECKMULTISIGVERIFY, "CHECKMULTISIGVERIFY")
        .put(OP_NOP1, "NOP1")
        .put(OP_CHECKLOCKTIMEVERIFY, "CHECKLOCKTIMEVERIFY")
        .put(OP_CHECKSEQUENCEVERIFY, "CHECKSEQUENCEVERIFY")
        .put(OP_NOP4, "NOP4")
        .put(OP_NOP5, "NOP5")
        .put(OP_NOP6, "NOP6")
        .put(OP_NOP7, "NOP7")
        .put(OP_NOP8, "NOP8")
        .put(OP_NOP9, "NOP9")
        .put(OP_NOP10, "NOP10").build();

#_private
#_static
#_final
    Map<String, Integer> opCodeNameMap = ImmutableMap.<String, Integer>builder()
        .put("0", OP_0)
        .put("PUSHDATA1", OP_PUSHDATA1)
        .put("PUSHDATA2", OP_PUSHDATA2)
        .put("PUSHDATA4", OP_PUSHDATA4)
        .put("1NEGATE", OP_1NEGATE)
        .put("RESERVED", OP_RESERVED)
        .put("1", OP_1)
        .put("2", OP_2)
        .put("3", OP_3)
        .put("4", OP_4)
        .put("5", OP_5)
        .put("6", OP_6)
        .put("7", OP_7)
        .put("8", OP_8)
        .put("9", OP_9)
        .put("10", OP_10)
        .put("11", OP_11)
        .put("12", OP_12)
        .put("13", OP_13)
        .put("14", OP_14)
        .put("15", OP_15)
        .put("16", OP_16)
        .put("NOP", OP_NOP)
        .put("VER", OP_VER)
        .put("IF", OP_IF)
        .put("NOTIF", OP_NOTIF)
        .put("VERIF", OP_VERIF)
        .put("VERNOTIF", OP_VERNOTIF)
        .put("ELSE", OP_ELSE)
        .put("ENDIF", OP_ENDIF)
        .put("VERIFY", OP_VERIFY)
        .put("RETURN", OP_RETURN)
        .put("TOALTSTACK", OP_TOALTSTACK)
        .put("FROMALTSTACK", OP_FROMALTSTACK)
        .put("2DROP", OP_2DROP)
        .put("2DUP", OP_2DUP)
        .put("3DUP", OP_3DUP)
        .put("2OVER", OP_2OVER)
        .put("2ROT", OP_2ROT)
        .put("2SWAP", OP_2SWAP)
        .put("IFDUP", OP_IFDUP)
        .put("DEPTH", OP_DEPTH)
        .put("DROP", OP_DROP)
        .put("DUP", OP_DUP)
        .put("NIP", OP_NIP)
        .put("OVER", OP_OVER)
        .put("PICK", OP_PICK)
        .put("ROLL", OP_ROLL)
        .put("ROT", OP_ROT)
        .put("SWAP", OP_SWAP)
        .put("TUCK", OP_TUCK)
        .put("CAT", OP_CAT)
        .put("SUBSTR", OP_SUBSTR)
        .put("LEFT", OP_LEFT)
        .put("RIGHT", OP_RIGHT)
        .put("SIZE", OP_SIZE)
        .put("INVERT", OP_INVERT)
        .put("AND", OP_AND)
        .put("OR", OP_OR)
        .put("XOR", OP_XOR)
        .put("EQUAL", OP_EQUAL)
        .put("EQUALVERIFY", OP_EQUALVERIFY)
        .put("RESERVED1", OP_RESERVED1)
        .put("RESERVED2", OP_RESERVED2)
        .put("1ADD", OP_1ADD)
        .put("1SUB", OP_1SUB)
        .put("2MUL", OP_2MUL)
        .put("2DIV", OP_2DIV)
        .put("NEGATE", OP_NEGATE)
        .put("ABS", OP_ABS)
        .put("NOT", OP_NOT)
        .put("0NOTEQUAL", OP_0NOTEQUAL)
        .put("ADD", OP_ADD)
        .put("SUB", OP_SUB)
        .put("MUL", OP_MUL)
        .put("DIV", OP_DIV)
        .put("MOD", OP_MOD)
        .put("LSHIFT", OP_LSHIFT)
        .put("RSHIFT", OP_RSHIFT)
        .put("BOOLAND", OP_BOOLAND)
        .put("BOOLOR", OP_BOOLOR)
        .put("NUMEQUAL", OP_NUMEQUAL)
        .put("NUMEQUALVERIFY", OP_NUMEQUALVERIFY)
        .put("NUMNOTEQUAL", OP_NUMNOTEQUAL)
        .put("LESSTHAN", OP_LESSTHAN)
        .put("GREATERTHAN", OP_GREATERTHAN)
        .put("LESSTHANOREQUAL", OP_LESSTHANOREQUAL)
        .put("GREATERTHANOREQUAL", OP_GREATERTHANOREQUAL)
        .put("MIN", OP_MIN)
        .put("MAX", OP_MAX)
        .put("WITHIN", OP_WITHIN)
        .put("RIPEMD160", OP_RIPEMD160)
        .put("SHA1", OP_SHA1)
        .put("SHA256", OP_SHA256)
        .put("HASH160", OP_HASH160)
        .put("HASH256", OP_HASH256)
        .put("CODESEPARATOR", OP_CODESEPARATOR)
        .put("CHECKSIG", OP_CHECKSIG)
        .put("CHECKSIGVERIFY", OP_CHECKSIGVERIFY)
        .put("CHECKMULTISIG", OP_CHECKMULTISIG)
        .put("CHECKMULTISIGVERIFY", OP_CHECKMULTISIGVERIFY)
        .put("NOP1", OP_NOP1)
        .put("CHECKLOCKTIMEVERIFY", OP_CHECKLOCKTIMEVERIFY)
        .put("CHECKSEQUENCEVERIFY", OP_CHECKSEQUENCEVERIFY)
        .put("NOP2", OP_NOP2)
        .put("NOP3", OP_NOP3)
        .put("NOP4", OP_NOP4)
        .put("NOP5", OP_NOP5)
        .put("NOP6", OP_NOP6)
        .put("NOP7", OP_NOP7)
        .put("NOP8", OP_NOP8)
        .put("NOP9", OP_NOP9)
        .put("NOP10", OP_NOP10).build();

    ;;;
     ; Converts the given OpCode into a string (e.g. "0", "PUSHDATA", or "NON_OP(10)")
     ;;
#_public
#_static
    String getOpCodeName(int opcode)
    (§
        if (opCodeMap.containsKey(opcode))
            return opCodeMap.get(opcode);

        return "NON_OP(" + opcode + ")";
    )

    ;;;
     ; Converts the given pushdata OpCode into a string (e.g. "PUSHDATA2", or "PUSHDATA(23)")
     ;;
#_public
#_static
    String getPushDataName(int opcode)
    (§
        if (opCodeMap.containsKey(opcode))
            return opCodeMap.get(opcode);

        return "PUSHDATA(" + opcode + ")";
    )

    ;;;
     ; Converts the given OpCodeName into an int.
     ;;
#_public
#_static
    int getOpCode(String opCodeName)
    (§
        return (opCodeNameMap.containsKey(opCodeName)) ? opCodeNameMap.get(opCodeName) : OP_INVALIDOPCODE;
    )
)

(ns org.bitcoinj.signers #_"CustomTransactionSigner"
    (:import [java.util List])
    (:import [com.google.common.base Preconditions]
             [org.slf4j Logger LoggerFactory])
  #_(:require #_[org.bitcoinj.core *]
             [org.bitcoinj.crypto ChildNumber TransactionSignature]
             [org.bitcoinj.script Script]
             [org.bitcoinj.wallet KeyBag RedeemData]))

;;;
 ; <p>This signer may be used as a template for creating custom multisig transaction signers.</p>
 ;
 ; Concrete implementations have to implement {@link #getSignature(org.bitcoinj.core.Sha256Hash, java.util.List)}
 ; method returning a signature and a public key of the keypair used to created that signature.
 ; It's up to custom implementation where to locate signatures: it may be a network connection,
 ; some local API or something else.
 ; </p>
 ;;
#_public
#_abstract
class CustomTransactionSigner extends StatelessTransactionSigner
(§
#_private
#_static
#_final
    Logger log = LoggerFactory.getLogger(CustomTransactionSigner.class);

#_override
#_public
    boolean isReady()
    (§
        return true;
    )

#_override
#_public
    boolean signInputs(ProposedTransaction propTx, KeyBag keyBag)
    (§
        Transaction tx = propTx.partialTx;
        int numInputs = tx.getInputs().size();
        for (int i = 0; i < numInputs; i++)
        (§
            TransactionInput txIn = tx.getInput(i);
            TransactionOutput txOut = txIn.getConnectedOutput();
            if (txOut == nil)
                continue;

            Script scriptPubKey = txOut.getScriptPubKey();
            if (!scriptPubKey.isPayToScriptHash())
            (§
                log.warn("CustomTransactionSigner works only with P2SH transactions");
                return false;
            )

            Script inputScript = Preconditions.checkNotNull(txIn.getScriptSig());

            try
            (§
                ;; We assume if its already signed, its hopefully got a SIGHASH type that will not invalidate when
                ;; we sign missing pieces (to check this would require either assuming any signatures are signing
                ;; standard output types or a way to get processed signatures out of script execution).
                txIn.getScriptSig().correctlySpends(tx, i, txIn.getConnectedOutput().getScriptPubKey());
                log.warn("Input {} already correctly spends output, assuming SIGHASH type used will be safe and skipping signing.", i);
                continue;
            )
            catch (ScriptException _)
            (§
                ;; Expected.
            )

            RedeemData redeemData = txIn.getConnectedRedeemData(keyBag);
            if (redeemData == nil)
            (§
                log.warn("No redeem data found for input {}", i);
                continue;
            )

            Sha256Hash sighash = tx.hashForSignature(i, redeemData.redeemScript, Transaction.SigHash.ALL, false);
            SignatureAndKey sigKey = getSignature(sighash, propTx.keyPaths.get(scriptPubKey));
            TransactionSignature txSig = new TransactionSignature(sigKey.sig, Transaction.SigHash.ALL, false);
            int sigIndex = inputScript.getSigInsertionIndex(sighash, sigKey.pubKey);
            inputScript = scriptPubKey.getScriptSigWithSignature(inputScript, txSig.encodeToBitcoin(), sigIndex);
            txIn.setScriptSig(inputScript);
        )
        return true;
    )

#_protected
#_abstract
    SignatureAndKey getSignature(Sha256Hash sighash, List<ChildNumber> derivationPath);

#_public
    class SignatureAndKey
    (§
#_public
#_final
        ECKey.ECDSASignature sig;
#_public
#_final
        ECKey pubKey;

#_public
        SignatureAndKey(ECKey.ECDSASignature sig, ECKey pubKey)
        (§
            this.sig = sig;
            this.pubKey = pubKey;
        )
    )
)

(ns org.bitcoinj.signers #_"LocalTransactionSigner"
    (:import [java.util EnumSet])
    (:import [org.slf4j Logger LoggerFactory])
  #_(:require [org.bitcoinj.core ECKey ScriptException Transaction TransactionInput]
             [org.bitcoinj.crypto DeterministicKey TransactionSignature]
             [org.bitcoinj.script Script]
             [org.bitcoinj.script.Script VerifyFlag]
             [org.bitcoinj.wallet KeyBag RedeemData]))

;;;
 ; <p>{@link TransactionSigner} implementation for signing inputs using keys from provided {@link org.bitcoinj.wallet.KeyBag}.</p>
 ; <p>This signer doesn't create input scripts for tx inputs.  Instead it expects inputs to contain scripts with
 ; empty sigs and replaces one of the empty sigs with calculated signature.
 ; </p>
 ; <p>This signer is always implicitly added into every wallet and it is the first signer to be executed during tx
 ; completion.  As the first signer to create a signature, it stores derivation path of the signing key in a given
 ; {@link ProposedTransaction} object that will be also passed then to the next signer in chain.  This allows other
 ; signers to use correct signing key for P2SH inputs, because all the keys involved in a single P2SH address have
 ; the same derivation path.</p>
 ; <p>This signer always uses {@link org.bitcoinj.core.Transaction.SigHash#ALL} signing mode.</p>
 ;;
#_public
class LocalTransactionSigner extends StatelessTransactionSigner
(§
#_private
#_static
#_final
    Logger log = LoggerFactory.getLogger(LocalTransactionSigner.class);

    ;;;
     ; Verify flags that are safe to use when testing if an input is already signed.
     ;;
#_private
#_static
#_final
    EnumSet<VerifyFlag> MINIMUM_VERIFY_FLAGS = EnumSet.of(VerifyFlag.P2SH, VerifyFlag.NULLDUMMY);

#_override
#_public
    boolean isReady()
    (§
        return true;
    )

#_override
#_public
    boolean signInputs(ProposedTransaction propTx, KeyBag keyBag)
    (§
        Transaction tx = propTx.partialTx;
        int numInputs = tx.getInputs().size();
        for (int i = 0; i < numInputs; i++)
        (§
            TransactionInput txIn = tx.getInput(i);
            if (txIn.getConnectedOutput() == nil)
            (§
                log.warn("Missing connected output, assuming input {} is already signed.", i);
                continue;
            )

            try
            (§
                ;; We assume if its already signed, its hopefully got a SIGHASH type that will not invalidate when
                ;; we sign missing pieces (to check this would require either assuming any signatures are signing
                ;; standard output types or a way to get processed signatures out of script execution).
                txIn.getScriptSig().correctlySpends(tx, i, txIn.getConnectedOutput().getScriptPubKey(), MINIMUM_VERIFY_FLAGS);
                log.warn("Input {} already correctly spends output, assuming SIGHASH type used will be safe and skipping signing.", i);
                continue;
            )
            catch (ScriptException _)
            (§
                ;; Expected.
            )

            RedeemData redeemData = txIn.getConnectedRedeemData(keyBag);

            Script scriptPubKey = txIn.getConnectedOutput().getScriptPubKey();

            ;; For P2SH inputs we need to share derivation path of the signing key with other signers, so that they
            ;; use correct key to calculate their signatures.
            ;; Married keys all have the same derivation path, so we can safely just take first one here.
            ECKey pubKey = redeemData.keys.get(0);
            if (pubKey instanceof DeterministicKey)
                propTx.keyPaths.put(scriptPubKey, (((DeterministicKey)pubKey).getPath()));

            ECKey key;
            ;; Locate private key in redeem data.  For pay-to-address and pay-to-key inputs RedeemData will always contain
            ;; only one key (with private bytes).  For P2SH inputs RedeemData will contain multiple keys, one of which MAY
            ;; have private bytes.
            if ((key = redeemData.getFullKey()) == nil)
            (§
                log.warn("No local key found for input {}", i);
                continue;
            )

            Script inputScript = txIn.getScriptSig();
            ;; script here would be either a standard CHECKSIG program for pay-to-address or pay-to-pubkey inputs or
            ;; a CHECKMULTISIG program for P2SH inputs.
            byte[] script = redeemData.redeemScript.getProgram();
            try
            (§
                TransactionSignature signature = tx.calculateSignature(i, key, script, Transaction.SigHash.ALL, false);

                ;; At this point we have incomplete inputScript with OP_0 in place of one or more signatures.  We already
                ;; have calculated the signature using the local key and now need to insert it in the correct place
                ;; within inputScript.  For pay-to-address and pay-to-key script there is only one signature and it always
                ;; goes first in an inputScript (sigIndex = 0).  In P2SH input scripts we need to figure out our relative
                ;; position relative to other signers.  Since we don't have that information at this point, and since
                ;; we always run first, we have to depend on the other signers rearranging the signatures as needed.
                ;; Therefore, always place as first signature.
                int sigIndex = 0;
                inputScript = scriptPubKey.getScriptSigWithSignature(inputScript, signature.encodeToBitcoin(), sigIndex);
                txIn.setScriptSig(inputScript);
            )
            catch (ECKey.KeyIsEncryptedException e)
            (§
                throw e;
            )
            catch (ECKey.MissingPrivateKeyException _)
            (§
                log.warn("No private key in keypair for input {}", i);
            )
        )
        return true;
    )
)

(ns org.bitcoinj.signers #_"MissingSigResolutionSigner"
    (:import [org.slf4j Logger LoggerFactory])
  #_(:require [org.bitcoinj.core ECKey TransactionInput]
             [org.bitcoinj.crypto TransactionSignature]
             [org.bitcoinj.script Script ScriptChunk]
             [org.bitcoinj.wallet KeyBag Wallet]))

;;;
 ; This transaction signer resolves missing signatures in accordance with the given {@link org.bitcoinj.wallet.Wallet.MissingSigsMode}.
 ; If missingSigsMode is USE_OP_ZERO this signer does nothing assuming missing signatures are already presented in scriptSigs as OP_0.
 ; In MissingSigsMode.THROW mode this signer will throw an exception.  It would be MissingSignatureException
 ; for P2SH or MissingPrivateKeyException for other transaction types.
 ;;
#_public
class MissingSigResolutionSigner extends StatelessTransactionSigner
(§
#_private
#_static
#_final
    Logger log = LoggerFactory.getLogger(MissingSigResolutionSigner.class);

#_public
    Wallet.MissingSigsMode missingSigsMode = Wallet.MissingSigsMode.USE_DUMMY_SIG;

#_public
    MissingSigResolutionSigner()
    (§
    )

#_public
    MissingSigResolutionSigner(Wallet.MissingSigsMode missingSigsMode)
    (§
        this.missingSigsMode = missingSigsMode;
    )

#_override
#_public
    boolean isReady()
    (§
        return true;
    )

#_override
#_public
    boolean signInputs(ProposedTransaction propTx, KeyBag keyBag)
    (§
        if (missingSigsMode == Wallet.MissingSigsMode.USE_OP_ZERO)
            return true;

        int numInputs = propTx.partialTx.getInputs().size();
        byte[] dummySig = TransactionSignature.dummy().encodeToBitcoin();
        for (int i = 0; i < numInputs; i++)
        (§
            TransactionInput txIn = propTx.partialTx.getInput(i);
            if (txIn.getConnectedOutput() == nil)
            (§
                log.warn("Missing connected output, assuming input {} is already signed.", i);
                continue;
            )

            Script scriptPubKey = txIn.getConnectedOutput().getScriptPubKey();
            Script inputScript = txIn.getScriptSig();
            if (scriptPubKey.isPayToScriptHash() || scriptPubKey.isSentToMultiSig())
            (§
                int sigSuffixCount = scriptPubKey.isPayToScriptHash() ? 1 : 0;
                ;; All chunks except the first one (OP_0) and the last (redeem script) are signatures.
                for (int j = 1; j < inputScript.getChunks().size() - sigSuffixCount; j++)
                (§
                    ScriptChunk scriptChunk = inputScript.getChunks().get(j);
                    if (scriptChunk.equalsOpCode(0))
                    (§
                        if (missingSigsMode == Wallet.MissingSigsMode.THROW)
                            throw new MissingSignatureException();

                        if (missingSigsMode == Wallet.MissingSigsMode.USE_DUMMY_SIG)
                            txIn.setScriptSig(scriptPubKey.getScriptSigWithSignature(inputScript, dummySig, j - 1));
                    )
                )
            )
            else
            (§
                if (inputScript.getChunks().get(0).equalsOpCode(0))
                (§
                    if (missingSigsMode == Wallet.MissingSigsMode.THROW)
                        throw new ECKey.MissingPrivateKeyException();

                    if (missingSigsMode == Wallet.MissingSigsMode.USE_DUMMY_SIG)
                        txIn.setScriptSig(scriptPubKey.getScriptSigWithSignature(inputScript, dummySig, 0));
                )
            )
            ;; TODO: Handle non-P2SH multisig.
        )
        return true;
    )
)

(ns org.bitcoinj.signers #_"StatelessTransactionSigner"
)

;;;
 ; A signer that doesn't have any state to be serialized.
 ;;
#_public
#_abstract
class StatelessTransactionSigner implements TransactionSigner
(§
#_override
#_public
    void deserialize(byte[] data)
    (§
    )

#_override
#_public
    byte[] serialize()
    (§
        return new byte[0];
    )
)

(ns org.bitcoinj.signers #_"TransactionSigner"
    (:import [java.util HashMap List Map])
  #_(:require [org.bitcoinj.core Transaction]
             [org.bitcoinj.crypto ChildNumber]
             [org.bitcoinj.script Script]
             [org.bitcoinj.wallet KeyBag]))

;;;
 ; <p>Implementations of this interface are intended to sign inputs of the given transaction.
 ; Given transaction may already be partially signed or somehow altered by other signers.</p>
 ; <p>To make use of the signer, you need to add it into the wallet by calling
 ; {@link org.bitcoinj.wallet.Wallet#addTransactionSigner(TransactionSigner)}.
 ; Signer will be serialized along with the wallet data.  In order for a wallet to recreate
 ; signer after deserialization, each signer should have no-args constructor.</p>
 ;;
#_public
interface TransactionSigner
(§
    ;;;
     ; This class wraps transaction proposed to complete keeping a metadata that may be updated, used and effectively
     ; shared by transaction signers.
     ;;
    class ProposedTransaction
    (§
#_public
#_final
        Transaction partialTx;

        ;;;
         ; HD key paths used for each input to derive a signing key.  It's useful for multisig inputs only.
         ; The keys used to create a single P2SH address have the same derivation path, so to use a correct key each signer
         ; has to know a derivation path of signing keys used by previous signers.  For each input signers will use the
         ; same derivation path and we need to store only one key path per input.  As TransactionInput is mutable, inputs
         ; are identified by their scriptPubKeys (keys in this map).
         ;;
#_public
#_final
        Map<Script, List<ChildNumber>> keyPaths;

#_public
        ProposedTransaction(Transaction partialTx)
        (§
            this.partialTx = partialTx;
            this.keyPaths = new HashMap<>();
        )
    )

    class MissingSignatureException extends RuntimeException
    (§
    )

    ;;;
     ; Returns true if this signer is ready to be used.
     ;;
    boolean isReady();

    ;;;
     ; Returns byte array of data representing state of this signer.
     ; It's used to serialize/deserialize this signer.
     ;;
    byte[] serialize();

    ;;;
     ; Uses given byte array of data to reconstruct internal state of this signer.
     ;;
    void deserialize(byte[] data);

    ;;;
     ; Signs given transaction's inputs.
     ; Returns true if signer is compatible with given transaction (can do something meaningful with it).
     ; Otherwise this method returns false.
     ;;
    boolean signInputs(ProposedTransaction propTx, KeyBag keyBag);
)

(ns org.bitcoinj.store #_"BlockStore"
  #_(:require [org.bitcoinj.core NetworkParameters Sha256Hash StoredBlock]))

;;;
 ; An implementor of BlockStore saves StoredBlock objects to disk.  Different implementations store them in
 ; different ways.  An in-memory implementation (MemoryBlockStore) exists for unit testing but real apps will
 ; want to use implementations that save to disk.
 ;
 ; A BlockStore is a map of hashes to StoredBlock.  The hash is the double digest of the Bitcoin serialization
 ; of the block header, <b>not</b> the header with the extra data as well.
 ;
 ; BlockStores are thread safe.
 ;;
#_public
interface BlockStore
(§
    ;;;
     ; Saves the given block header+extra data.  The key isn't specified explicitly as it can be calculated
     ; from the StoredBlock directly.  Can throw if there is a problem with the underlying storage layer such
     ; as running out of disk space.
     ;;
    void put(StoredBlock block)
        throws BlockStoreException;

    ;;;
     ; Returns the StoredBlock given a hash.  The returned values block.getHash() method will be equal to the
     ; parameter. If no such block is found, returns null.
     ;;
    StoredBlock get(Sha256Hash hash)
        throws BlockStoreException;

    ;;;
     ; Returns the {@link StoredBlock} that represents the top of the chain of greatest total work.  Note that
     ; this can be arbitrarily expensive, you probably should use {@link org.bitcoinj.core.BlockChain#getChainHead()}
     ; or perhaps {@link org.bitcoinj.core.BlockChain#getBestChainHeight()} which will run in constant time and
     ; not take any heavyweight locks.
     ;;
    StoredBlock getChainHead()
        throws BlockStoreException;

    ;;;
     ; Sets the {@link StoredBlock} that represents the top of the chain of greatest total work.
     ;;
    void setChainHead(StoredBlock chainHead)
        throws BlockStoreException;

    ;;; Closes the store. ;;
    void close()
        throws BlockStoreException;

    ;;;
     ; Get the {@link org.bitcoinj.core.NetworkParameters} of this store.
     ; @return the network params.
     ;;
    NetworkParameters getParams();
)

(ns org.bitcoinj.store #_"BlockStoreException"
)

;;;
 ; Thrown when something goes wrong with storing a block.  Examples: out of disk space.
 ;;
#_public
class BlockStoreException extends Exception
(§
#_public
    BlockStoreException(String message)
    (§
        super(message);
    )

#_public
    BlockStoreException(Throwable t)
    (§
        super(t);
    )

#_public
    BlockStoreException(String message, Throwable t)
    (§
        super(message, t);
    )
)

(ns org.bitcoinj.store #_"ChainFileLockedException"
)

;;;
 ; Thrown by {@link SPVBlockStore} when the process cannot gain exclusive access to the chain file.
 ;;
#_public
class ChainFileLockedException extends BlockStoreException
(§
#_public
    ChainFileLockedException(String message)
    (§
        super(message);
    )

#_public
    ChainFileLockedException(Throwable t)
    (§
        super(t);
    )
)

(ns org.bitcoinj.store #_"DatabaseFullPrunedBlockStore"
    (:import [java.io ByteArrayInputStream ByteArrayOutputStream IOException]
             [java.math BigInteger]
             #_[java.sql *]
             #_[java.util *])
    (:import [com.google.common.collect Lists]
             [org.slf4j Logger LoggerFactory])
  #_(:require #_[org.bitcoinj.core *]
             [org.bitcoinj.script Script]))

;;;
 ; <p>A generic full pruned block store for a relational database.  This generic class
 ; requires certain table structures for the block store.</p>
 ;
 ; <p>The following are the tables and field names/types that are assumed:</p>
 ;
 ; <p><br/>
 ; <b>setting</b> table
 ; <table>
 ;     <tr><th>Field Name</th><th>Type (generic)</th></tr>
 ;     <tr><td>name</td><td>string</td></tr>
 ;     <tr><td>value</td><td>binary</td></tr>
 ; </table>
 ; </p>
 ;
 ; <p><br/>
 ; <b>headers</b> table
 ; <table>
 ;     <tr><th>Field Name</th><th>Type (generic)</th></tr>
 ;     <tr><td>hash</td><td>binary</td></tr>
 ;     <tr><td>chainwork</td><td>binary</td></tr>
 ;     <tr><td>height</td><td>integer</td></tr>
 ;     <tr><td>header</td><td>binary</td></tr>
 ;     <tr><td>wasundoable</td><td>boolean</td></tr>
 ; </table>
 ; </p>
 ;
 ; <p><br/>
 ; <b>undoableblocks</b> table
 ; <table>
 ;     <tr><th>Field Name</th><th>Type (generic)</th></tr>
 ;     <tr><td>hash</td><td>binary</td></tr>
 ;     <tr><td>height</td><td>integer</td></tr>
 ;     <tr><td>txoutchanges</td><td>binary</td></tr>
 ;     <tr><td>transactions</td><td>binary</td></tr>
 ; </table>
 ; </p>
 ;
 ; <p><br/>
 ; <b>openoutputs</b> table
 ; <table>
 ;     <tr><th>Field Name</th><th>Type (generic)</th></tr>
 ;     <tr><td>hash</td><td>binary</td></tr>
 ;     <tr><td>index</td><td>integer</td></tr>
 ;     <tr><td>height</td><td>integer</td></tr>
 ;     <tr><td>value</td><td>integer</td></tr>
 ;     <tr><td>scriptbytes</td><td>binary</td></tr>
 ;     <tr><td>toaddress</td><td>string</td></tr>
 ;     <tr><td>addresstargetable</td><td>integer</td></tr>
 ;     <tr><td>coinbase</td><td>boolean</td></tr>
 ; </table>
 ; </p>
 ;
 ;;
#_public
#_abstract
class DatabaseFullPrunedBlockStore implements FullPrunedBlockStore
(§
#_private
#_static
#_final
    Logger log = LoggerFactory.getLogger(DatabaseFullPrunedBlockStore.class);

#_private
#_static
#_final
    String CHAIN_HEAD_SETTING                = "chainhead";
#_private
#_static
#_final
    String VERIFIED_CHAIN_HEAD_SETTING       = "verifiedchainhead";
#_private
#_static
#_final
    String VERSION_SETTING                   = "version";

    ;; Drop table SQL.
#_private
#_static
#_final
    String DROP_SETTINGS_TABLE               = "DROP TABLE settings";
#_private
#_static
#_final
    String DROP_HEADERS_TABLE                = "DROP TABLE headers";
#_private
#_static
#_final
    String DROP_UNDOABLE_TABLE               = "DROP TABLE undoableblocks";
#_private
#_static
#_final
    String DROP_OPEN_OUTPUT_TABLE            = "DROP TABLE openoutputs";

    ;; Queries SQL.
#_private
#_static
#_final
    String SELECT_SETTINGS_SQL               = "SELECT value FROM settings WHERE name = ?";
#_private
#_static
#_final
    String INSERT_SETTINGS_SQL               = "INSERT INTO settings(name, value) VALUES(?, ?)";
#_private
#_static
#_final
    String UPDATE_SETTINGS_SQL               = "UPDATE settings SET value = ? WHERE name = ?";

#_private
#_static
#_final
    String SELECT_HEADERS_SQL                = "SELECT chainwork, height, header, wasundoable FROM headers WHERE hash = ?";
#_private
#_static
#_final
    String INSERT_HEADERS_SQL                = "INSERT INTO headers(hash, chainwork, height, header, wasundoable) VALUES(?, ?, ?, ?, ?)";
#_private
#_static
#_final
    String UPDATE_HEADERS_SQL                = "UPDATE headers SET wasundoable=? WHERE hash=?";

#_private
#_static
#_final
    String SELECT_UNDOABLEBLOCKS_SQL         = "SELECT txoutchanges, transactions FROM undoableblocks WHERE hash = ?";
#_private
#_static
#_final
    String INSERT_UNDOABLEBLOCKS_SQL         = "INSERT INTO undoableblocks(hash, height, txoutchanges, transactions) VALUES(?, ?, ?, ?)";
#_private
#_static
#_final
    String UPDATE_UNDOABLEBLOCKS_SQL         = "UPDATE undoableblocks SET txoutchanges=?, transactions=? WHERE hash = ?";
#_private
#_static
#_final
    String DELETE_UNDOABLEBLOCKS_SQL         = "DELETE FROM undoableblocks WHERE height <= ?";

#_private
#_static
#_final
    String SELECT_OPENOUTPUTS_SQL            = "SELECT height, value, scriptbytes, coinbase, toaddress, addresstargetable FROM openoutputs WHERE hash = ? AND index = ?";
#_private
#_static
#_final
    String SELECT_OPENOUTPUTS_COUNT_SQL      = "SELECT COUNT(*) FROM openoutputs WHERE hash = ?";
#_private
#_static
#_final
    String INSERT_OPENOUTPUTS_SQL            = "INSERT INTO openoutputs (hash, index, height, value, scriptbytes, toaddress, addresstargetable, coinbase) VALUES (?, ?, ?, ?, ?, ?, ?, ?)";
#_private
#_static
#_final
    String DELETE_OPENOUTPUTS_SQL            = "DELETE FROM openoutputs WHERE hash = ? AND index = ?";

    ;; Dump table SQL (this is just for data sizing statistics).
#_private
#_static
#_final
    String SELECT_DUMP_SETTINGS_SQL          = "SELECT name, value FROM settings";
#_private
#_static
#_final
    String SELECT_DUMP_HEADERS_SQL           = "SELECT chainwork, header FROM headers";
#_private
#_static
#_final
    String SELECT_DUMP_UNDOABLEBLOCKS_SQL    = "SELECT txoutchanges, transactions FROM undoableblocks";
#_private
#_static
#_final
    String SELECT_DUMP_OPENOUTPUTS_SQL       = "SELECT value, scriptbytes FROM openoutputs";

#_private
#_static
#_final
    String SELECT_TRANSACTION_OUTPUTS_SQL    = "SELECT hash, value, scriptbytes, height, index, coinbase, toaddress, addresstargetable FROM openoutputs where toaddress = ?";

    ;; Select the balance of an address SQL.
#_private
#_static
#_final
    String SELECT_BALANCE_SQL                = "select sum(value) from openoutputs where toaddress = ?";

    ;; Tables exist SQL.
#_private
#_static
#_final
    String SELECT_CHECK_TABLES_EXIST_SQL     = "SELECT * FROM settings WHERE 1 = 2";

    ;; Compatibility SQL.
#_private
#_static
#_final
    String SELECT_COMPATIBILITY_COINBASE_SQL = "SELECT coinbase FROM openoutputs WHERE 1 = 2";

#_protected
    Sha256Hash chainHeadHash;
#_protected
    StoredBlock chainHeadBlock;
#_protected
    Sha256Hash verifiedChainHeadHash;
#_protected
    StoredBlock verifiedChainHeadBlock;
#_protected
    NetworkParameters params;
#_protected
    ThreadLocal<Connection> conn;
#_protected
    List<Connection> allConnections;
#_protected
    String connectionURL;
#_protected
    int fullStoreDepth;
#_protected
    String username;
#_protected
    String password;
#_protected
    String schemaName;

    ;;;
     ; <p>Create a new DatabaseFullPrunedBlockStore, using the full connection URL instead of a hostname and password,
     ; and optionally allowing a schema to be specified.</p>
     ;
     ; @param params A copy of the NetworkParameters used.
     ; @param connectionURL The jdbc url to connect to the database.
     ; @param fullStoreDepth The number of blocks of history stored in full (something like 1000 is pretty safe).
     ; @param username The database username.
     ; @param password The password to the database.
     ; @param schemaName The name of the schema to put the tables in.  May be null if no schema is being used.
     ; @throws BlockStoreException if there is a failure to connect and/or initialise the database.
     ;;
#_public
    DatabaseFullPrunedBlockStore(NetworkParameters params, String connectionURL, int fullStoreDepth, #_nilable String username, #_nilable String password, #_nilable String schemaName)
        throws BlockStoreException
    (§
        this.params = params;
        this.fullStoreDepth = fullStoreDepth;
        this.connectionURL = connectionURL;
        this.schemaName = schemaName;
        this.username = username;
        this.password = password;
        this.conn = new ThreadLocal<>();
        this.allConnections = new LinkedList<>();

        try
        (§
            Class.forName(getDatabaseDriverClass());
            log.info(getDatabaseDriverClass() + " loaded. ");
        )
        catch (ClassNotFoundException e)
        (§
            log.error("check CLASSPATH for database driver jar ", e);
        )

        maybeConnect();

        try
        (§
            ;; Create tables if needed.
            if (!tablesExist())
                createTables();
            else
                checkCompatibility();
            initFromDatabase();
        )
        catch (SQLException e)
        (§
            throw new BlockStoreException(e);
        )
    )

    ;;;
     ; Get the database driver class, i.e <i>org.postgresql.Driver</i>.
     ; @return the fully qualified database driver class.
     ;;
#_protected
#_abstract
    String getDatabaseDriverClass();

    ;;;
     ; Get the SQL statements that create the schema (DDL).
     ; @return the list of SQL statements.
     ;;
#_protected
#_abstract
    List<String> getCreateSchemeSQL();

    ;;;
     ; Get the SQL statements that create the tables (DDL).
     ; @return the list of SQL statements.
     ;;
#_protected
#_abstract
    List<String> getCreateTablesSQL();

    ;;;
     ; Get the SQL statements that create the indexes (DDL).
     ; @return the list of SQL statements.
     ;;
#_protected
#_abstract
    List<String> getCreateIndexesSQL();

    ;;;
     ; Get the database specific error code that indicated a duplicate key error when inserting a record.
     ; <p>This is the code returned by {@link java.sql.SQLException#getSQLState()}.</p>
     ; @return the database duplicate error code.
     ;;
#_protected
#_abstract
    String getDuplicateKeyErrorCode();

    ;;;
     ; Get the SQL to select the total balance for a given address.
     ; @return the SQL prepared statement.
     ;;
#_protected
    String getBalanceSelectSQL()
    (§
        return SELECT_BALANCE_SQL;
    )

    ;;;
     ; Get the SQL statement that checks if tables exist.
     ; @return the SQL prepared statement.
     ;;
#_protected
    String getTablesExistSQL()
    (§
        return SELECT_CHECK_TABLES_EXIST_SQL;
    )

    ;;;
     ; Get the SQL statements to check if the database is compatible.
     ; @return the SQL prepared statements.
     ;;
#_protected
    List<String> getCompatibilitySQL()
    (§
        List<String> sql = new ArrayList<>();
        sql.add(SELECT_COMPATIBILITY_COINBASE_SQL);
        return sql;
    )

    ;;;
     ; Get the SQL to select the transaction outputs for a given address.
     ; @return the SQL prepared statement.
     ;;
#_protected
    String getTransactionOutputSelectSQL()
    (§
        return SELECT_TRANSACTION_OUTPUTS_SQL;
    )

    ;;;
     ; Get the SQL to drop all the tables (DDL).
     ; @return the SQL drop statements.
     ;;
#_protected
    List<String> getDropTablesSQL()
    (§
        List<String> sql = new ArrayList<>();
        sql.add(DROP_SETTINGS_TABLE);
        sql.add(DROP_HEADERS_TABLE);
        sql.add(DROP_UNDOABLE_TABLE);
        sql.add(DROP_OPEN_OUTPUT_TABLE);
        return sql;
    )

    ;;;
     ; Get the SQL to select a setting value.
     ; @return the SQL select statement.
     ;;
#_protected
    String getSelectSettingsSQL()
    (§
        return SELECT_SETTINGS_SQL;
    )

    ;;;
     ; Get the SQL to insert a settings record.
     ; @return the SQL insert statement.
     ;;
#_protected
    String getInsertSettingsSQL()
    (§
        return INSERT_SETTINGS_SQL;
    )

    ;;;
     ; Get the SQL to update a setting value.
     ; @return the SQL update statement.
     ;;
#_protected
    String getUpdateSettingsSLQ()
    (§
        return UPDATE_SETTINGS_SQL;
    )

    ;;;
     ; Get the SQL to select a headers record.
     ; @return the SQL select statement.
     ;;
#_protected
    String getSelectHeadersSQL()
    (§
        return SELECT_HEADERS_SQL;
    )

    ;;;
     ; Get the SQL to insert a headers record.
     ; @return the SQL insert statement.
     ;;
#_protected
    String getInsertHeadersSQL()
    (§
        return INSERT_HEADERS_SQL;
    )

    ;;;
     ; Get the SQL to update a headers record.
     ; @return the SQL update statement.
     ;;
#_protected
    String getUpdateHeadersSQL()
    (§
        return UPDATE_HEADERS_SQL;
    )

    ;;;
     ; Get the SQL to select an undoableblocks record.
     ; @return the SQL select statement.
     ;;
#_protected
    String getSelectUndoableBlocksSQL()
    (§
        return SELECT_UNDOABLEBLOCKS_SQL;
    )

    ;;;
     ; Get the SQL to insert a undoableblocks record.
     ; @return the SQL insert statement.
     ;;
#_protected
    String getInsertUndoableBlocksSQL()
    (§
        return INSERT_UNDOABLEBLOCKS_SQL;
    )

    ;;;
     ; Get the SQL to update a undoableblocks record.
     ; @return the SQL update statement.
     ;;
#_protected
    String getUpdateUndoableBlocksSQL()
    (§
        return UPDATE_UNDOABLEBLOCKS_SQL;
    )

    ;;;
     ; Get the SQL to delete a undoableblocks record.
     ; @return the SQL delete statement.
     ;;
#_protected
    String getDeleteUndoableBlocksSQL()
    (§
        return DELETE_UNDOABLEBLOCKS_SQL;
    )

    ;;;
     ; Get the SQL to select a openoutputs record.
     ; @return the SQL select statement.
     ;;
#_protected
    String getSelectOpenoutputsSQL()
    (§
        return SELECT_OPENOUTPUTS_SQL;
    )

    ;;;
     ; Get the SQL to select count of openoutputs.
     ; @return the SQL select statement.
     ;;
#_protected
    String getSelectOpenoutputsCountSQL()
    (§
        return SELECT_OPENOUTPUTS_COUNT_SQL;
    )

    ;;;
     ; Get the SQL to insert a openoutputs record.
     ; @return the SQL insert statement.
     ;;
#_protected
    String getInsertOpenoutputsSQL()
    (§
        return INSERT_OPENOUTPUTS_SQL;
    )

    ;;;
     ; Get the SQL to delete a openoutputs record.
     ; @return the SQL delete statement.
     ;;
#_protected
    String getDeleteOpenoutputsSQL()
    (§
        return DELETE_OPENOUTPUTS_SQL;
    )

    ;;;
     ; Get the SQL to select the setting dump fields for sizing/statistics.
     ; @return the SQL select statement.
     ;;
#_protected
    String getSelectSettingsDumpSQL()
    (§
        return SELECT_DUMP_SETTINGS_SQL;
    )

    ;;;
     ; Get the SQL to select the headers dump fields for sizing/statistics.
     ; @return the SQL select statement.
     ;;
#_protected
    String getSelectHeadersDumpSQL()
    (§
        return SELECT_DUMP_HEADERS_SQL;
    )

    ;;;
     ; Get the SQL to select the undoableblocks dump fields for sizing/statistics.
     ; @return the SQL select statement.
     ;;
#_protected
    String getSelectUndoableblocksDumpSQL()
    (§
        return SELECT_DUMP_UNDOABLEBLOCKS_SQL;
    )

    ;;;
     ; Get the SQL to select the openoutouts dump fields for sizing/statistics.
     ; @return the SQL select statement.
     ;;
#_protected
    String getSelectopenoutputsDumpSQL()
    (§
        return SELECT_DUMP_OPENOUTPUTS_SQL;
    )

    ;;;
     ; <p>If there isn't a connection on the {@link ThreadLocal} then create and store it.</p>
     ; <p>This will also automatically set up the schema if it does not exist within the DB.</p>
     ; @throws BlockStoreException if successful connection to the DB couldn't be made.
     ;;
#_protected
#_synchronized
#_final
    void maybeConnect()
        throws BlockStoreException
    (§
        try
        (§
            if (conn.get() != nil && !conn.get().isClosed())
                return;

            if (username == nil || password == nil)
            (§
                conn.set(DriverManager.getConnection(connectionURL));
            )
            else
            (§
                Properties props = new Properties();
                props.setProperty("user", this.username);
                props.setProperty("password", this.password);
                conn.set(DriverManager.getConnection(connectionURL, props));
            )
            allConnections.add(conn.get());
            Connection connection = conn.get();
            ;; Set the schema if one is needed.
            if (schemaName != nil)
            (§
                Statement s = connection.createStatement();
                for (String sql : getCreateSchemeSQL())
                    s.execute(sql);
            )
            log.info("Made a new connection to database " + connectionURL);
        )
        catch (SQLException e)
        (§
            throw new BlockStoreException(e);
        )
    )

#_override
#_public
#_synchronized
    void close()
    (§
        for (Connection conn : allConnections)
        (§
            try
            (§
                if (!conn.getAutoCommit())
                    conn.rollback();
                conn.close();
                if (conn == this.conn.get())
                    this.conn.set(nil);
            )
            catch (SQLException e)
            (§
                throw new RuntimeException(e);
            )
        )
        allConnections.clear();
    )

    ;;;
     ; <p>Check if a tables exists within the database.</p>
     ;
     ; <p>This specifically checks for the 'settings' table and
     ; if it exists makes an assumption that the rest of the data
     ; structures are present.</p>
     ;
     ; @return if the tables exist.
     ; @throws java.sql.SQLException
     ;;
#_private
    boolean tablesExist()
        throws SQLException
    (§
        PreparedStatement ps = nil;
        try
        (§
            ps = conn.get().prepareStatement(getTablesExistSQL());
            ResultSet results = ps.executeQuery();
            results.close();
            return true;
        )
        catch (SQLException _)
        (§
            return false;
        )
        finally
        (§
            if (ps != nil && !ps.isClosed())
                ps.close();
        )
    )

    ;;;
     ; Check that the database is compatible with this version of the {@link DatabaseFullPrunedBlockStore}.
     ; @throws BlockStoreException if the database is not compatible.
     ;;
#_private
    void checkCompatibility()
        throws SQLException, BlockStoreException
    (§
        for (String sql : getCompatibilitySQL())
        (§
            PreparedStatement ps = nil;
            try
            (§
                ps = conn.get().prepareStatement(sql);
                ResultSet results = ps.executeQuery();
                results.close();
            )
            catch (SQLException e)
            (§
                throw new BlockStoreException("Database block store is not compatible with the current release.  See bitcoinj release notes for further information: " + e.getMessage());
            )
            finally
            (§
                if (ps != nil && !ps.isClosed())
                    ps.close();
            )
        )
    )

    ;;;
     ; Create the tables in the database.
     ; @throws java.sql.SQLException if there is a database error.
     ; @throws BlockStoreException if the block store could not be created.
     ;;
#_private
    void createTables()
        throws SQLException, BlockStoreException
    (§
        Statement s = conn.get().createStatement();
        ;; Create all the database tables.
        for (String sql : getCreateTablesSQL())
        (§
            if (log.isDebugEnabled())
                log.debug("DatabaseFullPrunedBlockStore : CREATE table [SQL= {0}]", sql);
            s.executeUpdate(sql);
        )
        ;; Create all the database indexes.
        for (String sql : getCreateIndexesSQL())
        (§
            if (log.isDebugEnabled())
                log.debug("DatabaseFullPrunedBlockStore : CREATE index [SQL= {0}]", sql);
            s.executeUpdate(sql);
        )
        s.close();

        ;; Insert the initial settings for this store.
        PreparedStatement ps = conn.get().prepareStatement(getInsertSettingsSQL());
        ps.setString(1, CHAIN_HEAD_SETTING);
        ps.setNull(2, Types.BINARY);
        ps.execute();
        ps.setString(1, VERIFIED_CHAIN_HEAD_SETTING);
        ps.setNull(2, Types.BINARY);
        ps.execute();
        ps.setString(1, VERSION_SETTING);
        ps.setBytes(2, "03".getBytes());
        ps.execute();
        ps.close();

        createNewStore(params);
    )

    ;;;
     ; Create a new store for the given {@link org.bitcoinj.core.NetworkParameters}.
     ; @param params The network.
     ; @throws BlockStoreException if the store couldn't be created.
     ;;
#_private
    void createNewStore(NetworkParameters params)
        throws BlockStoreException
    (§
        try
        (§
            ;; Set up the genesis block.  When we start out fresh, it is by definition the top of the chain.
            StoredBlock storedGenesisHeader = new StoredBlock(params.getGenesisBlock().cloneAsHeader(), params.getGenesisBlock().getWork(), 0);
            ;; The coinbase in the genesis block is not spendable.  This is because of how Bitcoin Core inits
            ;; its database - the genesis transaction isn't actually in the db so its spent flags can never be updated.
            List<Transaction> genesisTransactions = Lists.newLinkedList();
            StoredUndoableBlock storedGenesis = new StoredUndoableBlock(params.getGenesisBlock().getHash(), genesisTransactions);
            put(storedGenesisHeader, storedGenesis);
            setChainHead(storedGenesisHeader);
            setVerifiedChainHead(storedGenesisHeader);
        )
        catch (VerificationException e)
        (§
            throw new RuntimeException(e); ;; Cannot happen.
        )
    )

    ;;;
     ; Initialise the store state from the database.
     ; @throws java.sql.SQLException if there is a database error.
     ; @throws BlockStoreException if there is a block store error.
     ;;
#_private
    void initFromDatabase()
        throws SQLException, BlockStoreException
    (§
        PreparedStatement ps = conn.get().prepareStatement(getSelectSettingsSQL());
        ResultSet rs;
        ps.setString(1, CHAIN_HEAD_SETTING);
        rs = ps.executeQuery();
        if (!rs.next())
            throw new BlockStoreException("corrupt database block store - no chain head pointer");

        Sha256Hash hash = Sha256Hash.wrap(rs.getBytes(1));
        rs.close();
        this.chainHeadBlock = get(hash);
        this.chainHeadHash = hash;
        if (this.chainHeadBlock == nil)
            throw new BlockStoreException("corrupt database block store - head block not found");

        ps.setString(1, VERIFIED_CHAIN_HEAD_SETTING);
        rs = ps.executeQuery();
        if (!rs.next())
            throw new BlockStoreException("corrupt database block store - no verified chain head pointer");

        hash = Sha256Hash.wrap(rs.getBytes(1));
        rs.close();
        ps.close();
        this.verifiedChainHeadBlock = get(hash);
        this.verifiedChainHeadHash = hash;
        if (this.verifiedChainHeadBlock == nil)
            throw new BlockStoreException("corrupt database block store - verified head block not found");
    )

#_protected
    void putUpdateStoredBlock(StoredBlock storedBlock, boolean wasUndoable)
        throws SQLException
    (§
        try
        (§
            PreparedStatement ps = conn.get().prepareStatement(getInsertHeadersSQL());
            ;; We skip the first 4 bytes because (on mainnet) the minimum target has 4 0-bytes.
            byte[] hashBytes = new byte[28];
            System.arraycopy(storedBlock.getHeader().getHash().getBytes(), 4, hashBytes, 0, 28);
            ps.setBytes(1, hashBytes);
            ps.setBytes(2, storedBlock.getChainWork().toByteArray());
            ps.setInt(3, storedBlock.getHeight());
            ps.setBytes(4, storedBlock.getHeader().cloneAsHeader().unsafeBitcoinSerialize());
            ps.setBoolean(5, wasUndoable);
            ps.executeUpdate();
            ps.close();
        )
        catch (SQLException e)
        (§
            ;; It is possible we try to add a duplicate StoredBlock if we upgraded.
            ;; In that case, we just update the entry to mark it wasUndoable.
            if  (!(e.getSQLState().equals(getDuplicateKeyErrorCode())) || !wasUndoable)
                throw e;

            PreparedStatement ps = conn.get().prepareStatement(getUpdateHeadersSQL());
            ps.setBoolean(1, true);
            ;; We skip the first 4 bytes because (on mainnet) the minimum target has 4 0-bytes.
            byte[] hashBytes = new byte[28];
            System.arraycopy(storedBlock.getHeader().getHash().getBytes(), 4, hashBytes, 0, 28);
            ps.setBytes(2, hashBytes);
            ps.executeUpdate();
            ps.close();
        )
    )

#_override
#_public
    void put(StoredBlock storedBlock)
        throws BlockStoreException
    (§
        maybeConnect();
        try
        (§
            putUpdateStoredBlock(storedBlock, false);
        )
        catch (SQLException e)
        (§
            throw new BlockStoreException(e);
        )
    )

#_override
#_public
    void put(StoredBlock storedBlock, StoredUndoableBlock undoableBlock)
        throws BlockStoreException
    (§
        maybeConnect();
        ;; We skip the first 4 bytes because (on mainnet) the minimum target has 4 0-bytes.
        byte[] hashBytes = new byte[28];
        System.arraycopy(storedBlock.getHeader().getHash().getBytes(), 4, hashBytes, 0, 28);
        int height = storedBlock.getHeight();
        byte[] transactions = nil;
        byte[] txOutChanges = nil;
        try
        (§
            ByteArrayOutputStream bos = new ByteArrayOutputStream();
            if (undoableBlock.getTxOutChanges() != nil)
            (§
                undoableBlock.getTxOutChanges().serializeToStream(bos);
                txOutChanges = bos.toByteArray();
            )
            else
            (§
                int numTxn = undoableBlock.getTransactions().size();
                bos.write(0xff & numTxn);
                bos.write(0xff & (numTxn >> 8));
                bos.write(0xff & (numTxn >> 16));
                bos.write(0xff & (numTxn >> 24));
                for (Transaction tx : undoableBlock.getTransactions())
                    tx.bitcoinSerialize(bos);
                transactions = bos.toByteArray();
            )
            bos.close();
        )
        catch (IOException e)
        (§
            throw new BlockStoreException(e);
        )

        try
        (§
            try
            (§
                PreparedStatement ps = conn.get().prepareStatement(getInsertUndoableBlocksSQL());
                ps.setBytes(1, hashBytes);
                ps.setInt(2, height);
                if (transactions == nil)
                (§
                    ps.setBytes(3, txOutChanges);
                    ps.setNull(4, Types.BINARY);
                )
                else
                (§
                    ps.setNull(3, Types.BINARY);
                    ps.setBytes(4, transactions);
                )
                ps.executeUpdate();
                ps.close();
                try
                (§
                    putUpdateStoredBlock(storedBlock, true);
                )
                catch (SQLException e)
                (§
                    throw new BlockStoreException(e);
                )
            )
            catch (SQLException e)
            (§
                if (!e.getSQLState().equals(getDuplicateKeyErrorCode()))
                    throw new BlockStoreException(e);

                ;; There is probably an update-or-insert statement, but it wasn't obvious from the docs.
                PreparedStatement ps = conn.get().prepareStatement(getUpdateUndoableBlocksSQL());
                ps.setBytes(3, hashBytes);
                if (transactions == nil)
                (§
                    ps.setBytes(1, txOutChanges);
                    ps.setNull(2, Types.BINARY);
                )
                else
                (§
                    ps.setNull(1, Types.BINARY);
                    ps.setBytes(2, transactions);
                )
                ps.executeUpdate();
                ps.close();
            )
        )
        catch (SQLException e)
        (§
            throw new BlockStoreException(e);
        )
    )

#_public
    StoredBlock get(Sha256Hash hash, boolean wasUndoableOnly)
        throws BlockStoreException
    (§
        ;; Optimize for chain head.
        if (chainHeadHash != nil && chainHeadHash.equals(hash))
            return chainHeadBlock;

        if (verifiedChainHeadHash != nil && verifiedChainHeadHash.equals(hash))
            return verifiedChainHeadBlock;

        maybeConnect();
        PreparedStatement ps = nil;
        try
        (§
            ps = conn.get().prepareStatement(getSelectHeadersSQL());
            ;; We skip the first 4 bytes because (on mainnet) the minimum target has 4 0-bytes.
            byte[] hashBytes = new byte[28];
            System.arraycopy(hash.getBytes(), 4, hashBytes, 0, 28);
            ps.setBytes(1, hashBytes);
            ResultSet results = ps.executeQuery();
            if (!results.next())
                return nil;

            ;; Parse it.
            if (wasUndoableOnly && !results.getBoolean(4))
                return nil;

            BigInteger chainWork = new BigInteger(results.getBytes(1));
            int height = results.getInt(2);
            Block b = params.getDefaultSerializer().makeBlock(results.getBytes(3));
            b.verifyHeader();
            StoredBlock stored = new StoredBlock(b, chainWork, height);
            return stored;
        )
        catch (SQLException e)
        (§
            throw new BlockStoreException(e);
        )
        catch (ProtocolException e)
        (§
            ;; Corrupted database.
            throw new BlockStoreException(e);
        )
        catch (VerificationException e)
        (§
            ;; Should not be able to happen unless the database contains bad blocks.
            throw new BlockStoreException(e);
        )
        finally
        (§
            if (ps != nil)
            (§
                try
                (§
                    ps.close();
                )
                catch (SQLException _)
                (§
                    throw new BlockStoreException("Failed to close PreparedStatement");
                )
            )
        )
    )

#_override
#_public
    StoredBlock get(Sha256Hash hash)
        throws BlockStoreException
    (§
        return get(hash, false);
    )

#_override
#_public
    StoredBlock getOnceUndoableStoredBlock(Sha256Hash hash)
        throws BlockStoreException
    (§
        return get(hash, true);
    )

#_override
#_public
    StoredUndoableBlock getUndoBlock(Sha256Hash hash)
        throws BlockStoreException
    (§
        maybeConnect();
        PreparedStatement ps = nil;
        try
        (§
            ps = conn.get().prepareStatement(getSelectUndoableBlocksSQL());
            ;; We skip the first 4 bytes because (on mainnet) the minimum target has 4 0-bytes.

            byte[] hashBytes = new byte[28];
            System.arraycopy(hash.getBytes(), 4, hashBytes, 0, 28);
            ps.setBytes(1, hashBytes);
            ResultSet results = ps.executeQuery();
            if (!results.next())
                return nil;

            ;; Parse it.
            byte[] txOutChanges = results.getBytes(1);
            byte[] transactions = results.getBytes(2);
            StoredUndoableBlock block;
            if (txOutChanges == nil)
            (§
                int offset = 0;
                int numTxn = (transactions[offset++] & 0xff)
                          | ((transactions[offset++] & 0xff) << 8)
                          | ((transactions[offset++] & 0xff) << 16)
                          | ((transactions[offset++] & 0xff) << 24);
                List<Transaction> transactionList = new LinkedList<>();
                for (int i = 0; i < numTxn; i++)
                (§
                    Transaction tx = params.getDefaultSerializer().makeTransaction(transactions, offset);
                    transactionList.add(tx);
                    offset += tx.getMessageSize();
                )
                block = new StoredUndoableBlock(hash, transactionList);
            )
            else
            (§
                TransactionOutputChanges outChangesObject = new TransactionOutputChanges(new ByteArrayInputStream(txOutChanges));
                block = new StoredUndoableBlock(hash, outChangesObject);
            )
            return block;
        )
        catch (SQLException e)
        (§
            throw new BlockStoreException(e);
        )
        catch (NullPointerException e)
        (§
            ;; Corrupted database.
            throw new BlockStoreException(e);
        )
        catch (ClassCastException e)
        (§
            ;; Corrupted database.
            throw new BlockStoreException(e);
        )
        catch (ProtocolException e)
        (§
            ;; Corrupted database.
            throw new BlockStoreException(e);
        )
        catch (IOException e)
        (§
            ;; Corrupted database.
            throw new BlockStoreException(e);
        )
        finally
        (§
            if (ps != nil)
            (§
                try
                (§
                    ps.close();
                )
                catch (SQLException _)
                (§
                    throw new BlockStoreException("Failed to close PreparedStatement");
                )
            )
        )
    )

#_override
#_public
    StoredBlock getChainHead()
        throws BlockStoreException
    (§
        return chainHeadBlock;
    )

#_override
#_public
    void setChainHead(StoredBlock chainHead)
        throws BlockStoreException
    (§
        Sha256Hash hash = chainHead.getHeader().getHash();
        this.chainHeadHash = hash;
        this.chainHeadBlock = chainHead;
        maybeConnect();
        try
        (§
            PreparedStatement ps = conn.get().prepareStatement(getUpdateSettingsSLQ());
            ps.setString(2, CHAIN_HEAD_SETTING);
            ps.setBytes(1, hash.getBytes());
            ps.executeUpdate();
            ps.close();
        )
        catch (SQLException e)
        (§
            throw new BlockStoreException(e);
        )
    )

#_override
#_public
    StoredBlock getVerifiedChainHead()
        throws BlockStoreException
    (§
        return verifiedChainHeadBlock;
    )

#_override
#_public
    void setVerifiedChainHead(StoredBlock chainHead)
        throws BlockStoreException
    (§
        Sha256Hash hash = chainHead.getHeader().getHash();
        this.verifiedChainHeadHash = hash;
        this.verifiedChainHeadBlock = chainHead;
        maybeConnect();
        try
        (§
            PreparedStatement ps = conn.get().prepareStatement(getUpdateSettingsSLQ());
            ps.setString(2, VERIFIED_CHAIN_HEAD_SETTING);
            ps.setBytes(1, hash.getBytes());
            ps.executeUpdate();
            ps.close();
        )
        catch (SQLException e)
        (§
            throw new BlockStoreException(e);
        )
        if (this.chainHeadBlock.getHeight() < chainHead.getHeight())
            setChainHead(chainHead);
        removeUndoableBlocksWhereHeightIsLessThan(chainHead.getHeight() - fullStoreDepth);
    )

#_private
    void removeUndoableBlocksWhereHeightIsLessThan(int height)
        throws BlockStoreException
    (§
        try
        (§
            PreparedStatement ps = conn.get().prepareStatement(getDeleteUndoableBlocksSQL());
            ps.setInt(1, height);
            if (log.isDebugEnabled())
                log.debug("Deleting undoable undoable block with height <= " + height);
            ps.executeUpdate();
            ps.close();
        )
        catch (SQLException e)
        (§
            throw new BlockStoreException(e);
        )
    )

#_override
#_public
    UTXO getTransactionOutput(Sha256Hash hash, long index)
        throws BlockStoreException
    (§
        maybeConnect();
        PreparedStatement ps = nil;
        try
        (§
            ps = conn.get().prepareStatement(getSelectOpenoutputsSQL());
            ps.setBytes(1, hash.getBytes());
            ;; index is actually an unsigned int
            ps.setInt(2, (int)index);
            ResultSet results = ps.executeQuery();
            if (!results.next())
                return nil;

            ;; Parse it.
            int height = results.getInt(1);
            Coin value = Coin.valueOf(results.getLong(2));
            byte[] scriptBytes = results.getBytes(3);
            boolean coinbase = results.getBoolean(4);
            String address = results.getString(5);
            return new UTXO(hash, index, value, height, coinbase, new Script(scriptBytes), address);
        )
        catch (SQLException e)
        (§
            throw new BlockStoreException(e);
        )
        finally
        (§
            if (ps != nil)
            (§
                try
                (§
                    ps.close();
                )
                catch (SQLException _)
                (§
                    throw new BlockStoreException("Failed to close PreparedStatement");
                )
            )
        )
    )

#_override
#_public
    void addUnspentTransactionOutput(UTXO out)
        throws BlockStoreException
    (§
        maybeConnect();
        PreparedStatement ps = nil;
        try
        (§
            ps = conn.get().prepareStatement(getInsertOpenoutputsSQL());
            ps.setBytes(1, out.getHash().getBytes());
            ;; index is actually an unsigned int
            ps.setInt(2, (int)out.getIndex());
            ps.setInt(3, out.getHeight());
            ps.setLong(4, out.getValue().value);
            ps.setBytes(5, out.getScript().getProgram());
            ps.setString(6, out.getAddress());
            ps.setInt(7, out.getScript().getScriptType().ordinal());
            ps.setBoolean(8, out.isCoinbase());
            ps.executeUpdate();
            ps.close();
        )
        catch (SQLException e)
        (§
            if (!(e.getSQLState().equals(getDuplicateKeyErrorCode())))
                throw new BlockStoreException(e);
        )
        finally
        (§
            if (ps != nil)
            (§
                try
                (§
                    ps.close();
                )
                catch (SQLException e)
                (§
                    throw new BlockStoreException(e);
                )
            )
        )
    )

#_override
#_public
    void removeUnspentTransactionOutput(UTXO out)
        throws BlockStoreException
    (§
        maybeConnect();
        ;; TODO: This should only need one query (maybe a stored procedure).
        if (getTransactionOutput(out.getHash(), out.getIndex()) == nil)
            throw new BlockStoreException("Tried to remove a UTXO from DatabaseFullPrunedBlockStore that it didn't have!");

        try
        (§
            PreparedStatement ps = conn.get().prepareStatement(getDeleteOpenoutputsSQL());
            ps.setBytes(1, out.getHash().getBytes());
            ;; index is actually an unsigned int
            ps.setInt(2, (int)out.getIndex());
            ps.executeUpdate();
            ps.close();
        )
        catch (SQLException e)
        (§
            throw new BlockStoreException(e);
        )
    )

#_override
#_public
    void beginDatabaseBatchWrite()
        throws BlockStoreException
    (§
        maybeConnect();
        if (log.isDebugEnabled())
            log.debug("Starting database batch write with connection: " + conn.get().toString());

        try
        (§
            conn.get().setAutoCommit(false);
        )
        catch (SQLException e)
        (§
            throw new BlockStoreException(e);
        )
    )

#_override
#_public
    void commitDatabaseBatchWrite()
        throws BlockStoreException
    (§
        maybeConnect();
        if (log.isDebugEnabled())
            log.debug("Committing database batch write with connection: " + conn.get().toString());

        try
        (§
            conn.get().commit();
            conn.get().setAutoCommit(true);
        )
        catch (SQLException e)
        (§
            throw new BlockStoreException(e);
        )
    )

#_override
#_public
    void abortDatabaseBatchWrite()
        throws BlockStoreException
    (§
        maybeConnect();
        if (log.isDebugEnabled())
            log.debug("Rollback database batch write with connection: " + conn.get().toString());

        try
        (§
            if (!conn.get().getAutoCommit())
            (§
                conn.get().rollback();
                conn.get().setAutoCommit(true);
            )
            else
            (§
                log.warn("Warning: Rollback attempt without transaction");
            )
        )
        catch (SQLException e)
        (§
            throw new BlockStoreException(e);
        )
    )

#_override
#_public
    boolean hasUnspentOutputs(Sha256Hash hash, int numOutputs)
        throws BlockStoreException
    (§
        maybeConnect();
        PreparedStatement ps = nil;
        try
        (§
            ps = conn.get().prepareStatement(getSelectOpenoutputsCountSQL());
            ps.setBytes(1, hash.getBytes());
            ResultSet results = ps.executeQuery();
            if (!results.next())
                throw new BlockStoreException("Got no results from a COUNT(*) query");

            int count = results.getInt(1);
            return (count != 0);
        )
        catch (SQLException e)
        (§
            throw new BlockStoreException(e);
        )
        finally
        (§
            if (ps != nil)
            (§
                try
                (§
                    ps.close();
                )
                catch (SQLException _)
                (§
                    throw new BlockStoreException("Failed to close PreparedStatement");
                )
            )
        )
    )

#_override
#_public
    NetworkParameters getParams()
    (§
        return params;
    )

    ;;;
     ; Resets the store by deleting the contents of the tables and reinitialising them.
     ; @throws BlockStoreException if the tables couldn't be cleared and initialised.
     ;;
#_public
    void resetStore()
        throws BlockStoreException
    (§
        maybeConnect();
        try
        (§
            deleteStore();
            createTables();
            initFromDatabase();
        )
        catch (SQLException e)
        (§
            throw new RuntimeException(e);
        )
    )

    ;;;
     ; Deletes the store by deleting the tables within the database.
     ; @throws BlockStoreException if tables couldn't be deleted.
     ;;
#_public
    void deleteStore()
        throws BlockStoreException
    (§
        maybeConnect();
        try
        (§
            Statement s = conn.get().createStatement();
            for (String sql : getDropTablesSQL())
                s.execute(sql);
            s.close();
        )
        catch (SQLException e)
        (§
            throw new RuntimeException(e);
        )
    )

    ;;;
     ; Calculate the balance for a coinbase, to-address, or p2sh address.
     ;
     ; <p>The balance {@link org.bitcoinj.store.DatabaseFullPrunedBlockStore#getBalanceSelectSQL()} returns
     ; the balance (summed) as a number, then use calculateClientSide=false.</p>
     ;
     ; <p>The balance {@link org.bitcoinj.store.DatabaseFullPrunedBlockStore#getBalanceSelectSQL()} returns
     ; all the open outputs as stored in the DB (binary), then use calculateClientSide=true.</p>
     ;
     ; @param address The address to calculate the balance of.
     ; @return The balance of the address supplied.  If the address has not been seen,
     ;         or there are no outputs open for this address, the return value is 0.
     ; @throws BlockStoreException if there is an error getting the balance.
     ;;
#_public
    BigInteger calculateBalanceForAddress(Address address)
        throws BlockStoreException
    (§
        maybeConnect();
        PreparedStatement ps = nil;
        try
        (§
            ps = conn.get().prepareStatement(getBalanceSelectSQL());
            ps.setString(1, address.toString());
            ResultSet rs = ps.executeQuery();
            BigInteger balance = BigInteger.ZERO;
            return rs.next() ? BigInteger.valueOf(rs.getLong(1)) : balance;
        )
        catch (SQLException e)
        (§
            throw new BlockStoreException(e);
        )
        finally
        (§
            if (ps != nil)
            (§
                try
                (§
                    ps.close();
                )
                catch (SQLException _)
                (§
                    throw new BlockStoreException("Could not close statement");
                )
            )
        )
    )
)

(ns org.bitcoinj.store #_"FullPrunedBlockStore"
  #_(:require #_[org.bitcoinj.core *]))

;;;
 ; <p>An implementor of FullPrunedBlockStore saves StoredBlock objects to some storage mechanism.</p>
 ;
 ; <p>In addition to keeping track of a chain using {@link StoredBlock}s, it should also keep track of
 ; a second copy of the chain which holds {@link StoredUndoableBlock}s.  In this way, an application can
 ; perform a headers-only initial sync and then use that information to more efficiently download a locally
 ; verified full copy of the block chain.</p>
 ;
 ; <p>A FullPrunedBlockStore should function well as a standard {@link BlockStore} and then be able to
 ; trivially switch to being used as a FullPrunedBlockStore.</p>
 ;
 ; <p>It should store the {@link StoredUndoableBlock}s of a number of recent blocks before verifiedHead.height
 ; and all those after verifiedHead.height.
 ; It is advisable to store any {@link StoredUndoableBlock} which has a height > verifiedHead.height - N.
 ; Because N determines the memory usage, it is recommended that N be customizable.  N should be chosen such
 ; that re-orgs beyond that point are vanishingly unlikely, e.g. a few thousand blocks is a reasonable choice.</p>
 ;
 ; <p>It must store the {@link StoredBlock} of all blocks.</p>
 ;
 ; <p>A FullPrunedBlockStore contains a map of hashes to [Full]StoredBlock.  The hash is the double digest of
 ; the Bitcoin serialization of the block header, <b>not</b> the header with the extra data as well.</p>
 ;
 ; <p>A FullPrunedBlockStore also contains a map of hash+index to UTXO.  Again, the hash is
 ; a standard Bitcoin double-SHA256 hash of the transaction.</p>
 ;
 ; <p>FullPrunedBlockStores are thread safe.</p>
 ;;
#_public
interface FullPrunedBlockStore extends BlockStore
(§
    ;;;
     ; <p>Saves the given {@link StoredUndoableBlock} and {@link StoredBlock}.  Calculates keys from the {@link StoredBlock}.</p>
     ;
     ; <p>Though not required for proper function of a FullPrunedBlockStore, any user of a FullPrunedBlockStore should ensure
     ; that a StoredUndoableBlock for each block up to the fully verified chain head has been added to this block store using
     ; this function (not put(StoredBlock)), so that the ability to perform reorgs is maintained.</p>
     ;
     ; @throws BlockStoreException if there is a problem with the underlying storage layer, such as running out of disk space.
     ;;
    void put(StoredBlock storedBlock, StoredUndoableBlock undoableBlock)
        throws BlockStoreException;

    ;;;
     ; Returns the StoredBlock that was added as a StoredUndoableBlock given a hash.  The returned values block.getHash()
     ; method will be equal to the parameter.  If no such block is found, returns null.
     ;;
    StoredBlock getOnceUndoableStoredBlock(Sha256Hash hash)
        throws BlockStoreException;

    ;;;
     ; Returns a {@link StoredUndoableBlock} whose block.getHash() method will be equal to the parameter.  If no such
     ; block is found, returns null.  Note that this may return null more often than get(Sha256Hash hash) as not all
     ; {@link StoredBlock}s have a {@link StoredUndoableBlock} copy stored as well.
     ;;
    StoredUndoableBlock getUndoBlock(Sha256Hash hash)
        throws BlockStoreException;

    ;;;
     ; Gets a {@link org.bitcoinj.core.UTXO} with the given hash and index, or null if none is found.
     ;;
    UTXO getTransactionOutput(Sha256Hash hash, long index)
        throws BlockStoreException;

    ;;;
     ; Adds a {@link org.bitcoinj.core.UTXO} to the list of unspent TransactionOutputs.
     ;;
    void addUnspentTransactionOutput(UTXO out)
        throws BlockStoreException;

    ;;;
     ; Removes a {@link org.bitcoinj.core.UTXO} from the list of unspent TransactionOutputs.
     ; Note that the coinbase of the genesis block should NEVER be spendable and thus never in the list.
     ; @throws BlockStoreException if there is an underlying storage issue, or out was not in the list.
     ;;
    void removeUnspentTransactionOutput(UTXO out)
        throws BlockStoreException;

    ;;;
     ; True if this store has any unspent outputs from a transaction with a hash equal to the first parameter.
     ; @param numOutputs The number of outputs the given transaction has.
     ;;
    boolean hasUnspentOutputs(Sha256Hash hash, int numOutputs)
        throws BlockStoreException;

    ;;;
     ; Returns the {@link StoredBlock} that represents the top of the chain of greatest total work that has
     ; been fully verified and the point in the chain at which the unspent transaction output set in this
     ; store represents.
     ;;
    StoredBlock getVerifiedChainHead()
        throws BlockStoreException;

    ;;;
     ; Sets the {@link StoredBlock} that represents the top of the chain of greatest total work that has been
     ; fully verified.  It should generally be set after a batch of updates to the transaction unspent output set,
     ; before a call to commitDatabaseBatchWrite.
     ;
     ; If chainHead has a greater height than the non-verified chain head (i.e. that set with
     ; {@link BlockStore#setChainHead}) the non-verified chain head should be set to the one set here.
     ; In this way a class using a FullPrunedBlockStore only in full-verification mode can ignore the regular
     ; {@link BlockStore} functions implemented as a part of a FullPrunedBlockStore.
     ;;
    void setVerifiedChainHead(StoredBlock chainHead)
        throws BlockStoreException;

    ;;;
     ; <p>Begins/Commits/Aborts a database transaction.</p>
     ;
     ; <p>If abortDatabaseBatchWrite() is called by the same thread that called beginDatabaseBatchWrite(),
     ; any data writes between this call and abortDatabaseBatchWrite() made by the same thread
     ; should be discarded.</p>
     ;
     ; <p>Furthermore, any data written after a call to beginDatabaseBatchWrite() should not be readable
     ; by any other threads until commitDatabaseBatchWrite() has been called by this thread.
     ; Multiple calls to beginDatabaseBatchWrite() in any given thread should be ignored and treated as one call.</p>
     ;;
    void beginDatabaseBatchWrite() throws BlockStoreException;
    void commitDatabaseBatchWrite() throws BlockStoreException;
    void abortDatabaseBatchWrite() throws BlockStoreException;
)

(ns org.bitcoinj.store #_"H2FullPrunedBlockStore"
    (:import #_[java.sql *]
             [java.util ArrayList Collections List])
  #_(:require #_[org.bitcoinj.core *]))

;;;
 ; A full pruned block store using the H2 pure-java embedded database.
 ;
 ; Note that because of the heavy delete load on the database, during IBD,
 ; you may see the database files grow quite large (around 1.5G).
 ; H2 automatically frees some space at shutdown, so close()ing the database
 ; decreases the space usage somewhat (to only around 1.3G).
 ;;
#_public
class H2FullPrunedBlockStore extends DatabaseFullPrunedBlockStore
(§
#_private
#_static
#_final
    String H2_DUPLICATE_KEY_ERROR_CODE = "23505";
#_private
#_static
#_final
    String DATABASE_DRIVER_CLASS = "org.h2.Driver";
#_private
#_static
#_final
    String DATABASE_CONNECTION_URL_PREFIX = "jdbc:h2:";

    ;; create table SQL
#_private
#_static
#_final
    String CREATE_SETTINGS_TABLE = "CREATE TABLE settings ( "
            + "name VARCHAR(32) NOT NULL CONSTRAINT settings_pk PRIMARY KEY,"
            + "value BLOB"
            + ")";

#_private
#_static
#_final
    String CREATE_HEADERS_TABLE = "CREATE TABLE headers ( "
            + "hash BINARY(28) NOT NULL CONSTRAINT headers_pk PRIMARY KEY,"
            + "chainwork BLOB NOT NULL,"
            + "height INT NOT NULL,"
            + "header BLOB NOT NULL,"
            + "wasundoable BOOL NOT NULL"
            + ")";

#_private
#_static
#_final
    String CREATE_UNDOABLE_TABLE = "CREATE TABLE undoableblocks ( "
            + "hash BINARY(28) NOT NULL CONSTRAINT undoableblocks_pk PRIMARY KEY,"
            + "height INT NOT NULL,"
            + "txoutchanges BLOB,"
            + "transactions BLOB"
            + ")";

#_private
#_static
#_final
    String CREATE_OPEN_OUTPUT_TABLE = "CREATE TABLE openoutputs ("
            + "hash BINARY(32) NOT NULL,"
            + "index INT NOT NULL,"
            + "height INT NOT NULL,"
            + "value BIGINT NOT NULL,"
            + "scriptbytes BLOB NOT NULL,"
            + "toaddress VARCHAR(35),"
            + "addresstargetable TINYINT,"
            + "coinbase BOOLEAN,"
            + "PRIMARY KEY (hash, index),"
            + ")";

    ;; Some indexes to speed up inserts.
#_private
#_static
#_final
    String CREATE_OUTPUTS_ADDRESS_MULTI_INDEX     = "CREATE INDEX openoutputs_hash_index_height_toaddress_idx ON openoutputs (hash, index, height, toaddress)";
#_private
#_static
#_final
    String CREATE_OUTPUTS_TOADDRESS_INDEX         = "CREATE INDEX openoutputs_toaddress_idx ON openoutputs (toaddress)";
#_private
#_static
#_final
    String CREATE_OUTPUTS_ADDRESSTARGETABLE_INDEX = "CREATE INDEX openoutputs_addresstargetable_idx ON openoutputs (addresstargetable)";
#_private
#_static
#_final
    String CREATE_OUTPUTS_HASH_INDEX              = "CREATE INDEX openoutputs_hash_idx ON openoutputs (hash)";
#_private
#_static
#_final
    String CREATE_UNDOABLE_TABLE_INDEX            = "CREATE INDEX undoableblocks_height_idx ON undoableblocks (height)";

    ;;;
     ; Creates a new H2FullPrunedBlockStore, with given credentials for H2 database.
     ; @param params A copy of the NetworkParameters used.
     ; @param dbName The path to the database on disk.
     ; @param username The username to use in the database.
     ; @param password The username's password to use in the database.
     ; @param fullStoreDepth The number of blocks of history stored in full (something like 1000 is pretty safe).
     ; @throws BlockStoreException if the database fails to open for any reason.
     ;;
#_public
    H2FullPrunedBlockStore(NetworkParameters params, String dbName, String username, String password, int fullStoreDepth)
        throws BlockStoreException
    (§
        super(params, DATABASE_CONNECTION_URL_PREFIX + dbName + ";create=true;LOCK_TIMEOUT=60000;DB_CLOSE_ON_EXIT=FALSE", fullStoreDepth, username, password, nil);
    )

    ;;;
     ; Creates a new H2FullPrunedBlockStore.
     ; @param params A copy of the NetworkParameters used.
     ; @param dbName The path to the database on disk.
     ; @param fullStoreDepth The number of blocks of history stored in full (something like 1000 is pretty safe).
     ; @throws BlockStoreException if the database fails to open for any reason.
     ;;
#_public
    H2FullPrunedBlockStore(NetworkParameters params, String dbName, int fullStoreDepth)
        throws BlockStoreException
    (§
        this(params, dbName, nil, nil, fullStoreDepth);
    )

    ;;;
     ; Creates a new H2FullPrunedBlockStore with the given cache size.
     ; @param params A copy of the NetworkParameters used.
     ; @param dbName The path to the database on disk.
     ; @param fullStoreDepth The number of blocks of history stored in full (something like 1000 is pretty safe).
     ; @param cacheSize The number of kilobytes to dedicate to H2 Cache.  The default value of 16MB (16384) is a safe bet
     ;                  to achieve good performance/cost when importing blocks from disk, past 32MB makes little sense,
     ;                  and below 4MB sees a sharp drop in performance.
     ; @throws BlockStoreException if the database fails to open for any reason.
     ;;
#_public
    H2FullPrunedBlockStore(NetworkParameters params, String dbName, int fullStoreDepth, int cacheSize)
        throws BlockStoreException
    (§
        this(params, dbName, fullStoreDepth);

        try
        (§
            Statement s = conn.get().createStatement();
            s.executeUpdate("SET CACHE_SIZE " + cacheSize);
            s.close();
        )
        catch (SQLException e)
        (§
            throw new BlockStoreException(e);
        )
    )

#_override
#_protected
    String getDuplicateKeyErrorCode()
    (§
        return H2_DUPLICATE_KEY_ERROR_CODE;
    )

#_override
#_protected
    List<String> getCreateTablesSQL()
    (§
        List<String> sql = new ArrayList<>();
        sql.add(CREATE_SETTINGS_TABLE);
        sql.add(CREATE_HEADERS_TABLE);
        sql.add(CREATE_UNDOABLE_TABLE);
        sql.add(CREATE_OPEN_OUTPUT_TABLE);
        return sql;
    )

#_override
#_protected
    List<String> getCreateIndexesSQL()
    (§
        List<String> sql = new ArrayList<>();
        sql.add(CREATE_UNDOABLE_TABLE_INDEX);
        sql.add(CREATE_OUTPUTS_ADDRESS_MULTI_INDEX);
        sql.add(CREATE_OUTPUTS_ADDRESSTARGETABLE_INDEX);
        sql.add(CREATE_OUTPUTS_HASH_INDEX);
        sql.add(CREATE_OUTPUTS_TOADDRESS_INDEX);
        return sql;
    )

#_override
#_protected
    List<String> getCreateSchemeSQL()
    (§
        ;; do nothing
        return Collections.emptyList();
    )

#_override
#_protected
    String getDatabaseDriverClass()
    (§
        return DATABASE_DRIVER_CLASS;
    )
)

(ns org.bitcoinj.store #_"MemoryBlockStore"
    (:import [java.util LinkedHashMap Map])
  #_(:require #_[org.bitcoinj.core *]))

;;;
 ; Keeps {@link org.bitcoinj.core.StoredBlock}s in memory.  Used primarily for unit testing.
 ;;
#_public
class MemoryBlockStore implements BlockStore
(§
#_private
    LinkedHashMap<Sha256Hash, StoredBlock> blockMap = new LinkedHashMap<Sha256Hash, StoredBlock>()
    (§
#_override
#_protected
        boolean removeEldestEntry(Map.Entry<Sha256Hash, StoredBlock> eldest)
        (§
            return (5000 < blockMap.size());
        )
    );
#_private
    StoredBlock chainHead;
#_private
    NetworkParameters params;

#_public
    MemoryBlockStore(NetworkParameters params)
    (§
        ;; Insert the genesis block.
        try
        (§
            Block genesisHeader = params.getGenesisBlock().cloneAsHeader();
            StoredBlock storedGenesis = new StoredBlock(genesisHeader, genesisHeader.getWork(), 0);
            put(storedGenesis);
            setChainHead(storedGenesis);
            this.params = params;
        )
        catch (BlockStoreException e)
        (§
            throw new RuntimeException(e); ;; Cannot happen.
        )
        catch (VerificationException e)
        (§
            throw new RuntimeException(e); ;; Cannot happen.
        )
    )

#_override
#_public
#_synchronized
#_final
    void put(StoredBlock block)
        throws BlockStoreException
    (§
        if (blockMap == nil)
            throw new BlockStoreException("MemoryBlockStore is closed");

        Sha256Hash hash = block.getHeader().getHash();
        blockMap.put(hash, block);
    )

#_override
#_public
#_synchronized
    StoredBlock get(Sha256Hash hash)
        throws BlockStoreException
    (§
        if (blockMap == nil)
            throw new BlockStoreException("MemoryBlockStore is closed");

        return blockMap.get(hash);
    )

#_override
#_public
    StoredBlock getChainHead()
        throws BlockStoreException
    (§
        if (blockMap == nil)
            throw new BlockStoreException("MemoryBlockStore is closed");

        return chainHead;
    )

#_override
#_public
#_final
    void setChainHead(StoredBlock chainHead)
        throws BlockStoreException
    (§
        if (blockMap == nil)
            throw new BlockStoreException("MemoryBlockStore is closed");

        this.chainHead = chainHead;
    )

#_override
#_public
    void close()
    (§
        blockMap = nil;
    )

#_override
#_public
    NetworkParameters getParams()
    (§
        return params;
    )
)

(ns org.bitcoinj.store #_"MemoryFullPrunedBlockStore"
    (:import #_[java.util *])
    (:import [com.google.common.base Objects Preconditions]
             [com.google.common.collect Lists])
  #_(:require #_[org.bitcoinj.core *]))

;;;
 ; Used as a key for memory map (to avoid having to think about NetworkParameters,
 ; which is required for {@link TransactionOutPoint}.
 ;;
class StoredTransactionOutPoint
(§
    ;;; Hash of the transaction to which we refer. ;;
    Sha256Hash hash;
    ;;; Which output of that transaction we are talking about. ;;
    long index;

    StoredTransactionOutPoint(Sha256Hash hash, long index)
    (§
        this.hash = hash;
        this.index = index;
    )

    StoredTransactionOutPoint(UTXO out)
    (§
        this.hash = out.getHash();
        this.index = out.getIndex();
    )

    ;;;
     ; The hash of the transaction to which we refer.
     ;;
    Sha256Hash getHash()
    (§
        return hash;
    )

    ;;;
     ; The index of the output in transaction to which we refer.
     ;;
    long getIndex()
    (§
        return index;
    )

#_override
#_public
    int hashCode()
    (§
        return Objects.hashCode(getIndex(), getHash());
    )

#_override
#_public
    String toString()
    (§
        return "Stored transaction out point: " + hash + ":" + index;
    )

#_override
#_public
    boolean equals(Object o)
    (§
        if (this == o)
            return true;
        if (o == nil || getClass() != o.getClass())
            return false;
        StoredTransactionOutPoint other = (StoredTransactionOutPoint)o;
        return (getIndex() == other.getIndex() && Objects.equal(getHash(), other.getHash()));
    )
)

;;;
 ; A HashMap<KeyType, ValueType> that is DB transaction-aware.
 ; This class is not thread-safe.
 ;;
class TransactionalHashMap<KeyType, ValueType>
(§
    ThreadLocal<HashMap<KeyType, ValueType>> tempMap;
    ThreadLocal<HashSet<KeyType>> tempSetRemoved;
#_private
    ThreadLocal<Boolean> inTransaction;

    HashMap<KeyType, ValueType> map;

#_public
    TransactionalHashMap()
    (§
        tempMap = new ThreadLocal<>();
        tempSetRemoved = new ThreadLocal<>();
        inTransaction = new ThreadLocal<>();
        map = new HashMap<>();
    )

#_public
    void beginDatabaseBatchWrite()
    (§
        inTransaction.set(true);
    )

#_public
    void commitDatabaseBatchWrite()
    (§
        if (tempSetRemoved.get() != nil)
            for (KeyType key : tempSetRemoved.get())
                map.remove(key);
        if (tempMap.get() != nil)
            for (Map.Entry<KeyType, ValueType> entry : tempMap.get().entrySet())
                map.put(entry.getKey(), entry.getValue());
        abortDatabaseBatchWrite();
    )

#_public
    void abortDatabaseBatchWrite()
    (§
        inTransaction.set(false);
        tempSetRemoved.remove();
        tempMap.remove();
    )

#_nilable
#_public
    ValueType get(KeyType key)
    (§
        if (Boolean.TRUE.equals(inTransaction.get()))
        (§
            if (tempMap.get() != nil)
            (§
                ValueType value = tempMap.get().get(key);
                if (value != nil)
                    return value;
            )
            if (tempSetRemoved.get() != nil && tempSetRemoved.get().contains(key))
                return nil;
        )
        return map.get(key);
    )

#_public
    List<ValueType> values()
    (§
        List<ValueType> valueTypes = new ArrayList<>();
        for (KeyType keyType : map.keySet())
            valueTypes.add(get(keyType));
        return valueTypes;
    )

#_public
    void put(KeyType key, ValueType value)
    (§
        if (Boolean.TRUE.equals(inTransaction.get()))
        (§
            if (tempSetRemoved.get() != nil)
                tempSetRemoved.get().remove(key);
            if (tempMap.get() == nil)
                tempMap.set(new HashMap<KeyType, ValueType>());
            tempMap.get().put(key, value);
        )
        else
        (§
            map.put(key, value);
        )
    )

#_nilable
#_public
    ValueType remove(KeyType key)
    (§
        if (Boolean.TRUE.equals(inTransaction.get()))
        (§
            ValueType retVal = map.get(key);
            if (retVal != nil)
            (§
                if (tempSetRemoved.get() == nil)
                    tempSetRemoved.set(new HashSet<KeyType>());
                tempSetRemoved.get().add(key);
            )
            if (tempMap.get() != nil)
            (§
                ValueType tempVal = tempMap.get().remove(key);
                if (tempVal != nil)
                    return tempVal;
            )
            return retVal;
        )
        else
        (§
            return map.remove(key);
        )
    )
)

;;;
 ; A Map with multiple key types that is DB per-thread-transaction-aware.
 ; However, this class is not thread-safe.
 ; @param <UniqueKeyType> Is a key that must be unique per object.
 ; @param <MultiKeyType> Is a key that can have multiple values.
 ;;
class TransactionalMultiKeyHashMap<UniqueKeyType, MultiKeyType, ValueType>
(§
    TransactionalHashMap<UniqueKeyType, ValueType> mapValues;
    HashMap<MultiKeyType, Set<UniqueKeyType>> mapKeys;

#_public
    TransactionalMultiKeyHashMap()
    (§
        mapValues = new TransactionalHashMap<>();
        mapKeys = new HashMap<>();
    )

#_public
    void BeginTransaction()
    (§
        mapValues.beginDatabaseBatchWrite();
    )

#_public
    void CommitTransaction()
    (§
        mapValues.commitDatabaseBatchWrite();
    )

#_public
    void AbortTransaction()
    (§
        mapValues.abortDatabaseBatchWrite();
    )

#_nilable
#_public
    ValueType get(UniqueKeyType key)
    (§
        return mapValues.get(key);
    )

#_public
    void put(UniqueKeyType uniqueKey, MultiKeyType multiKey, ValueType value)
    (§
        mapValues.put(uniqueKey, value);
        Set<UniqueKeyType> set = mapKeys.get(multiKey);
        if (set == nil)
        (§
            set = new HashSet<>();
            set.add(uniqueKey);
            mapKeys.put(multiKey, set);
        )
        else
        (§
            set.add(uniqueKey);
        )
    )

#_nilable
#_public
    ValueType removeByUniqueKey(UniqueKeyType key)
    (§
        return mapValues.remove(key);
    )

#_public
    void removeByMultiKey(MultiKeyType key)
    (§
        Set<UniqueKeyType> set = mapKeys.remove(key);
        if (set != nil)
            for (UniqueKeyType uniqueKey : set)
                removeByUniqueKey(uniqueKey);
    )
)

;;;
 ; Keeps {@link StoredBlock}s, {@link StoredUndoableBlock}s and {@link org.bitcoinj.core.UTXO}s in memory.
 ; Used primarily for unit testing.
 ;;
#_public
class MemoryFullPrunedBlockStore implements FullPrunedBlockStore
(§
#_protected
#_static
    class StoredBlockAndWasUndoableFlag
    (§
#_public
        StoredBlock block;
#_public
        boolean wasUndoable;
#_public
        StoredBlockAndWasUndoableFlag(StoredBlock block, boolean wasUndoable) { this.block = block; this.wasUndoable = wasUndoable; }
    )
#_private
    TransactionalHashMap<Sha256Hash, StoredBlockAndWasUndoableFlag> blockMap;
#_private
    TransactionalMultiKeyHashMap<Sha256Hash, Integer, StoredUndoableBlock> fullBlockMap;
    ;; TODO: Use something more suited to remove-heavy use?
#_private
    TransactionalHashMap<StoredTransactionOutPoint, UTXO> transactionOutputMap;
#_private
    StoredBlock chainHead;
#_private
    StoredBlock verifiedChainHead;
#_private
    int fullStoreDepth;
#_private
    NetworkParameters params;

    ;;;
     ; Set up the MemoryFullPrunedBlockStore.
     ; @param params The network parameters of this block store - used to get genesis block.
     ; @param fullStoreDepth The depth of blocks to keep FullStoredBlocks instead of StoredBlocks.
     ;;
#_public
    MemoryFullPrunedBlockStore(NetworkParameters params, int fullStoreDepth)
    (§
        blockMap = new TransactionalHashMap<>();
        fullBlockMap = new TransactionalMultiKeyHashMap<>();
        transactionOutputMap = new TransactionalHashMap<>();
        this.fullStoreDepth = (0 < fullStoreDepth) ? fullStoreDepth : 1;
        ;; Insert the genesis block.
        try
        (§
            StoredBlock storedGenesisHeader = new StoredBlock(params.getGenesisBlock().cloneAsHeader(), params.getGenesisBlock().getWork(), 0);
            ;; The coinbase in the genesis block is not spendable.
            List<Transaction> genesisTransactions = Lists.newLinkedList();
            StoredUndoableBlock storedGenesis = new StoredUndoableBlock(params.getGenesisBlock().getHash(), genesisTransactions);
            put(storedGenesisHeader, storedGenesis);
            setChainHead(storedGenesisHeader);
            setVerifiedChainHead(storedGenesisHeader);
            this.params = params;
        )
        catch (BlockStoreException e)
        (§
            throw new RuntimeException(e); ;; Cannot happen.
        )
        catch (VerificationException e)
        (§
            throw new RuntimeException(e); ;; Cannot happen.
        )
    )

#_override
#_public
#_synchronized
    void put(StoredBlock block)
        throws BlockStoreException
    (§
        Preconditions.checkNotNull(blockMap, "MemoryFullPrunedBlockStore is closed");
        Sha256Hash hash = block.getHeader().getHash();
        blockMap.put(hash, new StoredBlockAndWasUndoableFlag(block, false));
    )

#_override
#_public
#_synchronized
#_final
    void put(StoredBlock storedBlock, StoredUndoableBlock undoableBlock)
        throws BlockStoreException
    (§
        Preconditions.checkNotNull(blockMap, "MemoryFullPrunedBlockStore is closed");
        Sha256Hash hash = storedBlock.getHeader().getHash();
        fullBlockMap.put(hash, storedBlock.getHeight(), undoableBlock);
        blockMap.put(hash, new StoredBlockAndWasUndoableFlag(storedBlock, true));
    )

#_override
#_nilable
#_public
#_synchronized
    StoredBlock get(Sha256Hash hash)
        throws BlockStoreException
    (§
        Preconditions.checkNotNull(blockMap, "MemoryFullPrunedBlockStore is closed");
        StoredBlockAndWasUndoableFlag storedBlock = blockMap.get(hash);
        return (storedBlock != nil) ? storedBlock.block : nil;
    )

#_override
#_nilable
#_public
#_synchronized
    StoredBlock getOnceUndoableStoredBlock(Sha256Hash hash)
        throws BlockStoreException
    (§
        Preconditions.checkNotNull(blockMap, "MemoryFullPrunedBlockStore is closed");
        StoredBlockAndWasUndoableFlag storedBlock = blockMap.get(hash);
        return (storedBlock != nil && storedBlock.wasUndoable) ? storedBlock.block : nil;
    )

#_override
#_nilable
#_public
#_synchronized
    StoredUndoableBlock getUndoBlock(Sha256Hash hash)
        throws BlockStoreException
    (§
        Preconditions.checkNotNull(fullBlockMap, "MemoryFullPrunedBlockStore is closed");
        return fullBlockMap.get(hash);
    )

#_override
#_public
#_synchronized
    StoredBlock getChainHead()
        throws BlockStoreException
    (§
        Preconditions.checkNotNull(blockMap, "MemoryFullPrunedBlockStore is closed");
        return chainHead;
    )

#_override
#_public
#_synchronized
#_final
    void setChainHead(StoredBlock chainHead)
        throws BlockStoreException
    (§
        Preconditions.checkNotNull(blockMap, "MemoryFullPrunedBlockStore is closed");
        this.chainHead = chainHead;
    )

#_override
#_public
#_synchronized
    StoredBlock getVerifiedChainHead()
        throws BlockStoreException
    (§
        Preconditions.checkNotNull(blockMap, "MemoryFullPrunedBlockStore is closed");
        return verifiedChainHead;
    )

#_override
#_public
#_synchronized
#_final
    void setVerifiedChainHead(StoredBlock chainHead)
        throws BlockStoreException
    (§
        Preconditions.checkNotNull(blockMap, "MemoryFullPrunedBlockStore is closed");
        this.verifiedChainHead = chainHead;
        if (this.chainHead.getHeight() < chainHead.getHeight())
            setChainHead(chainHead);
        ;; Potential leak here if not all blocks get setChainHead'd.
        ;; Though the FullPrunedBlockStore allows for this, the current AbstractBlockChain will not do it.
        fullBlockMap.removeByMultiKey(chainHead.getHeight() - fullStoreDepth);
    )

#_override
#_public
    void close()
    (§
        blockMap = nil;
        fullBlockMap = nil;
        transactionOutputMap = nil;
    )

#_override
#_nilable
#_public
#_synchronized
    UTXO getTransactionOutput(Sha256Hash hash, long index)
        throws BlockStoreException
    (§
        Preconditions.checkNotNull(transactionOutputMap, "MemoryFullPrunedBlockStore is closed");
        return transactionOutputMap.get(new StoredTransactionOutPoint(hash, index));
    )

#_override
#_public
#_synchronized
    void addUnspentTransactionOutput(UTXO out)
        throws BlockStoreException
    (§
        Preconditions.checkNotNull(transactionOutputMap, "MemoryFullPrunedBlockStore is closed");
        transactionOutputMap.put(new StoredTransactionOutPoint(out), out);
    )

#_override
#_public
#_synchronized
    void removeUnspentTransactionOutput(UTXO out)
        throws BlockStoreException
    (§
        Preconditions.checkNotNull(transactionOutputMap, "MemoryFullPrunedBlockStore is closed");
        if (transactionOutputMap.remove(new StoredTransactionOutPoint(out)) == nil)
            throw new BlockStoreException("Tried to remove a UTXO from MemoryFullPrunedBlockStore that it didn't have!");
    )

#_override
#_public
#_synchronized
    void beginDatabaseBatchWrite()
        throws BlockStoreException
    (§
        blockMap.beginDatabaseBatchWrite();
        fullBlockMap.BeginTransaction();
        transactionOutputMap.beginDatabaseBatchWrite();
    )

#_override
#_public
#_synchronized
    void commitDatabaseBatchWrite()
        throws BlockStoreException
    (§
        blockMap.commitDatabaseBatchWrite();
        fullBlockMap.CommitTransaction();
        transactionOutputMap.commitDatabaseBatchWrite();
    )

#_override
#_public
#_synchronized
    void abortDatabaseBatchWrite()
        throws BlockStoreException
    (§
        blockMap.abortDatabaseBatchWrite();
        fullBlockMap.AbortTransaction();
        transactionOutputMap.abortDatabaseBatchWrite();
    )

#_override
#_public
#_synchronized
    boolean hasUnspentOutputs(Sha256Hash hash, int numOutputs)
        throws BlockStoreException
    (§
        for (int i = 0; i < numOutputs; i++)
            if (getTransactionOutput(hash, i) != nil)
                return true;
        return false;
    )

#_override
#_public
    NetworkParameters getParams()
    (§
        return params;
    )
)

(ns org.bitcoinj.store #_"PostgresFullPrunedBlockStore"
    (:import [java.io ByteArrayOutputStream IOException]
             [java.sql PreparedStatement ResultSet SQLException Types]
             [java.util ArrayList List])
    (:import [org.slf4j Logger LoggerFactory])
  #_(:require #_[org.bitcoinj.core *]))

;;;
 ; <p>A full pruned block store using the Postgres database engine.  As an added bonus an address index is calculated,
 ; so you can use {@link #calculateBalanceForAddress(org.bitcoinj.core.Address)} to quickly look up
 ; the quantity of bitcoins controlled by that address.</p>
 ;;
#_public
class PostgresFullPrunedBlockStore extends DatabaseFullPrunedBlockStore
(§
#_private
#_static
#_final
    Logger log = LoggerFactory.getLogger(PostgresFullPrunedBlockStore.class);

#_private
#_static
#_final
    String POSTGRES_DUPLICATE_KEY_ERROR_CODE = "23505";
#_private
#_static
#_final
    String DATABASE_DRIVER_CLASS = "org.postgresql.Driver";
#_private
#_static
#_final
    String DATABASE_CONNECTION_URL_PREFIX = "jdbc:postgresql://";

    ;; create table SQL
#_private
#_static
#_final
    String CREATE_SETTINGS_TABLE = "CREATE TABLE settings (\n" +
            "    name character varying(32) NOT NULL,\n" +
            "    value bytea,\n" +
            "    CONSTRAINT setting_pk PRIMARY KEY (name)\n" +
            ")\n";

#_private
#_static
#_final
    String CREATE_HEADERS_TABLE = "CREATE TABLE headers (\n" +
            "    hash bytea NOT NULL,\n" +
            "    chainwork bytea NOT NULL,\n" +
            "    height integer NOT NULL,\n" +
            "    header bytea NOT NULL,\n" +
            "    wasundoable boolean NOT NULL,\n" +
            "    CONSTRAINT headers_pk PRIMARY KEY (hash)\n" +
            ")\n";

#_private
#_static
#_final
    String CREATE_UNDOABLE_TABLE = "CREATE TABLE undoableblocks (\n" +
            "    hash bytea NOT NULL,\n" +
            "    height integer NOT NULL,\n" +
            "    txoutchanges bytea,\n" +
            "    transactions bytea,\n" +
            "    CONSTRAINT undoableblocks_pk PRIMARY KEY (hash)\n" +
            ")\n";

#_private
#_static
#_final
    String CREATE_OPEN_OUTPUT_TABLE = "CREATE TABLE openoutputs (\n" +
            "    hash bytea NOT NULL,\n" +
            "    index integer NOT NULL,\n" +
            "    height integer NOT NULL,\n" +
            "    value bigint NOT NULL,\n" +
            "    scriptbytes bytea NOT NULL,\n" +
            "    toaddress character varying(35),\n" +
            "    addresstargetable smallint,\n" +
            "    coinbase boolean,\n" +
            "    CONSTRAINT openoutputs_pk PRIMARY KEY (hash,index)\n" +
            ")\n";

    ;; Some indexes to speed up inserts.
#_private
#_static
#_final
    String CREATE_OUTPUTS_ADDRESS_MULTI_INDEX     = "CREATE INDEX openoutputs_hash_index_num_height_toaddress_idx ON openoutputs USING btree (hash, index, height, toaddress)";
#_private
#_static
#_final
    String CREATE_OUTPUTS_TOADDRESS_INDEX         = "CREATE INDEX openoutputs_toaddress_idx ON openoutputs USING btree (toaddress)";
#_private
#_static
#_final
    String CREATE_OUTPUTS_ADDRESSTARGETABLE_INDEX = "CREATE INDEX openoutputs_addresstargetable_idx ON openoutputs USING btree (addresstargetable)";
#_private
#_static
#_final
    String CREATE_OUTPUTS_HASH_INDEX              = "CREATE INDEX openoutputs_hash_idx ON openoutputs USING btree (hash)";
#_private
#_static
#_final
    String CREATE_UNDOABLE_TABLE_INDEX            = "CREATE INDEX undoableblocks_height_idx ON undoableBlocks USING btree (height)";

#_private
#_static
#_final
    String SELECT_UNDOABLEBLOCKS_EXISTS_SQL       = "select 1 from undoableblocks where hash = ?";

    ;;;
     ; Creates a new PostgresFullPrunedBlockStore.
     ;
     ; @param params A copy of the NetworkParameters used.
     ; @param fullStoreDepth The number of blocks of history stored in full (something like 1000 is pretty safe).
     ; @param hostname The hostname of the database to connect to.
     ; @param dbName The database to connect to.
     ; @param username The database username.
     ; @param password The password to the database.
     ; @throws BlockStoreException if the database fails to open for any reason.
     ;;
#_public
    PostgresFullPrunedBlockStore(NetworkParameters params, int fullStoreDepth, String hostname, String dbName, String username, String password)
        throws BlockStoreException
    (§
        super(params, DATABASE_CONNECTION_URL_PREFIX + hostname + "/" + dbName, fullStoreDepth, username, password, nil);
    )

    ;;;
     ; <p>Create a new PostgresFullPrunedBlockStore, storing the tables in the schema specified.  You may want to
     ; specify a schema to avoid name collisions, or just to keep the database better organized.  The schema is not
     ; required, and if one is not provided than the default schema for the username will be used.  See
     ; <a href="http://www.postgres.org/docs/9.3/static/ddl-schemas.html">the postgres schema docs</a>
     ; for more on schemas.</p>
     ;
     ; @param params A copy of the NetworkParameters used.
     ; @param fullStoreDepth The number of blocks of history stored in full (something like 1000 is pretty safe).
     ; @param hostname The hostname of the database to connect to.
     ; @param dbName The database to connect to.
     ; @param username The database username.
     ; @param password The password to the database.
     ; @param schemaName The name of the schema to put the tables in.  May be null if no schema is being used.
     ; @throws BlockStoreException if the database fails to open for any reason.
     ;;
#_public
    PostgresFullPrunedBlockStore(NetworkParameters params, int fullStoreDepth, String hostname, String dbName, String username, String password, #_nilable String schemaName)
        throws BlockStoreException
    (§
        super(params, DATABASE_CONNECTION_URL_PREFIX + hostname + "/" + dbName, fullStoreDepth, username, password, schemaName);
    )

#_override
#_protected
    String getDuplicateKeyErrorCode()
    (§
        return POSTGRES_DUPLICATE_KEY_ERROR_CODE;
    )

#_override
#_protected
    List<String> getCreateTablesSQL()
    (§
        List<String> sql = new ArrayList<>();
        sql.add(CREATE_SETTINGS_TABLE);
        sql.add(CREATE_HEADERS_TABLE);
        sql.add(CREATE_UNDOABLE_TABLE);
        sql.add(CREATE_OPEN_OUTPUT_TABLE);
        return sql;
    )

#_override
#_protected
    List<String> getCreateIndexesSQL()
    (§
        List<String> sql = new ArrayList<>();
        sql.add(CREATE_UNDOABLE_TABLE_INDEX);
        sql.add(CREATE_OUTPUTS_ADDRESS_MULTI_INDEX);
        sql.add(CREATE_OUTPUTS_ADDRESSTARGETABLE_INDEX);
        sql.add(CREATE_OUTPUTS_HASH_INDEX);
        sql.add(CREATE_OUTPUTS_TOADDRESS_INDEX);
        return sql;
    )

#_override
#_protected
    List<String> getCreateSchemeSQL()
    (§
        List<String> sql = new ArrayList<>();
        sql.add("CREATE SCHEMA IF NOT EXISTS " + schemaName);
        sql.add("set search_path to '" + schemaName +"'");
        return sql;
    )

#_override
#_protected
    String getDatabaseDriverClass()
    (§
        return DATABASE_DRIVER_CLASS;
    )

#_override
#_public
    void put(StoredBlock storedBlock, StoredUndoableBlock undoableBlock)
        throws BlockStoreException
    (§
        maybeConnect();
        ;; We skip the first 4 bytes because (on mainnet) the minimum target has 4 0-bytes.
        byte[] hashBytes = new byte[28];
        System.arraycopy(storedBlock.getHeader().getHash().getBytes(), 4, hashBytes, 0, 28);
        int height = storedBlock.getHeight();
        byte[] transactions = nil;
        byte[] txOutChanges = nil;
        try
        (§
            ByteArrayOutputStream bos = new ByteArrayOutputStream();
            if (undoableBlock.getTxOutChanges() != nil)
            (§
                undoableBlock.getTxOutChanges().serializeToStream(bos);
                txOutChanges = bos.toByteArray();
            )
            else
            (§
                int numTxn = undoableBlock.getTransactions().size();
                bos.write(0xff & numTxn);
                bos.write(0xff & (numTxn >> 8));
                bos.write(0xff & (numTxn >> 16));
                bos.write(0xff & (numTxn >> 24));
                for (Transaction tx : undoableBlock.getTransactions())
                    tx.bitcoinSerialize(bos);
                transactions = bos.toByteArray();
            )
            bos.close();
        )
        catch (IOException e)
        (§
            throw new BlockStoreException(e);
        )

        try
        (§
            if (log.isDebugEnabled())
                log.debug("Looking for undoable block with hash: " + Utils.HEX.encode(hashBytes));

            PreparedStatement findS = conn.get().prepareStatement(SELECT_UNDOABLEBLOCKS_EXISTS_SQL);
            findS.setBytes(1, hashBytes);

            ResultSet rs = findS.executeQuery();
            if (rs.next())
            (§
                ;; We already have this output, update it.
                findS.close();

                ;; Postgres insert-or-updates are very complex (and finnicky).
                ;; This level of transaction isolation seems to work for bitcoinj.
                PreparedStatement ps = conn.get().prepareStatement(getUpdateUndoableBlocksSQL());
                ps.setBytes(3, hashBytes);

                if (log.isDebugEnabled())
                    log.debug("Updating undoable block with hash: " + Utils.HEX.encode(hashBytes));

                if (transactions == nil)
                (§
                    ps.setBytes(1, txOutChanges);
                    ps.setNull(2, Types.BINARY);
                )
                else
                (§
                    ps.setNull(1, Types.BINARY);
                    ps.setBytes(2, transactions);
                )
                ps.executeUpdate();
                ps.close();

                return;
            )

            PreparedStatement ps = conn.get().prepareStatement(getInsertUndoableBlocksSQL());
            ps.setBytes(1, hashBytes);
            ps.setInt(2, height);

            if (log.isDebugEnabled())
                log.debug("Inserting undoable block with hash: " + Utils.HEX.encode(hashBytes)  + " at height " + height);

            if (transactions == nil)
            (§
                ps.setBytes(3, txOutChanges);
                ps.setNull(4, Types.BINARY);
            )
            else
            (§
                ps.setNull(3, Types.BINARY);
                ps.setBytes(4, transactions);
            )
            ps.executeUpdate();
            ps.close();
            try
            (§
                putUpdateStoredBlock(storedBlock, true);
            )
            catch (SQLException e)
            (§
                throw new BlockStoreException(e);
            )
        )
        catch (SQLException e)
        (§
            if (!e.getSQLState().equals(POSTGRES_DUPLICATE_KEY_ERROR_CODE))
                throw new BlockStoreException(e);
        )
    )
)

(ns org.bitcoinj.store #_"SPVBlockStore"
    (:import #_[java.io *]
             #_[java.nio *]
             #_[java.nio.channels *]
             #_[java.util *]
             #_[java.util.concurrent.locks *])
    (:import [com.google.common.base Charsets Preconditions]
             #_[org.slf4j *])
  #_(:require #_[org.bitcoinj.core *]
             #_[org.bitcoinj.utils *]))

;; TODO: Lose the mmap in this class.  There are too many platform bugs that require odd workarounds.

;;;
 ; An SPVBlockStore holds a limited number of block headers in a memory mapped ring buffer.  With such a store,
 ; you may not be able to process very deep re-orgs and could be disconnected from the chain (requiring a replay),
 ; but as they are virtually unheard of this is not a significant risk.
 ;;
#_public
class SPVBlockStore implements BlockStore
(§
#_private
#_static
#_final
    Logger log = LoggerFactory.getLogger(SPVBlockStore.class);

    ;;; The default number of headers that will be stored in the ring buffer. ;;
#_public
#_static
#_final
    int DEFAULT_CAPACITY = 5000;
#_public
#_static
#_final
    String HEADER_MAGIC = "SPVB";

#_protected
#_volatile
    MappedByteBuffer buffer;
#_protected
#_final
    int capacity;
#_protected
#_final
    NetworkParameters params;

#_protected
    ReentrantLock lock = Threading.lock("SPVBlockStore");

    ;; The entire ring-buffer is mmapped and accessing it should be as fast as accessing regular memory once it's
    ;; faulted in.  Unfortunately, in theory practice and theory are the same.  In practice they aren't.
    ;;
    ;; MMapping a file in Java does not give us a byte[] as you may expect but rather a ByteBuffer, and whilst on
    ;; the OpenJDK/Oracle JVM calls into the get() methods are compiled down to inlined native code on Android each
    ;; get() call is actually a full-blown JNI method under the hood, meaning it's unbelievably slow.  The caches
    ;; below let us stay in the JIT-compiled Java world without expensive JNI transitions and make a 10x difference!
#_protected
    LinkedHashMap<Sha256Hash, StoredBlock> blockCache = new LinkedHashMap<Sha256Hash, StoredBlock>()
    (§
#_override
#_protected
        boolean removeEldestEntry(Map.Entry<Sha256Hash, StoredBlock> entry)
        (§
            return (2050 < size()); ;; Slightly more than the difficulty transition period.
        )
    );

    ;; Use a separate cache to track get() misses.  This is to efficiently handle the case of an unconnected block
    ;; during chain download.  Each new block will do a get() on the unconnected block so if we haven't seen it yet
    ;; we must efficiently respond.
    ;;
    ;; We don't care about the value in this cache.  It is always notFoundMarker.  Unfortunately LinkedHashSet does
    ;; not provide the removeEldestEntry control.
#_private
#_static
#_final
    Object NOT_FOUND_MARKER = new Object();
#_protected
    LinkedHashMap<Sha256Hash, Object> notFoundCache = new LinkedHashMap<Sha256Hash, Object>()
    (§
#_override
#_protected
        boolean removeEldestEntry(Map.Entry<Sha256Hash, Object> entry)
        (§
            return (100 < size()); ;; This was chosen arbitrarily.
        )
    );

    ;; Used to stop other applications/processes from opening the store.
#_protected
    FileLock fileLock;
#_protected
    RandomAccessFile randomAccessFile;

    ;;;
     ; Creates and initializes an SPV block store that can hold {@link #DEFAULT_CAPACITY} blocks.
     ; Will create the given file if it's missing.  This operation will block on disk.
     ; @param file File to use for the block store.
     ; @throws BlockStoreException if something goes wrong.
     ;;
#_public
    SPVBlockStore(NetworkParameters params, File file)
        throws BlockStoreException
    (§
        this(params, file, DEFAULT_CAPACITY);
    )

    ;;;
     ; Creates and initializes an SPV block store that can hold a given amount of blocks.
     ; Will create the given file if it's missing.  This operation will block on disk.
     ; @param file File to use for the block store.
     ; @param capacity Custom capacity.
     ; @throws BlockStoreException if something goes wrong.
     ;;
#_public
    SPVBlockStore(NetworkParameters params, File file, int capacity)
        throws BlockStoreException
    (§
        Preconditions.checkNotNull(file);
        this.params = Preconditions.checkNotNull(params);
        Preconditions.checkArgument(capacity > 0);

        this.capacity = capacity;
        try
        (§
            boolean exists = file.exists();
            ;; Set up the backing file.
            randomAccessFile = new RandomAccessFile(file, "rw");
            long fileSize = getFileSize(capacity);
            if (!exists)
            (§
                log.info("Creating new SPV block chain file " + file);
                randomAccessFile.setLength(fileSize);
            )
            else if (randomAccessFile.length() != fileSize)
            (§
                throw new BlockStoreException("File size on disk does not match expected size: " + randomAccessFile.length() + " vs " + fileSize);
            )

            FileChannel channel = randomAccessFile.getChannel();
            fileLock = channel.tryLock();
            if (fileLock == nil)
                throw new ChainFileLockedException("Store file is already locked by another process");

            ;; Map it into memory read/write.  The kernel will take care of flushing writes to disk at the most
            ;; efficient times, which may mean that until the map is deallocated the data on disk is randomly
            ;; inconsistent.  However the only process accessing it is us, via this mapping, so our own view will
            ;; always be correct.  Once we establish the mmap the underlying file and channel can go away.  Note
            ;; that the details of mmapping vary between platforms.
            buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, fileSize);

            ;; Check or initialize the header bytes to ensure we don't try to open some random file.
            byte[] header;
            if (exists)
            (§
                header = new byte[4];
                buffer.get(header);
                if (!new String(header, Charsets.US_ASCII).equals(HEADER_MAGIC))
                    throw new BlockStoreException("Header bytes do not equal " + HEADER_MAGIC);
            )
            else
            (§
                initNewStore(params);
            )
        )
        catch (Exception e1)
        (§
            try
            (§
                if (randomAccessFile != nil)
                    randomAccessFile.close();
            )
            catch (IOException e2)
            (§
                throw new BlockStoreException(e2);
            )
            throw new BlockStoreException(e1);
        )
    )

#_private
    void initNewStore(NetworkParameters params)
        throws Exception
    (§
        byte[] header = HEADER_MAGIC.getBytes("US-ASCII");
        buffer.put(header);
        ;; Insert the genesis block.
        lock.lock();
        try
        (§
            setRingCursor(buffer, FILE_PROLOGUE_BYTES);
        )
        finally
        (§
            lock.unlock();
        )
        Block genesis = params.getGenesisBlock().cloneAsHeader();
        StoredBlock storedGenesis = new StoredBlock(genesis, genesis.getWork(), 0);
        put(storedGenesis);
        setChainHead(storedGenesis);
    )

    ;;; Returns the size in bytes of the file that is used to store the chain with the current parameters. ;;
#_public
#_static
#_final
    int getFileSize(int capacity)
    (§
        return RECORD_SIZE * capacity + FILE_PROLOGUE_BYTES; ;; extra kilobyte for stuff
    )

#_override
#_public
    void put(StoredBlock block)
        throws BlockStoreException
    (§
#_final
        MappedByteBuffer buffer = this.buffer;
        if (buffer == nil)
            throw new BlockStoreException("Store closed");

        lock.lock();
        try
        (§
            int cursor = getRingCursor(buffer);
            ;; Wrapped around.
            if (cursor == getFileSize(capacity))
                cursor = FILE_PROLOGUE_BYTES;
            buffer.position(cursor);
            Sha256Hash hash = block.getHeader().getHash();
            notFoundCache.remove(hash);
            buffer.put(hash.getBytes());
            block.serializeCompact(buffer);
            setRingCursor(buffer, buffer.position());
            blockCache.put(hash, block);
        )
        finally
        (§
            lock.unlock();
        )
    )

#_override
#_nilable
#_public
    StoredBlock get(Sha256Hash hash)
        throws BlockStoreException
    (§
#_final
        MappedByteBuffer buffer = this.buffer;
        if (buffer == nil)
            throw new BlockStoreException("Store closed");

        lock.lock();
        try
        (§
            StoredBlock cacheHit = blockCache.get(hash);
            if (cacheHit != nil)
                return cacheHit;
            if (notFoundCache.get(hash) != nil)
                return nil;

            ;; Starting from the current tip of the ring work backwards until we have either
            ;; found the block or wrapped around.
            int cursor = getRingCursor(buffer);
#_final
            int startingPoint = cursor;
#_final
            int fileSize = getFileSize(capacity);
#_final
            byte[] targetHashBytes = hash.getBytes();
            byte[] scratch = new byte[32];
            do
            (§
                cursor -= RECORD_SIZE;
                ;; We hit the start, so wrap around.
                if (cursor < FILE_PROLOGUE_BYTES)
                    cursor = fileSize - RECORD_SIZE;
                ;; Cursor is now at the start of the next record to check, so read the hash and compare it.
                buffer.position(cursor);
                buffer.get(scratch);
                if (Arrays.equals(scratch, targetHashBytes))
                (§
                    ;; Found the target.
                    StoredBlock storedBlock = StoredBlock.deserializeCompact(params, buffer);
                    blockCache.put(hash, storedBlock);
                    return storedBlock;
                )
            )
            while (cursor != startingPoint);

            ;; Not found.
            notFoundCache.put(hash, NOT_FOUND_MARKER);
            return nil;
        )
        catch (ProtocolException e)
        (§
            throw new RuntimeException(e); ;; Cannot happen.
        )
        finally
        (§
            lock.unlock();
        )
    )

#_protected
    StoredBlock lastChainHead;

#_override
#_public
    StoredBlock getChainHead()
        throws BlockStoreException
    (§
#_final
        MappedByteBuffer buffer = this.buffer;
        if (buffer == nil)
            throw new BlockStoreException("Store closed");

        lock.lock();
        try
        (§
            if (lastChainHead == nil)
            (§
                byte[] headHash = new byte[32];
                buffer.position(8);
                buffer.get(headHash);
                Sha256Hash hash = Sha256Hash.wrap(headHash);
                StoredBlock block = get(hash);
                if (block == nil)
                    throw new BlockStoreException("Corrupted block store: could not find chain head: " + hash);

                lastChainHead = block;
            )
            return lastChainHead;
        )
        finally
        (§
            lock.unlock();
        )
    )

#_override
#_public
    void setChainHead(StoredBlock chainHead)
        throws BlockStoreException
    (§
#_final
        MappedByteBuffer buffer = this.buffer;
        if (buffer == nil)
            throw new BlockStoreException("Store closed");

        lock.lock();
        try
        (§
            lastChainHead = chainHead;
            byte[] headHash = chainHead.getHeader().getHash().getBytes();
            buffer.position(8);
            buffer.put(headHash);
        )
        finally
        (§
            lock.unlock();
        )
    )

#_override
#_public
    void close()
        throws BlockStoreException
    (§
        try
        (§
            buffer.force();
            buffer = nil; ;; Allow it to be GCd and the underlying file mapping to go away.
            randomAccessFile.close();
        )
        catch (IOException e)
        (§
            throw new BlockStoreException(e);
        )
    )

#_override
#_public
    NetworkParameters getParams()
    (§
        return params;
    )

#_protected
#_static
#_final
    int RECORD_SIZE = 32 + StoredBlock.COMPACT_SERIALIZED_SIZE; ;; hash

    ;; File format:
    ;;   4 header bytes = "SPVB"
    ;;   4 cursor bytes, which indicate the offset from the first kb where the next block header should be written
    ;;   32 bytes for the hash of the chain head
    ;;
    ;; For each header (128 bytes)
    ;;   32 bytes hash of the header
    ;;   12 bytes of chain work
    ;;    4 bytes of height
    ;;   80 bytes of block header data
#_protected
#_static
#_final
    int FILE_PROLOGUE_BYTES = 1024;

    ;;; Returns the offset from the file start where the latest block should be written (end of prev block). ;;
#_private
    int getRingCursor(ByteBuffer buffer)
    (§
        int c = buffer.getInt(4);
        Preconditions.checkState(FILE_PROLOGUE_BYTES <= c, "Integer overflow");
        return c;
    )

#_private
    void setRingCursor(ByteBuffer buffer, int newCursor)
    (§
        Preconditions.checkArgument(0 <= newCursor);
        buffer.putInt(4, newCursor);
    )
)

(ns org.bitcoinj.uri #_"BitcoinURI"
    (:import [java.io UnsupportedEncodingException]
             [java.net URI URISyntaxException URLDecoder]
             [java.util ArrayList Collections LinkedHashMap List Locale Map])
    (:import [com.google.common.base Preconditions])
  #_(:require [org.bitcoinj.core Address AddressFormatException Coin NetworkParameters]
             [org.bitcoinj.params AbstractBitcoinNetParams]))

;;;
 ; <p>Provides a standard implementation of a Bitcoin URI with support for the following:</p>
 ;
 ; <ul>
 ; <li>URLEncoded URIs (as passed in by IE on the command line)</li>
 ; <li>BIP21 names (including the "req-" prefix handling requirements)</li>
 ; </ul>
 ;
 ; <h2>Accepted formats</h2>
 ;
 ; <p>The following input forms are accepted:</p>
 ;
 ; <ul>
 ; <li>{@code bitcoin:<address>}</li>
 ; <li>{@code bitcoin:<address>?<name1>=<value1>&<name2>=<value2>} with multiple additional name/value pairs</li>
 ; </ul>
 ;
 ; <p>The name/value pairs are processed as follows.</p>
 ; <ol>
 ; <li>URL encoding is stripped and treated as UTF-8</li>
 ; <li>names prefixed with {@code req-} are treated as required and if unknown or conflicting cause a parse exception</li>
 ; <li>Unknown names not prefixed with {@code req-} are added to a Map, accessible by parameter name</li>
 ; <li>Known names not prefixed with {@code req-} are processed unless they are malformed</li>
 ; </ol>
 ;
 ; <p>The following names are known and have the following formats:</p>
 ; <ul>
 ; <li>{@code amount} decimal value to 8 dp (e.g. 0.12345678) <b>Note that the exponent notation is not supported any more.</b></li>
 ; <li>{@code label} any URL encoded alphanumeric</li>
 ; <li>{@code message} any URL encoded alphanumeric</li>
 ; </ul>
 ;
 ; @author Andreas Schildbach (initial code)
 ; @author Jim Burton (enhancements for MultiBit)
 ; @author Gary Rowe (BIP21 support)
 ; @see <a href="https://github.com/bitcoin/bips/blob/master/bip-0021.mediawiki">BIP 0021</a>
 ;;
#_public
class BitcoinURI
(§
    ;; Not worth turning into an enum.
#_public
#_static
#_final
    String FIELD_MESSAGE = "message";
#_public
#_static
#_final
    String FIELD_LABEL = "label";
#_public
#_static
#_final
    String FIELD_AMOUNT = "amount";
#_public
#_static
#_final
    String FIELD_ADDRESS = "address";
#_public
#_static
#_final
    String FIELD_PAYMENT_REQUEST_URL = "r";

    ;;;
     ; URI for Bitcoin network.  Use {@link org.bitcoinj.params.AbstractBitcoinNetParams#BITCOIN_SCHEME}
     ; if you specifically need Bitcoin, or use {@link org.bitcoinj.core.NetworkParameters#getUriScheme}
     ; to get the scheme from network parameters.
     ;;
#_deprecated
#_public
#_static
#_final
    String BITCOIN_SCHEME = "bitcoin";
#_private
#_static
#_final
    String ENCODED_SPACE_CHARACTER = "%20";
#_private
#_static
#_final
    String AMPERSAND_SEPARATOR = "&";
#_private
#_static
#_final
    String QUESTION_MARK_SEPARATOR = "?";

    ;;;
     ; Contains all the parameters in the order in which they were processed.
     ;;
#_private
#_final
    Map<String, Object> parameterMap = new LinkedHashMap<>();

    ;;;
     ; Constructs a new BitcoinURI from the given string.  Can be for any network.
     ;
     ; @param uri The raw URI data to be parsed (see class comments for accepted formats).
     ; @throws BitcoinURIParseException if the URI is not syntactically or semantically valid.
     ;;
#_public
    BitcoinURI(String uri)
        throws BitcoinURIParseException
    (§
        this(nil, uri);
    )

    ;;;
     ; Constructs a new object by trying to parse the input as a valid Bitcoin URI.
     ;
     ; @param params The network parameters that determine which network the URI is from, or null if you
     ;               don't have any expectation about what network the URI is for and wish to check yourself.
     ; @param input The raw URI data to be parsed (see class comments for accepted formats).
     ;
     ; @throws BitcoinURIParseException if the input fails Bitcoin URI syntax and semantic checks.
     ;;
#_public
    BitcoinURI(#_nilable NetworkParameters params, String input)
        throws BitcoinURIParseException
    (§
        Preconditions.checkNotNull(input);

        String scheme = (params != nil) ? params.getUriScheme() : AbstractBitcoinNetParams.BITCOIN_SCHEME;

        ;; Attempt to form the URI (fail fast syntax checking to official standards).
        URI uri;
        try
        (§
            uri = new URI(input);
        )
        catch (URISyntaxException e)
        (§
            throw new BitcoinURIParseException("Bad URI syntax", e);
        )

        ;; URI is formed as  bitcoin:<address>?<query parameters>
        ;; blockchain.info generates URIs of non-BIP compliant form bitcoin://address?....
        ;; We support both until Ben fixes his code.

        ;; Remove the bitcoin scheme.
        ;; (Note: getSchemeSpecificPart() is not used as it unescapes the label and parse then fails.
        ;; For instance with  bitcoin:129mVqKUmJ9uwPxKJBnNdABbuaaNfho4Ha?amount=0.06&label=Tom%20%26%20Jerry
        ;; the & (%26) in Tom and Jerry gets interpreted as a separator and the label then gets parsed
        ;; as 'Tom ' instead of 'Tom & Jerry'.)
        String blockchainInfoScheme = scheme + "://";
        String correctScheme = scheme + ":";
        String schemeSpecificPart;
        if (input.startsWith(blockchainInfoScheme))
            schemeSpecificPart = input.substring(blockchainInfoScheme.length());
        else if (input.startsWith(correctScheme))
            schemeSpecificPart = input.substring(correctScheme.length());
        else
            throw new BitcoinURIParseException("Unsupported URI scheme: " + uri.getScheme());

        ;; Split off the address from the rest of the query parameters.
        String[] addressSplitTokens = schemeSpecificPart.split("\\?", 2);
        if (addressSplitTokens.length == 0)
            throw new BitcoinURIParseException("No data found after the bitcoin: prefix");

        String addressToken = addressSplitTokens[0]; ;; may be empty!

        String[] nameValuePairTokens;
        if (addressSplitTokens.length == 1)
        (§
            ;; Only an address is specified - use an empty '<name>=<value>' token array.
            nameValuePairTokens = new String[] {};
        )
        else
        (§
            ;; Split into '<name>=<value>' tokens.
            nameValuePairTokens = addressSplitTokens[1].split("&");
        )

        ;; Attempt to parse the rest of the URI parameters.
        parseParameters(params, addressToken, nameValuePairTokens);

        if (!addressToken.isEmpty())
        (§
            ;; Attempt to parse the addressToken as a Bitcoin address for this network.
            try
            (§
                Address address = Address.fromBase58(params, addressToken);
                putWithValidation(FIELD_ADDRESS, address);
            )
            catch (final AddressFormatException e)
            (§
                throw new BitcoinURIParseException("Bad address", e);
            )
        )

        if (addressToken.isEmpty() && getPaymentRequestUrl() == nil)
            throw new BitcoinURIParseException("No address and no r= parameter found");
    )

    ;;;
     ; @param params The network parameters or null.
     ; @param nameValuePairTokens The tokens representing the name value pairs (assumed to be separated by '=' e.g. 'amount=0.2').
     ;;
#_private
    void parseParameters(#_nilable NetworkParameters params, String addressToken, String[] nameValuePairTokens)
        throws BitcoinURIParseException
    (§
        ;; Attempt to decode the rest of the tokens into a parameter map.
        for (String nameValuePairToken : nameValuePairTokens)
        (§
#_final
            int sepIndex = nameValuePairToken.indexOf('=');
            if (sepIndex == -1)
                throw new BitcoinURIParseException("Malformed Bitcoin URI - no separator in '" + nameValuePairToken + "'");
            if (sepIndex == 0)
                throw new BitcoinURIParseException("Malformed Bitcoin URI - empty name '" + nameValuePairToken + "'");

#_final
            String nameToken = nameValuePairToken.substring(0, sepIndex).toLowerCase(Locale.ENGLISH);
#_final
            String valueToken = nameValuePairToken.substring(sepIndex + 1);

            ;; Parse the amount.
            if (FIELD_AMOUNT.equals(nameToken))
            (§
                ;; Decode the amount (contains an optional decimal component to 8dp).
                try
                (§
                    Coin amount = Coin.parseCoin(valueToken);
                    if (params != nil && amount.isGreaterThan(params.getMaxMoney()))
                        throw new BitcoinURIParseException("Max number of coins exceeded");
                    if (amount.signum() < 0)
                        throw new ArithmeticException("Negative coins specified");

                    putWithValidation(FIELD_AMOUNT, amount);
                )
                catch (IllegalArgumentException e)
                (§
                    throw new OptionalFieldValidationException(String.format(Locale.US, "'%s' is not a valid amount", valueToken), e);
                )
                catch (ArithmeticException e)
                (§
                    throw new OptionalFieldValidationException(String.format(Locale.US, "'%s' has too many decimal places", valueToken), e);
                )
            )
            else
            (§
                if (nameToken.startsWith("req-"))
                (§
                    ;; A required parameter that we do not know about.
                    throw new RequiredFieldValidationException("'" + nameToken + "' is required but not known, this URI is not valid");
                )

                ;; Known fields and unknown parameters that are optional.
                try
                (§
                    if (0 < valueToken.length())
                        putWithValidation(nameToken, URLDecoder.decode(valueToken, "UTF-8"));
                )
                catch (UnsupportedEncodingException e)
                (§
                    throw new RuntimeException(e); ;; Can't happen.
                )
            )
        )

        ;; Note to the future:
        ;; when you want to implement 'req-expires', have a look at commit 410a53791841 which had it in.
    )

    ;;;
     ; Put the value against the key in the map checking for duplication.  This avoids address field overwrite etc.
     ;
     ; @param key The key for the map.
     ; @param value The value to store.
     ;;
#_private
    void putWithValidation(String key, Object value)
        throws BitcoinURIParseException
    (§
        if (parameterMap.containsKey(key))
            throw new BitcoinURIParseException(String.format(Locale.US, "'%s' is duplicated, URI is invalid", key));

        parameterMap.put(key, value);
    )

    ;;;
     ; The Bitcoin Address from the URI, if one was present.  It's possible to have Bitcoin URI's with no address
     ; if a r= payment protocol parameter is specified, though this form is not recommended as older wallets
     ; can't understand it.
     ;;
#_nilable
#_public
    Address getAddress()
    (§
        return (Address)parameterMap.get(FIELD_ADDRESS);
    )

    ;;;
     ; @return The amount name encoded using a pure integer value based at 10,000,000 units is 1 BTC.
     ;         May be null if no amount is specified.
     ;;
#_public
    Coin getAmount()
    (§
        return (Coin)parameterMap.get(FIELD_AMOUNT);
    )

    ;;;
     ; @return the label from the URI.
     ;;
#_public
    String getLabel()
    (§
        return (String)parameterMap.get(FIELD_LABEL);
    )

    ;;;
     ; @return the message from the URI.
     ;;
#_public
    String getMessage()
    (§
        return (String)parameterMap.get(FIELD_MESSAGE);
    )

    ;;;
     ; @return the URL where a payment request (as specified in BIP 70) may be fetched.
     ;;
#_public
#_final
    String getPaymentRequestUrl()
    (§
        return (String)parameterMap.get(FIELD_PAYMENT_REQUEST_URL);
    )

    ;;;
     ; Returns the URLs where a payment request (as specified in BIP 70) may be fetched.
     ; The first URL is the main URL, all subsequent URLs are fallbacks.
     ;;
#_public
    List<String> getPaymentRequestUrls()
    (§
        ArrayList<String> urls = new ArrayList<>();
        while (true)
        (§
            int i = urls.size();
            String paramName = FIELD_PAYMENT_REQUEST_URL + (0 < i ? Integer.toString(i) : "");
            String url = (String)parameterMap.get(paramName);
            if (url == nil)
                break;
            urls.add(url);
        )
        Collections.reverse(urls);
        return urls;
    )

    ;;;
     ; @param name The name of the parameter.
     ; @return the parameter value, or null if not present.
     ;;
#_public
    Object getParameterByName(String name)
    (§
        return parameterMap.get(name);
    )

#_override
#_public
    String toString()
    (§
        StringBuilder sb = new StringBuilder("BitcoinURI[");
        boolean first = true;
        for (Map.Entry<String, Object> entry : parameterMap.entrySet())
        (§
            if (first)
                first = false;
            else
                sb.append(",");
            sb.append("'").append(entry.getKey()).append("'=").append("'").append(entry.getValue()).append("'");
        )
        sb.append("]");
        return sb.toString();
    )

    ;;;
     ; Simple Bitcoin URI builder using known good fields.
     ;
     ; @param address The Bitcoin address.
     ; @param amount The amount.
     ; @param label A label.
     ; @param message A message.
     ; @return a String containing the Bitcoin URI.
     ;;
#_public
#_static
    String convertToBitcoinURI(Address address, Coin amount, String label, String message)
    (§
        return convertToBitcoinURI(address.getParameters(), address.toString(), amount, label, message);
    )

    ;;;
     ; Simple Bitcoin URI builder using known good fields.
     ;
     ; @param params The network parameters that determine which network the URI is for.
     ; @param address The Bitcoin address.
     ; @param amount The amount.
     ; @param label A label.
     ; @param message A message.
     ; @return a String containing the Bitcoin URI.
     ;;
#_public
#_static
    String convertToBitcoinURI(NetworkParameters params, String address, #_nilable Coin amount, #_nilable String label, #_nilable String message)
    (§
        Preconditions.checkNotNull(params);
        Preconditions.checkNotNull(address);

        if (amount != nil && amount.signum() < 0)
            throw new IllegalArgumentException("Coin must be positive");

        StringBuilder sb = new StringBuilder();
        String scheme = params.getUriScheme();
        sb.append(scheme).append(":").append(address);

        boolean questionMarkHasBeenOutput = false;

        if (amount != nil)
        (§
            sb.append(QUESTION_MARK_SEPARATOR).append(FIELD_AMOUNT).append("=");
            sb.append(amount.toPlainString());
            questionMarkHasBeenOutput = true;
        )

        if (label != nil && !"".equals(label))
        (§
            if (questionMarkHasBeenOutput)
            (§
                sb.append(AMPERSAND_SEPARATOR);
            )
            else
            (§
                sb.append(QUESTION_MARK_SEPARATOR);
                questionMarkHasBeenOutput = true;
            )
            sb.append(FIELD_LABEL).append("=").append(encodeURLString(label));
        )

        if (message != nil && !"".equals(message))
        (§
            if (questionMarkHasBeenOutput)
            (§
                sb.append(AMPERSAND_SEPARATOR);
            )
            else
            (§
                sb.append(QUESTION_MARK_SEPARATOR);
            )
            sb.append(FIELD_MESSAGE).append("=").append(encodeURLString(message));
        )

        return sb.toString();
    )

    ;;;
     ; Encode a string using URL encoding.
     ;
     ; @param stringToEncode The string to URL encode.
     ;;
#_static
    String encodeURLString(String stringToEncode)
    (§
        try
        (§
            return java.net.URLEncoder.encode(stringToEncode, "UTF-8").replace("+", ENCODED_SPACE_CHARACTER);
        )
        catch (UnsupportedEncodingException e)
        (§
            throw new RuntimeException(e); ;; Can't happen.
        )
    )
)

(ns org.bitcoinj.uri #_"BitcoinURIParseException"
)

;;;
 ; <p>Exception to provide the following to {@link BitcoinURI}:</p>
 ; <ul>
 ; <li>Provision of parsing error messages.</li>
 ; </ul>
 ; <p>This base exception acts as a general failure mode not attributable to a specific cause (other than
 ; that reported in the exception message).  Since this is in English, it may not be worth reporting directly
 ; to the user other than as part of a "general failure to parse" response.</p>
 ;;
#_public
class BitcoinURIParseException extends Exception
(§
#_public
    BitcoinURIParseException(String s)
    (§
        super(s);
    )

#_public
    BitcoinURIParseException(String s, Throwable throwable)
    (§
        super(s, throwable);
    )
)

(ns org.bitcoinj.uri #_"OptionalFieldValidationException"
)

;;;
 ; <p>Exception to provide the following to {@link org.bitcoinj.uri.BitcoinURI}:</p>
 ; <ul>
 ; <li>Provision of parsing error messages.</li>
 ; </ul>
 ; <p>This exception occurs when an optional field is detected (under the Bitcoin URI scheme) and fails
 ; to pass the associated test (such as {@code amount} not being a valid number).</p>
 ;
 ; @since 0.3.0
 ;
 ;;
#_public
class OptionalFieldValidationException extends BitcoinURIParseException
(§
#_public
    OptionalFieldValidationException(String s)
    (§
        super(s);
    )

#_public
    OptionalFieldValidationException(String s, Throwable throwable)
    (§
        super(s, throwable);
    )
)

(ns org.bitcoinj.uri #_"RequiredFieldValidationException"
)

;;;
 ; <p>Exception to provide the following to {@link BitcoinURI}:</p>
 ; <ul>
 ; <li>Provision of parsing error messages.</li>
 ; </ul>
 ; <p>This exception occurs when a required field is detected (under the BIP21 rules) and fails
 ; to pass the associated test (such as {@code req-expires} being out of date), or the required field is unknown
 ; to this version of the client in which case it should fail for security reasons.</p>
 ;
 ; @since 0.3.0
 ;
 ;;
#_public
class RequiredFieldValidationException extends BitcoinURIParseException
(§
#_public
    RequiredFieldValidationException(String s)
    (§
        super(s);
    )

#_public
    RequiredFieldValidationException(String s, Throwable throwable)
    (§
        super(s, throwable);
    )
)

(ns org.bitcoinj.utils #_"BaseTaggableObject"
    (:import [java.util HashMap Map])
    (:import [com.google.common.base Preconditions]
             [com.google.common.collect Maps]
             [com.google.protobuf ByteString]))

;;;
 ; A simple implementation of {@link TaggableObject} that just uses a lazily created hashmap
 ; that is synchronized on this objects Java monitor.
 ;;
#_public
class BaseTaggableObject implements TaggableObject
(§
#_nilable
#_protected
    Map<String, ByteString> tags;

    ;;; {@inheritDoc} ;;
#_override
#_nilable
#_public
#_synchronized
    ByteString maybeGetTag(String tag)
    (§
        return (tags != nil) ? tags.get(tag) : nil;
    )

    ;;; {@inheritDoc} ;;
#_override
#_public
    ByteString getTag(String tag)
    (§
        ByteString b = maybeGetTag(tag);
        if (b == nil)
            throw new IllegalArgumentException("Unknown tag " + tag);
        return b;
    )

    ;;; {@inheritDoc} ;;
#_override
#_public
#_synchronized
    void setTag(String tag, ByteString value)
    (§
        Preconditions.checkNotNull(tag);
        Preconditions.checkNotNull(value);

        if (tags == nil)
            tags = new HashMap<>();
        tags.put(tag, value);
    )

    ;;; {@inheritDoc} ;;
#_override
#_public
#_synchronized
    Map<String, ByteString> getTags()
    (§
        return (tags != nil) ? Maps.newHashMap(tags) : Maps.newHashMap();
    )
)

(ns org.bitcoinj.utils #_"BtcAutoFormat"
    (:import [java.math BigDecimal]
             #_static #_[java.math.BigDecimal ONE]
             #_static #_[java.math.BigDecimal ZERO]
             [java.math BigInteger]
             #_static #_[java.math.RoundingMode HALF_UP]
             [java.text DecimalFormat DecimalFormatSymbols NumberFormat]
             [java.util Locale])
    (:import [com.google.common.collect ImmutableList])
    (:import #_static #_[org.bitcoinj.core.Coin SMALLEST_UNIT_EXPONENT]))

;;;
 ; <p>This class, a concrete extension of {@link BtcFormat}, is distinguished by its
 ; accommodation of multiple denominational units as follows:
 ;
 ; <p>When formatting Bitcoin monetary values, an instance of this class automatically adjusts
 ; the denominational units in which it represents a given value so as to minimize the number
 ; of consecutive zeros in the number that is displayed, and includes either a currency code or
 ; symbol in the formatted value to indicate which denomination was chosen.
 ;
 ; <p>When parsing <code>String</code> representations of Bitcoin monetary values, instances of
 ; this class automatically recognize units indicators consisting of currency codes and
 ; symbols, including including those containing currency or metric prefixes such as
 ; <code>"¢"</code> or <code>"c"</code> to indicate hundredths, and interpret each number being
 ; parsed in accordance with the recognized denominational units.
 ;
 ; <p>A more detailed explanation, including examples, is in the documentation for the {@link
 ; BtcFormat} class, and further information beyond that is in the documentation for the {@link
 ; java.text.Format} class, from which this class descends.
 ;
 ; @see java.text.Format
 ; @see java.text.NumberFormat
 ; @see java.text.DecimalFormat
 ; @see DecimalFormatSymbols
 ; @see org.bitcoinj.core.Coin
 ;;

#_public
#_final
class BtcAutoFormat extends BtcFormat
(§
    ;;;
     ; Enum for specifying the style of currency indicators thas are used
     ; when formatting, ether codes or symbols.
     ;;
#_public
    enum Style
    (§
        ;; Notes:
         ; 1) The odd-looking character in the replacements below, named "currency sign," is used
         ;    in the patterns recognized by Java's number formatter.  A single occurrence of this
         ;    character specifies a currency symbol, while two adjacent occurrences indicate an
         ;    international currency code.
         ; 2) The positive and negative patterns each have three parts: prefix, number, suffix.
         ;    The number characters are limited to digits, zero, decimal-separator, group-separator,
         ;    and scientific-notation specifier: [#0.,E]
         ;    All number characters besides 'E' must be single-quoted in order to appear as
         ;    literals in either the prefix or suffix.
         ; These patterns are explained in the documentation for java.text.DecimalFormat.
         ;;

        ;;; Constant for the formatting style that uses a currency code, e.g. "BTC". ;;
        CODE
        (§
#_override
            void apply(DecimalFormat decimalFormat)
            (§
                ;; To switch to using codes from symbols, we replace each single occurrence of the
                 ; currency-sign character with two such characters in a row.
                 ; We also insert a space character between every occurence of this character and an
                 ; adjacent numerical digit or negative sign (that is, between the currency-sign and
                 ; the signed-number).
                 ;;
                decimalFormat.applyPattern(negify(decimalFormat.toPattern())
                    .replaceAll("¤", "¤¤")
                    .replaceAll("([#0.,E-])¤¤", "$1 ¤¤")
                    .replaceAll("¤¤([0#.,E-])", "¤¤ $1"));
            )
        ),

        ;;; Constant for the formatting style that uses a currency symbol, e.g. "฿". ;;
        SYMBOL
        (§
#_override
            void apply(DecimalFormat decimalFormat)
            (§
                ;; To make certain we are using symbols rather than codes, we replace
                 ; each double occurrence of the currency sign character with a single.
                 ;;
                decimalFormat.applyPattern(negify(decimalFormat.toPattern()).replaceAll("¤¤", "¤"));
            )
        );

        ;;; Effect a style corresponding to an enum value on the given number formatter object. ;;
#_abstract
        void apply(DecimalFormat decimalFormat);
    )

    ;;; Constructor. ;;
#_protected
    BtcAutoFormat(Locale locale, Style style, int fractionPlaces)
    (§
        super((DecimalFormat)NumberFormat.getCurrencyInstance(locale), fractionPlaces, ImmutableList.<Integer>of());

        style.apply(this.numberFormat);
    )

    ;;;
     ; Calculate the appropriate denomination for the given Bitcoin monetary value.
     ; This method takes a BigInteger representing a quantity of satoshis, and returns the
     ; number of places that value's decimal point is to be moved when formatting said value
     ; in order that the resulting number represents the correct quantity of denominational
     ; units.
     ;
     ; <p>As a side-effect, this sets the units indicators of the underlying NumberFormat object.
     ; Only invoke this from a synchronized method, and be sure to put the DecimalFormatSymbols
     ; back to its proper state, otherwise immutability, equals() and hashCode() fail.
     ;;
#_override
#_protected
    int scale(BigInteger satoshis, int fractionPlaces)
    (§
        ;; The algorithm is as follows.  TODO: is there a way to optimize step 4?
         ; 1. Can we use coin denomination w/ no rounding?  If yes, do it.
         ; 2. Else, can we use millicoin denomination w/ no rounding?  If yes, do it.
         ; 3. Else, can we use micro denomination w/ no rounding?  If yes, do it.
         ; 4. Otherwise we must round:
         ;   (a) round to nearest coin + decimals
         ;   (b) round to nearest millicoin + decimals
         ;   (c) round to nearest microcoin + decimals
         ;   Subtract each of (a), (b) and (c) from the true value, and choose the
         ;   denomination that gives smallest absolute difference.  It case of tie,
         ;   use the smaller denomination.
         ;;
        int places;
        int coinOffset = Math.max(SMALLEST_UNIT_EXPONENT - fractionPlaces, 0);
        BigDecimal inCoins = new BigDecimal(satoshis).movePointLeft(coinOffset);
        if (inCoins.remainder(ONE).compareTo(ZERO) == 0)
        (§
            places = COIN_SCALE;
        )
        else
        (§
            BigDecimal inMillis = inCoins.movePointRight(MILLICOIN_SCALE);
            if (inMillis.remainder(ONE).compareTo(ZERO) == 0)
            (§
                places = MILLICOIN_SCALE;
            )
            else
            (§
                BigDecimal inMicros = inCoins.movePointRight(MICROCOIN_SCALE);
                if (inMicros.remainder(ONE).compareTo(ZERO) == 0)
                (§
                    places = MICROCOIN_SCALE;
                )
                else
                (§
                    ;; No way to avoid rounding: so what denomination gives smallest error?
                    BigDecimal a = inCoins.subtract(inCoins.setScale(0, HALF_UP)).movePointRight(coinOffset).abs();
                    BigDecimal b = inMillis.subtract(inMillis.setScale(0, HALF_UP)).movePointRight(coinOffset - MILLICOIN_SCALE).abs();
                    BigDecimal c = inMicros.subtract(inMicros.setScale(0, HALF_UP)).movePointRight(coinOffset - MICROCOIN_SCALE).abs();
                    if (a.compareTo(b) < 0)
                        places = (a.compareTo(c) < 0) ? COIN_SCALE : MICROCOIN_SCALE;
                    else if (b.compareTo(c) < 0)
                        places = MILLICOIN_SCALE;
                    else
                        places = MICROCOIN_SCALE;
                )
            )
        )
        prefixUnitsIndicator(numberFormat, places);
        return places;
    )

    ;;;
     ; Returns the <code>int</code> value indicating coin denomination.  This is what causes
     ; the number in a parsed value that lacks a units indicator to be interpreted as a quantity
     ; of bitcoins.
     ;;
#_override
#_protected
    int scale() { return COIN_SCALE; }

    ;;;
     ; Return the number of decimal places in the fraction part of numbers formatted by this
     ; instance.  This is the maximum number of fraction places that will be displayed;
     ; the actual number used is limited to a precision of satoshis.
     ;;
#_public
    int fractionPlaces() { return minimumFractionDigits; }

    ;;;
     ; Return true if the other instance is equivalent to this one.
     ; Formatters for different locales will never be equal, even if they behave identically.
     ;;
#_override
#_public
    boolean equals(Object o)
    (§
        if (this == o)
            return true;
        if (!(o instanceof BtcAutoFormat))
            return false;
        return super.equals(o);
    )

    ;;;
     ; Return a brief description of this formatter.  The exact details of the representation
     ; are unspecified and subject to change, but will include some representation of the
     ; pattern and the number of fractional decimal places.
     ;;
#_override
#_public
    String toString()
    (§
        return "Auto-format " + pattern();
    )
)

(ns org.bitcoinj.utils #_"BtcFixedFormat"
    (:import [java.math BigInteger]
             [java.text DecimalFormat NumberFormat]
             [java.util Locale List])
    (:import [com.google.common.base Objects Preconditions])
    (:import #_static #_[org.bitcoinj.core.Coin SMALLEST_UNIT_EXPONENT]))

;;;
 ; This class, a concrete extension of {@link BtcFormat}, is distinguished in that each
 ; instance formats and by-default parses all Bitcoin monetary values in units of a single
 ; denomination that is specified at the time that instance is constructed.
 ;
 ; By default, neither currency codes nor symbols are included in formatted values as
 ; output, nor recognized in parsed values as input.  The can be overridden by applying a
 ; custom pattern using either the {@link BtcFormat.Builder#localizedPattern}
 ; or {@link BtcFormat.Builder#localizedPattern} methods, as described in the documentation
 ; for the {@link BtcFormat.Builder} class.
 ;
 ; A more detailed explanation, including examples, is in the documentation for the
 ; {@link BtcFormat} class, and further information beyond that is in the documentation
 ; for the {@link java.text.Format} class, from which this class descends.
 ;
 ; @see java.text.Format
 ; @see java.text.NumberFormat
 ; @see java.text.DecimalFormat
 ; @see org.bitcoinj.core.Coin
 ;;

#_public
#_final
class BtcFixedFormat extends BtcFormat
(§
    ;;;
     ; A constant specifying the use of as many optional decimal places in the fraction part
     ; of a formatted number as are useful for expressing precision.  This value can be passed
     ; as the final argument to a factory method or {@link #format(Object, int, int...)}.
     ;;
#_public
#_static
#_final
    int[] REPEATING_PLACES = {1,1,1,1,1,1,1,1,1,1,1,1,1,1};

    ;;;
     ; A constant specifying the use of as many optional groups of <strong>two</strong>
     ; decimal places in the fraction part of a formatted number as are useful for expressing
     ; precision.  This value can be passed as the final argument to a factory method or
     ; {@link #format(Object, int, int...)}.
     ;;
#_public
#_static
#_final
    int[] REPEATING_DOUBLETS = {2,2,2,2,2,2,2};

    ;;;
     ; A constant specifying the use of as many optional groups of <strong>three</strong>
     ; decimal places in the fraction part of a formatted number as are useful for expressing
     ; precision.  This value can be passed as the final argument to a factory method or
     ; {@link #format(Object, int, int...)}.
     ;;
#_public
#_static
#_final
    int[] REPEATING_TRIPLETS = {3,3,3,3,3};

    ;;;
     ; The number of places the decimal point of formatted values is shifted rightward from
     ; thet same value expressed in bitcoins.
     ;;
#_private
#_final
    int scale;

    ;;; Constructor. ;;
#_protected
    BtcFixedFormat(Locale locale, int scale, int minDecimals, List<Integer> groups)
    (§
        super((DecimalFormat)NumberFormat.getInstance(locale), minDecimals, groups);

        Preconditions.checkArgument(scale <= SMALLEST_UNIT_EXPONENT, "decimal cannot be shifted " + String.valueOf(scale) + " places");

        this.scale = scale;
    )

    ;;;
     ; Return the decimal-place shift for this object's unit-denomination.  For example, if
     ; the denomination is millibitcoins, this method will return the value <code>3</code>.
     ; As a side-effect, prefixes the currency signs of the underlying NumberFormat object.
     ; This method is invoked by the superclass when formatting.  The arguments are ignored
     ; because the denomination is fixed regardless of the value being formatted.
     ;;
#_override
#_protected
    int scale(BigInteger satoshis, int fractionPlaces)
    (§
        prefixUnitsIndicator(numberFormat, scale);
        return scale;
    )

    ;;;
     ; Return the decimal-place shift for this object's fixed unit-denomination.  For example,
     ; if the denomination is millibitcoins, this method will return the value <code>3</code>.
     ;;
#_override
#_public
    int scale() { return scale; }

    ;;;
     ; Return the currency code that identifies the units in which values formatted and
     ; (by-default) parsed by this instance are denominated.  For example, if the formatter's
     ; denomination is millibitcoins, then this method will return <code>"mBTC"</code>,
     ; assuming the default base currency-code is not overridden using a {@link BtcFormat.Builder}.
     ;;
#_public
    String code() { return prefixCode(coinCode(), scale); }

    ;;;
     ; Return the currency symbol that identifies the units in which values formatted by this
     ; instance are denominated.  For example, when invoked on an instance denominated in
     ; millibitcoins, this method by default returns <code>"₥฿"</code>, depending on the
     ; locale.
     ;;
#_public
    String symbol() { return prefixSymbol(coinSymbol(), scale); }

    ;;;
     ; Return the fractional decimal-placing used when formatting.  This method returns an
     ; <code>int</code> array.  The value of the first element is the minimum number of
     ; decimal places to be used in all cases, limited to a precision of satoshis.  The value
     ; of each successive element is the size of an optional place-group that will be applied,
     ; possibly partially, if useful for expressing precision.  The actual size of each group
     ; is limited to, and may be reduced to the limit of, a precision of no smaller than
     ; satoshis.
     ;;
#_public
    int[] fractionPlaceGroups()
    (§
        Object[] boxedArray = decimalGroups.toArray();
        int len = boxedArray.length + 1;
        int[] array = new int[len];
        array[0] = minimumFractionDigits;
        for (int i = 1; i < len; i++)
            array[i] = (Integer)boxedArray[i-1];
        return array;
    )

    ;;;
     ; Return true if the given object is equivalent to this one.  Formatters for different
     ; locales will never be equal, even if they behave identically.
     ;;
#_override
#_public
    boolean equals(Object o)
    (§
        if (o == this)
            return true;
        if (!(o instanceof BtcFixedFormat))
            return false;
        BtcFixedFormat other = (BtcFixedFormat)o;
        return (super.equals(other) && other.scale() == scale() && other.decimalGroups.equals(decimalGroups));
    )

    ;;; Return a hash code value for this instance.
     ;  @see java.lang.Object#hashCode
     ;;
#_override
#_public
    int hashCode()
    (§
        return Objects.hashCode(super.hashCode(), scale);
    )

#_private
#_static
    String prefixLabel(int scale)
    (§
        switch (scale)
        (§
        case COIN_SCALE:      return "Coin-";
        case 1:               return "Decicoin-";
        case 2:               return "Centicoin-";
        case MILLICOIN_SCALE: return "Millicoin-";
        case MICROCOIN_SCALE: return "Microcoin-";
        case -1:              return "Dekacoin-";
        case -2:              return "Hectocoin-";
        case -3:              return "Kilocoin-";
        case -6:              return "Megacoin-";
        default: return "Fixed (" + scale + ") ";
        )
    )

    ;;;
     ; Returns a brief description of this formatter.  The exact details of the representation
     ; are unspecified and subject to change, but will include some representation of the
     ; formatting/parsing pattern and the fractional decimal place grouping.
     ;;
#_override
#_public
    String toString()
    (§
        return prefixLabel(scale) + "format " + pattern();
    )
)

(ns org.bitcoinj.utils #_"BtcFormat"
    (:import [java.math BigDecimal BigInteger]
             #_static #_[java.math.RoundingMode HALF_UP]
             [java.text AttributedCharacterIterator DecimalFormat DecimalFormatSymbols FieldPosition Format NumberFormat ParseException ParsePosition]
             [java.util Locale List ArrayList]
             [java.util.regex Matcher Pattern])
    (:import [com.google.common.base Objects Preconditions Strings]
             [com.google.common.collect ImmutableList])
  #_(:require [org.bitcoinj.core Coin]
             [org.bitcoinj.utils.BtcAutoFormat Style]
             #_static #_[org.bitcoinj.utils.BtcAutoFormat.Style *]))

;;;
 ; <p>Instances of this class format and parse locale-specific numerical representations of Bitcoin monetary values.
 ;
 ; <p>A primary goal of this class is to minimize the danger of human-misreading of monetary values due to mis-counting
 ; the number of zeros (or, more generally, of decimal places) in the number that represents a Bitcoin monetary value.
 ; Some of the features offered for doing this are:
 ; <ol>
 ;   <li>automatic adjustment of denominational units in which a value is represented so as to lessen the number of adjacent zeros,
 ;   <li>use of locale-specific decimal-separators to group digits in the integer portion of formatted numbers,
 ;   <li>fine control over the number and  grouping of fractional decimal places, and
 ;   <li>access to character information that allows for vertical alignment of tabular columns of formatted values.
 ; </ol>
 ;
 ; <h3>Basic Usage</h3>
 ;
 ; Basic usage is very simple:
 ; <ol>
 ;   <li>Construct a new formatter object using one of the factory methods.
 ;   <li>Format a value by passing it as an argument to the {@link BtcFormat#format(Object)} method.
 ;   <li>Parse a value by passing a <code>String</code>-type representation of it to the {@link BtcFormat#parse(String)} method.
 ; </ol>
 ;
 ; <p>For example, depending on your locale, values might be formatted and parsed as follows:
 ;
 ; <blockquote><pre>
 ; BtcFormat f = BtcFormat.getInstance();
 ; String c = f.format(Coin.COIN);                <strong>// "BTC 1.00"</strong>
 ; String k = f.format(Coin.COIN.multiply(1000)); <strong>// "BTC 1,000.00"</strong>
 ; String m = f.format(Coin.COIN.divide(1000));   <strong>// "mBTC 1.00"</strong>
 ; Coin all = f.parseObject("M฿ 21");             <strong>// All the money in the world</strong>
 ; </pre></blockquote>
 ;
 ; <h3>Auto-Denomination versus Fixed-Denomination</h3>
 ;
 ; There are two provided concrete classes, one that automatically denominates values to be formatted, {@link BtcAutoFormat},
 ; and another that formats any value in units of a fixed, specified denomination, {@link BtcFixedFormat}.
 ;
 ; <h5>Automatic Denomination</h5>
 ;
 ; Automatic denomination means that the formatter adjusts the denominational units in which a formatted number is
 ; expressed based on the monetary value that number represents.  An auto-denominating formatter is defined by its
 ; style, specified by one of the enumerated values of {@link BtcAutoFormat.Style}.  There are two styles constants:
 ; {@link BtcAutoFormat.Style#CODE} (the default), and {@link BtcAutoFormat.Style#SYMBOL}.  The difference is that
 ; the <code>CODE</code> style uses an internationally-distinct currency code, such as <code>"BTC"</code>, to indicate
 ; the units of denomination, while the <code>SYMBOL</code> style uses a possibly-ambiguous currency symbol such as
 ; <code>"฿"</code>.
 ;
 ; <p>The denomination used when formatting will be either bitcoin, millicoin or microcoin, depending on the value
 ; being represented, chosen so as to minimize the number of consecutive zeros displayed without losing precision.
 ; For example, depending on the locale, a value of one bitcoin might be formatted as <pre>฿1.00</pre> where a value
 ; exceeding that by one satoshi would be <pre>µ฿1,000,000.01</pre>.
 ;
 ; <h5>Fixed Denomination</h5>
 ;
 ; Fixed denomination means that the same denomination of units is used for every value that is formatted or parsed
 ; by a given formatter instance.  A fixed-denomination formatter is defined by its scale, which is the number of
 ; places one must shift the decimal point in increasing precision to convert the representation of a given quantity
 ; of bitcoins into a representation of the same value denominated in the formatter's units.  For example, a scale
 ; value of <code>3</code> specifies a denomination of millibitcoins, because to represent <code>1.0000 BTC</code>,
 ; or one bitcoin, in millibitcoins, one shifts the decimal point three places, that is, to <code>1000.0 mBTC</code>.
 ;
 ; <h3>Construction</h3>
 ;
 ; There are two ways to obtain an instance of this class:
 ; <ol>
 ;   <li>Use one of the factory methods; or
 ;   <li>Use a {@link BtcFormat.Builder} object.
 ; </ol>
 ;
 ; <p>The factory methods are appropriate for basic use where the default configuration is either used or modified.
 ; The <code>Builder</code> class provides more control over the configuration, and gives access to some features
 ; not available through the factory methods, such as using custom formatting patterns and currency symbols.
 ;
 ; <h5>Factory Methods</h5>
 ;
 ; Although formatting and parsing is performed by one of the concrete subclasses, you can obtain formatters using
 ; the various static factory methods of this abstract base class <code>BtcFormat</code>.  There are a variety of
 ; overloaded methods that allow you to obtain a formatter that behaves according to your needs.
 ;
 ; <p>The primary distinction is between automatic- and fixed-denomination formatters.  By default, the
 ; <code>getInstance()</code> method with no arguments returns a new, automatic-denominating <code>BtcAutoFormat</code>
 ; instance for your default locale that will display exactly two fractional decimal places and a currency code.
 ; For example, if you happen to be in the USA:
 ;
 ; <blockquote><pre>
 ; BtcFormat f = BtcFormat.getInstance();
 ; String s = f.format(Coin.COIN); <strong>// "BTC 1.00"</strong>
 ; </pre></blockquote>
 ;
 ; <p>The first argument to <code>getInstance()</code> can determine whether you get an auto- or fixed-denominating
 ; formatter.  If the type of the first argument is an <code>int</code>, then the value of that <code>int</code>
 ; will be interpreted as the decimal-place scale of the {@link BtcFixedFormat} instance that is returned, and thus
 ; will determine its denomination.  For example, if you want to format values in units of microbitcoins:
 ;
 ; <blockquote><pre>
 ; BtcFormat m = BtcFormat.getInstance(6);
 ; String s = m.format(Coin.COIN); <strong>// "1,000,000.00"</strong>
 ; </pre></blockquote>
 ;
 ; <p>This class provides several constants bound to common scale values:
 ;
 ; <blockquote><pre>
 ; BtcFormat milliFormat = BtcFormat.getInstance(MILLICOIN_SCALE);
 ; </pre></blockquote>
 ;
 ; <p>Alternatively, if the type of the first argument to <code>getInstance()</code> is one of the enumerated values
 ; of the {@link BtcAutoFormat.Style} type, either <code>CODE</code> or <code>SYMBOL</code>, then you will get a
 ; {@link BtcAutoFormat} instance that uses either a currency code or symbol, respectively, to indicate the results
 ; of its auto-denomination.
 ;
 ; <blockquote><pre>
 ; BtcFormat s = BtcFormat.getInstance(SYMBOL);
 ; Coin value = Coin.parseCoin("0.1234");
 ; String mil = s.format(value);              <strong>// "₥฿123.40"</strong>
 ; String mic = s.format(value.divide(1000)); <strong>// "µ฿123.40"</strong>
 ; </pre></blockquote>
 ;
 ; <p>An alternative way to specify whether you want an auto- or fixed-denomination formatter is to use one
 ; of the factory methods that is named to indicate that characteristics of the new instance returned.  For
 ; fixed-denomination formatters, these methods are {@link #getCoinInstance()}, {@link #getMilliInstance()},
 ; and {@link #getMicroInstance()}.  These three methods are equivalent to invoking <code>getInstance()</code>
 ; with a first argument of <code>0</code>, <code>3</code> and <code>6</code>, respectively.  For auto-denominating
 ; formatters the relevant factory methods are {@link #getCodeInstance()} and {@link #getSymbolInstance()},
 ; which are equivalent to <code>getInstance(Style.CODE)</code>, and <code>getInstance(Style.SYMBOL)</code>.
 ;
 ; <p>Regardless of how you specify whether your new formatter is to be of automatic- or fixed-denomination, the
 ; next (and possibly first) parameter to each of the factory methods is an optional <code>Locale</code> value.
 ;
 ; For example, here we construct four instances for the same locale that each format
 ; differently the same one-bitcoin value:
 ;
 ; <blockquote><pre>
 ; <strong>// Next line returns "1,00 BTC"</strong>
 ; BtcFormat.getInstance(Locale.GERMANY).format(Coin.COIN);
 ; <strong>// Next line returns "1,00 ฿"</strong>
 ; BtcFormat.getInstance(SYMBOL, Locale.GERMANY).format(Coin.COIN);
 ; <strong>// Next line returns "1.000,00"</strong>
 ; BtcFormat.getMilliInstance(Locale.GERMANY).format(Coin.COIN);
 ; <strong>// Next line returns "10.000,00"</strong>
 ; BtcFormat.getInstance(4, Locale.GERMANY).format(Coin.COIN);
 ; </pre></blockquote>
 ;
 ; Omitting such a <code>Locale</code> parameter will give you a formatter for your default locale.
 ;
 ; <p>The final (and possibly only) arguments to the factory methods serve to set the default number of
 ; fractional decimal places that will be displayed when formatting monetary values.  In the case of an
 ; auto-denominating formatter, this can be a single <code>int</code> value, which will determine the number
 ; of fractional decimal places to be used in all cases, except where either (1) doing so would provide
 ; a place for fractional satoshis, or (2) that default value is overridden when invoking
 ; the <code>format()</code> method as described below.
 ;
 ; <p>In the case of a fixed-denomination formatter, you can pass any number of <code>int</code> values.
 ; The first will determine the minimum number of fractional decimal places, and each following <code>int</code>
 ; value specifies the size of an optional group of decimal-places to be displayed only if useful for expressing
 ; precision.  As with auto-denominating formatters, numbers will never be formatted with a decimal place that
 ; represents a fractional quantity of satoshis, and these defaults can be overridden by arguments to the
 ; <code>format()</code> method.  See below for examples.
 ;
 ; <h5>The <code>Builder</code> Class</h5>
 ;
 ; A new {@link BtcFormat.Builder} instance is returned by the {@link #builder()} method.  Such an object has
 ; methods that set the configuration parameters of a <code>BtcFormat</code> object.  Its {@link Builder#build()}
 ; method constructs and returns a <code>BtcFormat</code> instance configured according to those settings.
 ;
 ; <p>In addition to setter-methods that correspond to the factory-method parameters explained above,
 ; a <code>Builder</code> also allows you to specify custom formatting and parsing patterns and currency symbols
 ; and codes.  For example, rather than using the default currency symbol, which has the same unicode character
 ; point as the national currency symbol of Thailand, some people prefer to use a capital letter "B" with
 ; a vertical overstrike.
 ;
 ; <blockquote><pre>
 ; BtcFormat.Builder builder = BtcFormat.builder();
 ; builder.style(SYMBOL);
 ; builder.symbol("B&#x5c;u20e6"); <strong>// unicode char "double vertical stroke overlay"</strong>
 ; BtcFormat f = builder.build();
 ; String out = f.format(COIN); <strong>// "B⃦1.00" depending on locale</strong>
 ; </pre></blockquote>
 ;
 ; The <code>Builder</code> methods are chainable.  So, for example, if you are
 ; deferential to ISO 4217, you might construct a formatter in a single line this way:
 ;
 ; <blockquote><pre>
 ; BtcFormat f = BtcFormat.builder().style(CODE).code("XBT").build();
 ; String out = f.format(COIN); <strong>// "XBT 1.00"</strong>
 ; </pre></blockquote>
 ;
 ; <p>See the documentation of the {@link BtcFormat.Builder} class for details.
 ;
 ; <h3>Formatting</h3>
 ;
 ; <p>You format a Bitcoin monetary value by passing it to the {@link BtcFormat#format(Object)} method.  This argument
 ; can be either a {@link org.bitcoinj.core.Coin}-type object or a numerical object such as {@link java.lang.Long} or
 ; {@link java.math.BigDecimal}.  Integer-based types such as {@link java.math.BigInteger} are interpreted as representing
 ; a number of satoshis, while a {@link java.math.BigDecimal} is interpreted as representing a number of bitcoins.
 ; A value having a fractional amount of satoshis is rounded to the nearest whole satoshi at least, and possibly to
 ; a greater unit depending on the number of fractional decimal-places displayed.  The <code>format()</code> method will
 ; not accept an argument whose type is <code>String</code>, <code>Float</code> nor <code>Double</code>.
 ;
 ; <p>Subsequent to the monetary value to be formatted, the {@link #format(Object)} method also accepts as arguments
 ; optional <code>int</code> values that specify the number of decimal places to use to represent the fractional portion
 ; of the number.  This overrides the default, and enables a single formatter instance to be reused, formatting different
 ; values that require different numbers of fractional decimal places.  These parameters have the same meaning as those
 ; that set the default values in the factory methods as described above.  Namely, a single <code>int</code> value determines
 ; the minimum number of fractional decimal places that will be used in all cases, to a precision limit of satoshis.
 ; Instances of {@link BtcFixedFormat} also accept a variable-length sequence of additional <code>int</code> values, each
 ; of which specifies the size of a group of fractional decimal-places to be used in addition to all preceding places, only
 ; if useful to express precision, and only to a maximum precision of satoshis.  For example:
 ;
 ; <blockquote><pre>
 ; BtcFormat f = BtcFormat.getCoinInstance();
 ; Coin value = COIN.add(Coin.valueOf(5)); <strong>// 100000005 satoshis</strong>
 ; f.format(value, 2);       <strong>// "1.00"</strong>
 ; f.format(value, 3);       <strong>// "1.000"</strong>
 ; f.format(value, 2, 3);    <strong>// "1.00" three more zeros doesn't help</strong>
 ; f.format(value, 2, 3, 3); <strong>// "1.00000005" </strong>
 ; f.format(value, 2, 3, 4); <strong>// "1.00000005" fractions of satoshis have no place</strong>
 ; f.format(value, 2, 3, 2); <strong>// "1.0000001" rounds to nearest usable place</strong>
 ; </pre></blockquote>
 ;
 ; <p>Note that if using all the fractional decimal places in a specified group would give a place to fractions of satoshis,
 ; then the size of that group will be reduced to a maximum precision of satoshis.  Either all or none of the allowed decimal
 ; places of that group will still be applied as doing so is useful for expressing the precision of the value being formatted.
 ;
 ; <p>Several convenient constants of repeating group-size sequences are provided: {@link BtcFixedFormat#REPEATING_PLACES},
 ; {@link BtcFixedFormat#REPEATING_DOUBLETS} and {@link BtcFixedFormat#REPEATING_TRIPLETS}.  These signify repeating groups
 ; of one, two and three decimals places, respectively.  For example, to display only as many fractional places as useful
 ; in order to prevent hanging zeros on the least-significant end of formatted numbers:
 ;
 ; <blockquote><pre>
 ; format(value, 0, REPEATING_PLACES);
 ; </pre></blockquote>
 ;
 ; <p>When using an automatically-denominating formatter, you might want to know what denomination was chosen.  You can get
 ; the currency-units indicator, as well as any other field in the formatted output, by using a {@link java.text.FieldPosition}
 ; instance constructed using an appropriate constant from the {@link java.text.NumberFormat.Field} class:
 ;
 ; <blockquote><pre>
 ; BtcFormat de = BtcFormat.getInstance(Locale.GERMANY);
 ; FieldPosition currField = new FieldPosition(NumberFormat.Field.CURRENCY);
 ; <strong>// next line formats the value as "987.654.321,23 µBTC"</strong>
 ; String output = de.format(valueOf(98765432123L), new StringBuffer(), currField);
 ; <strong>// next line sets variable currencyCode to "µBTC"</strong>
 ; String currencyCode = output.substring(currField.getBeginIndex(), currField.getEndIndex()));
 ; </pre></blockquote>
 ;
 ; <p>When using a fixed-denomination formatter whose scale can be expressed as a standard "metric" prefix,
 ; you can invoke the <code>code()</code> and <code>symbol()</code> methods to obtain a <code>String</code>
 ; whose value is the appropriate currency code or symbol, respectively, for that formatter.
 ;
 ; <blockquote><pre>
 ; BtcFixedFormat kilo = (BtcFixedFormat)BtcFormat(-3); <strong>// scale -3 for kilocoins</strong>
 ; Coin value = Coin.parseCoin("1230");
 ; <strong>// variable coded will be set to "kBTC 1.23"</strong>
 ; String coded = kilo.code() + " " + kilo.format(value);
 ; <strong>// variable symbolic will be set to "k฿1.23"</strong>
 ; String symbolic = kilo.symbol() + kilo.format(value);
 ; BtcFormat(4).code(); <strong>// unnamed denomination has no code; raises exception</strong>
 ; </pre></blockquote>
 ;
 ; <h5>Formatting for Tabular Columns</h5>
 ;
 ; When displaying tables of monetary values, you can lessen the risk of human misreading-error by vertically
 ; aligning the decimal separator of those values.  This example demonstrates one way to do that:
 ;
 ; <blockquote><pre>
 ; <strong>// The elements of this array are the values we will format:</strong>
 ; Coin[] rows = { MAX_MONEY, MAX_MONEY.subtract(SATOSHI), Coin.parseCoin("1234"), COIN,
 ;                 COIN.divide(1000), valueOf(10000), valueOf(1000), valueOf(100), SATOSHI };
 ; BtcFormat f = BtcFormat.getCoinInstance(2, REPEATING_PLACES);
 ; FieldPosition fp = new FieldPosition(DECIMAL_SEPARATOR); <strong>// see java.text.NumberFormat.Field</strong>
 ; String[] output = new String[rows.length];
 ; int[] indexes = new int[rows.length];
 ; int maxIndex = 0;
 ; for (int i = 0; i < rows.length; i++)
 ; {
 ;     output[i] = f.format(rows[i], new StringBuffer(), fp).toString();
 ;     indexes[i] = fp.getBeginIndex();
 ;     if (maxIndex < indexes[i])
 ;         maxIndex = indexes[i];
 ; }
 ; for (int i = 0; i < output.length; i++)
 ; {
 ;     System.out.println(repeat(" ", maxIndex - indexes[i]) + output[i]);
 ; }
 ; </pre></blockquote>
 ;
 ; Assuming you are using a monospaced font, and depending on your locale, the foregoing will print the following:
 ;
 ; <blockquote><pre>
 ; 21,000,000.00
 ; 20,999,999.99999999
 ;      1,234.00
 ;          1.00
 ;          0.001
 ;          0.0001
 ;          0.00001
 ;          0.000001
 ;          0.00000001
 ; </pre></blockquote>
 ;
 ; If you need to vertically-align columns printed in a proportional font, then see the documentation
 ; for the {@link java.text.NumberFormat} class for an explanation of how to do that.
 ;
 ; <h3>Parsing</h3>
 ;
 ; <p>The {@link #parse(String)} method accepts a <code>String</code> argument, and returns a {@link Coin}-type value.
 ; The difference in parsing behavior between instances of {@link BtcFixedFormat} and {@link BtcAutoFormat} is analogous
 ; to the difference in formatting behavior between instances of those classes.  Instances of {@link BtcAutoFormat} recognize
 ; currency codes and symbols in the <code>String</code> being parsed, and interpret them as indicators of the units in which
 ; the number being parsed is denominated.  On the other hand, instances of {@link BtcFixedFormat} by default recognize no
 ; codes nor symbols, but rather interpret every number as being denominated in the units that were specified when constructing
 ; the instance doing the parsing.  This default behavior of {@link BtcFixedFormat} can be overridden by setting a parsing
 ; pattern that includes a currency sign using the {@link BtcFormat.Builder#pattern()} method.
 ;
 ; <p>The {@link BtcAutoFormat#parse(String)}</code> method of {@link BtcAutoFormat} (and of {@link BtcAutoFormat} configured
 ; with applicable non-default pattern) will recognize a variety of currency symbols and codes, including all standard
 ; international (metric) prefixes from micro to mega.  For example, denominational units of microcoins may be specified
 ; by <code>µ฿</code>, <code>u฿</code>, <code>µB⃦</code>, <code>µɃ</code>, <code>µBTC</code> or other appropriate permutations
 ; of those characters.  Additionally, if either or both of a custom currency code or symbol is configured using
 ; {@link BtcFormat.Builder#code} or {@link BtcFormat.Builder#code}, then such code or symbol will be recognized in addition
 ; to those recognized by default.
 ;
 ; <p>Instances of this class that recognize currency signs will recognize both currency symbols and codes, regardless of which
 ; that instance uses for formatting.  However, if the style is <code>CODE</code> (and unless overridden by a custom pattern)
 ; then a space character must separate the units indicator from the number.  When parsing with a <code>SYMBOL</code>-style
 ; <code>BtcFormat</code> instance, on the other hand, whether or not the units indicator must be separated by a space from
 ; the number is determined by the locale.  The {@link BtcFormat#pattern()} method returns a representation of the pattern
 ; that can be examined to determine whether a space must separate currency signs from numbers in parsed <code>String</code>s.
 ;
 ; <p>When parsing, if the currency-units indicator is absent, then a {@link BtcAutoFormat} instance will infer a denomination
 ; of bitcoins while a {@link BtcFixedFormat} will infer the denomination in which it expresses formatted values.  Note: by
 ; default (unless overridden by a custom pattern), if the locale or style requires a space to separate the number from the
 ; units indicator, that space must be present in the String to be parsed, even if the units indicator is absent.
 ;
 ; <p>The <code>parse()</code> method returns an instance of the {@link Coin} class.  Therefore, attempting to parse a value
 ; greater than the maximum that a <code>Coin</code> object can represent will raise a <code>ParseException</code>, as will
 ; any other detected parsing error.
 ;
 ; <h3>Limitations</h3>
 ;
 ; <h5>Parsing</h5>
 ;
 ; Parsing is performed by an underlying {@link java.text.NumberFormat} object.  While this delivers the benefit
 ; of recognizing locale-specific patterns, some have criticized other aspects of its behavior.  For example, see
 ; <a href="http://www.ibm.com/developerworks/library/j-numberformat/">this article by Joe Sam Shirah</a>.  In particular,
 ; explicit positive-signs are not recognized.  If you are parsing input from end-users, then you should consider whether
 ; you would benefit from any of the work-arounds mentioned in that article.
 ;
 ; <h5>Exotic Locales</h5>
 ;
 ; This class is not well-tested in locales that use non-ascii character sets, especially those where writing proceeds
 ; from right-to-left.  Helpful feedback in that regard is appreciated.
 ;
 ; <h3>Thread-Safety</h3>
 ;
 ; <p>Instances of this class are immutable.
 ;
 ; @see java.text.Format
 ; @see java.text.NumberFormat
 ; @see java.text.DecimalFormat
 ; @see java.text.DecimalFormatSymbols
 ; @see java.text.FieldPosition
 ; @see org.bitcoinj.core.Coin
 ;;

#_public
#_abstract
class BtcFormat extends Format
(§
    ;; CONCURRENCY NOTES
     ;
     ; There is one mutable member of this class, the `DecimalFormat` object bound to variable `numberFormat`.
     ; The relevant methods invoked on it are: setMinimumFractionDigits(), setMaximumFractionDigits(), and
     ; setDecimalFormatSymbols(), along with the respective getter methods corresponding to each.  The first
     ; two methods are used to set the number of fractional decimal places displayed when formatting, which is
     ; reflected in the patterns returned by the public pattern() and localizedPattern() methods.  The last
     ; method sets the value of that object's member `DecimalFormatSymbols` object for formatting and parsing,
     ; which is also reflected in the aforementioned patterns.  The patterns, which are the passed-through
     ; return values of the DecimalFormat object's toPattern() and toLocalizedPattern() methods, and the value
     ; of the DecimalFormat object's DecimalFormatSymbols member are among the values compared between instances
     ; of this class in determining the return values of the `equals()` and `hashCode()` methods.
     ;
     ; From the foregoing, you can understand that immutability is achieved as follows: access to the variable
     ; `numberFormat` referent's fraction-digits and format-symbols fields are synchronized on that DecimalFormat
     ; object.  The state of those fraction-digits limits and decimal-format symbols must be returned to a static
     ; state after being changed for formatting or parsing since the user can see them reflected in the return
     ; values of above-mentioned methods and because `equals()` and `hashCode()` use them for comparisons.
     ;;

    ;;; The conventional international currency code for bitcoins: "BTC" ;;
#_private
#_static
#_final
    String COIN_CODE = "BTC";
    ;;; The default currency symbols for bitcoins. ;;
#_private
#_static
#_final
    String COIN_SYMBOL = "฿";
    ;;; An alternative currency symbol to use in locales where the default symbol is used for the national currency. ;;
#_protected
#_static
#_final
    String COIN_SYMBOL_ALT = "Ƀ";

#_protected
#_final
    DecimalFormat numberFormat; ;; warning: mutable
#_protected
#_final
    int minimumFractionDigits;
#_protected
#_final
    List<Integer> decimalGroups;

    ;; Scale is the number of decimal-places difference from same value in bitcoins.

    ;;;
     ; A constant useful for specifying a denomination of bitcoins, the <code>int</code> value <code>0</code>.
     ;;
#_public
#_static
#_final
    int COIN_SCALE = 0;

    ;;;
     ; A constant useful for specifying a denomination of millibitcoins, the <code>int</code> value <code>3</code>.
     ;;
#_public
#_static
#_final
    int MILLICOIN_SCALE = 3;

    ;;;
     ; A constant useful for specifying a denomination of microbitcoins, the <code>int</code> value <code>6</code>.
     ;;
#_public
#_static
#_final
    int MICROCOIN_SCALE = 6;

    ;;;
     ; Return the number of decimal places by which any value denominated in the units indicated
     ; by the given scale differs from that same value denominated in satoshis.
     ;;
#_private
#_static
    int offSatoshis(int scale)
    (§
        return Coin.SMALLEST_UNIT_EXPONENT - scale;
    )

#_private
#_static
    Locale defaultLocale()
    (§
        return Locale.getDefault();
    )

    ;;;
     ; <p>This class constructs new instances of {@link BtcFormat}, allowing for the configuration of those instances
     ; before they are constructed.  After obtaining a <code>Builder</code> object from the {@link BtcFormat#builder()}
     ; method, invoke the necessary setter methods to obtain your desired configuration.  Finaly, the {@link #build()}
     ; method returns a new <code>BtcFormat</code> object that has the specified configuration.
     ;
     ; <p>All the setter methods override defaults.  Invoking <code>build()</code> without invoking any of the setting
     ; methods is equivalent to invoking {@link BtcFormat#getInstance()} with no arguments.
     ;
     ; <p>Each setter methods returns the same instance on which it is invoked, thus these methods can be chained.
     ;
     ; <p>Instances of this class are <strong>not</strong> thread-safe.
     ;;
#_public
#_static
    class Builder
    (§
#_private
        enum Variant
        (§
            AUTO
            (§
#_override
                BtcFormat newInstance(Builder b) { return getInstance(b.style, b.locale, b.minimumFractionDigits); }
            ),
            FIXED,
            UNSET;

            BtcFormat newInstance(Builder b)
            (§
                return getInstance(b.scale, b.locale, b.minimumFractionDigits, b.fractionGroups);
            )
        )
        ;; Parameters are initialized to default or unset values.
#_private
        Variant variant = Variant.UNSET;
#_private
        Locale locale = defaultLocale();
#_private
        int minimumFractionDigits = 2;
#_private
        int[] fractionGroups = {};
#_private
        Style style = BtcAutoFormat.Style.CODE;
#_private
        int scale = 0;
#_private
        String symbol = "", code = "", pattern = "", localizedPattern = "";

#_private
        Builder()
        (§
        )

        ;;;
         ; Specify the new <code>BtcFormat</code> is to be automatically-denominating.
         ; The argument determines which of either codes or symbols the new <code>BtcFormat</code>
         ; will use by default to indicate the denominations it chooses when formatting values.
         ;
         ; <p>Note that the <code>Style</code> argument specifies the <em>default</em> style, which is
         ; overridden by invoking either {@link #pattern(String)} or {@link #localizedPattern(String)}.
         ;
         ; @throws IllegalArgumentException if {@link #scale(int)} has previously been invoked on this instance.
         ;;
#_public
        Builder style(BtcAutoFormat.Style val)
        (§
            if (variant == Variant.FIXED)
                throw new IllegalStateException("You cannot invoke both style() and scale()");

            variant = Variant.AUTO;
            style = val;
            return this;
        )

        ;;;
         ; Specify the number of decimal places in the fraction part of formatted numbers.
         ; This is equivalent to the {@link #minimumFractionDigits(int)} method, but named
         ; appropriately for the context of generating {@link BtcAutoFormat} instances.
         ;
         ; <p>If neither this method nor <code>minimumFactionDigits()</code> is invoked,
         ; the default value will be <code>2</code>.
         ;;
#_public
        Builder fractionDigits(int val)
        (§
            return minimumFractionDigits(val);
        )

        ;;;
         ; Specify a fixed-denomination of units to use when formatting and parsing values.
         ; The argument specifies the number of decimal places, in increasing precision, by which
         ; each formatted value will differ from that same value denominated in bitcoins.  For example,
         ; a denomination of millibitcoins is specified with a value of <code>3</code>.
         ;
         ; <p>The <code>BtcFormat</code> class provides appropriately named <code>int</code>-type constants
         ; for the three common values, {@link BtcFormat#COIN_SCALE}, {@link BtcFormat#MILLICOIN_SCALE}
         ; and {@link BtcFormat#MICROCOIN_SCALE}.
         ;
         ; <p>If neither this method nor {@link #style(BtcAutoFormat.Style)} is invoked on a <code>Builder</code>,
         ; then the <code>BtcFormat</code> will default to a fixed-denomination of bitcoins, equivalent
         ; to invoking this method with an argument of <code>0</code>.
         ;;
#_public
        Builder scale(int val)
        (§
            if (variant == Variant.AUTO)
                throw new IllegalStateException("You cannot invoke both scale() and style()");

            variant = Variant.FIXED;
            scale = val;
            return this;
        )

        ;;;
         ; Specify the minimum number of decimal places in the fraction part of formatted values.
         ; This method is equivalent to {@link #fractionDigits(int)}, but named appropriately for
         ; the context of generating a fixed-denomination formatter.
         ;
         ; <p>If neither this method nor <code>fractionDigits()</code> is invoked, the default value
         ; will be <code>2</code>.
         ;;
#_public
        Builder minimumFractionDigits(int val)
        (§
            minimumFractionDigits = val;
            return this;
        )

        ;;;
         ; Specify the sizes of a variable number of optional decimal-place groups in the fraction
         ; part of formatted values.  A group of each specified size will be used in addition to
         ; all previously applied decimal places only if doing so is useful for expressing precision.
         ; The size of each group is limited to a maximum precision of satoshis.
         ;
         ; <p>If this method is not invoked, then the number of fractional decimal places will be limited to
         ; the value passed to {@link #minimumFractionDigits}, or <code>2</code> if that method is not invoked.
         ;;
#_public
        Builder fractionGroups(int... val)
        (§
            fractionGroups = val;
            return this;
        )

        ;;;
         ; Specify the {@link java.util.Locale} for formatting and parsing.
         ; If this method is not invoked, then the runtime default locale will be used.
         ;;
#_public
        Builder locale(Locale val)
        (§
            locale = val;
            return this;
        )

        ;;;
         ; Specify a currency symbol to be used in the denomination-unit indicators of formatted values.
         ; This method only sets the symbol, but does not cause it to be used.  You must also invoke either
         ; <code>style(SYMBOL)</code>, or else apply a custom pattern that includes a single currency-sign
         ; character by invoking either {@link #pattern(String)} or {@link #localizedPattern(String)}.
         ;
         ; <p>Specify only the base symbol.  The appropriate prefix will be applied according to
         ; the denomination of formatted and parsed values.
         ;;
#_public
        Builder symbol(String val)
        (§
            symbol = val;
            return this;
        )

        ;;;
         ; Specify a custom currency code to be used in the denomination-unit indicators of formatted values.
         ; This method only sets the code, but does not cause it to be used.  You must also invoke either
         ; <code>style(CODE)</code>, or else apply a custom pattern that includes a double currency-sign
         ; character by invoking either {@link #pattern(String)} or {@link #localizedPattern(String)}.
         ;
         ; <p>Specify only the base code.  The appropriate prefix will be applied according to
         ; the denomination of formatted and parsed values.
         ;;
#_public
        Builder code(String val)
        (§
            code = val;
            return this;
        )

        ;;;
         ; Use the given pattern when formatting and parsing.  The format of this pattern is identical to
         ; that used by the {@link java.text.DecimalFormat} class.
         ;
         ; <p>If the pattern lacks a negative subpattern, then the formatter will indicate negative values
         ; by placing a minus sign immediately preceding the number part of formatted values.
         ;
         ; <p>Note that while the pattern format specified by the {@link java.text.DecimalFormat} class
         ; includes a mechanism for setting the number of fractional decimal places, that part of the pattern
         ; is ignored.  Instead, use the {@link #fractionDigits(int)}, {@link #minimumFractionDigits(int)}
         ; and {@link #fractionGroups(int...)} methods.
         ;
         ; <p>Warning: if you set a pattern that includes a currency-sign for a fixed-denomination formatter
         ; that uses a non-standard scale, then an exception will be raised when you try to format a value.
         ; The standard scales include all for which a metric prefix exists from micro to mega.
         ;
         ; <p>Note that by applying a pattern you override the configured formatting style of
         ; {@link BtcAutoFormat} instances.
         ;;
#_public
        Builder pattern(String val)
        (§
            if (localizedPattern != "")
                throw new IllegalStateException("You cannot invoke both pattern() and localizedPattern()");

            pattern = val;
            return this;
        )

        ;;;
         ; Use the given localized-pattern for formatting and parsing.  The format of this pattern is identical
         ; to the patterns used by the {@link java.text.DecimalFormat} class.
         ;
         ; <p>The pattern is localized according to the locale of the <code>BtcFormat</code> instance, the symbols
         ; for which can be examined by inspecting the {@link java.text.DecimalFormatSymbols} object returned by
         ; {@link BtcFormat#symbols()}.  So, for example, if you are in Germany, then the non-localized pattern of
         ; <pre>"#,##0.###"</pre> would be localized as <pre>"#.##0,###"</pre>.
         ;
         ; <p>If the pattern lacks a negative subpattern, then the formatter will indicate negative values by
         ; placing a minus sign immediately preceding the number part of formatted values.
         ;
         ; <p>Note that while the pattern format specified by the {@link java.text.DecimalFormat} class includes
         ; a mechanism for setting the number of fractional decimal places, that part of the pattern is ignored.
         ; Instead, use the {@link #fractionDigits(int)}, {@link #minimumFractionDigits(int)} and
         ; {@link #fractionGroups(int...)} methods.
         ;
         ; <p>Warning: if you set a pattern that includes a currency-sign for a fixed-denomination formatter
         ; that uses a non-standard scale, then an exception will be raised when you try to format a value.
         ; The standard scales include all for which a metric prefix exists from micro to mega.
         ;
         ; <p>Note that by applying a pattern you override the configured formatting style of
         ; {@link BtcAutoFormat} instances.
         ;;
#_public
        Builder localizedPattern(String val)
        (§
            if (pattern != "")
                throw new IllegalStateException("You cannot invoke both pattern() and localizedPattern().");

            localizedPattern = val;
            return this;
        )

        ;;;
         ; Return a new {@link BtcFormat} instance.  The object returned will be configured according
         ; to the state of this <code>Builder</code> instance at the time this method is invoked.
         ;;
#_public
        BtcFormat build()
        (§
            BtcFormat f = variant.newInstance(this);
            if (symbol != "" || code != "")
            (§
#_synchronized
                (f.numberFormat)
                (§
                    DecimalFormatSymbols defaultSigns = f.numberFormat.getDecimalFormatSymbols();
                    setSymbolAndCode(f.numberFormat,
                        (symbol != "") ? symbol : defaultSigns.getCurrencySymbol(),
                        (code != "") ? code : defaultSigns.getInternationalCurrencySymbol());
                )
            )
            if (localizedPattern != "" || pattern != "")
            (§
                int places = f.numberFormat.getMinimumFractionDigits();
                if (localizedPattern != "")
                    f.numberFormat.applyLocalizedPattern(negify(localizedPattern));
                else
                    f.numberFormat.applyPattern(negify(pattern));
                f.numberFormat.setMinimumFractionDigits(places);
                f.numberFormat.setMaximumFractionDigits(places);
            )
            return f;
        )
    )

    ;;; Return a new {@link Builder} object.  See the documentation of that class for usage details. ;;
#_public
#_static
    Builder builder() { return new Builder(); }

    ;;; This single constructor is invoked by the overriding subclass constructors. ;;
#_protected
    BtcFormat(DecimalFormat numberFormat, int minDecimals, List<Integer> groups)
    (§
        Preconditions.checkArgument(0 <= minDecimals, "There can be no fewer than zero fractional decimal places");

        this.numberFormat = numberFormat;
        this.numberFormat.setParseBigDecimal(true);
        this.numberFormat.setRoundingMode(HALF_UP);
        this.minimumFractionDigits = minDecimals;
        this.numberFormat.setMinimumFractionDigits(this.minimumFractionDigits);
        this.numberFormat.setMaximumFractionDigits(this.minimumFractionDigits);
        this.decimalGroups = groups;
#_synchronized
        (this.numberFormat)
        (§
            setSymbolAndCode(this.numberFormat, (this.numberFormat.getDecimalFormatSymbols().getCurrencySymbol().contains(COIN_SYMBOL)) ? COIN_SYMBOL_ALT : COIN_SYMBOL, COIN_CODE);
        )
    )

    ;;;
     ; Return a new instance of this class using all defaults.  The returned formatter will auto-denominate
     ; values so as to minimize zeros without loss of precision and display a currency code, for example
     ; "<code>BTC</code>", to indicate that denomination.  The returned object will uses the default locale
     ; for formatting the number and placement of the currency-code.  Two fractional decimal places will
     ; be displayed in all formatted numbers.
     ;;
#_public
#_static
    BtcFormat getInstance() { return getInstance(defaultLocale()); }

    ;;;
     ; Return a new auto-denominating instance that will indicate units using a currency symbol, for example,
     ; <code>"฿"</code>.  Formatting and parsing will be done according to the default locale.
     ;;
#_public
#_static
    BtcFormat getSymbolInstance() { return getSymbolInstance(defaultLocale()); }

    ;;;
     ; Return a new auto-denominating instance that will indicate units using a currency code, for example,
     ; <code>"BTC"</code>.  Formatting and parsing will be done according to the default locale.
     ;;
#_public
#_static
    BtcFormat getCodeInstance() { return getCodeInstance(defaultLocale()); }

    ;;;
     ; Return a new symbol-style auto-formatter with the given number of fractional decimal places.
     ; Denominational units will be indicated using a currency symbol, for example, <code>"฿"</code>.
     ; The returned object will format the fraction-part of numbers using the given number of decimal
     ; places, or fewer as necessary to avoid giving a place to fractional satoshis.  Formatting and
     ; parsing will be done according to the default locale.
     ;;
#_public
#_static
    BtcFormat getSymbolInstance(int fractionPlaces)
    (§
        return getSymbolInstance(defaultLocale(), fractionPlaces);
    )

    ;;;
     ; Return a new code-style auto-formatter with the given number of fractional decimal places.
     ; Denominational units will be indicated using a currency code, for example, <code>"BTC"</code>.
     ; The returned object will format the fraction-part of numbers using the given number of decimal
     ; places, or fewer as necessary to avoid giving a place to fractional satoshis.  Formatting and
     ; parsing will be done according to the default locale.
     ;;
#_public
#_static
    BtcFormat getCodeInstance(int minDecimals)
    (§
        return getCodeInstance(defaultLocale(), minDecimals);
    )

    ;;;
     ; Return a new code-style auto-formatter for the given locale.  The returned object will
     ; select denominational units based on each value being formatted, and will indicate those
     ; units using a currency code, for example, <code>"mBTC"</code>.
     ;;
#_public
#_static
    BtcFormat getInstance(Locale locale) { return getCodeInstance(locale); }

    ;;;
     ; Return a new code-style auto-formatter for the given locale.  The returned object will
     ; select denominational units based on each value being formatted, and will indicate those
     ; units using a currency code, for example, <code>"mBTC"</code>.
     ;;
#_public
#_static
    BtcFormat getCodeInstance(Locale locale) { return getInstance(CODE, locale); }

    ;;;
     ; Return a new code-style auto-formatter for the given locale with the given number of
     ; fraction places.  The returned object will select denominational units based on each
     ; value being formatted, and will indicate those units using a currency code, for example,
     ; <code>"mBTC"</code>.  The returned object will format the fraction-part of numbers using
     ; the given number of decimal places, or fewer as necessary to avoid giving a place to
     ; fractional satoshis.
     ;;
#_public
#_static
    BtcFormat getInstance(Locale locale, int minDecimals)
    (§
        return getCodeInstance(locale, minDecimals);
    )

    ;;;
     ; Return a new code-style auto-formatter for the given locale with the given number of
     ; fraction places.  The returned object will select denominational units based on each
     ; value being formatted, and will indicate those units using a currency code, for example,
     ; <code>"mBTC"</code>.  The returned object will format the fraction-part of numbers using
     ; the given number of decimal places, or fewer as necessary to avoid giving a place to
     ; fractional satoshis.
     ;;
#_public
#_static
    BtcFormat getCodeInstance(Locale locale, int minDecimals)
    (§
        return getInstance(CODE, locale, minDecimals);
    )

    ;;;
     ; Return a new symbol-style auto-formatter for the given locale.  The returned object will
     ; select denominational units based on each value being formatted, and will indicate those
     ; units using a currency symbol, for example, <code>"µ฿"</code>.
     ;;
#_public
#_static
    BtcFormat getSymbolInstance(Locale locale)
    (§
        return getInstance(SYMBOL, locale);
    )

    ;;;
     ; Return a new symbol-style auto-formatter for the given locale with the given number of
     ; fraction places.  The returned object will select denominational units based on each
     ; value being formatted, and will indicate those units using a currency symbol, for example,
     ; <code>"µ฿"</code>.  The returned object will format the fraction-part of numbers using
     ; the given number of decimal places, or fewer as necessary to avoid giving a place to
     ; fractional satoshis.
     ;;
#_public
#_static
    BtcFormat getSymbolInstance(Locale locale, int fractionPlaces)
    (§
        return getInstance(SYMBOL, locale, fractionPlaces);
    )

    ;;;
     ; Return a new auto-denominating formatter.  The returned object will indicate the
     ; denominational units of formatted values using either a currency symbol, such as,
     ; <code>"฿"</code>, or code, such as <code>"mBTC"</code>, depending on the value of
     ; the argument.  Formatting and parsing will be done according to the default locale.
     ;;
#_public
#_static
    BtcFormat getInstance(Style style) { return getInstance(style, defaultLocale()); }

    ;;;
     ; Return a new auto-denominating formatter with the given number of fractional decimal
     ; places.  The returned object will indicate the denominational units of formatted values
     ; using either a currency symbol, such as, <code>"฿"</code>, or code, such as
     ; <code>"mBTC"</code>, depending on the value of the first argument.  The returned object
     ; will format the fraction-part of numbers using the given number of decimal places, or
     ; fewer as necessary to avoid giving a place to fractional satoshis.  Formatting and
     ; parsing will be done according to the default locale.
     ;;
#_public
#_static
    BtcFormat getInstance(Style style, int fractionPlaces)
    (§
        return getInstance(style, defaultLocale(), fractionPlaces);
    )

    ;;;
     ; Return a new auto-formatter with the given style for the given locale.
     ; The returned object that will auto-denominate each formatted value, and will indicate
     ; that denomination using either a currency code, such as "<code>BTC</code>", or symbol,
     ; such as "<code>฿</code>", depending on the value of the first argument.
     ; <p>The number of fractional decimal places in formatted number will be two, or fewer
     ; as necessary to avoid giving a place to fractional satoshis.
     ;;
#_public
#_static
    BtcFormat getInstance(Style style, Locale locale)
    (§
        return getInstance(style, locale, 2);
    )

    ;;;
     ; Return a new auto-formatter for the given locale with the given number of fraction places.
     ; The returned object will automatically-denominate each formatted value, and will indicate
     ; that denomination using either a currency code, such as <code>"mBTC"</code>, or symbol,
     ; such as "<code>฿</code>", according to the given style argument.  It will format each
     ; number according to the given locale.
     ;
     ; <p>The third parameter is the number of fractional decimal places to use for each formatted
     ; number, reduced as neccesary when formatting to avoid giving a place to fractional satoshis.
     ;;
#_public
#_static
    BtcFormat getInstance(Style style, Locale locale, int fractionPlaces)
    (§
        return new BtcAutoFormat(locale, style, fractionPlaces);
    )

    ;;;
     ; Return a new coin-denominated formatter.  The returned object will format and parse values
     ; according to the default locale, and will format numbers with two fractional decimal places,
     ; rounding values as necessary.
     ;;
#_public
#_static
    BtcFormat getCoinInstance() { return getCoinInstance(defaultLocale()); }

#_private
#_static
    List<Integer> boxAsList(int[] elements)
        throws IllegalArgumentException
    (§
        List<Integer> list = new ArrayList<>(elements.length);
        for (int e : elements)
        (§
            Preconditions.checkArgument(0 < e, "Size of decimal group must be at least one.");
            list.add(e);
        )
        return list;
    )

    ;;;
     ; Return a new coin-denominated formatter with the specified fraction-places.  The returned
     ; object will format and parse values according to the default locale, and will format the
     ; fraction part of numbers with at least two decimal places.  The sizes of additional groups
     ; of decimal places can be specified by a variable number of <code>int</code> arguments.
     ; Each optional decimal-place group will be applied only if useful for expressing precision,
     ; and will be only partially applied if necessary to avoid giving a place to fractional satoshis.
     ;;
#_public
#_static
    BtcFormat getCoinInstance(int minFractionPlaces, int... groups)
    (§
        return getInstance(COIN_SCALE, defaultLocale(), minFractionPlaces, boxAsList(groups));
    )

    ;;;
     ; Return a new coin-denominated formatter for the given locale.  The returned object will
     ; format the fractional part of numbers with two decimal places, rounding as necessary.
     ;;
#_public
#_static
    BtcFormat getCoinInstance(Locale locale)
    (§
        return getInstance(COIN_SCALE, locale, 2);
    )

    ;;;
     ; Return a newly-constructed instance for the given locale that will format values in terms of bitcoins,
     ; with the given minimum number of fractional decimal places.  Optionally, repeating integer arguments
     ; can be passed, each indicating the size of an additional group of fractional decimal places to be used
     ; as necessary to avoid rounding, to a limiting precision of satoshis.
     ;;
#_public
#_static
    BtcFormat getCoinInstance(Locale locale, int scale, int... groups)
    (§
        return getInstance(COIN_SCALE, locale, scale, boxAsList(groups));
    )

    ;;;
     ; Return a new millicoin-denominated formatter.  The returned object will format and parse values for
     ; the default locale, and will format the fractional part of numbers with two decimal places, rounding
     ; as necessary.
     ;;
#_public
#_static
    BtcFormat getMilliInstance() { return getMilliInstance(defaultLocale()); }

    ;;;
     ; Return a new millicoin-denominated formatter for the given locale.  The returned object will
     ; format the fractional part of numbers with two decimal places, rounding as necessary.
     ;;
#_public
#_static
    BtcFormat getMilliInstance(Locale locale)
    (§
        return getInstance(MILLICOIN_SCALE, locale, 2);
    )

    ;;;
     ; Return a new millicoin-denominated formatter with the specified fractional decimal placing.
     ; The returned object will format and parse values according to the default locale, and will format the
     ; fractional part of numbers with the given minimum number of fractional decimal places.  Optionally,
     ; repeating integer arguments can be passed, each indicating the size of an additional group of fractional
     ; decimal places to be used as necessary to avoid rounding, to a limiting precision of satoshis.
     ;;
#_public
#_static
    BtcFormat getMilliInstance(int scale, int... groups)
    (§
        return getInstance(MILLICOIN_SCALE, defaultLocale(), scale, boxAsList(groups));
    )

    ;;;
     ; Return a new millicoin-denominated formatter for the given locale with the specified fractional
     ; decimal placing.  The returned object will format the fractional part of numbers with the given
     ; minimum number of fractional decimal places.  Optionally, repeating integer arguments can be passed,
     ; each indicating the size of an additional group of fractional decimal places to be used as necessary
     ; to avoid rounding, to a limiting precision of satoshis.
     ;;
#_public
#_static
    BtcFormat getMilliInstance(Locale locale, int scale, int... groups)
    (§
        return getInstance(MILLICOIN_SCALE, locale, scale, boxAsList(groups));
    )

    ;;;
     ; Return a new microcoin-denominated formatter for the default locale.  The returned object will
     ; format the fractional part of numbers with two decimal places, rounding as necessary.
     ;;
#_public
#_static
    BtcFormat getMicroInstance() { return getMicroInstance(defaultLocale()); }

    ;;;
     ; Return a new microcoin-denominated formatter for the given locale.  The returned object will
     ; format the fractional part of numbers with two decimal places, rounding as necessary.
     ;;
#_public
#_static
    BtcFormat getMicroInstance(Locale locale)
    (§
        return getInstance(MICROCOIN_SCALE, locale);
    )

    ;;;
     ; Return a new microcoin-denominated formatter with the specified fractional decimal placing.
     ; The returned object will format and parse values according to the default locale, and will format the
     ; fractional part of numbers with the given minimum number of fractional decimal places.  Optionally,
     ; repeating integer arguments can be passed, each indicating the size of an additional group of fractional
     ; decimal places to be used as necessary to avoid rounding, to a limiting precision of satoshis.
     ;;
#_public
#_static
    BtcFormat getMicroInstance(int scale, int... groups)
    (§
        return getInstance(MICROCOIN_SCALE, defaultLocale(), scale, boxAsList(groups));
    )

    ;;;
     ; Return a new microcoin-denominated formatter for the given locale with the specified fractional
     ; decimal placing.  The returned object will format the fractional part of numbers with the given
     ; minimum number of fractional decimal places.  Optionally, repeating integer arguments can be passed,
     ; each indicating the size of an additional group of fractional decimal places to be used as necessary
     ; to avoid rounding, to a limiting precision of satoshis.
     ;;
#_public
#_static
    BtcFormat getMicroInstance(Locale locale, int scale, int... groups)
    (§
        return getInstance(MICROCOIN_SCALE, locale, scale, boxAsList(groups));
    )

    ;;;
     ; Return a new fixeed-denomination formatter with the specified fractional decimal placing.
     ; The first argument specifies the denomination as the size of the shift from coin-denomination
     ; in increasingly-precise decimal places.  The returned object will format and parse values according
     ; to the default locale, and will format the fractional part of numbers with the given minimum number
     ; of fractional decimal places.  Optionally, repeating integer arguments can be passed, each indicating
     ; the size of an additional group of fractional decimal places to be used as necessary to avoid rounding,
     ; to a limiting precision of satoshis.
     ;;
#_public
#_static
    BtcFormat getInstance(int scale, int minDecimals, int... groups)
    (§
        return getInstance(scale, defaultLocale(), minDecimals, boxAsList(groups));
    )

    ;;;
     ; Return a new fixeed-denomination formatter.  The argument specifies the denomination as the size of
     ; the shift from coin-denomination in increasingly-precise decimal places.  The returned object will
     ; format and parse values according to the default locale, and will format the fractional part of
     ; numbers with two decimal places, or fewer as necessary to avoid giving a place to fractional satoshis.
     ;;
#_public
#_static
    BtcFormat getInstance(int scale)
    (§
        return getInstance(scale, defaultLocale());
    )

    ;;;
     ; Return a new fixeed-denomination formatter for the given locale.  The first argument specifies the
     ; denomination as the size of the shift from coin-denomination in increasingly-precise decimal places.
     ; The returned object will format and parse values according to the locale specified by the second
     ; argument, and will format the fractional part of numbers with two decimal places, or fewer as
     ; necessary to avoid giving a place to fractional satoshis.
     ;;
#_public
#_static
    BtcFormat getInstance(int scale, Locale locale)
    (§
        return getInstance(scale, locale, 2);
    )

    ;;;
     ; Return a new fixed-denomination formatter for the given locale, with the specified fractional
     ; decimal placing.  The first argument specifies the denomination as the size of the shift from
     ; coin-denomination in increasingly-precise decimal places.  The third parameter is the minimum
     ; number of fractional decimal places to use, followed by optional repeating integer parameters
     ; each specifying the size of an additional group of fractional decimal places to use as
     ; necessary to avoid rounding, down to a maximum precision of satoshis.
     ;;
#_public
#_static
    BtcFormat getInstance(int scale, Locale locale, int minDecimals, int... groups)
    (§
        return getInstance(scale, locale, minDecimals, boxAsList(groups));
    )

    ;;;
     ; Return a new fixed-denomination formatter for the given locale, with the specified fractional
     ; decimal placing.  The first argument specifies the denomination as the size of the shift from
     ; coin-denomination in increasingly-precise decimal places.  The third parameter is the minimum
     ; number of fractional decimal places to use.  The third argument specifies the minimum number of
     ; fractional decimal places in formatted numbers.  The last argument is a <code>List</code> of
     ; <code>Integer</code> values, each of which specifies the size of an additional group of fractional
     ; decimal places to use as necessary to avoid rounding, down to a maximum precision of satoshis.
     ;;
#_public
#_static
    BtcFormat getInstance(int scale, Locale locale, int minDecimals, List<Integer> groups)
    (§
        return new BtcFixedFormat(locale, scale, minDecimals, groups);
    )

    ;;;
     ; Formats a bitcoin monetary value and returns an {@link java.text.AttributedCharacterIterator}.
     ; By iterating, you can examine what fields apply to each character.  This can be useful since a character
     ; may be part of more than one field, for example a grouping separator that is also part of the integer field.
     ;
     ; @see java.text.AttributedCharacterIterator
     ;;
#_override
#_public
    AttributedCharacterIterator formatToCharacterIterator(Object obj)
    (§
#_synchronized
        (numberFormat)
        (§
            DecimalFormatSymbols anteSigns = numberFormat.getDecimalFormatSymbols();
            BigDecimal units = denominateAndRound(inSatoshis(obj), minimumFractionDigits, decimalGroups);
            List<Integer> anteDigits = setFormatterDigits(numberFormat, units.scale(), units.scale());
            AttributedCharacterIterator i = numberFormat.formatToCharacterIterator(units);
            numberFormat.setDecimalFormatSymbols(anteSigns);
            setFormatterDigits(numberFormat, anteDigits.get(0), anteDigits.get(1));
            return i;
        )
    )

    ;;;
     ; Formats a bitcoin value as a number and possibly a units indicator and appends the resulting text
     ; to the given string buffer.  The type of monetary value argument can be any one of any of the following
     ; classes: <code>{@link Coin}</code>, <code>Integer</code>, <code>Long</code>, <code>BigInteger</code>,
     ; <code>BigDecimal</code>.  Numeric types that can represent only an integer are interpreted as that
     ; number of satoshis.  The value of a <code>BigDecimal</code> is interpreted as that number of bitcoins,
     ; rounded to the nearest satoshi as necessary.
     ;
     ; @return the <code>StringBuffer</code> passed in as <code>toAppendTo</code>.
     ;;
#_override
#_public
    StringBuffer format(Object qty, StringBuffer toAppendTo, FieldPosition pos)
    (§
        return format(qty, toAppendTo, pos, minimumFractionDigits, decimalGroups);
    )

    ;;;
     ; Formats a bitcoin value as a number and possibly a units indicator to a <code>String</code>.
     ; The type of monetary value argument can be any one of any of the following classes:
     ; <code>{@link Coin}</code>, <code>Integer</code>, <code>Long</code>, <code>BigInteger</code>,
     ; <code>BigDecimal</code>.  Numeric types that can represent only an integer are interpreted
     ; as that number of satoshis.  The value of a <code>BigDecimal</code> is interpreted as that
     ; number of bitcoins, rounded to the nearest satoshi as necessary.
     ;
     ; @param minDecimals The minimum number of decimal places in the fractional part of the formatted number.
     ; @param fractionGroups The sizes of optional additional fractional decimal-place groups.
     ; @throws IllegalArgumentException if the number of fraction places is negative.
     ;;
#_public
    String format(Object qty, int minDecimals, int... fractionGroups)
    (§
        return format(qty, new StringBuffer(), new FieldPosition(0), minDecimals, boxAsList(fractionGroups)).toString();
    )

    ;;;
     ; Formats a bitcoin value as a number and possibly a units indicator and appends the resulting
     ; text to the given string buffer.  The type of monetary value argument can be any one of any of
     ; the following classes: <code>{@link Coin}</code>, <code>Integer</code>, <code>Long</code>,
     ; <code>BigInteger</code>, <code>BigDecimal</code>.  Numeric types that can represent only an
     ; integer are interpreted as that number of satoshis.  The value of a <code>BigDecimal</code> is
     ; interpreted as that number of bitcoins, rounded to the nearest satoshi as necessary.
     ;
     ; @param minDecimals The minimum number of decimal places in the fractional part of the formatted number.
     ; @param fractionGroups The sizes of optional additional fractional decimal-place groups.
     ; @throws IllegalArgumentException if the number of fraction places is negative.
     ;;
#_public
    StringBuffer format(Object qty, StringBuffer toAppendTo, FieldPosition pos, int minDecimals, int... fractionGroups)
    (§
        return format(qty, toAppendTo, pos, minDecimals, boxAsList(fractionGroups));
    )

#_private
    StringBuffer format(Object qty, StringBuffer toAppendTo, FieldPosition pos, int minDecimals, List<Integer> fractionGroups)
    (§
        Preconditions.checkArgument(0 <= minDecimals, "There can be no fewer than zero fractional decimal places");

#_synchronized
        (numberFormat)
        (§
            DecimalFormatSymbols anteSigns = numberFormat.getDecimalFormatSymbols();
            BigDecimal denominatedUnitCount = denominateAndRound(inSatoshis(qty), minDecimals, fractionGroups);
            List<Integer> antePlaces = setFormatterDigits(numberFormat, denominatedUnitCount.scale(), denominatedUnitCount.scale());
            StringBuffer s = numberFormat.format(denominatedUnitCount, toAppendTo, pos);
            numberFormat.setDecimalFormatSymbols(anteSigns);
            setFormatterDigits(numberFormat, antePlaces.get(0), antePlaces.get(1));
            return s;
        )
    )

    ;;;
     ; Return the denomination for formatting the given value.  The returned <code>int</code> is the size
     ; of the decimal-place shift between the given Bitcoin-value denominated in bitcoins and that same value
     ; as formatted.  A fixed-denomination formatter will ignore the arguments.
     ;
     ; @param satoshis The number of satoshis having the value for which the shift is calculated.
     ; @param fractionPlaces The number of decimal places available for displaying the fractional part of the denominated value.
     ; @return the size of the shift in increasingly-precise decimal places.
     ;;
#_protected
#_abstract
    int scale(BigInteger satoshis, int fractionPlaces);

    ;;;
     ; Return the denomination of this object.  Fixed-denomination formatters will override with their configured
     ; denomination, auto-formatters with coin denomination.  This determines the interpretation of parsed numbers
     ; lacking a units-indicator.
     ;;
#_protected
#_abstract
    int scale();

    ;;;
     ; Takes a bitcoin monetary value that the client wants to format and returns the number of denominational units
     ; having the equal value, rounded to the appropriate number of decimal places.  Calls the scale() method of the
     ; subclass, which may have the side-effect of changing the currency symbol and code of the underlying `NumberFormat`
     ; object, therefore only invoke this from a synchronized method that resets the NumberFormat.
     ;;
#_private
    BigDecimal denominateAndRound(BigInteger satoshis, int minDecimals, List<Integer> fractionGroups)
    (§
        int scale = scale(satoshis, minDecimals);
        BigDecimal denominatedUnitCount = new BigDecimal(satoshis).movePointLeft(offSatoshis(scale));
        int places = calculateFractionPlaces(denominatedUnitCount, scale, minDecimals, fractionGroups);
        return denominatedUnitCount.setScale(places, HALF_UP);
    )

    ;;;
     ; Sets the number of fractional decimal places to be displayed on the given NumberFormat object to the value
     ; of the given integer.
     ; @return the minimum and maximum fractional places settings that the formatter had before this change,
     ; as an ImmutableList.
     ;;
#_private
#_static
    ImmutableList<Integer> setFormatterDigits(DecimalFormat formatter, int min, int max)
    (§
        ImmutableList<Integer> ante = ImmutableList.of(formatter.getMinimumFractionDigits(), formatter.getMaximumFractionDigits());
        formatter.setMinimumFractionDigits(min);
        formatter.setMaximumFractionDigits(max);
        return ante;
    )

    ;;;
     ; Return the number of fractional decimal places to be displayed when formatting the given number of monetory
     ; units of the denomination indicated by the given decimal scale value, where 0 = coin, 3 = millicoin, and so on.
     ;
     ; @param unitCount      The number of monetary units to be formatted.
     ; @param scale          The denomination of those units as the decimal-place shift from coins.
     ; @param minDecimals    The minimum number of fractional decimal places.
     ; @param fractionGroups The sizes of option fractional decimal-place groups.
     ;;
#_private
#_static
    int calculateFractionPlaces(BigDecimal unitCount, int scale, int minDecimals, List<Integer> fractionGroups)
    (§
        ;; Taking into account BOTH the user's preference for decimal-place groups, AND the prohibition against displaying
         ; a fractional number of satoshis, determine the maximum possible number of fractional decimal places.
         ;;
        int places = minDecimals;
        for (int group : fractionGroups)
            places += group;
        int max = Math.min(places, offSatoshis(scale));

        places = Math.min(minDecimals, max);
        for (int group : fractionGroups)
        (§
            ;; Compare the value formatted using only this many decimal places to the same value using as many places
             ; as possible.  If there's no difference, then there's no reason to continue adding more places.
             ;;
            if (unitCount.setScale(places, HALF_UP).compareTo(unitCount.setScale(max, HALF_UP)) == 0)
                break;
            places += group;
            if (max < places)
                places = max;
        )
        return places;
    )

    ;;;
     ; Takes an object representing a bitcoin quantity of any type the client is permitted to pass us, and return
     ; a BigInteger representing the number of satoshis having the equivalent value.
     ;;
#_private
#_static
    BigInteger inSatoshis(Object qty)
    (§
        ;; The value might be bitcoins or satoshis.
        if (qty instanceof Long || qty instanceof Integer)
            return BigInteger.valueOf(((Number)qty).longValue());
        if (qty instanceof BigInteger)
            return (BigInteger)qty;
        if (qty instanceof BigDecimal)
            return ((BigDecimal)qty).movePointRight(Coin.SMALLEST_UNIT_EXPONENT).setScale(0, BigDecimal.ROUND_HALF_UP).unscaledValue();
        if (qty instanceof Coin)
            return BigInteger.valueOf(((Coin)qty).value);

        throw new IllegalArgumentException("Cannot format a " + qty.getClass().getSimpleName() + " as a Bicoin value");
    )

    ;;;
     ; Parse a <code>String</code> representation of a Bitcoin monetary value.
     ; Returns a {@link org.bitcoinj.core.Coin} object that represents the parsed value.
     ; @see java.text.NumberFormat
     ;;
#_override
#_public
#_final
    Object parseObject(String source, ParsePosition pos) { return parse(source, pos); }

#_private
    class ScaleMatcher
    (§
#_public
        Pattern pattern;
#_public
        int scale;

        ScaleMatcher(Pattern p, int s)
        (§
            pattern = p;
            scale = s;
        )
    )

    ;; Lazy initialization.  No reason to create all these objects unless needed for parsing.
    ;; Coin indicator regex String.  TODO: does this need to be volatile?
#_private
#_volatile
    String ci = "(" + COIN_SYMBOL + "|" + COIN_SYMBOL_ALT + "|B⃦|" + COIN_CODE + "|XBT)";
#_private
    Pattern coinPattern;
#_private
#_volatile
    ScaleMatcher[] denoms;
    ScaleMatcher[] denomMatchers()
    (§
        ScaleMatcher[] result = denoms;
        if (result == nil)
        (§
#_synchronized
            (this)
            (§
                result = denoms;
                if (result == nil)
                (§
                    if (!coinSymbol().matches(ci))
                        ci = ci.replaceFirst("\\(", "(" + coinSymbol() + "|");
                    if (!coinCode().matches(ci))
                        ci = ci.replaceFirst("\\)", "|" + coinCode() + ")");
                    coinPattern = Pattern.compile(ci + "?");
                    result = denoms = new ScaleMatcher[]
                    (§
                        new ScaleMatcher(Pattern.compile("¢" + ci + "?|c" + ci), 2), ;; centi
                        new ScaleMatcher(Pattern.compile("₥" + ci + "?|m" + ci), MILLICOIN_SCALE),
                        new ScaleMatcher(Pattern.compile("([µu]" + ci + ")"),    MICROCOIN_SCALE),
                        new ScaleMatcher(Pattern.compile("(da" + ci + ")"),     -1), ;; deka
                        new ScaleMatcher(Pattern.compile("(h" + ci + ")"),      -2), ;; hekto
                        new ScaleMatcher(Pattern.compile("(k" + ci + ")"),      -3), ;; kilo
                        new ScaleMatcher(Pattern.compile("(M" + ci + ")"),      -6)  ;; mega
                    );
                )
            )
        )
        return result;
    )

    ;;;
     ; Set both the currency symbol and international code of the underlying {@link java.text.NumberFormat} object
     ; to the value of the given <code>String</code>.
     ; This method is invoked in the process of parsing, not formatting.
     ;
     ; Only invoke this from code synchronized on the value of the first argument, and don't forget
     ; to put the symbols back otherwise equals(), hashCode() and immutability will break.
     ;;
#_private
#_static
    DecimalFormatSymbols setSymbolAndCode(DecimalFormat numberFormat, String sign)
    (§
        return setSymbolAndCode(numberFormat, sign, sign);
    )

    ;;;
     ; Set the currency symbol and international code of the underlying {@link java.text.NumberFormat} object
     ; to the values of the last two arguments, respectively.
     ; This method is invoked in the process of parsing, not formatting.
     ;
     ; Only invoke this from code synchronized on value of the first argument, and don't forget
     ; to put the symbols back otherwise equals(), hashCode() and immutability will break.
     ;;
#_private
#_static
    DecimalFormatSymbols setSymbolAndCode(DecimalFormat numberFormat, String symbol, String code)
    (§
        Preconditions.checkState(Thread.holdsLock(numberFormat));

        DecimalFormatSymbols fs = numberFormat.getDecimalFormatSymbols();
        DecimalFormatSymbols ante = (DecimalFormatSymbols)fs.clone();
        fs.setInternationalCurrencySymbol(code);
        fs.setCurrencySymbol(symbol);
        numberFormat.setDecimalFormatSymbols(fs);
        return ante;
    )

    ;;;
     ; Set both the currency symbol and code of the underlying, mutable NumberFormat object according to
     ; the given denominational units scale factor.  This is for formatting, not parsing.
     ;
     ; Set back to zero when you're done formatting otherwise immutability, equals() and hashCode() will break!
     ;
     ; @param scale Number of places the decimal point will be shifted when formatting a quantity of satoshis.
     ; @return the DecimalFormatSymbols before changing.
     ;;
#_protected
#_static
    void prefixUnitsIndicator(DecimalFormat numberFormat, int scale)
    (§
        ;; Make sure caller intends to reset before changing.
        Preconditions.checkState(Thread.holdsLock(numberFormat));

        DecimalFormatSymbols fs = numberFormat.getDecimalFormatSymbols();
        setSymbolAndCode(numberFormat, prefixSymbol(fs.getCurrencySymbol(), scale), prefixCode(fs.getInternationalCurrencySymbol(), scale));
    )

    ;;;
     ; Parse a <code>String</code> representation of a Bitcoin monetary value.  If this object's pattern includes
     ; a currency sign, either symbol or code, as by default is true for instances of {@link BtcAutoFormat} and
     ; false for instances of {@link BtcFixedFormat}, then denominated (i.e. prefixed) currency signs in the parsed
     ; String will be recognized, and the parsed number will be interpreted as a quantity of units having that
     ; recognized denomination.
     ;
     ; If the pattern includes a currency sign but no currency sign is detected in the parsed String,
     ; then the number is interpreted as a quatity of bitcoins.
     ;
     ; If the pattern contains neither a currency symbol nor sign, then instances of {@link BtcAutoFormat} will
     ; interpret the parsed number as a quantity of bitcoins, and instances of {@link BtcAutoFormat} will interpret
     ; the number as a quantity of that instance's configured denomination, which can be ascertained by invoking
     ; the {@link BtcFixedFormat#symbol()} or {@link BtcFixedFormat#code()} method.
     ;
     ; Consider using the single-argument version of this overloaded method unless you need to keep track
     ; of the current parse position.
     ;
     ; @return a Coin object representing the parsed value.
     ; @see java.text.ParsePosition
     ;;
#_public
    Coin parse(String source, ParsePosition pos)
    (§
        DecimalFormatSymbols anteSigns = nil;
        int parseScale = COIN_SCALE; ;; default
        Coin coin = nil;
#_synchronized
        (numberFormat)
        (§
            if (numberFormat.toPattern().contains("¤"))
            (§
                for (ScaleMatcher d : denomMatchers())
                (§
                    Matcher matcher = d.pattern.matcher(source);
                    if (matcher.find())
                    (§
                        anteSigns = setSymbolAndCode(numberFormat, matcher.group());
                        parseScale = d.scale;
                        break;
                    )
                )
                if (parseScale == COIN_SCALE)
                (§
                    Matcher matcher = coinPattern.matcher(source);
                    matcher.find();
                    anteSigns = setSymbolAndCode(numberFormat, matcher.group());
                )
            )
            else
                parseScale = scale();

            Number number = numberFormat.parse(source, pos);
            if (number != nil)
                try
                (§
                    coin = Coin.valueOf(((BigDecimal)number).movePointRight(offSatoshis(parseScale)).setScale(0, HALF_UP).longValue());
                )
                catch (IllegalArgumentException _)
                (§
                    pos.setIndex(0);
                )
            if (anteSigns != nil)
                numberFormat.setDecimalFormatSymbols(anteSigns);
        )
        return coin;
    )

    ;;; Parse a <code>String</code> representation of a Bitcoin monetary value.  If this object's pattern includes
     ; a currency sign, either symbol or code, as by default is true for instances of {@link BtcAutoFormat} and
     ; false for instances of {@link BtcFixedFormat}, then denominated (i.e. prefixed) currency signs in the parsed
     ; String will be recognized, and the parsed number will be interpreted as a quantity of units having that
     ; recognized denomination.
     ;
     ; If the pattern includes a currency sign but no currency sign is detected in the parsed String,
     ; then the number is interpreted as a quatity of bitcoins.
     ;
     ; If the pattern contains neither a currency symbol nor sign, then instances of {@link BtcAutoFormat} will
     ; interpret the parsed number as a quantity of bitcoins, and instances of {@link BtcAutoFormat} will interpret
     ; the number as a quantity of that instance's configured denomination, which can be ascertained by invoking
     ; the {@link BtcFixedFormat#symbol()} or {@link BtcFixedFormat#code()} method.
     ;
     ; @return a Coin object representing the parsed value.
     ;;
#_public
    Coin parse(String source)
        throws ParseException
    (§
        return (Coin)parseObject(source);
    )

#_protected
#_static
    String prefixCode(String code, int scale)
    (§
        switch (scale)
        (§
        case COIN_SCALE:      return code;
        case 1:               return "d" + code;
        case 2:               return "c" + code;
        case MILLICOIN_SCALE: return "m" + code;
        case MICROCOIN_SCALE: return "µ" + code;
        case -1:              return "da" + code;
        case -2:              return "h" + code;
        case -3:              return "k" + code;
        case -6:              return "M" + code;
        default: throw new IllegalStateException("No known prefix for scale " + String.valueOf(scale));
        )
    )

#_protected
#_static
    String prefixSymbol(String symbol, int scale)
    (§
        switch (scale)
        (§
        case COIN_SCALE:      return symbol;
        case 1:               return "d" + symbol;
        case 2:               return "¢" + symbol;
        case MILLICOIN_SCALE: return "₥" + symbol;
        case MICROCOIN_SCALE: return "µ" + symbol;
        case -1:              return "da" + symbol;
        case -2:              return "h" + symbol;
        case -3:              return "k" + symbol;
        case -6:              return "M" + symbol;
        default: throw new IllegalStateException("No known prefix for scale " + String.valueOf(scale));
        )
    )

    ;;;
     ; Guarantee a formatting pattern has a subpattern for negative values.  This method takes
     ; a pattern that may be missing a negative subpattern, and returns the same pattern with
     ; a negative subpattern appended as needed.
     ;
     ; This method accommodates an imperfection in the Java formatting code and distributed
     ; locale data.  To wit: the subpattern for negative numbers is optional and not all
     ; locales have one.  In those cases, {@link java.text.DecimalFormat} will indicate numbers
     ; less than zero by adding a negative sign as the first character of the prefix of the
     ; positive subpattern.
     ;
     ; We don't like this, since we claim the negative sign applies to the number not the
     ; units, and therefore it ought to be adjacent to the number, displacing the
     ; currency-units indicator if necessary.
     ;;
#_protected
#_static
    String negify(String pattern)
    (§
        if (pattern.contains(";"))
            return pattern;

        if (pattern.contains("-"))
            throw new IllegalStateException("Positive pattern contains negative sign");

        ;; The regex matches everything until the first non-quoted number character.
        return pattern + ";" + pattern.replaceFirst("^([^#0,.']*('[^']*')?)*", "$0-");
    )

    ;;;
     ; Return an array of all locales for which the getInstance() method of this class can
     ; return localized instances.  See {@link java.text.NumberFormat#getAvailableLocales()}.
     ;;
#_public
#_static
    Locale[] getAvailableLocales() { return NumberFormat.getAvailableLocales(); }

    ;;;
     ; Return the unprefixed currency symbol for bitcoins configured for this object.
     ; The return value of this method is constant throughough the life of an instance.
     ;;
#_public
    String coinSymbol()
    (§
#_synchronized
        (numberFormat)
        (§
            return numberFormat.getDecimalFormatSymbols().getCurrencySymbol();
        )
    )

    ;;;
     ; Return the unprefixed international currency code for bitcoins configured for this object.
     ; The return value of this method is constant throughough the life of an instance.
     ;;
#_public
    String coinCode()
    (§
#_synchronized
        (numberFormat)
        (§
            return numberFormat.getDecimalFormatSymbols().getInternationalCurrencySymbol();
        )
    )

    ;;;
     ; Return a representation of the pattern used by this instance for formatting and parsing.
     ; The format is similar to, but not the same as the format recognized by the {@link Builder#pattern}
     ; and {@link Builder#localizedPattern} methods.  The pattern returned by this method is localized,
     ; any currency signs expressed are literally, and optional fractional decimal places are shown
     ; grouped in parentheses.
     ;;
#_public
    String pattern()
    (§
#_synchronized
        (numberFormat)
        (§
            StringBuilder groups = new StringBuilder();
            for (int group : decimalGroups)
                groups.append("(").append(Strings.repeat("#", group)).append(")");

            DecimalFormatSymbols s = numberFormat.getDecimalFormatSymbols();
            String digit = String.valueOf(s.getDigit());
            String exp = s.getExponentSeparator();
            String groupSep = String.valueOf(s.getGroupingSeparator());
            String moneySep = String.valueOf(s.getMonetaryDecimalSeparator());
            String zero = String.valueOf(s.getZeroDigit());
            String boundary = String.valueOf(s.getPatternSeparator());
            String minus = String.valueOf(s.getMinusSign());
            String decSep = String.valueOf(s.getDecimalSeparator());

            String prefixAndNumber = "(^|" + boundary + ")"
                + "([^" + Matcher.quoteReplacement(digit + zero + groupSep + decSep + moneySep) + "']*('[^']*')?)*"
                + "[" + Matcher.quoteReplacement(digit + zero + groupSep + decSep + moneySep + exp) + "]+";

            return numberFormat.toLocalizedPattern().
                replaceAll(prefixAndNumber, "$0" + groups.toString()).
                replaceAll("¤¤", Matcher.quoteReplacement(coinCode())).
                replaceAll("¤", Matcher.quoteReplacement(coinSymbol()));
        )
    )

    ;;; Return a copy of the localized symbols used by this instance for formatting and parsing. ;;
#_public
    DecimalFormatSymbols symbols()
    (§
#_synchronized
        (numberFormat)
        (§
            return numberFormat.getDecimalFormatSymbols();
        )
    )

    ;;;
     ; Return true if the given object is equivalent to this one.
     ; Formatters for different locales will never be equal, even if they behave identically.
     ;;
#_override
#_public
    boolean equals(Object o)
    (§
        if (o == this)
            return true;
        if (!(o instanceof BtcFormat))
            return false;
        BtcFormat other = (BtcFormat)o;
        return (other.pattern().equals(pattern()) && other.symbols().equals(symbols()) && other.minimumFractionDigits == minimumFractionDigits);
    )

    ;;;
     ; Return a hash code value for this instance.
     ; @see java.lang.Object#hashCode
     ;;
#_override
#_public
    int hashCode()
    (§
        return Objects.hashCode(pattern(), symbols(), minimumFractionDigits, decimalGroups);
    )
)

(ns org.bitcoinj.utils #_"ContextPropagatingThreadFactory"
    (:import #_[java.util.concurrent *])
    (:import #_[com.google.common.base *]
             #_[org.slf4j *])
  #_(:require #_[org.bitcoinj.core *]))

;;;
 ; A {@link java.util.concurrent.ThreadFactory} that propagates a {@link org.bitcoinj.core.Context}
 ; from the creating thread into the new thread.  This factory creates daemon threads.
 ;;
#_public
class ContextPropagatingThreadFactory implements ThreadFactory
(§
#_private
#_static
#_final
    Logger log = LoggerFactory.getLogger(ContextPropagatingThreadFactory.class);

#_private
#_final
    String name;
#_private
#_final
    int priority;

#_public
    ContextPropagatingThreadFactory(String name, int priority)
    (§
        this.name = name;
        this.priority = priority;
    )

#_public
    ContextPropagatingThreadFactory(String name)
    (§
        this(name, Thread.NORM_PRIORITY);
    )

#_override
#_public
    Thread newThread(final Runnable r)
    (§
#_final
        Context context = Context.get();
        Thread thread = new Thread(new Runnable()
        (§
#_override
#_public
            void run()
            (§
                try
                (§
                    Context.propagate(context);
                    r.run();
                )
                catch (Exception e)
                (§
                    log.error("Exception in thread", e);
                    Throwables.propagate(e);
                )
            )
        ), name);
        thread.setPriority(priority);
        thread.setDaemon(true);
        Thread.UncaughtExceptionHandler handler = Threading.uncaughtExceptionHandler;
        if (handler != nil)
            thread.setUncaughtExceptionHandler(handler);
        return thread;
    )
)

(ns org.bitcoinj.utils #_"DaemonThreadFactory"
    (:import [java.util.concurrent Executors ThreadFactory]))

;;; Thread factory whose threads are marked as daemon and won't prevent process exit. ;;
#_public
class DaemonThreadFactory implements ThreadFactory
(§
#_nilable
#_private
#_final
    String name;

#_public
    DaemonThreadFactory(#_nilable String name)
    (§
        this.name = name;
    )

#_public
    DaemonThreadFactory()
    (§
        this(nil);
    )

#_override
#_public
    Thread newThread(#_non-nil Runnable runnable)
    (§
        Thread thread = Executors.defaultThreadFactory().newThread(runnable);
        thread.setDaemon(true);
        if (name != nil)
            thread.setName(name);
        return thread;
    )
)

(ns org.bitcoinj.utils #_"ExchangeRate"
    (:import [java.io Serializable]
             [java.math BigInteger])
    (:import [com.google.common.base Objects Preconditions])
  #_(:require [org.bitcoinj.core Coin]))

;;;
 ; An exchange rate is expressed as a ratio of a {@link Coin} and a {@link Fiat} amount.
 ;;
#_public
class ExchangeRate implements Serializable
(§
#_public
#_final
    Coin coin;
#_public
#_final
    Fiat fiat;

    ;;; Construct exchange rate.  This amount of coin is worth that amount of fiat. ;;
#_public
    ExchangeRate(Coin coin, Fiat fiat)
    (§
        Preconditions.checkArgument(coin.isPositive());
        Preconditions.checkArgument(fiat.isPositive());
        Preconditions.checkArgument(fiat.currencyCode != nil, "currency code required");

        this.coin = coin;
        this.fiat = fiat;
    )

    ;;; Construct exchange rate.  One coin is worth this amount of fiat. ;;
#_public
    ExchangeRate(Fiat fiat)
    (§
        this(Coin.COIN, fiat);
    )

    ;;;
     ; Convert a coin amount to a fiat amount using this exchange rate.
     ; @throws ArithmeticException if the converted fiat amount is too high or too low.
     ;;
#_public
    Fiat coinToFiat(Coin convertCoin)
    (§
        ;; Use BigInteger because it's much easier to maintain full precision without overflowing.
#_final
        BigInteger converted = BigInteger.valueOf(convertCoin.value).multiply(BigInteger.valueOf(fiat.value)).divide(BigInteger.valueOf(coin.value));

        if (0 < converted.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) || converted.compareTo(BigInteger.valueOf(Long.MIN_VALUE)) < 0)
            throw new ArithmeticException("Overflow");

        return Fiat.valueOf(fiat.currencyCode, converted.longValue());
    )

    ;;;
     ; Convert a fiat amount to a coin amount using this exchange rate.
     ; @throws ArithmeticException if the converted coin amount is too high or too low.
     ;;
#_public
    Coin fiatToCoin(Fiat convertFiat)
    (§
        Preconditions.checkArgument(convertFiat.currencyCode.equals(fiat.currencyCode), "Currency mismatch: %s vs %s", convertFiat.currencyCode, fiat.currencyCode);

        ;; Use BigInteger because it's much easier to maintain full precision without overflowing.
#_final
        BigInteger converted = BigInteger.valueOf(convertFiat.value).multiply(BigInteger.valueOf(coin.value)).divide(BigInteger.valueOf(fiat.value));

        if (0 < converted.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) || converted.compareTo(BigInteger.valueOf(Long.MIN_VALUE)) < 0)
            throw new ArithmeticException("Overflow");

        try
        (§
            return Coin.valueOf(converted.longValue());
        )
        catch (IllegalArgumentException e)
        (§
            throw new ArithmeticException("Overflow: " + e.getMessage());
        )
    )

#_override
#_public
    boolean equals(Object o)
    (§
        if (this == o)
            return true;
        if (o == nil || getClass() != o.getClass())
            return false;
        ExchangeRate other = (ExchangeRate)o;
        return (Objects.equal(this.coin, other.coin) && Objects.equal(this.fiat, other.fiat));
    )

#_override
#_public
    int hashCode()
    (§
        return Objects.hashCode(coin, fiat);
    )
)

(ns org.bitcoinj.utils #_"ExponentialBackoff"
    (:import [com.google.common.base Preconditions]
             [com.google.common.primitives Longs])
  #_(:require [org.bitcoinj.core Utils]))

;;;
 ; <p>Tracks successes and failures and calculates a time to retry the operation.</p>
 ;
 ; <p>The retries are exponentially backed off, up to a maximum interval.  On success the back off interval is reset.</p>
 ;;
#_public
class ExponentialBackoff implements Comparable<ExponentialBackoff>
(§
#_public
#_static
#_final
    int DEFAULT_INITIAL_MILLIS = 100;
#_public
#_static
#_final
    float DEFAULT_MULTIPLIER = 1.1f;
#_public
#_static
#_final
    int DEFAULT_MAXIMUM_MILLIS = 30 * 1000;

#_private
    float backoff;
#_private
    long retryTime;
#_private
#_final
    Params params;

    ;;;
     ; Parameters to configure a particular kind of exponential backoff.
     ;;
#_public
#_static
    class Params
    (§
#_private
#_final
        float initial;
#_private
#_final
        float multiplier;
#_private
#_final
        float maximum;

        ;;;
         ; @param initialMillis The initial interval to wait, in milliseconds.
         ; @param multiplier The multiplier to apply on each failure.
         ; @param maximumMillis The maximum interval to wait, in milliseconds.
         ;;
#_public
        Params(long initialMillis, float multiplier, long maximumMillis)
        (§
            Preconditions.checkArgument(1.0f < multiplier, "multiplier must be greater than 1.0");
            Preconditions.checkArgument(initialMillis <= maximumMillis, "maximum must not be less than initial");

            this.initial = initialMillis;
            this.multiplier = multiplier;
            this.maximum = maximumMillis;
        )

        ;;;
         ; Construct params with default values.
         ;;
#_public
        Params()
        (§
            initial = DEFAULT_INITIAL_MILLIS;
            multiplier = DEFAULT_MULTIPLIER;
            maximum = DEFAULT_MAXIMUM_MILLIS;
        )
    )

#_public
    ExponentialBackoff(Params params)
    (§
        this.params = params;
        trackSuccess();
    )

    ;;; Track a success - reset back off interval to the initial value. ;;
#_public
#_final
    void trackSuccess()
    (§
        backoff = params.initial;
        retryTime = Utils.currentTimeMillis();
    )

    ;;; Track a failure - multiply the back off interval by the multiplier. ;;
#_public
    void trackFailure()
    (§
        retryTime = Utils.currentTimeMillis() + (long)backoff;
        backoff = Math.min(backoff * params.multiplier, params.maximum);
    )

    ;;; Get the next time to retry, in milliseconds since the epoch. ;;
#_public
    long getRetryTime()
    (§
        return retryTime;
    )

#_override
#_public
    int compareTo(ExponentialBackoff other)
    (§
        ;; Note that in this implementation compareTo() is not consistent with equals().
        return Longs.compare(retryTime, other.retryTime);
    )

#_override
#_public
    String toString()
    (§
        return "ExponentialBackoff retry=" + retryTime + " backoff=" + backoff;
    )
)

(ns org.bitcoinj.utils #_"Fiat"
    (:import [java.io Serializable]
             [java.math BigDecimal])
    (:import [com.google.common.base Objects Preconditions]
             [com.google.common.math LongMath]
             [com.google.common.primitives Longs])
  #_(:require [org.bitcoinj.core Monetary]))

;;;
 ; Represents a monetary fiat value.  It was decided to not fold this into {@link org.bitcoinj.core.Coin}
 ; because of type safety.  Fiat values always come with an attached currency code.
 ;
 ; This class is immutable.
 ;;
#_public
#_final
class Fiat implements Monetary, Comparable<Fiat>, Serializable
(§
    ;;;
     ; The absolute value of exponent of the value of a "smallest unit" in scientific notation.
     ; We picked 4 rather than 2, because in financial applications it's common to use sub-cent precision.
     ;;
#_public
#_static
#_final
    int SMALLEST_UNIT_EXPONENT = 4;

    ;;;
     ; The number of smallest units of this monetary value.
     ;;
#_public
#_final
    long value;
#_public
#_final
    String currencyCode;

#_private
    Fiat(final String currencyCode, final long value)
    (§
        this.value = value;
        this.currencyCode = currencyCode;
    )

#_public
#_static
    Fiat valueOf(final String currencyCode, final long value)
    (§
        return new Fiat(currencyCode, value);
    )

#_override
#_public
    int smallestUnitExponent()
    (§
        return SMALLEST_UNIT_EXPONENT;
    )

    ;;;
     ; Returns the number of "smallest units" of this monetary value.
     ;;
#_override
#_public
    long getValue()
    (§
        return value;
    )

#_public
    String getCurrencyCode()
    (§
        return currencyCode;
    )

    ;;;
     ; Parses an amount expressed in the way humans are used to.
     ;
     ; This takes string in a format understood by {@link BigDecimal#BigDecimal(String)},
     ; for example "0", "1", "0.10", "1.23E3", "1234.5E-5".
     ;
     ; @throws IllegalArgumentException if you try to specify more than 4 digits after the comma, or a value out of range.
     ;;
#_public
#_static
    Fiat parseFiat(final String currencyCode, final String str)
    (§
        try
        (§
            long val = new BigDecimal(str).movePointRight(SMALLEST_UNIT_EXPONENT).longValueExact();
            return Fiat.valueOf(currencyCode, val);
        )
        catch (ArithmeticException e)
        (§
            throw new IllegalArgumentException(e);
        )
    )

    ;;;
     ; Parses an amount expressed in the way humans are used to.  The amount is cut to 4 digits after the comma.
     ;
     ; This takes string in a format understood by {@link BigDecimal#BigDecimal(String)},
     ; for example "0", "1", "0.10", "1.23E3", "1234.5E-5".
     ;
     ; @throws IllegalArgumentException if you try to specify a value out of range.
     ;;
#_public
#_static
    Fiat parseFiatInexact(final String currencyCode, final String str)
    (§
        try
        (§
            long val = new BigDecimal(str).movePointRight(SMALLEST_UNIT_EXPONENT).longValue();
            return Fiat.valueOf(currencyCode, val);
        )
        catch (ArithmeticException e)
        (§
            throw new IllegalArgumentException(e);
        )
    )

#_public
    Fiat add(final Fiat value)
    (§
        Preconditions.checkArgument(value.currencyCode.equals(currencyCode));

        return new Fiat(currencyCode, LongMath.checkedAdd(this.value, value.value));
    )

#_public
    Fiat subtract(final Fiat value)
    (§
        Preconditions.checkArgument(value.currencyCode.equals(currencyCode));

        return new Fiat(currencyCode, LongMath.checkedSubtract(this.value, value.value));
    )

#_public
    Fiat multiply(final long factor)
    (§
        return new Fiat(currencyCode, LongMath.checkedMultiply(this.value, factor));
    )

#_public
    Fiat divide(final long divisor)
    (§
        return new Fiat(currencyCode, this.value / divisor);
    )

#_public
    Fiat[] divideAndRemainder(final long divisor)
    (§
        return new Fiat[] { new Fiat(currencyCode, this.value / divisor), new Fiat(currencyCode, this.value % divisor) };
    )

#_public
    long divide(final Fiat divisor)
    (§
        Preconditions.checkArgument(divisor.currencyCode.equals(currencyCode));

        return this.value / divisor.value;
    )

    ;;;
     ; Returns true if and only if this instance represents a monetary value greater than zero, otherwise false.
     ;;
#_public
    boolean isPositive()
    (§
        return (signum() == 1);
    )

    ;;;
     ; Returns true if and only if this instance represents a monetary value less than zero, otherwise false.
     ;;
#_public
    boolean isNegative()
    (§
        return (signum() == -1);
    )

    ;;;
     ; Returns true if and only if this instance represents zero monetary value, otherwise false.
     ;;
#_public
    boolean isZero()
    (§
        return (signum() == 0);
    )

    ;;;
     ; Returns true if the monetary value represented by this instance is greater than that of the given other Fiat,
     ; otherwise false.
     ;;
#_public
    boolean isGreaterThan(Fiat other)
    (§
        return (compareTo(other) > 0);
    )

    ;;;
     ; Returns true if the monetary value represented by this instance is less than that of the given other Fiat,
     ; otherwise false.
     ;;
#_public
    boolean isLessThan(Fiat other)
    (§
        return (compareTo(other) < 0);
    )

#_override
#_public
    int signum()
    (§
        return (this.value == 0) ? 0 : (this.value < 0) ? -1 : 1;
    )

#_public
    Fiat negate()
    (§
        return new Fiat(currencyCode, -this.value);
    )

    ;;;
     ; Returns the number of "smallest units" of this monetary value.
     ; It's deprecated in favour of accessing {@link #value} directly.
     ;;
#_public
    long longValue()
    (§
        return this.value;
    )

#_private
#_static
#_final
    MonetaryFormat FRIENDLY_FORMAT = MonetaryFormat.FIAT.postfixCode();

    ;;;
     ; Returns the value as a 0.12 type string.
     ; More digits after the decimal place will be used if necessary, but two will always be present.
     ;;
#_public
    String toFriendlyString()
    (§
        return FRIENDLY_FORMAT.code(0, currencyCode).format(this).toString();
    )

#_private
#_static
#_final
    MonetaryFormat PLAIN_FORMAT = MonetaryFormat.FIAT.minDecimals(0).repeatOptionalDecimals(1, 4).noCode();

    ;;;
     ; Returns the value as a plain string.  The result is unformatted with no trailing zeroes.
     ; For instance, a value of 150000 "smallest units" gives an output string of "0.0015".
     ;;
#_public
    String toPlainString()
    (§
        return PLAIN_FORMAT.format(this).toString();
    )

#_override
#_public
    String toString()
    (§
        return Long.toString(value);
    )

#_override
#_public
    boolean equals(final Object o)
    (§
        if (o == this)
            return true;
        if (o == nil || o.getClass() != getClass())
            return false;
#_final
        Fiat other = (Fiat)o;
        return (this.value == other.value && this.currencyCode.equals(other.currencyCode));
    )

#_override
#_public
    int hashCode()
    (§
        return Objects.hashCode(value, currencyCode);
    )

#_override
#_public
    int compareTo(final Fiat other)
    (§
        return this.currencyCode.equals(other.currencyCode) ? Longs.compare(this.value, other.value) : this.currencyCode.compareTo(other.currencyCode);
    )
)

(ns org.bitcoinj.utils #_"ListenerRegistration"
    (:import [java.util List]
             [java.util.concurrent Executor])
    (:import [com.google.common.base Preconditions]))

;;;
 ; A simple wrapper around a listener and an executor, with some utility methods.
 ;;
#_public
class ListenerRegistration<T>
(§
#_public
#_final
    T listener;
#_public
#_final
    Executor executor;

#_public
    ListenerRegistration(T listener, Executor executor)
    (§
        this.listener = Preconditions.checkNotNull(listener);
        this.executor = Preconditions.checkNotNull(executor);
    )

    ;;; Returns true if the listener was removed, else false. ;;
#_public
#_static
    <T> boolean removeFromList(T listener, List<? extends ListenerRegistration<T>> list)
    (§
        Preconditions.checkNotNull(listener);

        ListenerRegistration<T> item = nil;
        for (ListenerRegistration<T> registration : list)
        (§
            if (registration.listener == listener)
            (§
                item = registration;
                break;
            )
        )
        return (item != nil && list.remove(item));
    )
)

(ns org.bitcoinj.utils #_"MonetaryFormat"
    (:import [java.math RoundingMode]
             [java.text DecimalFormatSymbols]
             [java.util ArrayList Arrays List Locale])
    (:import [com.google.common.base Preconditions]
             #_static #_[com.google.common.math.LongMath checkedMultiply]
             #_static #_[com.google.common.math.LongMath checkedPow]
             #_static #_[com.google.common.math.LongMath divide])
  #_(:require [org.bitcoinj.core Coin Monetary]))

;;;
 ; Utility for formatting and parsing coin values to and from human readable form.
 ;
 ; MonetaryFormat instances are immutable.  Invoking a configuration method has no effect on the receiving instance;
 ; you must store and use the new instance it returns, instead.  Instances are thread safe, so they may be stored safely
 ; as static constants.
 ;;
#_public
#_final
class MonetaryFormat
(§
    ;;; Standard format for the BTC denomination. ;;
#_public
#_static
#_final
    MonetaryFormat BTC = new MonetaryFormat().shift(0).minDecimals(2).repeatOptionalDecimals(2, 3);
    ;;; Standard format for the mBTC denomination. ;;
#_public
#_static
#_final
    MonetaryFormat MBTC = new MonetaryFormat().shift(3).minDecimals(2).optionalDecimals(2);
    ;;; Standard format for the µBTC denomination. ;;
#_public
#_static
#_final
    MonetaryFormat UBTC = new MonetaryFormat().shift(6).minDecimals(0).optionalDecimals(2);
    ;;; Standard format for fiat amounts. ;;
#_public
#_static
#_final
    MonetaryFormat FIAT = new MonetaryFormat().shift(0).minDecimals(2).repeatOptionalDecimals(2, 1);
    ;;; Currency code for base 1 Bitcoin. ;;
#_public
#_static
#_final
    String CODE_BTC = "BTC";
    ;;; Currency code for base 1/1000 Bitcoin. ;;
#_public
#_static
#_final
    String CODE_MBTC = "mBTC";
    ;;; Currency code for base 1/1000000 Bitcoin. ;;
#_public
#_static
#_final
    String CODE_UBTC = "µBTC";

#_public
#_static
#_final
    int MAX_DECIMALS = 8;

#_private
#_final
    char negativeSign;
#_private
#_final
    char positiveSign;
#_private
#_final
    char zeroDigit;
#_private
#_final
    char decimalMark;
#_private
#_final
    int minDecimals;
#_private
#_final
    List<Integer> decimalGroups;
#_private
#_final
    int shift;
#_private
#_final
    RoundingMode roundingMode;
#_private
#_final
    String[] codes;
#_private
#_final
    char codeSeparator;
#_private
#_final
    boolean codePrefixed;

#_private
#_static
#_final
    String DECIMALS_PADDING = "0000000000000000"; ;; a few more than necessary for Bitcoin

    ;;;
     ; Set character to prefix negative values.
     ;;
#_public
    MonetaryFormat negativeSign(char negativeSign)
    (§
        Preconditions.checkArgument(!Character.isDigit(negativeSign));
        Preconditions.checkArgument(0 < negativeSign);

        return (negativeSign == this.negativeSign) ? this : new MonetaryFormat(negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, codePrefixed);
    )

    ;;;
     ; Set character to prefix positive values.  A zero value means no sign is used in this case.
     ; For parsing, a missing sign will always be interpreted as if the positive sign was used.
     ;;
#_public
    MonetaryFormat positiveSign(char positiveSign)
    (§
        Preconditions.checkArgument(!Character.isDigit(positiveSign));

        return (positiveSign == this.positiveSign) ? this : new MonetaryFormat(negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, codePrefixed);
    )

    ;;;
     ; Set character range to use for representing digits.  It starts with the specified character representing zero.
     ;;
#_public
    MonetaryFormat digits(char zeroDigit)
    (§
        return (zeroDigit == this.zeroDigit) ? this : new MonetaryFormat(negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, codePrefixed);
    )

    ;;;
     ; Set character to use as the decimal mark.  If the formatted value does not have any decimals,
     ; no decimal mark is used either.
     ;;
#_public
    MonetaryFormat decimalMark(char decimalMark)
    (§
        Preconditions.checkArgument(!Character.isDigit(decimalMark));
        Preconditions.checkArgument(0 < decimalMark);

        return (decimalMark == this.decimalMark) ? this : new MonetaryFormat(negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, codePrefixed);
    )

    ;;;
     ; Set minimum number of decimals to use for formatting.  If the value precision exceeds all decimals specified
     ; (including additional decimals specified by {@link #optionalDecimals(int...)} or {@link #repeatOptionalDecimals(int, int)}),
     ; the value will be rounded.  This configuration is not relevant for parsing.
     ;;
#_public
    MonetaryFormat minDecimals(int minDecimals)
    (§
        return (minDecimals == this.minDecimals) ? this : new MonetaryFormat(negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, codePrefixed);
    )

    ;;;
     ; Set additional groups of decimals to use after the minimum decimals, if they are useful for expressing precision.
     ; Each value is a number of decimals in that group.  If the value precision exceeds all decimals specified
     ; (including minimum decimals), the value will be rounded.  This configuration is not relevant for parsing.
     ;
     ; For example, if you pass <tt>4,2</tt> it will add four decimals to your formatted string if needed, and then add
     ; another two decimals if needed.  At this point, rather than adding further decimals the value will be rounded.
     ;
     ; @param groups Any number numbers of decimals, one for each group.
     ;;
#_public
    MonetaryFormat optionalDecimals(int... groups)
    (§
        List<Integer> decimalGroups = new ArrayList<>(groups.length);
        for (int group : groups)
            decimalGroups.add(group);
        return new MonetaryFormat(negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, codePrefixed);
    )

    ;;;
     ; Set repeated additional groups of decimals to use after the minimum decimals, if they are useful for expressing
     ; precision.  If the value precision exceeds all decimals specified (including minimum decimals), the value will be
     ; rounded.  This configuration is not relevant for parsing.
     ;
     ; For example, if you pass <tt>1,8</tt> it will up to eight decimals to your formatted string if needed.
     ; After these have been used up, rather than adding further decimals the value will be rounded.
     ;
     ; @param decimals Value of the group to be repeated.
     ; @param repetitions Number of repetitions.
     ;;
#_public
    MonetaryFormat repeatOptionalDecimals(int decimals, int repetitions)
    (§
        Preconditions.checkArgument(0 <= repetitions);

        List<Integer> decimalGroups = new ArrayList<>(repetitions);
        for (int i = 0; i < repetitions; i++)
            decimalGroups.add(decimals);
        return new MonetaryFormat(negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, codePrefixed);
    )

    ;;;
     ; Set number of digits to shift the decimal separator to the right, coming from the standard BTC notation that was
     ; common pre-2014.  Note this will change the currency code if enabled.
     ;;
#_public
    MonetaryFormat shift(int shift)
    (§
        return (shift == this.shift) ? this : new MonetaryFormat(negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, codePrefixed);
    )

    ;;;
     ; Set rounding mode to use when it becomes necessary.
     ;;
#_public
    MonetaryFormat roundingMode(RoundingMode roundingMode)
    (§
        return (roundingMode == this.roundingMode) ? this : new MonetaryFormat(negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, codePrefixed);
    )

    ;;;
     ; Don't display currency code when formatting.  This configuration is not relevant for parsing.
     ;;
#_public
    MonetaryFormat noCode()
    (§
        return (codes == nil) ? this : new MonetaryFormat(negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, nil, codeSeparator, codePrefixed);
    )

    ;;;
     ; Configure currency code for given decimal separator shift.  This configuration is not relevant for parsing.
     ;
     ; @param codeShift Decimal separator shift, see {@link #shift}.
     ; @param code Currency code.
     ;;
#_public
    MonetaryFormat code(int codeShift, String code)
    (§
        Preconditions.checkArgument(0 <= codeShift);

#_final
        String[] codes = (this.codes != nil) ? Arrays.copyOf(this.codes, this.codes.length) : new String[MAX_DECIMALS];

        codes[codeShift] = code;
        return new MonetaryFormat(negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, codePrefixed);
    )

    ;;;
     ; Separator between currency code and formatted value.  This configuration is not relevant for parsing.
     ;;
#_public
    MonetaryFormat codeSeparator(char codeSeparator)
    (§
        Preconditions.checkArgument(!Character.isDigit(codeSeparator));
        Preconditions.checkArgument(0 < codeSeparator);

        return (codeSeparator == this.codeSeparator) ? this : new MonetaryFormat(negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, codePrefixed);
    )

    ;;;
     ; Prefix formatted output by currency code.  This configuration is not relevant for parsing.
     ;;
#_public
    MonetaryFormat prefixCode()
    (§
        return codePrefixed ? this : new MonetaryFormat(negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, true);
    )

    ;;;
     ; Postfix formatted output with currency code.  This configuration is not relevant for parsing.
     ;;
#_public
    MonetaryFormat postfixCode()
    (§
        return !codePrefixed ? this : new MonetaryFormat(negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, false);
    )

    ;;;
     ; Configure this instance with values from a {@link Locale}.
     ;;
#_public
    MonetaryFormat withLocale(Locale locale)
    (§
        DecimalFormatSymbols dfs = new DecimalFormatSymbols(locale);
        char negativeSign = dfs.getMinusSign();
        char zeroDigit = dfs.getZeroDigit();
        char decimalMark = dfs.getMonetaryDecimalSeparator();
        return new MonetaryFormat(negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, codePrefixed);
    )

#_public
    MonetaryFormat()
    (§
        ;; defaults
        this.negativeSign = '-';
        this.positiveSign = 0; ;; none
        this.zeroDigit = '0';
        this.decimalMark = '.';
        this.minDecimals = 2;
        this.decimalGroups = nil;
        this.shift = 0;
        this.roundingMode = RoundingMode.HALF_UP;
        this.codes = new String[MAX_DECIMALS];
        this.codes[0] = CODE_BTC;
        this.codes[3] = CODE_MBTC;
        this.codes[6] = CODE_UBTC;
        this.codeSeparator = ' ';
        this.codePrefixed = true;
    )

#_private
    MonetaryFormat(char negativeSign, char positiveSign, char zeroDigit, char decimalMark, int minDecimals, List<Integer> decimalGroups, int shift, RoundingMode roundingMode, String[] codes, char codeSeparator, boolean codePrefixed)
    (§
        this.negativeSign = negativeSign;
        this.positiveSign = positiveSign;
        this.zeroDigit = zeroDigit;
        this.decimalMark = decimalMark;
        this.minDecimals = minDecimals;
        this.decimalGroups = decimalGroups;
        this.shift = shift;
        this.roundingMode = roundingMode;
        this.codes = codes;
        this.codeSeparator = codeSeparator;
        this.codePrefixed = codePrefixed;
    )

    ;;;
     ; Format the given monetary value to a human readable form.
     ;;
#_public
    CharSequence format(Monetary monetary)
    (§
        ;; preparation
        int maxDecimals = minDecimals;
        if (decimalGroups != nil)
            for (int group : decimalGroups)
                maxDecimals += group;
        int smallestUnitExponent = monetary.smallestUnitExponent();
        Preconditions.checkState(maxDecimals <= smallestUnitExponent, "The maximum possible number of decimals (%s) cannot exceed %s.", maxDecimals, smallestUnitExponent);

        ;; rounding
        long satoshis = Math.abs(monetary.getValue());
        long precisionDivisor = checkedPow(10, smallestUnitExponent - shift - maxDecimals);
        satoshis = checkedMultiply(divide(satoshis, precisionDivisor, roundingMode), precisionDivisor);

        ;; shifting
        long shiftDivisor = checkedPow(10, smallestUnitExponent - shift);
        long numbers = satoshis / shiftDivisor;
        long decimals = satoshis % shiftDivisor;

        ;; formatting
        String decimalsStr = String.format(Locale.US, "%0" + (smallestUnitExponent - shift) + "d", decimals);
        StringBuilder sb = new StringBuilder(decimalsStr);
        while (minDecimals < sb.length() && sb.charAt(sb.length() - 1) == '0')
            sb.setLength(sb.length() - 1); ;; trim trailing zero
        int i = minDecimals;
        if (decimalGroups != nil)
        (§
            for (int group : decimalGroups)
            (§
                if (i < sb.length() && sb.length() < i + group)
                (§
                    while (sb.length() < i + group)
                        sb.append('0');
                    break;
                )
                i += group;
            )
        )
        if (0 < sb.length())
            sb.insert(0, decimalMark);
        sb.insert(0, numbers);
        if (monetary.getValue() < 0)
            sb.insert(0, negativeSign);
        else if (positiveSign != 0)
            sb.insert(0, positiveSign);
        if (codes != nil)
        (§
            if (codePrefixed)
            (§
                sb.insert(0, codeSeparator);
                sb.insert(0, code());
            )
            else
            (§
                sb.append(codeSeparator);
                sb.append(code());
            )
        )

        ;; Convert to non-arabic digits.
        if (zeroDigit != '0')
        (§
            int offset = zeroDigit - '0';
            for (int d = 0; d < sb.length(); d++)
            (§
                char c = sb.charAt(d);
                if (Character.isDigit(c))
                    sb.setCharAt(d, (char)(c + offset));
            )
        )
        return sb;
    )

    ;;;
     ; Parse a human readable coin value to a {@link org.bitcoinj.core.Coin} instance.
     ;
     ; @throws NumberFormatException if the string cannot be parsed for some reason.
     ;;
#_public
    Coin parse(String str)
        throws NumberFormatException
    (§
        return Coin.valueOf(parseValue(str, Coin.SMALLEST_UNIT_EXPONENT));
    )

    ;;;
     ; Parse a human readable fiat value to a {@link org.bitcoinj.utils.Fiat} instance.
     ;
     ; @throws NumberFormatException if the string cannot be parsed for some reason.
     ;;
#_public
    Fiat parseFiat(String currencyCode, String str)
        throws NumberFormatException
    (§
        return Fiat.valueOf(currencyCode, parseValue(str, Fiat.SMALLEST_UNIT_EXPONENT));
    )

#_private
    long parseValue(String str, int smallestUnitExponent)
    (§
        Preconditions.checkState(smallestUnitExponent <= DECIMALS_PADDING.length());

        if (str.isEmpty())
            throw new NumberFormatException("empty string");

        char first = str.charAt(0);
        if (first == negativeSign || first == positiveSign)
            str = str.substring(1);
        String numbers;
        String decimals;
        int decimalMarkIndex = str.indexOf(decimalMark);
        if (decimalMarkIndex != -1)
        (§
            numbers = str.substring(0, decimalMarkIndex);
            decimals = (str + DECIMALS_PADDING).substring(decimalMarkIndex + 1);
            if (decimals.indexOf(decimalMark) != -1)
                throw new NumberFormatException("more than one decimal mark");
        )
        else
        (§
            numbers = str;
            decimals = DECIMALS_PADDING;
        )

        String satoshis = numbers + decimals.substring(0, smallestUnitExponent - shift);
        for (char c : satoshis.toCharArray())
            if (!Character.isDigit(c))
                throw new NumberFormatException("illegal character: " + c);

        ;; Non-arabic digits allowed here.
        long value = Long.parseLong(satoshis);
        if (first == negativeSign)
            value = -value;
        return value;
    )

    ;;;
     ; Get currency code that will be used for current shift.
     ;;
#_public
    String code()
    (§
        if (codes == nil)
            return nil;
        if (codes[shift] == nil)
            throw new NumberFormatException("missing code for shift: " + shift);
        return codes[shift];
    )
)

(ns org.bitcoinj.utils #_"TaggableObject"
    (:import [java.util Map])
    (:import [com.google.protobuf ByteString]))

;;;
 ; <p>An object that can carry around and possibly serialize a map of strings to immutable byte arrays.  Tagged objects
 ; can have data stored on them that might be useful for an application developer.  For example a wallet can store tags,
 ; and thus this would be a reasonable place to put any important data items that the bitcoinj API does not allow for:
 ; things like exchange rates at the time a transaction was made would currently fall into this category.  Of course,
 ; it helps interop and other developers if you introduce a real type safe API for a new feature instead of using this
 ; so please consider that path, if you find yourself tempted to store tags!</p>
 ;
 ; <p>Good tag names won't conflict with other people's code, should you one day decide to merge them.  Choose tag names
 ; like "com.example:keyowner:02b7e6dc316dfaa19c5a599f63d88ffeae398759b857ca56b2f69de3e815381343" instead of "owner"
 ; or just "o".  Also, it's good practice to create constants for each string you use, to help avoid typos
 ; in string parameters causing confusing bugs!</p>
 ;;
#_public
interface TaggableObject
(§
    ;;; Returns the immutable byte array associated with the given tag name, or null if there is none. ;;
#_nilable
    ByteString maybeGetTag(String tag);

    ;;;
     ; Returns the immutable byte array associated with the given tag name, or throws {@link java.lang.IllegalArgumentException}
     ; if that tag wasn't set yet.
     ;;
    ByteString getTag(String tag);

    ;;; Associates the given immutable byte array with the string tag.  See the docs for TaggableObject to learn more. ;;
    void setTag(String tag, ByteString value);

    ;;; Returns a copy of all the tags held by this object. ;;
    Map<String, ByteString> getTags();
)

(ns org.bitcoinj.utils #_"Threading"
    (:import #_[java.util.concurrent *]
             [java.util.concurrent.locks ReentrantLock])
    (:import [com.google.common.util.concurrent CycleDetectingLockFactory ListeningExecutorService MoreExecutors Uninterruptibles]
             [org.slf4j Logger LoggerFactory])
  #_(:require #_[org.bitcoinj.core *]))

;;;
 ; Various threading related utilities.  Provides a wrapper around explicit lock creation that lets you control whether
 ; bitcoinj performs cycle detection or not.  Cycle detection is useful to detect bugs but comes with a small cost.
 ; Also provides a worker thread that is designed for event listeners to be dispatched on.
 ;;
#_public
class Threading
(§
    ;;;
     ; An executor with one thread that is intended for running event listeners on.  This ensures all event listener
     ; code runs without any locks being held.  It's intended for the API user to run things on.  Callbacks registered
     ; by bitcoinj internally shouldn't normally run here, although currently there are a few exceptions.
     ;;
#_public
#_static
    Executor USER_THREAD;

    ;;;
     ; A dummy executor that just invokes the runnable immediately.  Use this over
     ; {@link com.google.common.util.concurrent.MoreExecutors#sameThreadExecutor()} because the latter creates
     ; a new object each time in order to implement the more complex {@link ExecutorService} interface, which is
     ; overkill for our needs.
     ;;
#_public
#_static
#_final
    Executor SAME_THREAD;

    ;;;
     ; Put a dummy task into the queue and wait for it to be run.  Because it's single threaded, this means all
     ; tasks submitted before this point are now completed.  Usually you won't want to use this method - it's a
     ; convenience primarily used in unit testing.  If you want to wait for an event to be called the right thing
     ; to do is usually to create a {@link com.google.common.util.concurrent.SettableFuture} and then call set
     ; on it.  You can then either block on that future, compose it, add listeners to it and so on.
     ;;
#_public
#_static
    void waitForUserCode()
    (§
#_final
        CountDownLatch latch = new CountDownLatch(1);
        USER_THREAD.execute(new Runnable()
        (§
#_override
#_public
            void run()
            (§
                latch.countDown();
            )
        ));
        Uninterruptibles.awaitUninterruptibly(latch);
    )

    ;;;
     ; An exception handler that will be invoked for any exceptions that occur in the user thread, and any unhandled
     ; exceptions that are caught whilst the framework is processing network traffic or doing other background tasks.
     ; The purpose of this is to allow you to report back unanticipated crashes from your users to a central collection
     ; center for analysis and debugging.  You should configure this <b>before</b> any bitcoinj library code is run,
     ; setting it after you started network traffic and other forms of processing may result in the change not taking effect.
     ;;
#_nilable
#_public
#_static
#_volatile
    Thread.UncaughtExceptionHandler uncaughtExceptionHandler;

#_public
#_static
    class UserThread extends Thread implements Executor
    (§
#_private
#_static
#_final
        Logger log = LoggerFactory.getLogger(UserThread.class);

        ;; 10,000 pending tasks is entirely arbitrary and may or may not be appropriate for the device we're running on.
#_public
#_static
        int WARNING_THRESHOLD = 10000;

#_private
        LinkedBlockingQueue<Runnable> tasks;

#_public
        UserThread()
        (§
            super("bitcoinj user thread");

            setDaemon(true);
            tasks = new LinkedBlockingQueue<>();
            start();
        )

#_suppress("InfiniteLoopStatement")
#_override
#_public
        void run()
        (§
            while (true)
            (§
                Runnable task = Uninterruptibles.takeUninterruptibly(tasks);
                try
                (§
                    task.run();
                )
                catch (Throwable t)
                (§
                    log.warn("Exception in user thread", t);
                    Thread.UncaughtExceptionHandler handler = uncaughtExceptionHandler;
                    if (handler != nil)
                        handler.uncaughtException(this, t);
                )
            )
        )

#_override
#_public
        void execute(Runnable command)
        (§
#_final
            int size = tasks.size();
            if (size == WARNING_THRESHOLD)
            (§
                log.warn("User thread has {} pending tasks, memory exhaustion may occur.\n"
                       + "If you see this message, check your memory consumption and see if it's problematic or excessively spikey.\n"
                       + "If it is, check for deadlocked or slow event handlers. If it isn't, try adjusting the constant \n"
                       + "Threading.UserThread.WARNING_THRESHOLD upwards until it's a suitable level for your app, or Integer.MAX_VALUE to disable." , size);
            )
            Uninterruptibles.putUninterruptibly(tasks, command);
        )
    )

    #_static
    (§
        ;; Default policy goes here.  If you want to change this, use one of the static methods before instantiating
        ;; any bitcoinj objects.  The policy change will take effect only on new objects from that point onwards.
        throwOnLockCycles();

        USER_THREAD = new UserThread();
        SAME_THREAD = new Executor()
        (§
#_override
#_public
            void execute(#_non-nil Runnable runnable)
            (§
                runnable.run();
            )
        );
    )

#_private
#_static
    CycleDetectingLockFactory.Policy policy;
#_public
#_static
    CycleDetectingLockFactory factory;

#_public
#_static
    ReentrantLock lock(String name)
    (§
        return Utils.isAndroidRuntime() ? new ReentrantLock(true) : factory.newReentrantLock(name);
    )

#_public
#_static
    void warnOnLockCycles()
    (§
        setPolicy(CycleDetectingLockFactory.Policies.WARN);
    )

#_public
#_static
    void throwOnLockCycles()
    (§
        setPolicy(CycleDetectingLockFactory.Policies.THROW);
    )

#_public
#_static
    void ignoreLockCycles()
    (§
        setPolicy(CycleDetectingLockFactory.Policies.DISABLED);
    )

#_public
#_static
    void setPolicy(CycleDetectingLockFactory.Policy policy)
    (§
        Threading.policy = policy;
        factory = CycleDetectingLockFactory.newInstance(policy);
    )

#_public
#_static
    CycleDetectingLockFactory.Policy getPolicy()
    (§
        return policy;
    )

    ;;; A caching thread pool that creates daemon threads, which won't keep the JVM alive waiting for more work. ;;
#_public
#_static
    ListeningExecutorService THREAD_POOL = MoreExecutors.listeningDecorator(
            Executors.newCachedThreadPool(new ThreadFactory()
            (§
#_override
#_public
                Thread newThread(Runnable r)
                (§
                    Thread t = new Thread(r);
                    t.setName("Threading.THREAD_POOL worker");
                    t.setDaemon(true);
                    return t;
                )
            ))
    );
)

(ns org.bitcoinj.utils #_"VersionTally"
    (:import [java.util Stack])
  #_(:require [org.bitcoinj.core NetworkParameters StoredBlock]
             [org.bitcoinj.store BlockStore BlockStoreException]))

;;;
 ; Caching counter for the block versions within a moving window.  This class is NOT thread safe
 ; (as if two threads are trying to use it concurrently, there's risk of getting versions out of sequence).
 ;
 ; @see org.bitcoinj.core.NetworkParameters#getMajorityWindow()
 ; @see org.bitcoinj.core.NetworkParameters#getMajorityEnforceBlockUpgrade()
 ; @see org.bitcoinj.core.NetworkParameters#getMajorityRejectBlockOutdated()
 ;;
#_public
class VersionTally
(§
    ;;;
     ; Cache of version numbers.
     ;;
#_private
#_final
    long[] versionWindow;

    ;;;
     ; Offset within the version window at which the next version will be written.
     ;;
#_private
    int versionWriteHead = 0;

    ;;;
     ; Number of versions written into the tally.  Until this matches the length
     ; of the version window, we do not have sufficient data to return values.
     ;;
#_private
    int versionsStored = 0;

#_public
    VersionTally(final NetworkParameters params)
    (§
        versionWindow = new long[params.getMajorityWindow()];
    )

    ;;;
     ; Add a new block version to the tally, and return the count for that version within the window.
     ;
     ; @param version The block version to add.
     ;;
#_public
    void add(final long version)
    (§
        versionWindow[versionWriteHead++] = version;
        if (versionWriteHead == versionWindow.length)
            versionWriteHead = 0;
        versionsStored++;
    )

    ;;;
     ; Get the count of blocks at or above the given version, within the window.
     ;
     ; @param version The block version to query.
     ; @return the count for the block version, or null if the window is not yet full.
     ;;
#_public
    Integer getCountAtOrAbove(final long version)
    (§
        if (versionsStored < versionWindow.length)
            return nil;

        int count = 0;
        for (int versionIdx = 0; versionIdx < versionWindow.length; versionIdx++)
            if (version <= versionWindow[versionIdx])
                count++;

        return count;
    )

    ;;;
     ; Initialize the version tally from the block store.  Note this does not search backwards past
     ; the start of the block store, so if starting from a checkpoint this may not fill the window.
     ;
     ; @param blockStore Block store to load blocks from.
     ; @param chainHead Current chain tip.
     ;;
#_public
    void initialize(final BlockStore blockStore, final StoredBlock chainHead)
        throws BlockStoreException
    (§
        StoredBlock versionBlock = chainHead;
#_final
        Stack<Long> versions = new Stack<>();

        ;; We don't know how many blocks back we can go, so load what we can first.
        versions.push(versionBlock.getHeader().getVersion());
        for (int headOffset = 0; headOffset < versionWindow.length; headOffset++)
        (§
            versionBlock = versionBlock.getPrev(blockStore);
            if (versionBlock == nil)
                break;
            versions.push(versionBlock.getHeader().getVersion());
        )

        ;; Replay the versions into the tally.
        while (!versions.isEmpty())
            add(versions.pop());
    )

    ;;;
     ; Get the size of the version window.
     ;;
#_public
    int size()
    (§
        return versionWindow.length;
    )
)

(ns org.bitcoinj.wallet #_"AllRandomKeysRotating"
)

;;;
 ; Indicates that an attempt was made to upgrade a random wallet to deterministic, but there were no non-rotating
 ; random keys to use as source material for the seed.  Add a non-compromised key first!
 ;;
#_public
class AllRandomKeysRotating extends RuntimeException
(§
)

(ns org.bitcoinj.wallet #_"AllowUnconfirmedCoinSelector"
  #_(:require [org.bitcoinj.core Transaction]))

;;;
 ; This coin selector will select any transaction at all, regardless of where it came from or whether it was
 ; confirmed yet.  However immature coinbases will not be included (would be a protocol violation).
 ;;
#_public
class AllowUnconfirmedCoinSelector extends DefaultCoinSelector
(§
#_override
#_protected
    boolean shouldSelect(Transaction tx)
    (§
        return true;
    )

#_private
#_static
    AllowUnconfirmedCoinSelector instance;

    ;;; Returns a global static instance of the selector. ;;
#_public
#_static
    AllowUnconfirmedCoinSelector get()
    (§
        ;; This doesn't have to be thread safe as the object has no state, so discarded duplicates are harmless.
        if (instance == nil)
            instance = new AllowUnconfirmedCoinSelector();
        return instance;
    )
)

(ns org.bitcoinj.wallet #_"BasicKeyChain"
    (:import #_[java.util *]
             [java.util.concurrent CopyOnWriteArrayList Executor]
             [java.util.concurrent.locks ReentrantLock])
    (:import [com.google.common.base Preconditions]
             [com.google.common.collect ImmutableList Lists]
             [com.google.protobuf ByteString]
             [org.spongycastle.crypto.params KeyParameter])
  #_(:require [org.bitcoinj.core BloomFilter ECKey]
             #_[org.bitcoinj.crypto *]
             [org.bitcoinj.utils ListenerRegistration Threading]
             [org.bitcoinj.wallet.listeners KeyChainEventListener]))

;;;
 ; A {@link KeyChain} that implements the simplest model possible: it can have keys imported into it, and just
 ; acts as a dumb bag of keys.  It will, left to its own devices, always return the same key for usage by the wallet,
 ; although it will automatically add one to itself if it's empty or if encryption is requested.
 ;;
#_public
class BasicKeyChain implements EncryptableKeyChain
(§
#_private
#_final
    ReentrantLock lock = Threading.lock("BasicKeyChain");

    ;; Maps used to let us quickly look up a key given data we find in transcations or the block chain.
#_private
#_final
    LinkedHashMap<ByteString, ECKey> hashToKeys;
#_private
#_final
    LinkedHashMap<ByteString, ECKey> pubkeyToKeys;
#_nilable
#_private
#_final
    KeyCrypter keyCrypter;
#_private
    boolean isWatching;

#_private
#_final
    CopyOnWriteArrayList<ListenerRegistration<KeyChainEventListener>> listeners;

#_public
    BasicKeyChain()
    (§
        this(nil);
    )

#_public
    BasicKeyChain(#_nilable KeyCrypter crypter)
    (§
        this.keyCrypter = crypter;
        hashToKeys = new LinkedHashMap<>();
        pubkeyToKeys = new LinkedHashMap<>();
        listeners = new CopyOnWriteArrayList<>();
    )

    ;;; Returns the {@link KeyCrypter} in use or null if the key chain is not encrypted. ;;
#_override
#_nilable
#_public
    KeyCrypter getKeyCrypter()
    (§
        lock.lock();
        try
        (§
            return keyCrypter;
        )
        finally
        (§
            lock.unlock();
        )
    )

#_override
#_public
    ECKey getKey(#_nilable KeyPurpose ignored)
    (§
        lock.lock();
        try
        (§
            if (hashToKeys.isEmpty())
            (§
                ;; We will refuse to encrypt an empty key chain.
                Preconditions.checkState(keyCrypter == nil);

#_final
                ECKey key = new ECKey();
                importKeyLocked(key);
                queueOnKeysAdded(ImmutableList.of(key));
            )
            return hashToKeys.values().iterator().next();
        )
        finally
        (§
            lock.unlock();
        )
    )

#_override
#_public
    List<ECKey> getKeys(#_nilable KeyPurpose purpose, int numberOfKeys)
    (§
        Preconditions.checkArgument(0 < numberOfKeys);

        lock.lock();
        try
        (§
            if (hashToKeys.size() < numberOfKeys)
            (§
                Preconditions.checkState(keyCrypter == nil);

                List<ECKey> keys = new ArrayList<>();
                for (int i = 0; i < numberOfKeys - hashToKeys.size(); i++)
                    keys.add(new ECKey());

                ImmutableList<ECKey> immutableKeys = ImmutableList.copyOf(keys);
                importKeysLocked(immutableKeys);
                queueOnKeysAdded(immutableKeys);
            )

            List<ECKey> keysToReturn = new ArrayList<>();
            int count = 0;
            while (hashToKeys.values().iterator().hasNext() && numberOfKeys != count)
            (§
                keysToReturn.add(hashToKeys.values().iterator().next());
                count++;
            )
            return keysToReturn;
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;; Returns a copy of the list of keys that this chain is managing. ;;
#_public
    List<ECKey> getKeys()
    (§
        lock.lock();
        try
        (§
            return new ArrayList<>(hashToKeys.values());
        )
        finally
        (§
            lock.unlock();
        )
    )

#_public
    int importKeys(ECKey... keys)
    (§
        return importKeys(ImmutableList.copyOf(keys));
    )

#_public
    int importKeys(List<? extends ECKey> keys)
    (§
        lock.lock();
        try
        (§
            ;; Check that if we're encrypted, the keys are all encrypted, and if we're not, that none are.
            ;; We are NOT checking that the actual password matches here because we don't have access to the
            ;; password at this point: if you screw up and import keys with mismatched passwords, you lose!
            ;; So make sure the password is checked first.
            for (ECKey key : keys)
                checkKeyEncryptionStateMatches(key);

            List<ECKey> actuallyAdded = new ArrayList<>(keys.size());
            for (final ECKey key : keys)
            (§
                if (!hasKey(key))
                (§
                    actuallyAdded.add(key);
                    importKeyLocked(key);
                )
            )
            if (0 < actuallyAdded.size())
                queueOnKeysAdded(actuallyAdded);
            return actuallyAdded.size();
        )
        finally
        (§
            lock.unlock();
        )
    )

#_private
    void checkKeyEncryptionStateMatches(ECKey key)
    (§
        if (keyCrypter == nil && key.isEncrypted())
            throw new KeyCrypterException("Key is encrypted but chain is not");
        if (keyCrypter != nil && !key.isEncrypted())
            throw new KeyCrypterException("Key is not encrypted but chain is");
        if (keyCrypter != nil && key.getKeyCrypter() != nil && !key.getKeyCrypter().equals(keyCrypter))
            throw new KeyCrypterException("Key encrypted under different parameters to chain");
    )

#_private
    void importKeyLocked(ECKey key)
    (§
        if (hashToKeys.isEmpty())
        (§
            isWatching = key.isWatching();
        )
        else
        (§
            if (key.isWatching() && !isWatching)
                throw new IllegalArgumentException("Key is watching but chain is not");
            if (!key.isWatching() && isWatching)
                throw new IllegalArgumentException("Key is not watching but chain is");
        )
        ECKey previousKey = pubkeyToKeys.put(ByteString.copyFrom(key.getPubKey()), key);
        hashToKeys.put(ByteString.copyFrom(key.getPubKeyHash()), key);
        Preconditions.checkState(previousKey == nil);
    )

#_private
    void importKeysLocked(List<ECKey> keys)
    (§
        for (ECKey key : keys)
            importKeyLocked(key);
    )

    ;;;
     ; Imports a key to the key chain.  If key is present in the key chain, ignore it.
     ;;
#_public
    void importKey(ECKey key)
    (§
        lock.lock();
        try
        (§
            checkKeyEncryptionStateMatches(key);
            if (hasKey(key))
                return;

            importKeyLocked(key);
            queueOnKeysAdded(ImmutableList.of(key));
        )
        finally
        (§
            lock.unlock();
        )
    )

#_public
    ECKey findKeyFromPubHash(byte[] pubkeyHash)
    (§
        lock.lock();
        try
        (§
            return hashToKeys.get(ByteString.copyFrom(pubkeyHash));
        )
        finally
        (§
            lock.unlock();
        )
    )

#_public
    ECKey findKeyFromPubKey(byte[] pubkey)
    (§
        lock.lock();
        try
        (§
            return pubkeyToKeys.get(ByteString.copyFrom(pubkey));
        )
        finally
        (§
            lock.unlock();
        )
    )

#_override
#_public
    boolean hasKey(ECKey key)
    (§
        return (findKeyFromPubKey(key.getPubKey()) != nil);
    )

#_override
#_public
    int numKeys()
    (§
        return pubkeyToKeys.size();
    )

    ;;; Whether this basic key chain is empty, full of regular (usable for signing) keys, or full of watching keys. ;;
#_public
    enum State
    (§
        EMPTY,
        WATCHING,
        REGULAR
    )

    ;;;
     ; Returns whether this chain consists of pubkey only (watching) keys, regular keys (usable for signing),
     ; or has no keys in it yet at all (thus we cannot tell).
     ;;
#_public
    State isWatching()
    (§
        lock.lock();
        try
        (§
            return hashToKeys.isEmpty() ? State.EMPTY : isWatching ? State.WATCHING : State.REGULAR;
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Removes the given key from the keychain.  Be very careful with this - losing a private key
     ; <b>destroys the money associated with it</b>.
     ; @return whether the key was removed or not.
     ;;
#_public
    boolean removeKey(ECKey key)
    (§
        lock.lock();
        try
        (§
            boolean a = (hashToKeys.remove(ByteString.copyFrom(key.getPubKeyHash())) != nil);
            boolean b = (pubkeyToKeys.remove(ByteString.copyFrom(key.getPubKey())) != nil);
            Preconditions.checkState(a == b); ;; Should be in both maps or neither.
            return a;
        )
        finally
        (§
            lock.unlock();
        )
    )

#_override
#_public
    long getEarliestKeyCreationTime()
    (§
        lock.lock();
        try
        (§
            long time = Long.MAX_VALUE;
            for (ECKey key : hashToKeys.values())
                time = Math.min(key.getCreationTimeSeconds(), time);
            return time;
        )
        finally
        (§
            lock.unlock();
        )
    )

#_public
    List<ListenerRegistration<KeyChainEventListener>> getListeners()
    (§
        return new ArrayList<>(listeners);
    )

    Map<ECKey, Protos.Key.Builder> serializeToEditableProtobufs()
    (§
        Map<ECKey, Protos.Key.Builder> result = new LinkedHashMap<>();
        for (ECKey ecKey : hashToKeys.values())
        (§
            Protos.Key.Builder protoKey = serializeEncryptableItem(ecKey);
            protoKey.setPublicKey(ByteString.copyFrom(ecKey.getPubKey()));
            result.put(ecKey, protoKey);
        )
        return result;
    )

#_override
#_public
    List<Protos.Key> serializeToProtobuf()
    (§
        Collection<Protos.Key.Builder> builders = serializeToEditableProtobufs().values();
        List<Protos.Key> result = new ArrayList<>(builders.size());
        for (Protos.Key.Builder builder : builders)
            result.add(builder.build());
        return result;
    )

#_static
    Protos.Key.Builder serializeEncryptableItem(EncryptableItem item)
    (§
        Protos.Key.Builder proto = Protos.Key.newBuilder();
        proto.setCreationTimestamp(item.getCreationTimeSeconds() * 1000);
        if (item.isEncrypted() && item.getEncryptedData() != nil)
        (§
            ;; The encrypted data can be missing for an "encrypted" key in the case of a deterministic wallet
            ;; for which the leaf keys chain to an encrypted parent and rederive their private keys on the fly.
            ;; In that case the caller in DeterministicKeyChain will take care of setting the type.
            EncryptedData data = item.getEncryptedData();
            proto.getEncryptedDataBuilder()
                    .setEncryptedPrivateKey(ByteString.copyFrom(data.encryptedBytes))
                    .setInitialisationVector(ByteString.copyFrom(data.initialisationVector));
            ;; We don't allow mixing of encryption types at the moment.
            Preconditions.checkState(item.getEncryptionType() == Protos.Wallet.EncryptionType.ENCRYPTED_SCRYPT_AES);
            proto.setType(Protos.Key.Type.ENCRYPTED_SCRYPT_AES);
        )
        else
        (§
#_final
            byte[] secret = item.getSecretBytes();
            ;; The secret might be missing in the case of a watching wallet, or a key for which the private key
            ;; is expected to be rederived on the fly from its parent.
            if (secret != nil)
                proto.setSecretBytes(ByteString.copyFrom(secret));
            proto.setType(Protos.Key.Type.ORIGINAL);
        )
        return proto;
    )

    ;;;
     ; Returns a new BasicKeyChain that contains all basic, ORIGINAL type keys extracted from the list.
     ; Unrecognised key types are ignored.
     ;;
#_public
#_static
    BasicKeyChain fromProtobufUnencrypted(List<Protos.Key> keys)
        throws UnreadableWalletException
    (§
        BasicKeyChain chain = new BasicKeyChain();
        chain.deserializeFromProtobuf(keys);
        return chain;
    )

    ;;;
     ; Returns a new BasicKeyChain that contains all basic, ORIGINAL type keys and also any encrypted keys
     ; extracted from the list.  Unrecognised key types are ignored.
     ; @throws org.bitcoinj.wallet.UnreadableWalletException.BadPassword if the password doesn't seem to match.
     ; @throws org.bitcoinj.wallet.UnreadableWalletException if the data structures are corrupted/inconsistent.
     ;;
#_public
#_static
    BasicKeyChain fromProtobufEncrypted(List<Protos.Key> keys, KeyCrypter crypter)
        throws UnreadableWalletException
    (§
        BasicKeyChain chain = new BasicKeyChain(Preconditions.checkNotNull(crypter));
        chain.deserializeFromProtobuf(keys);
        return chain;
    )

#_private
    void deserializeFromProtobuf(List<Protos.Key> keys)
        throws UnreadableWalletException
    (§
        lock.lock();
        try
        (§
            Preconditions.checkState(hashToKeys.isEmpty(), "Tried to deserialize into a non-empty chain");
            for (Protos.Key key : keys)
            (§
                if (key.getType() != Protos.Key.Type.ORIGINAL && key.getType() != Protos.Key.Type.ENCRYPTED_SCRYPT_AES)
                    continue;

                boolean encrypted = (key.getType() == Protos.Key.Type.ENCRYPTED_SCRYPT_AES);
                byte[] priv = key.hasSecretBytes() ? key.getSecretBytes().toByteArray() : nil;
                if (!key.hasPublicKey())
                    throw new UnreadableWalletException("Public key missing");

                byte[] pub = key.getPublicKey().toByteArray();
                ECKey ecKey;
                if (encrypted)
                (§
                    Preconditions.checkState(keyCrypter != nil, "This wallet is encrypted but encrypt() was not called prior to deserialization");
                    if (!key.hasEncryptedData())
                        throw new UnreadableWalletException("Encrypted private key data missing");

                    Protos.EncryptedData proto = key.getEncryptedData();
                    EncryptedData e = new EncryptedData(proto.getInitialisationVector().toByteArray(), proto.getEncryptedPrivateKey().toByteArray());
                    ecKey = ECKey.fromEncrypted(e, keyCrypter, pub);
                )
                else
                (§
                    ecKey = (priv != nil) ? ECKey.fromPrivateAndPrecalculatedPublic(priv, pub) : ECKey.fromPublicOnly(pub);
                )
                ecKey.setCreationTimeSeconds(key.getCreationTimestamp() / 1000);
                importKeyLocked(ecKey);
            )
        )
        finally
        (§
            lock.unlock();
        )
    )

#_override
#_public
    void addEventListener(KeyChainEventListener listener)
    (§
        addEventListener(listener, Threading.USER_THREAD);
    )

#_override
#_public
    void addEventListener(KeyChainEventListener listener, Executor executor)
    (§
        listeners.add(new ListenerRegistration<>(listener, executor));
    )

#_override
#_public
    boolean removeEventListener(KeyChainEventListener listener)
    (§
        return ListenerRegistration.removeFromList(listener, listeners);
    )

#_private
    void queueOnKeysAdded(final List<ECKey> keys)
    (§
        Preconditions.checkState(lock.isHeldByCurrentThread());

        for (final ListenerRegistration<KeyChainEventListener> registration : listeners)
        (§
            registration.executor.execute(new Runnable()
            (§
#_override
#_public
                void run()
                (§
                    registration.listener.onKeysAdded(keys);
                )
            ));
        )
    )

    ;;;
     ; Convenience wrapper around {@link #toEncrypted(org.bitcoinj.crypto.KeyCrypter, org.spongycastle.crypto.params.KeyParameter)}
     ; which uses the default Scrypt key derivation algorithm and parameters, derives a key from the given password and returns
     ; the created key.
     ;;
#_override
#_public
    BasicKeyChain toEncrypted(CharSequence password)
    (§
        Preconditions.checkNotNull(password);
        Preconditions.checkArgument(0 < password.length());

        KeyCrypter scrypt = new KeyCrypterScrypt();
        KeyParameter derivedKey = scrypt.deriveKey(password);
        return toEncrypted(scrypt, derivedKey);
    )

    ;;;
     ; Encrypt the wallet using the KeyCrypter and the AES key.  A good default KeyCrypter to use is
     ; {@link org.bitcoinj.crypto.KeyCrypterScrypt}.
     ;
     ; @param keyCrypter The KeyCrypter that specifies how to encrypt/ decrypt a key.
     ; @param aesKey AES key to use (normally created using KeyCrypter#deriveKey and cached as it is time consuming
     ;               to create from a password).
     ; @throws KeyCrypterException if the wallet encryption fails.  If so, the wallet state is unchanged.
     ;;
#_override
#_public
    BasicKeyChain toEncrypted(KeyCrypter keyCrypter, KeyParameter aesKey)
    (§
        lock.lock();
        try
        (§
            Preconditions.checkNotNull(keyCrypter);
            Preconditions.checkState(this.keyCrypter == nil, "Key chain is already encrypted");

            BasicKeyChain encrypted = new BasicKeyChain(keyCrypter);
            for (ECKey key : hashToKeys.values())
            (§
                ECKey encryptedKey = key.encrypt(keyCrypter, aesKey);
                ;; Check that the encrypted key can be successfully decrypted.
                ;; This is done as it is a critical failure if the private key cannot be decrypted successfully
                ;; (all bitcoin controlled by that private key is lost forever).
                ;; For a correctly constructed keyCrypter the encryption should always be reversible so it is just
                ;; being as cautious as possible.
                if (!ECKey.encryptionIsReversible(key, encryptedKey, keyCrypter, aesKey))
                    throw new KeyCrypterException("The key " + key.toString() + " cannot be successfully decrypted after encryption so aborting wallet encryption.");
                encrypted.importKeyLocked(encryptedKey);
            )
            return encrypted;
        )
        finally
        (§
            lock.unlock();
        )
    )

#_override
#_public
    BasicKeyChain toDecrypted(CharSequence password)
    (§
        Preconditions.checkNotNull(keyCrypter, "Wallet is already decrypted");

        return toDecrypted(keyCrypter.deriveKey(password));
    )

#_override
#_public
    BasicKeyChain toDecrypted(KeyParameter aesKey)
    (§
        lock.lock();
        try
        (§
            Preconditions.checkState(keyCrypter != nil, "Wallet is already decrypted");

            ;; Do an up-front check.
            if (0 < numKeys() && !checkAESKey(aesKey))
                throw new KeyCrypterException("Password/key was incorrect.");

            BasicKeyChain decrypted = new BasicKeyChain();
            for (ECKey key : hashToKeys.values())
                decrypted.importKeyLocked(key.decrypt(aesKey));
            return decrypted;
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Returns whether the given password is correct for this key chain.
     ; @throws IllegalStateException if the chain is not encrypted at all.
     ;;
#_override
#_public
    boolean checkPassword(CharSequence password)
    (§
        Preconditions.checkNotNull(password);
        Preconditions.checkState(keyCrypter != nil, "Key chain not encrypted");

        return checkAESKey(keyCrypter.deriveKey(password));
    )

    ;;;
     ; Check whether the AES key can decrypt the first encrypted key in the wallet.
     ;
     ; @return true if AES key supplied can decrypt the first encrypted private key in the wallet, false otherwise.
     ;;
#_override
#_public
    boolean checkAESKey(KeyParameter aesKey)
    (§
        lock.lock();
        try
        (§
            ;; If no keys then cannot decrypt.
            if (hashToKeys.isEmpty())
                return false;

            Preconditions.checkState(keyCrypter != nil, "Key chain is not encrypted");

            ;; Find the first encrypted key in the wallet.
            ECKey first = nil;
            for (ECKey key : hashToKeys.values())
            (§
                if (key.isEncrypted())
                (§
                    first = key;
                    break;
                )
            )
            Preconditions.checkState(first != nil, "No encrypted keys in the wallet");

            try
            (§
                ECKey rebornKey = first.decrypt(aesKey);
                return Arrays.equals(first.getPubKey(), rebornKey.getPubKey());
            )
            catch (KeyCrypterException _)
            (§
                ;; The AES key supplied is incorrect.
                return false;
            )
        )
        finally
        (§
            lock.unlock();
        )
    )

#_override
#_public
    BloomFilter getFilter(int size, double falsePositiveRate, long tweak)
    (§
        lock.lock();
        try
        (§
            BloomFilter filter = new BloomFilter(size, falsePositiveRate, tweak);
            for (ECKey key : hashToKeys.values())
                filter.insert(key);
            return filter;
        )
        finally
        (§
            lock.unlock();
        )
    )

#_override
#_public
    int numBloomFilterEntries()
    (§
        return numKeys() * 2;
    )

    ;;; Returns the first ECKey created after the given UNIX time, or null if there is none. ;;
#_nilable
#_public
    ECKey findOldestKeyAfter(long timeSecs)
    (§
        lock.lock();
        try
        (§
            ECKey oldest = nil;
            for (ECKey key : hashToKeys.values())
            (§
#_final
                long keyTime = key.getCreationTimeSeconds();
                if (timeSecs < keyTime && (oldest == nil || keyTime < oldest.getCreationTimeSeconds()))
                    oldest = key;
            )
            return oldest;
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;; Returns a list of all ECKeys created after the given UNIX time. ;;
#_public
    List<ECKey> findKeysBefore(long timeSecs)
    (§
        lock.lock();
        try
        (§
            List<ECKey> results = Lists.newLinkedList();
            for (ECKey key : hashToKeys.values())
            (§
#_final
                long keyTime = key.getCreationTimeSeconds();
                if (keyTime < timeSecs)
                    results.add(key);
            )
            return results;
        )
        finally
        (§
            lock.unlock();
        )
    )
)

(ns org.bitcoinj.wallet #_"CoinSelection"
    (:import [java.util Collection])
  #_(:require [org.bitcoinj.core Coin TransactionOutput]))

;;;
 ; Represents the results of a {@link CoinSelector#select(Coin, java.util.List)} operation.
 ; A coin selection represents a list of spendable transaction outputs that sum together to give valueGathered.
 ; Different coin selections could be produced by different coin selectors from the same input set, according
 ; to their varying policies.
 ;;
#_public
class CoinSelection
(§
#_public
    Coin valueGathered;
#_public
    Collection<TransactionOutput> gathered;

#_public
    CoinSelection(Coin valueGathered, Collection<TransactionOutput> gathered)
    (§
        this.valueGathered = valueGathered;
        this.gathered = gathered;
    )
)

(ns org.bitcoinj.wallet #_"CoinSelector"
    (:import [java.util List])
  #_(:require [org.bitcoinj.core Coin TransactionOutput]))

;;;
 ; A CoinSelector is responsible for picking some outputs to spend, from the list of all possible outputs.
 ; It allows you to customize the policies for creation of transactions to suit your needs.  The select operation
 ; may return a {@link CoinSelection} that has a valueGathered lower than the requested target, if there's not
 ; enough money in the wallet.
 ;;
#_public
interface CoinSelector
(§
    ;;;
     ; Creates a CoinSelection that tries to meet the target amount of value.  The candidates list is given to
     ; this call and can be edited freely.  See the docs for CoinSelection to learn more, or look a the implementation
     ; of {@link DefaultCoinSelector}.
     ;;
    CoinSelection select(Coin target, List<TransactionOutput> candidates);
)

(ns org.bitcoinj.wallet #_"DecryptingKeyBag"
    (:import [java.util ArrayList List])
    (:import [com.google.common.base Preconditions]
             [org.spongycastle.crypto.params KeyParameter])
  #_(:require [org.bitcoinj.core ECKey]))

;;;
 ; A DecryptingKeyBag filters a pre-existing key bag, decrypting keys as they are requested using the provided AES key.
 ; If the keys are encrypted and no AES key provided, {@link org.bitcoinj.core.ECKey.KeyIsEncryptedException} will be thrown.
 ;;
#_public
class DecryptingKeyBag implements KeyBag
(§
#_protected
#_final
    KeyBag target;
#_protected
#_final
    KeyParameter aesKey;

#_public
    DecryptingKeyBag(KeyBag target, #_nilable KeyParameter aesKey)
    (§
        this.target = Preconditions.checkNotNull(target);
        this.aesKey = aesKey;
    )

#_nilable
#_private
    ECKey maybeDecrypt(ECKey key)
    (§
        if (key == nil)
            return nil;

        if (key.isEncrypted())
        (§
            if (aesKey == nil)
                throw new ECKey.KeyIsEncryptedException();
            return key.decrypt(aesKey);
        )

        return key;
    )

#_private
    RedeemData maybeDecrypt(RedeemData redeemData)
    (§
        List<ECKey> decryptedKeys = new ArrayList<>();
        for (ECKey key : redeemData.keys)
            decryptedKeys.add(maybeDecrypt(key));
        return RedeemData.of(decryptedKeys, redeemData.redeemScript);
    )

#_nilable
#_override
#_public
    ECKey findKeyFromPubHash(byte[] pubkeyHash)
    (§
        return maybeDecrypt(target.findKeyFromPubHash(pubkeyHash));
    )

#_nilable
#_override
#_public
    ECKey findKeyFromPubKey(byte[] pubkey)
    (§
        return maybeDecrypt(target.findKeyFromPubKey(pubkey));
    )

#_nilable
#_override
#_public
    RedeemData findRedeemDataFromScriptHash(byte[] scriptHash)
    (§
        return maybeDecrypt(target.findRedeemDataFromScriptHash(scriptHash));
    )
)

(ns org.bitcoinj.wallet #_"DefaultCoinSelector"
    (:import [java.math BigInteger]
             #_[java.util *])
    (:import [com.google.common.annotations VisibleForTesting])
  #_(:require [org.bitcoinj.core Coin NetworkParameters Transaction TransactionConfidence TransactionOutput]))

;;;
 ; This class implements a {@link CoinSelector} which attempts to get the highest priority possible.
 ; This means that the transaction is the most likely to get confirmed.  Note that this means we may end up
 ; "spending" more priority than would be required to get the transaction we are creating confirmed.
 ;;
#_public
class DefaultCoinSelector implements CoinSelector
(§
#_override
#_public
    CoinSelection select(Coin target, List<TransactionOutput> candidates)
    (§
        ArrayList<TransactionOutput> selected = new ArrayList<>();
        ;; Sort the inputs by age * value, so we get the highest "coindays" spent.
        ;; TODO: Consider changing the wallets internal format to track just outputs and keep them ordered.
        ArrayList<TransactionOutput> sortedOutputs = new ArrayList<>(candidates);
        ;; When calculating the wallet balance, we may be asked to select all possible coins, if so, avoid
        ;; sorting them in order to improve performance.
        ;; TODO: Take in network parameters when instanatiated, and then test against the current network.
        ;; Or just have a boolean parameter for "give me everything".
        if (!target.equals(NetworkParameters.MAX_MONEY))
            sortOutputs(sortedOutputs);
        ;; Now iterate over the sorted outputs until we have got as close to the target as possible or
        ;; a little bit over (excessive value will be change).
        long total = 0;
        for (TransactionOutput output : sortedOutputs)
        (§
            if (target.value <= total)
                break;
            ;; Only pick chain-included transactions, or transactions that are ours and pending.
            if (shouldSelect(output.getParentTransaction()))
            (§
                selected.add(output);
                total += output.getValue().value;
            )
        )
        ;; Total may be lower than the target here if the given candidates were insufficient to create
        ;; the requested transaction.
        return new CoinSelection(Coin.valueOf(total), selected);
    )

#_testing
#_static
    void sortOutputs(ArrayList<TransactionOutput> outputs)
    (§
        Collections.sort(outputs, new Comparator<TransactionOutput>()
        (§
#_override
#_public
            int compare(TransactionOutput a, TransactionOutput b)
            (§
                int depth1 = a.getParentTransactionDepthInBlocks();
                int depth2 = b.getParentTransactionDepthInBlocks();
                Coin aValue = a.getValue();
                Coin bValue = b.getValue();
                BigInteger aCoinDepth = BigInteger.valueOf(aValue.value).multiply(BigInteger.valueOf(depth1));
                BigInteger bCoinDepth = BigInteger.valueOf(bValue.value).multiply(BigInteger.valueOf(depth2));
                int c1 = bCoinDepth.compareTo(aCoinDepth);
                if (c1 != 0)
                    return c1;

                ;; The "coin * days" destroyed are equal, sort by value alone to get the lowest transaction size.
                int c2 = bValue.compareTo(aValue);
                if (c2 != 0)
                    return c2;

                ;; They are entirely equivalent (possibly pending) so sort by hash to ensure a total ordering.
                BigInteger aHash = a.getParentTransactionHash().toBigInteger();
                BigInteger bHash = b.getParentTransactionHash().toBigInteger();
                return aHash.compareTo(bHash);
            )
        ));
    )

    ;;; Sub-classes can override this to just customize whether transactions are usable, but keep age sorting. ;;
#_protected
    boolean shouldSelect(Transaction tx)
    (§
        return (tx != nil) ? isSelectable(tx) : true;
    )

#_public
#_static
    boolean isSelectable(Transaction tx)
    (§
        ;; Only pick chain-included transactions, or transactions that are ours and pending.
        TransactionConfidence confidence = tx.getConfidence();
        TransactionConfidence.ConfidenceType type = confidence.getConfidenceType();
        return type.equals(TransactionConfidence.ConfidenceType.BUILDING)
            || (type.equals(TransactionConfidence.ConfidenceType.PENDING)
                && confidence.getSource().equals(TransactionConfidence.Source.SELF)
                ;; TODO: The value 1 below dates from a time when transactions we broadcast *to* were counted, set to 0.
                && 1 < confidence.numBroadcastPeers());
    )
)

(ns org.bitcoinj.wallet #_"DefaultKeyChainFactory"
  #_(:require #_[org.bitcoinj.crypto *]))

;;;
 ; Default factory for creating keychains while de-serializing.
 ;;
#_public
class DefaultKeyChainFactory implements KeyChainFactory
(§
#_override
#_public
    DeterministicKeyChain makeKeyChain(Protos.Key key, Protos.Key firstSubKey, DeterministicSeed seed, KeyCrypter crypter, boolean isMarried)
    (§
        return isMarried ? new MarriedKeyChain(seed, crypter) : new DeterministicKeyChain(seed, crypter);
    )

#_override
#_public
    DeterministicKeyChain makeWatchingKeyChain(Protos.Key key, Protos.Key firstSubKey, DeterministicKey accountKey, boolean isFollowingKey, boolean isMarried)
        throws UnreadableWalletException
    (§
        if (!accountKey.getPath().equals(DeterministicKeyChain.ACCOUNT_ZERO_PATH))
            throw new UnreadableWalletException("Expecting account key but found key with path: " + HDUtils.formatPath(accountKey.getPath()));

        return isMarried ? new MarriedKeyChain(accountKey) : new DeterministicKeyChain(accountKey, isFollowingKey);
    )
)

(ns org.bitcoinj.wallet #_"DefaultRiskAnalysis"
    (:import [java.util List])
    (:import [com.google.common.base Preconditions]
             [org.slf4j Logger LoggerFactory])
  #_(:require [org.bitcoinj.core Coin ECKey]
             [org.bitcoinj.core.ECKey ECDSASignature]
             [org.bitcoinj.core NetworkParameters Transaction TransactionConfidence TransactionInput TransactionOutput]
             [org.bitcoinj.crypto TransactionSignature]
             [org.bitcoinj.script ScriptChunk]))

;;;
 ; <p>The default risk analysis.  Currently, it only is concerned with whether a tx/dependency is non-final or not,
 ; and whether a tx/dependency violates the dust rules.  Outside of specialised protocols you should not encounter
 ; non-final transactions.</p>
 ;;
#_public
class DefaultRiskAnalysis implements RiskAnalysis
(§
#_private
#_static
#_final
    Logger log = LoggerFactory.getLogger(DefaultRiskAnalysis.class);

    ;;;
     ; Any standard output smaller than this value (in satoshis) will be considered risky, as it's most likely
     ; be rejected by the network.  This is usually the same as {@link Transaction#MIN_NONDUST_OUTPUT} but can
     ; be different when the fee is about to change in Bitcoin Core.
     ;;
#_public
#_static
#_final
    Coin MIN_ANALYSIS_NONDUST_OUTPUT = Transaction.MIN_NONDUST_OUTPUT;

#_protected
#_final
    Transaction tx;
#_protected
#_final
    List<Transaction> dependencies;
#_nilable
#_protected
#_final
    Wallet wallet;

#_private
    Transaction nonStandard;
#_protected
    Transaction nonFinal;
#_protected
    boolean analyzed;

#_private
    DefaultRiskAnalysis(Wallet wallet, Transaction tx, List<Transaction> dependencies)
    (§
        this.tx = tx;
        this.dependencies = dependencies;
        this.wallet = wallet;
    )

#_override
#_public
    Result analyze()
    (§
        Preconditions.checkState(!analyzed);
        analyzed = true;

        Result result = analyzeIsFinal();
        if (result != nil && result != Result.OK)
            return result;

        return analyzeIsStandard();
    )

#_nilable
#_private
    Result analyzeIsFinal()
    (§
        ;; Transactions we create ourselves are, by definition, not at risk of double spending against us.
        if (tx.getConfidence().getSource() == TransactionConfidence.Source.SELF)
            return Result.OK;

        ;; We consider transactions that opt into replace-by-fee at risk of double spending.
        if (tx.isOptInFullRBF())
        (§
            nonFinal = tx;
            return Result.NON_FINAL;
        )

        if (wallet == nil)
            return nil;

#_final
        int height = wallet.getLastBlockSeenHeight();
#_final
        long time = wallet.getLastBlockSeenTimeSecs();
        ;; If the transaction has a lock time specified in blocks, we consider that if the tx would become final
        ;; in the next block, it is not risky (as it would confirm normally).
#_final
        int adjustedHeight = height + 1;

        if (!tx.isFinal(adjustedHeight, time))
        (§
            nonFinal = tx;
            return Result.NON_FINAL;
        )

        for (Transaction dep : dependencies)
        (§
            if (!dep.isFinal(adjustedHeight, time))
            (§
                nonFinal = dep;
                return Result.NON_FINAL;
            )
        )

        return Result.OK;
    )

    ;;;
     ; The reason a transaction is considered non-standard, returned by {@link #isStandard(org.bitcoinj.core.Transaction)}.
     ;;
#_public
    enum RuleViolation
    (§
        NONE,
        VERSION,
        DUST,
        SHORTEST_POSSIBLE_PUSHDATA,
        NONEMPTY_STACK, ;; Not yet implemented (for post 0.12)
        SIGNATURE_CANONICAL_ENCODING
    )

    ;;;
     ; <p>Checks if a transaction is considered "standard" by Bitcoin Core's IsStandardTx and AreInputsStandard functions.</p>
     ;
     ; <p>Note that this method currently only implements a minimum of checks.  More to be added later.</p>
     ;;
#_public
#_static
    RuleViolation isStandard(Transaction tx)
    (§
        ;; TODO: Finish this function off.
        if (1 < tx.getVersion() || tx.getVersion() < 1)
        (§
            log.warn("TX considered non-standard due to unknown version number {}", tx.getVersion());
            return RuleViolation.VERSION;
        )

#_final
        List<TransactionOutput> outputs = tx.getOutputs();
        for (int i = 0; i < outputs.size(); i++)
        (§
            TransactionOutput output = outputs.get(i);
            RuleViolation violation = isOutputStandard(output);
            if (violation != RuleViolation.NONE)
            (§
                log.warn("TX considered non-standard due to output {} violating rule {}", i, violation);
                return violation;
            )
        )

#_final
        List<TransactionInput> inputs = tx.getInputs();
        for (int i = 0; i < inputs.size(); i++)
        (§
            TransactionInput input = inputs.get(i);
            RuleViolation violation = isInputStandard(input);
            if (violation != RuleViolation.NONE)
            (§
                log.warn("TX considered non-standard due to input {} violating rule {}", i, violation);
                return violation;
            )
        )

        return RuleViolation.NONE;
    )

    ;;;
     ; Checks the output to see if the script violates a standardness rule.  Not complete.
     ;;
#_public
#_static
    RuleViolation isOutputStandard(TransactionOutput output)
    (§
        if (output.getValue().compareTo(MIN_ANALYSIS_NONDUST_OUTPUT) < 0)
            return RuleViolation.DUST;

        for (ScriptChunk chunk : output.getScriptPubKey().getChunks())
            if (chunk.isPushData() && !chunk.isShortestPossiblePushData())
                return RuleViolation.SHORTEST_POSSIBLE_PUSHDATA;

        return RuleViolation.NONE;
    )

    ;;; Checks if the given input passes some of the AreInputsStandard checks.  Not complete. ;;
#_public
#_static
    RuleViolation isInputStandard(TransactionInput input)
    (§
        for (ScriptChunk chunk : input.getScriptSig().getChunks())
        (§
            if (chunk.data != nil && !chunk.isShortestPossiblePushData())
                return RuleViolation.SHORTEST_POSSIBLE_PUSHDATA;

            if (chunk.isPushData())
            (§
                ECDSASignature signature;
                try
                (§
                    signature = ECKey.ECDSASignature.decodeFromDER(chunk.data);
                )
                catch (IllegalArgumentException _)
                (§
                    ;; Doesn't look like a signature.
                    signature = nil;
                )
                if (signature != nil)
                (§
                    if (!TransactionSignature.isEncodingCanonical(chunk.data))
                        return RuleViolation.SIGNATURE_CANONICAL_ENCODING;
                    if (!signature.isCanonical())
                        return RuleViolation.SIGNATURE_CANONICAL_ENCODING;
                )
            )
        )
        return RuleViolation.NONE;
    )

#_private
    Result analyzeIsStandard()
    (§
        ;; The IsStandard rules don't apply on testnet, because they're just a safety mechanism and we don't
        ;; want to crush innovation with valueless test coins.
        if (wallet != nil && !wallet.getNetworkParameters().getId().equals(NetworkParameters.ID_MAINNET))
            return Result.OK;

        RuleViolation ruleViolation = isStandard(tx);
        if (ruleViolation != RuleViolation.NONE)
        (§
            nonStandard = tx;
            return Result.NON_STANDARD;
        )

        for (Transaction dep : dependencies)
        (§
            ruleViolation = isStandard(dep);
            if (ruleViolation != RuleViolation.NONE)
            (§
                nonStandard = dep;
                return Result.NON_STANDARD;
            )
        )

        return Result.OK;
    )

    ;;; Returns the transaction that was found to be non-standard, or null. ;;
#_nilable
#_public
    Transaction getNonStandard()
    (§
        return nonStandard;
    )

    ;;; Returns the transaction that was found to be non-final, or null. ;;
#_nilable
#_public
    Transaction getNonFinal()
    (§
        return nonFinal;
    )

#_override
#_public
    String toString()
    (§
        if (!analyzed)
            return "Pending risk analysis for " + tx.getHashAsString();
        if (nonFinal != nil)
            return "Risky due to non-finality of " + nonFinal.getHashAsString();
        if (nonStandard != nil)
            return "Risky due to non-standard tx " + nonStandard.getHashAsString();

        return "Non-risky";
    )

#_public
#_static
    class Analyzer implements RiskAnalysis.Analyzer
    (§
#_override
#_public
        DefaultRiskAnalysis create(Wallet wallet, Transaction tx, List<Transaction> dependencies)
        (§
            return new DefaultRiskAnalysis(wallet, tx, dependencies);
        )
    )

#_public
#_static
    Analyzer FACTORY = new Analyzer();
)

(ns org.bitcoinj.wallet #_"DeterministicKeyChain"
    (:import [java.math BigInteger]
             [java.security SecureRandom]
             #_[java.util *]
             [java.util.concurrent Executor]
             [java.util.concurrent.locks ReentrantLock])
    (:import [com.google.common.base Preconditions Stopwatch]
             [com.google.common.collect ImmutableList Iterators]
             #_static #_[com.google.common.collect.Lists newArrayList]
             #_static #_[com.google.common.collect.Lists newLinkedList]
             [com.google.common.collect PeekingIterator]
             [com.google.protobuf ByteString]
             [org.slf4j Logger LoggerFactory]
             [org.spongycastle.crypto.params KeyParameter])
  #_(:require [org.bitcoinj.core BloomFilter ECKey NetworkParameters Utils]
             #_[org.bitcoinj.crypto *]
             [org.bitcoinj.script Script]
             [org.bitcoinj.utils Threading]
             [org.bitcoinj.wallet.listeners KeyChainEventListener]))

;;;
 ; <p>A deterministic key chain is a {@link KeyChain} that uses the
 ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">BIP 32 standard</a>, as implemented by
 ; {@link org.bitcoinj.crypto.DeterministicHierarchy}, to derive all the keys in the keychain from a master seed.
 ; This type of wallet is extremely convenient and flexible.  Although backing up full wallet files is always a good
 ; idea, to recover money only the root seed needs to be preserved and that is a number small enough that it can be
 ; written down on paper or, when represented using a BIP 39 {@link org.bitcoinj.crypto.MnemonicCode},
 ; dictated over the phone (possibly even memorized).</p>
 ;
 ; <p>Deterministic key chains have other advantages: parts of the key tree can be selectively revealed to allow
 ; for auditing, and new public keys can be generated without access to the private keys, yielding a highly secure
 ; configuration for web servers which can accept payments into a wallet but not spend from them.  This does not work
 ; quite how you would expect due to a quirk of elliptic curve mathematics and the techniques used to deal with it.
 ; A watching wallet is not instantiated using the public part of the master key as you may imagine.  Instead, you
 ; need to take the account key (first child of the master key) and provide the public part of that to the watching
 ; wallet instead.  You can do this by calling {@link #getWatchingKey()} and then serializing it with
 ; {@link org.bitcoinj.crypto.DeterministicKey#serializePubB58(org.bitcoinj.core.NetworkParameters)}.  The resulting
 ; "xpub..." string encodes sufficient information about the account key to create a watching chain via
 ; {@link org.bitcoinj.crypto.DeterministicKey#deserializeB58(org.bitcoinj.crypto.DeterministicKey, String, org.bitcoinj.core.NetworkParameters)}
 ; (with null as the first parameter) and then
 ; {@link DeterministicKeyChain#DeterministicKeyChain(org.bitcoinj.crypto.DeterministicKey)}.</p>
 ;
 ; <p>This class builds on {@link org.bitcoinj.crypto.DeterministicHierarchy} and {@link org.bitcoinj.crypto.DeterministicKey}
 ; by adding support for serialization to and from protobufs, and encryption of parts of the key tree.  Internally it
 ; arranges itself as per the BIP 32 spec, with the seed being used to derive a master key, which is then used to derive
 ; an account key, the account key is used to derive two child keys called the <i>internal</i> and <i>external</i> parent
 ; keys (for change and handing out addresses respectively) and finally the actual leaf keys that users use hanging off
 ; the end.  The leaf keys are special in that they don't internally store the private part at all, instead choosing to
 ; rederive the private key from the parent when needed for signing.  This simplifies the design for encrypted key chains.</p>
 ;
 ; <p>The key chain manages a <i>lookahead zone</i>.  This zone is required because when scanning the chain, you don't
 ; know exactly which keys might receive payments.  The user may have handed out several addresses and received payments
 ; on them, but for latency reasons the block chain is requested from remote peers in bulk, meaning you must
 ; "look ahead" when calculating keys to put in the Bloom filter.  The default lookahead zone is 100 keys, meaning
 ; if the user hands out more than 100 addresses and receives payment on them before the chain is next scanned, some
 ; transactions might be missed.  100 is a reasonable choice for consumer wallets running on CPU constrained devices.
 ; For industrial wallets that are receiving keys all the time, a higher value is more appropriate.  Ideally DKC and
 ; the wallet would know how to adjust this value automatically, but that's not implemented at the moment.</p>
 ;
 ; <p>In fact the real size of the lookahead zone is larger than requested, by default, it's one third larger.  This
 ; is because the act of deriving new keys means recalculating the Bloom filters and this is an expensive operation.
 ; Thus, to ensure we don't have to recalculate on every single new key/address requested or seen we add more buffer
 ; space and only extend the lookahead zone when that buffer is exhausted.  For example with a lookahead zone of 100
 ; keys, you can request 33 keys before more keys will be calculated and the Bloom filter rebuilt and rebroadcast.
 ; But even when you are requesting the 33rd key, you will still be looking 100 keys ahead.</p>
 ;
 ; @author Andreas Schildbach
 ;;
#_suppress("PublicStaticCollectionField")
#_public
class DeterministicKeyChain implements EncryptableKeyChain
(§
#_private
#_static
#_final
    Logger log = LoggerFactory.getLogger(DeterministicKeyChain.class);
#_public
#_static
#_final
    String DEFAULT_PASSPHRASE_FOR_MNEMONIC = "";

#_protected
#_final
    ReentrantLock lock = Threading.lock("DeterministicKeyChain");

#_private
    DeterministicHierarchy hierarchy;
#_nilable
#_private
    DeterministicKey rootKey;
#_nilable
#_private
    DeterministicSeed seed;

    ;; Paths through the key tree.  External keys are ones that are communicated to other parties.  Internal keys are
    ;; keys created for change addresses, coinbases, mixing, etc - anything that isn't communicated.  The distinction
    ;; is somewhat arbitrary but can be useful for audits.  The first number is the "account number" but we don't use
    ;; that feature yet.  In future we might hand out different accounts for cases where we wish to hand payers
    ;; a payment request that can generate lots of addresses independently.
    ;; The account path may be overridden by subclasses.
#_public
#_static
#_final
    ImmutableList<ChildNumber> ACCOUNT_ZERO_PATH = ImmutableList.of(ChildNumber.ZERO_HARDENED);
#_public
#_static
#_final
    ImmutableList<ChildNumber> EXTERNAL_SUBPATH = ImmutableList.of(ChildNumber.ZERO);
#_public
#_static
#_final
    ImmutableList<ChildNumber> INTERNAL_SUBPATH = ImmutableList.of(ChildNumber.ONE);
#_public
#_static
#_final
    ImmutableList<ChildNumber> EXTERNAL_PATH = HDUtils.concat(ACCOUNT_ZERO_PATH, EXTERNAL_SUBPATH);
#_public
#_static
#_final
    ImmutableList<ChildNumber> INTERNAL_PATH = HDUtils.concat(ACCOUNT_ZERO_PATH, INTERNAL_SUBPATH);
    ;; m / 44' / 0' / 0'
#_public
#_static
#_final
    ImmutableList<ChildNumber> BIP44_ACCOUNT_ZERO_PATH = ImmutableList.of(new ChildNumber(44, true), ChildNumber.ZERO_HARDENED, ChildNumber.ZERO_HARDENED);

    ;; We try to ensure we have at least this many keys ready and waiting to be handed out via getKey().  See docs
    ;; for getLookaheadSize() for more info on what this is for.  The -1 value means it hasn't been calculated yet.
    ;; For new chains it's set to whatever the default is, unless overridden by setLookaheadSize.  For deserialized
    ;; chains, it will be calculated on demand from the number of loaded keys.
#_private
#_static
#_final
    int LAZY_CALCULATE_LOOKAHEAD = -1;
#_protected
    int lookaheadSize = 100;
    ;; The lookahead threshold causes us to batch up creation of new keys to minimize the frequency of Bloom filter
    ;; regenerations, which are expensive and will (in future) trigger chain download stalls/retries.  One third is
    ;; an efficiency tradeoff.
#_protected
    int lookaheadThreshold = calcDefaultLookaheadThreshold();

#_private
    int calcDefaultLookaheadThreshold()
    (§
        return lookaheadSize / 3;
    )

    ;; The parent keys for external keys (handed out to other people) and internal keys (used for change addresses).
#_private
    DeterministicKey externalParentKey, internalParentKey;
    ;; How many keys on each path have actually been used.  This may be fewer than the number that have been
    ;; deserialized or held in memory, because of the lookahead zone.
#_private
    int issuedExternalKeys, issuedInternalKeys;
    ;; A counter that is incremented each time a key in the lookahead threshold zone is marked as used and lookahead
    ;; is triggered.  The Wallet/KCG reads these counters and combines them so it can tell the Peer whether to throw
    ;; away the current block (and any future blocks in the same download batch) and restart chain sync once a new filter
    ;; has been calculated.  This field isn't persisted to the wallet as it's only relevant within a network session.
#_private
    int keyLookaheadEpoch;

    ;; We simplify by wrapping a basic key chain and that way we get some functionality like key lookup and event
    ;; listeners "for free".  All keys in the key tree appear here, even if they aren't meant to be used for
    ;; receiving money.
#_private
#_final
    BasicKeyChain basicKeyChain;

    ;; If set this chain is following another chain in a married KeyChainGroup.
#_private
    boolean isFollowing;

    ;; Holds a number of signatures required to spend.  It's the N from N-of-M CHECKMULTISIG script for P2SH transactions
    ;; and always 1 for other transaction types.
#_protected
    int sigsRequiredToSpend = 1;

#_public
#_static
    class Builder<T extends Builder<T>>
    (§
#_protected
        SecureRandom random;
#_protected
        int bits = 128;
#_protected
        String passphrase;
#_protected
        long seedCreationTimeSecs;
#_protected
        byte[] entropy;
#_protected
        DeterministicSeed seed;
#_protected
        DeterministicKey watchingKey;

#_protected
        Builder()
        (§
        )

#_suppress("unchecked")
#_protected
        T self()
        (§
            return (T)this;
        )

        ;;;
         ; Creates a deterministic key chain starting from the given entropy.  All keys yielded by this chain will be the
         ; same if the starting entropy is the same.  You should provide the creation time in seconds since the UNIX epoch
         ; for the seed: this lets us know from what part of the chain we can expect to see derived keys appear.
         ;;
#_public
        T entropy(byte[] entropy)
        (§
            this.entropy = entropy;
            return self();
        )

        ;;;
         ; Creates a deterministic key chain starting from the given seed.  All keys yielded by this chain will be the same
         ; if the starting seed is the same.
         ;;
#_public
        T seed(DeterministicSeed seed)
        (§
            this.seed = seed;
            return self();
        )

        ;;;
         ; Generates a new key chain with entropy selected randomly from the given {@link java.security.SecureRandom} object
         ; and of the requested size in bits.  The derived seed is further protected with a user selected passphrase (see BIP 39).
         ; @param random The random number generator - use new SecureRandom().
         ; @param bits The number of bits of entropy to use when generating entropy.  Either 128 (default), 192 or 256.
         ;;
#_public
        T random(SecureRandom random, int bits)
        (§
            this.random = random;
            this.bits = bits;
            return self();
        )

        ;;;
         ; Generates a new key chain with 128 bits of entropy selected randomly from the given {@link java.security.SecureRandom}
         ; object.  The derived seed is further protected with a user selected passphrase (see BIP 39).
         ; @param random The random number generator - use new SecureRandom().
         ;;
#_public
        T random(SecureRandom random)
        (§
            this.random = random;
            return self();
        )

#_public
        T watchingKey(DeterministicKey watchingKey)
        (§
            this.watchingKey = watchingKey;
            return self();
        )

#_public
        T seedCreationTimeSecs(long seedCreationTimeSecs)
        (§
            this.seedCreationTimeSecs = seedCreationTimeSecs;
            return self();
        )

        ;;;
         ; The passphrase to use with the generated mnemonic, or null if you would like to use the default empty string.
         ; Currently must be the empty string.
         ;;
#_public
        T passphrase(String passphrase)
        (§
            ;; FIXME support non-empty passphrase
            this.passphrase = passphrase;
            return self();
        )

#_public
        DeterministicKeyChain build()
        (§
            Preconditions.checkState(random != nil || entropy != nil || seed != nil || watchingKey!= nil, "Must provide either entropy or random or seed or watchingKey");
            Preconditions.checkState(passphrase == nil || seed == nil, "Passphrase must not be specified with seed");

            ;; Default passphrase to "" if not specified.
            if (random != nil)
                return new DeterministicKeyChain(random, bits, getPassphrase(), seedCreationTimeSecs);

            if (entropy != nil)
                return new DeterministicKeyChain(entropy, getPassphrase(), seedCreationTimeSecs);

            if (seed != nil)
            (§
                seed.setCreationTimeSeconds(seedCreationTimeSecs);
                return new DeterministicKeyChain(seed);
            )

            watchingKey.setCreationTimeSeconds(seedCreationTimeSecs);
            return new DeterministicKeyChain(watchingKey);
        )

#_protected
        String getPassphrase()
        (§
            return (passphrase != nil) ? passphrase : DEFAULT_PASSPHRASE_FOR_MNEMONIC;
        )
    )

#_public
#_static
    Builder<?> builder()
    (§
        return new Builder();
    )

    ;;;
     ; Generates a new key chain with entropy selected randomly from the given {@link java.security.SecureRandom}
     ; object and the default entropy size.
     ;;
#_public
    DeterministicKeyChain(SecureRandom random)
    (§
        this(random, DeterministicSeed.DEFAULT_SEED_ENTROPY_BITS, DEFAULT_PASSPHRASE_FOR_MNEMONIC, Utils.currentTimeSeconds());
    )

    ;;;
     ; Generates a new key chain with entropy selected randomly from the given {@link java.security.SecureRandom}
     ; object and of the requested size in bits.
     ;;
#_public
    DeterministicKeyChain(SecureRandom random, int bits)
    (§
        this(random, bits, DEFAULT_PASSPHRASE_FOR_MNEMONIC, Utils.currentTimeSeconds());
    )

    ;;;
     ; Generates a new key chain with entropy selected randomly from the given {@link java.security.SecureRandom}
     ; object and of the requested size in bits.  The derived seed is further protected with a user selected passphrase
     ; (see BIP 39).
     ;;
#_public
    DeterministicKeyChain(SecureRandom random, int bits, String passphrase, long seedCreationTimeSecs)
    (§
        this(new DeterministicSeed(random, bits, passphrase, seedCreationTimeSecs));
    )

    ;;;
     ; Creates a deterministic key chain starting from the given entropy.  All keys yielded by this chain will be the
     ; same if the starting seed is the same.  You should provide the creation time in seconds since the UNIX epoch
     ; for the seed: this lets us know from what part of the chain we can expect to see derived keys appear.
     ;;
#_public
    DeterministicKeyChain(byte[] entropy, String passphrase, long seedCreationTimeSecs)
    (§
        this(new DeterministicSeed(entropy, passphrase, seedCreationTimeSecs));
    )

    ;;;
     ; Creates a deterministic key chain starting from the given seed.  All keys yielded by this chain will be the
     ; same if the starting seed is the same.
     ;;
#_protected
    DeterministicKeyChain(DeterministicSeed seed)
    (§
        this(seed, nil);
    )

    ;;;
     ; Creates a deterministic key chain that watches the given (public only) root key.  You can use this to calculate
     ; balances and generally follow along, but spending is not possible with such a chain.  Currently you can't use
     ; this method to watch an arbitrary fragment of some other tree, this limitation may be removed in future.
     ;;
#_public
    DeterministicKeyChain(DeterministicKey watchingKey)
    (§
        Preconditions.checkArgument(watchingKey.isPubKeyOnly(), "Private subtrees not currently supported: if you got this key from DKC.getWatchingKey() then use .dropPrivate().dropParent() on it first.");
        Preconditions.checkArgument(watchingKey.getPath().size() == getAccountPath().size(), "You can only watch an account key currently");

        basicKeyChain = new BasicKeyChain();
        this.seed = nil;
        this.rootKey = nil;
        basicKeyChain.importKey(watchingKey);
        hierarchy = new DeterministicHierarchy(watchingKey);
        initializeHierarchyUnencrypted(watchingKey);
    )

    ;;;
     ; <p>Creates a deterministic key chain with the given watch key.  If <code>isFollowing</code> flag is set then this
     ; keychain follows some other keychain.  In a married wallet following keychain represents "spouse's" keychain.</p>
     ; <p>Watch key has to be an account key.</p>
     ;;
#_protected
    DeterministicKeyChain(DeterministicKey watchKey, boolean isFollowing)
    (§
        this(watchKey);
        this.isFollowing = isFollowing;
    )

    ;;;
     ; Creates a deterministic key chain with the given watch key and that follows some other keychain.
     ; In a married wallet following keychain represents "spouse".
     ; Watch key has to be an account key.
     ;;
#_public
#_static
    DeterministicKeyChain watchAndFollow(DeterministicKey watchKey)
    (§
        return new DeterministicKeyChain(watchKey, true);
    )

    ;;;
     ; Creates a key chain that watches the given account key.
     ;;
#_public
#_static
    DeterministicKeyChain watch(DeterministicKey accountKey)
    (§
        return new DeterministicKeyChain(accountKey);
    )

    ;;;
     ; For use in {@link KeyChainFactory} during deserialization.
     ;;
#_protected
    DeterministicKeyChain(DeterministicSeed seed, #_nilable KeyCrypter crypter)
    (§
        this.seed = seed;
        basicKeyChain = new BasicKeyChain(crypter);
        if (!seed.isEncrypted())
        (§
            rootKey = HDKeyDerivation.createMasterPrivateKey(Preconditions.checkNotNull(seed.getSeedBytes()));
            rootKey.setCreationTimeSeconds(seed.getCreationTimeSeconds());
            basicKeyChain.importKey(rootKey);
            hierarchy = new DeterministicHierarchy(rootKey);
            for (int i = 1; i <= getAccountPath().size(); i++)
                basicKeyChain.importKey(hierarchy.get(getAccountPath().subList(0, i), false, true));
            initializeHierarchyUnencrypted(rootKey);
        )
        ;; Else...
        ;; We can't initialize ourselves with just an encrypted seed, so we expected deserialization code
        ;; to do the rest of the setup (loading the root key).
    )

    ;;;
     ; For use in encryption when {@link #toEncrypted(KeyCrypter, KeyParameter)} is called,
     ; so that subclasses can override that method and create an instance of the right class.
     ;
     ; See also {@link #makeKeyChainFromSeed(DeterministicSeed)}.
     ;;
#_protected
    DeterministicKeyChain(KeyCrypter crypter, KeyParameter aesKey, DeterministicKeyChain chain)
    (§
        ;; Can't encrypt a watching chain.
        Preconditions.checkNotNull(chain.rootKey);
        Preconditions.checkNotNull(chain.seed);

        Preconditions.checkArgument(!chain.rootKey.isEncrypted(), "Chain already encrypted");

        this.issuedExternalKeys = chain.issuedExternalKeys;
        this.issuedInternalKeys = chain.issuedInternalKeys;

        this.lookaheadSize = chain.lookaheadSize;
        this.lookaheadThreshold = chain.lookaheadThreshold;

        this.seed = chain.seed.encrypt(crypter, aesKey);
        basicKeyChain = new BasicKeyChain(crypter);
        ;; The first number is the "account number" but we don't use that feature.
        rootKey = chain.rootKey.encrypt(crypter, aesKey, nil);
        hierarchy = new DeterministicHierarchy(rootKey);
        basicKeyChain.importKey(rootKey);

        for (int i = 1; i < getAccountPath().size(); i++)
            encryptNonLeaf(aesKey, chain, rootKey, getAccountPath().subList(0, i));

        DeterministicKey account = encryptNonLeaf(aesKey, chain, rootKey, getAccountPath());
        externalParentKey = encryptNonLeaf(aesKey, chain, account, HDUtils.concat(getAccountPath(), EXTERNAL_SUBPATH));
        internalParentKey = encryptNonLeaf(aesKey, chain, account, HDUtils.concat(getAccountPath(), INTERNAL_SUBPATH));

        ;; Now copy the (pubkey only) leaf keys across to avoid rederiving them.  The private key bytes are missing
        ;; anyway so there's nothing to encrypt.
        for (ECKey eckey : chain.basicKeyChain.getKeys())
        (§
            DeterministicKey key = (DeterministicKey)eckey;
            if (key.getPath().size() != getAccountPath().size() + 2)
                continue; ;; Not a leaf key.

            DeterministicKey parent = hierarchy.get(Preconditions.checkNotNull(key.getParent()).getPath(), false, false);
            ;; Clone the key to the new encrypted hierarchy.
            key = new DeterministicKey(key.dropPrivateBytes(), parent);
            hierarchy.putKey(key);
            basicKeyChain.importKey(key);
        )
    )

    ;;; Override in subclasses to use a different account derivation path. ;;
#_protected
    ImmutableList<ChildNumber> getAccountPath()
    (§
        return ACCOUNT_ZERO_PATH;
    )

#_private
    DeterministicKey encryptNonLeaf(KeyParameter aesKey, DeterministicKeyChain chain, DeterministicKey parent, ImmutableList<ChildNumber> path)
    (§
        DeterministicKey key = chain.hierarchy.get(path, false, false);
        key = key.encrypt(Preconditions.checkNotNull(basicKeyChain.getKeyCrypter()), aesKey, parent);
        hierarchy.putKey(key);
        basicKeyChain.importKey(key);
        return key;
    )

    ;; Derives the account path keys and inserts them into the basic key chain.
    ;; This is important to preserve their order for serialization, amongst other things.
#_private
    void initializeHierarchyUnencrypted(DeterministicKey baseKey)
    (§
        externalParentKey = hierarchy.deriveChild(getAccountPath(), false, false, ChildNumber.ZERO);
        internalParentKey = hierarchy.deriveChild(getAccountPath(), false, false, ChildNumber.ONE);
        basicKeyChain.importKey(externalParentKey);
        basicKeyChain.importKey(internalParentKey);
    )

    ;;; Returns a freshly derived key that has not been returned by this method before. ;;
#_override
#_public
    DeterministicKey getKey(KeyPurpose purpose)
    (§
        return getKeys(purpose, 1).get(0);
    )

    ;;; Returns freshly derived key/s that have not been returned by this method before. ;;
#_override
#_public
    List<DeterministicKey> getKeys(KeyPurpose purpose, int numberOfKeys)
    (§
        Preconditions.checkArgument(0 < numberOfKeys);
        lock.lock();
        try
        (§
            DeterministicKey parentKey;
            int index;
            switch (purpose)
            (§
                ;; Map both REFUND and RECEIVE_KEYS to the same branch for now.  Refunds are a feature of the BIP 70
                ;; payment protocol.  Later we may wish to map it to a different branch (in a new wallet version?).
                ;; This would allow a watching wallet to only be able to see inbound payments, but not change
                ;; (i.e. spends) or refunds.  Might be useful for auditing ...
                case RECEIVE_FUNDS:
                case REFUND:
                    issuedExternalKeys += numberOfKeys;
                    index = issuedExternalKeys;
                    parentKey = externalParentKey;
                    break;
                case AUTHENTICATION:
                case CHANGE:
                    issuedInternalKeys += numberOfKeys;
                    index = issuedInternalKeys;
                    parentKey = internalParentKey;
                    break;
                default:
                    throw new UnsupportedOperationException();
            )
            ;; Optimization: potentially do a very quick key generation for just the number of keys we need if we
            ;; didn't already create them, ignoring the configured lookahead size.  This ensures we'll be able to
            ;; retrieve the keys in the following loop, but if we're totally fresh and didn't get a chance to
            ;; calculate the lookahead keys yet, this will not block waiting to calculate 100+ EC point multiplies.
            ;; On slow/crappy Android phones looking ahead 100 keys can take ~5 seconds but the OS will kill us
            ;; if we block for just one second on the UI thread.  Because UI threads may need an address in order
            ;; to render the screen, we need getKeys to be fast even if the wallet is totally brand new and lookahead
            ;; didn't happen yet.
            ;;
            ;; It's safe to do this because when a network thread tries to calculate a Bloom filter, we'll go ahead
            ;; and calculate the full lookahead zone there, so network requests will always use the right amount.
            List<DeterministicKey> lookahead = maybeLookAhead(parentKey, index, 0, 0);
            basicKeyChain.importKeys(lookahead);
            List<DeterministicKey> keys = new ArrayList<>(numberOfKeys);
            for (int i = 0; i < numberOfKeys; i++)
            (§
                ImmutableList<ChildNumber> path = HDUtils.append(parentKey.getPath(), new ChildNumber(index - numberOfKeys + i, false));
                DeterministicKey k = hierarchy.get(path, false, false);
                ;; Just a last minute sanity check before we hand the key out to the app for usage.  This isn't
                ;; inspired by any real problem reports from bitcoinj users, but I've heard of cases via the grapevine
                ;; of places that lost money due to bitflips causing addresses to not match keys.  Of course in an
                ;; environment with flaky RAM there's no real way to always win: bitflips could be introduced at any
                ;; other layer.  But as we're potentially retrieving from long term storage here, check anyway.
                checkForBitFlip(k);
                keys.add(k);
            )
            return keys;
        )
        finally
        (§
            lock.unlock();
        )
    )

#_private
    void checkForBitFlip(DeterministicKey k)
    (§
        DeterministicKey parent = Preconditions.checkNotNull(k.getParent());
        byte[] rederived = HDKeyDerivation.deriveChildKeyBytesFromPublic(parent, k.getChildNumber(), HDKeyDerivation.PublicDeriveMode.WITH_INVERSION).keyBytes;
        byte[] actual = k.getPubKey();
        if (!Arrays.equals(rederived, actual))
            throw new IllegalStateException(String.format(Locale.US, "Bit-flip check failed: %s vs %s", Arrays.toString(rederived), Arrays.toString(actual)));
    )

    ;;;
     ; Mark the DeterministicKey as used.
     ; Also correct the issued{Internal|External}Keys counter, because all lower children seem to be requested already.
     ; If the counter was updated, we also might trigger lookahead.
     ;;
#_public
    DeterministicKey markKeyAsUsed(DeterministicKey k)
    (§
        int numChildren = k.getChildNumber().i() + 1;

        if (k.getParent() == internalParentKey)
        (§
            if (issuedInternalKeys < numChildren)
            (§
                issuedInternalKeys = numChildren;
                maybeLookAhead();
            )
        )
        else if (k.getParent() == externalParentKey)
        (§
            if (issuedExternalKeys < numChildren)
            (§
                issuedExternalKeys = numChildren;
                maybeLookAhead();
            )
        )
        return k;
    )

#_public
    DeterministicKey findKeyFromPubHash(byte[] pubkeyHash)
    (§
        lock.lock();
        try
        (§
            return (DeterministicKey)basicKeyChain.findKeyFromPubHash(pubkeyHash);
        )
        finally
        (§
            lock.unlock();
        )
    )

#_public
    DeterministicKey findKeyFromPubKey(byte[] pubkey)
    (§
        lock.lock();
        try
        (§
            return (DeterministicKey)basicKeyChain.findKeyFromPubKey(pubkey);
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Mark the DeterministicKeys as used, if they match the pubkeyHash.
     ; See {@link DeterministicKeyChain#markKeyAsUsed(DeterministicKey)} for more info on this.
     ;;
#_nilable
#_public
    DeterministicKey markPubHashAsUsed(byte[] pubkeyHash)
    (§
        lock.lock();
        try
        (§
            DeterministicKey k = (DeterministicKey)basicKeyChain.findKeyFromPubHash(pubkeyHash);
            if (k != nil)
                markKeyAsUsed(k);
            return k;
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Mark the DeterministicKeys as used, if they match the pubkey.
     ; See {@link DeterministicKeyChain#markKeyAsUsed(DeterministicKey)} for more info on this.
     ;;
#_nilable
#_public
    DeterministicKey markPubKeyAsUsed(byte[] pubkey)
    (§
        lock.lock();
        try
        (§
            DeterministicKey k = (DeterministicKey)basicKeyChain.findKeyFromPubKey(pubkey);
            if (k != nil)
                markKeyAsUsed(k);
            return k;
        )
        finally
        (§
            lock.unlock();
        )
    )

#_override
#_public
    boolean hasKey(ECKey key)
    (§
        lock.lock();
        try
        (§
            return basicKeyChain.hasKey(key);
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;; Returns the deterministic key for the given absolute path in the hierarchy. ;;
#_protected
    DeterministicKey getKeyByPath(ChildNumber... path)
    (§
        return getKeyByPath(ImmutableList.copyOf(path));
    )

    ;;; Returns the deterministic key for the given absolute path in the hierarchy. ;;
#_protected
    DeterministicKey getKeyByPath(List<ChildNumber> path)
    (§
        return getKeyByPath(path, false);
    )

    ;;; Returns the deterministic key for the given absolute path in the hierarchy, optionally creating it. ;;
#_public
    DeterministicKey getKeyByPath(List<ChildNumber> path, boolean create)
    (§
        return hierarchy.get(path, false, create);
    )

    ;;;
     ; <p>An alias for <code>getKeyByPath(getAccountPath())</code>.</p>
     ;
     ; <p>Use this when you would like to create a watching key chain that follows this one, but can't spend money from it.
     ; The returned key can be serialized and then passed into {@link #watch(org.bitcoinj.crypto.DeterministicKey)}
     ; on another system to watch the hierarchy.</p>
     ;
     ; <p>Note that the returned key is not pubkey only unless this key chain already is: the returned key can still
     ; be used for signing etc if the private key bytes are available.</p>
     ;;
#_public
    DeterministicKey getWatchingKey()
    (§
        return getKeyByPath(getAccountPath());
    )

    ;;; Returns true if this chain is watch only, meaning it has public keys but no private key. ;;
#_public
    boolean isWatching()
    (§
        return getWatchingKey().isWatching();
    )

#_override
#_public
    int numKeys()
    (§
        ;; We need to return here the total number of keys including the lookahead zone, not the number
        ;; of keys we have issued via getKey/freshReceiveKey.
        lock.lock();
        try
        (§
            maybeLookAhead();
            return basicKeyChain.numKeys();
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Returns number of leaf keys used including both internal and external paths.  This may be fewer
     ; than the number that have been deserialized or held in memory, because of the lookahead zone.
     ;;
#_public
    int numLeafKeysIssued()
    (§
        lock.lock();
        try
        (§
            return issuedExternalKeys + issuedInternalKeys;
        )
        finally
        (§
            lock.unlock();
        )
    )

#_override
#_public
    long getEarliestKeyCreationTime()
    (§
        return (seed != nil) ? seed.getCreationTimeSeconds() : getWatchingKey().getCreationTimeSeconds();
    )

#_override
#_public
    void addEventListener(KeyChainEventListener listener)
    (§
        basicKeyChain.addEventListener(listener);
    )

#_override
#_public
    void addEventListener(KeyChainEventListener listener, Executor executor)
    (§
        basicKeyChain.addEventListener(listener, executor);
    )

#_override
#_public
    boolean removeEventListener(KeyChainEventListener listener)
    (§
        return basicKeyChain.removeEventListener(listener);
    )

    ;;; Returns a list of words that represent the seed or null if this chain is a watching chain. ;;
#_nilable
#_public
    List<String> getMnemonicCode()
    (§
        if (seed == nil)
            return nil;

        lock.lock();
        try
        (§
            return seed.getMnemonicCode();
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Return true if this keychain is following another keychain.
     ;;
#_public
    boolean isFollowing()
    (§
        return isFollowing;
    )

#_override
#_public
    List<Protos.Key> serializeToProtobuf()
    (§
        List<Protos.Key> result = newArrayList();
        lock.lock();
        try
        (§
            result.addAll(serializeMyselfToProtobuf());
        )
        finally
        (§
            lock.unlock();
        )
        return result;
    )

#_protected
    List<Protos.Key> serializeMyselfToProtobuf()
    (§
        ;; Most of the serialization work is delegated to the basic key chain, which will serialize the bulk of the
        ;; data (handling encryption along the way), and letting us patch it up with the extra data we care about.
        LinkedList<Protos.Key> entries = newLinkedList();
        if (seed != nil)
        (§
            Protos.Key.Builder mnemonicEntry = BasicKeyChain.serializeEncryptableItem(seed);
            mnemonicEntry.setType(Protos.Key.Type.DETERMINISTIC_MNEMONIC);
            serializeSeedEncryptableItem(seed, mnemonicEntry);
            entries.add(mnemonicEntry.build());
        )
        Map<ECKey, Protos.Key.Builder> keys = basicKeyChain.serializeToEditableProtobufs();
        for (Map.Entry<ECKey, Protos.Key.Builder> entry : keys.entrySet())
        (§
            DeterministicKey key = (DeterministicKey)entry.getKey();
            Protos.Key.Builder proto = entry.getValue();
            proto.setType(Protos.Key.Type.DETERMINISTIC_KEY);
#_final
            Protos.DeterministicKey.Builder detKey = proto.getDeterministicKeyBuilder();
            detKey.setChainCode(ByteString.copyFrom(key.getChainCode()));
            for (ChildNumber num : key.getPath())
                detKey.addPath(num.i());
            if (key.equals(externalParentKey))
            (§
                detKey.setIssuedSubkeys(issuedExternalKeys);
                detKey.setLookaheadSize(lookaheadSize);
                detKey.setSigsRequiredToSpend(getSigsRequiredToSpend());
            )
            else if (key.equals(internalParentKey))
            (§
                detKey.setIssuedSubkeys(issuedInternalKeys);
                detKey.setLookaheadSize(lookaheadSize);
                detKey.setSigsRequiredToSpend(getSigsRequiredToSpend());
            )
            ;; Flag the very first key of following keychain.
            if (entries.isEmpty() && isFollowing())
                detKey.setIsFollowing(true);
            ;; HD keys inherit the timestamp of their parent if they have one, so no need to serialize it.
            if (key.getParent() != nil)
                proto.clearCreationTimestamp();
            entries.add(proto.build());
        )
        return entries;
    )

#_static
    List<DeterministicKeyChain> fromProtobuf(List<Protos.Key> keys, #_nilable KeyCrypter crypter)
        throws UnreadableWalletException
    (§
        return fromProtobuf(keys, crypter, new DefaultKeyChainFactory());
    )

    ;;;
     ; Returns all the key chains found in the given list of keys.  Typically there will only be one,
     ; but in the case of key rotation it can happen that there are multiple chains found.
     ;;
#_public
#_static
    List<DeterministicKeyChain> fromProtobuf(List<Protos.Key> keys, #_nilable KeyCrypter crypter, KeyChainFactory factory)
        throws UnreadableWalletException
    (§
        List<DeterministicKeyChain> chains = newLinkedList();
        DeterministicSeed seed = nil;
        DeterministicKeyChain chain = nil;

        int lookaheadSize = -1;
        int sigsRequiredToSpend = 1;

        PeekingIterator<Protos.Key> iter = Iterators.peekingIterator(keys.iterator());
        while (iter.hasNext())
        (§
            Protos.Key key = iter.next();
#_final
            Protos.Key.Type t = key.getType();
            if (t == Protos.Key.Type.DETERMINISTIC_MNEMONIC)
            (§
                if (chain != nil)
                (§
                    Preconditions.checkState(0 <= lookaheadSize);

                    chain.setLookaheadSize(lookaheadSize);
                    chain.setSigsRequiredToSpend(sigsRequiredToSpend);
                    chain.maybeLookAhead();
                    chains.add(chain);
                    chain = nil;
                )
                long timestamp = key.getCreationTimestamp() / 1000;
                String passphrase = DEFAULT_PASSPHRASE_FOR_MNEMONIC; ;; FIXME allow non-empty passphrase
                if (key.hasSecretBytes())
                (§
                    if (key.hasEncryptedDeterministicSeed())
                        throw new UnreadableWalletException("Malformed key proto: " + key.toString());

                    byte[] seedBytes = nil;
                    if (key.hasDeterministicSeed())
                        seedBytes = key.getDeterministicSeed().toByteArray();
                    seed = new DeterministicSeed(key.getSecretBytes().toStringUtf8(), seedBytes, passphrase, timestamp);
                )
                else if (key.hasEncryptedData())
                (§
                    if (key.hasDeterministicSeed())
                        throw new UnreadableWalletException("Malformed key proto: " + key.toString());

                    EncryptedData data = new EncryptedData(key.getEncryptedData().getInitialisationVector().toByteArray(), key.getEncryptedData().getEncryptedPrivateKey().toByteArray());
                    EncryptedData encryptedSeedBytes = nil;
                    if (key.hasEncryptedDeterministicSeed())
                    (§
                        Protos.EncryptedData encryptedSeed = key.getEncryptedDeterministicSeed();
                        encryptedSeedBytes = new EncryptedData(encryptedSeed.getInitialisationVector().toByteArray(), encryptedSeed.getEncryptedPrivateKey().toByteArray());
                    )
                    seed = new DeterministicSeed(data, encryptedSeedBytes, timestamp);
                )
                else
                    throw new UnreadableWalletException("Malformed key proto: " + key.toString());

                if (log.isDebugEnabled())
                    log.debug("Deserializing: DETERMINISTIC_MNEMONIC: {}", seed);
            )
            else if (t == Protos.Key.Type.DETERMINISTIC_KEY)
            (§
                if (!key.hasDeterministicKey())
                    throw new UnreadableWalletException("Deterministic key missing extra data: " + key.toString());

                byte[] chainCode = key.getDeterministicKey().getChainCode().toByteArray();
                ;; Deserialize the path through the tree.
                LinkedList<ChildNumber> path = newLinkedList();
                for (int i : key.getDeterministicKey().getPathList())
                    path.add(new ChildNumber(i));

                ;; Deserialize the public key and path.
                LazyECPoint pubkey = new LazyECPoint(ECKey.CURVE.getCurve(), key.getPublicKey().toByteArray());
#_final
                ImmutableList<ChildNumber> immutablePath = ImmutableList.copyOf(path);
                ;; Possibly create the chain, if we didn't already do so yet.
                boolean isWatchingAccountKey = false;
                boolean isFollowingKey = false;
                ;; Save previous chain if any if the key is marked as following.  Current key and the next ones
                ;; are to be placed in new following key chain.
                if (key.getDeterministicKey().getIsFollowing())
                (§
                    if (chain != nil)
                    (§
                        Preconditions.checkState(0 <= lookaheadSize);

                        chain.setLookaheadSize(lookaheadSize);
                        chain.setSigsRequiredToSpend(sigsRequiredToSpend);
                        chain.maybeLookAhead();
                        chains.add(chain);
                        chain = nil;
                        seed = nil;
                    )
                    isFollowingKey = true;
                )

                if (chain == nil)
                (§
                    ;; If this is not a following chain and previous was, this must be married.
                    boolean isMarried = (!isFollowingKey && !chains.isEmpty() && chains.get(chains.size() - 1).isFollowing());
                    if (seed == nil)
                    (§
                        DeterministicKey accountKey = new DeterministicKey(immutablePath, chainCode, pubkey, nil, nil);
                        accountKey.setCreationTimeSeconds(key.getCreationTimestamp() / 1000);
                        chain = factory.makeWatchingKeyChain(key, iter.peek(), accountKey, isFollowingKey, isMarried);
                        isWatchingAccountKey = true;
                    )
                    else
                    (§
                        chain = factory.makeKeyChain(key, iter.peek(), seed, crypter, isMarried);
                        chain.lookaheadSize = LAZY_CALCULATE_LOOKAHEAD;
                        ;; If the seed is encrypted, then the chain is incomplete at this point.  However, we will load
                        ;; it up below as we parse in the keys.  We just need to check at the end that we've loaded
                        ;; everything afterwards.
                    )
                )
                ;; Find the parent key assuming this is not the root key, and not an account key for a watching chain.
                DeterministicKey parent = nil;
                if (!path.isEmpty() && !isWatchingAccountKey)
                (§
                    ChildNumber index = path.removeLast();
                    parent = chain.hierarchy.get(path, false, false);
                    path.add(index);
                )
                DeterministicKey detkey;
                if (key.hasSecretBytes())
                (§
                    ;; Not encrypted: private key is available.
#_final
                    BigInteger priv = new BigInteger(1, key.getSecretBytes().toByteArray());
                    detkey = new DeterministicKey(immutablePath, chainCode, pubkey, priv, parent);
                )
                else
                (§
                    if (key.hasEncryptedData())
                    (§
                        Protos.EncryptedData proto = key.getEncryptedData();
                        EncryptedData data = new EncryptedData(proto.getInitialisationVector().toByteArray(), proto.getEncryptedPrivateKey().toByteArray());
                        Preconditions.checkNotNull(crypter, "Encountered an encrypted key but no key crypter provided");
                        detkey = new DeterministicKey(immutablePath, chainCode, crypter, pubkey, data, parent);
                    )
                    else
                    (§
                        ;; No secret key bytes and key is not encrypted: either a watching key or private key bytes
                        ;; will be rederived on the fly from the parent.
                        detkey = new DeterministicKey(immutablePath, chainCode, pubkey, nil, parent);
                    )
                )
                if (key.hasCreationTimestamp())
                    detkey.setCreationTimeSeconds(key.getCreationTimestamp() / 1000);
                if (log.isDebugEnabled())
                    log.debug("Deserializing: DETERMINISTIC_KEY: {}", detkey);
                if (!isWatchingAccountKey)
                (§
                    ;; If the non-encrypted case, the non-leaf keys (account, internal, external) have already
                    ;; been rederived and inserted at this point.  In the encrypted case though, we can't
                    ;; rederive and we must reinsert, potentially building the heirarchy object if need be.
                    if (path.size() == 0)
                    (§
                        ;; Master key.
                        if (chain.rootKey == nil)
                        (§
                            chain.rootKey = detkey;
                            chain.hierarchy = new DeterministicHierarchy(detkey);
                        )
                    )
                    else if (path.size() == chain.getAccountPath().size() + 1)
                    (§
                        if (detkey.getChildNumber().num() == 0)
                        (§
                            chain.externalParentKey = detkey;
                            chain.issuedExternalKeys = key.getDeterministicKey().getIssuedSubkeys();
                            lookaheadSize = Math.max(lookaheadSize, key.getDeterministicKey().getLookaheadSize());
                            sigsRequiredToSpend = key.getDeterministicKey().getSigsRequiredToSpend();
                        )
                        else if (detkey.getChildNumber().num() == 1)
                        (§
                            chain.internalParentKey = detkey;
                            chain.issuedInternalKeys = key.getDeterministicKey().getIssuedSubkeys();
                        )
                    )
                )
                chain.hierarchy.putKey(detkey);
                chain.basicKeyChain.importKey(detkey);
            )
        )
        if (chain != nil)
        (§
            Preconditions.checkState(lookaheadSize >= 0);
            chain.setLookaheadSize(lookaheadSize);
            chain.setSigsRequiredToSpend(sigsRequiredToSpend);
            chain.maybeLookAhead();
            chains.add(chain);
        )
        return chains;
    )

#_override
#_public
    DeterministicKeyChain toEncrypted(CharSequence password)
    (§
        Preconditions.checkNotNull(password);
        Preconditions.checkArgument(0 < password.length());
        Preconditions.checkState(seed != nil, "Attempt to encrypt a watching chain.");
        Preconditions.checkState(!seed.isEncrypted());

        KeyCrypter scrypt = new KeyCrypterScrypt();
        KeyParameter derivedKey = scrypt.deriveKey(password);
        return toEncrypted(scrypt, derivedKey);
    )

#_override
#_public
    DeterministicKeyChain toEncrypted(KeyCrypter keyCrypter, KeyParameter aesKey)
    (§
        return new DeterministicKeyChain(keyCrypter, aesKey, this);
    )

#_override
#_public
    DeterministicKeyChain toDecrypted(CharSequence password)
    (§
        Preconditions.checkNotNull(password);
        Preconditions.checkArgument(0 < password.length());

        KeyCrypter crypter = getKeyCrypter();
        Preconditions.checkState(crypter != nil, "Chain not encrypted");
        KeyParameter derivedKey = crypter.deriveKey(password);
        return toDecrypted(derivedKey);
    )

#_override
#_public
    DeterministicKeyChain toDecrypted(KeyParameter aesKey)
    (§
        Preconditions.checkState(getKeyCrypter() != nil, "Key chain not encrypted");
        Preconditions.checkState(seed != nil, "Can't decrypt a watching chain");
        Preconditions.checkState(seed.isEncrypted());

        String passphrase = DEFAULT_PASSPHRASE_FOR_MNEMONIC; ;; FIXME allow non-empty passphrase
        DeterministicSeed decSeed = seed.decrypt(getKeyCrypter(), passphrase, aesKey);
        DeterministicKeyChain chain = makeKeyChainFromSeed(decSeed);
        ;; Now double check that the keys match to catch the case where the key is wrong but padding didn't catch it.
        if (!chain.getWatchingKey().getPubKeyPoint().equals(getWatchingKey().getPubKeyPoint()))
            throw new KeyCrypterException("Provided AES key is wrong");

        chain.lookaheadSize = lookaheadSize;
        ;; Now copy the (pubkey only) leaf keys across to avoid rederiving them.  The private key bytes are missing
        ;; anyway so there's nothing to decrypt.
        for (ECKey eckey : basicKeyChain.getKeys())
        (§
            DeterministicKey key = (DeterministicKey)eckey;
            if (key.getPath().size() != getAccountPath().size() + 2)
                continue; ;; Not a leaf key.

            Preconditions.checkState(key.isEncrypted());
            DeterministicKey parent = chain.hierarchy.get(Preconditions.checkNotNull(key.getParent()).getPath(), false, false);
            ;; Clone the key to the new decrypted hierarchy.
            key = new DeterministicKey(key.dropPrivateBytes(), parent);
            chain.hierarchy.putKey(key);
            chain.basicKeyChain.importKey(key);
        )
        chain.issuedExternalKeys = issuedExternalKeys;
        chain.issuedInternalKeys = issuedInternalKeys;
        return chain;
    )

    ;;;
     ; Factory method to create a key chain from a seed.
     ; Subclasses should override this to create an instance of the subclass instead of a plain DKC.
     ; This is used in encryption/decryption.
     ;;
#_protected
    DeterministicKeyChain makeKeyChainFromSeed(DeterministicSeed seed)
    (§
        return new DeterministicKeyChain(seed);
    )

#_override
#_public
    boolean checkPassword(CharSequence password)
    (§
        Preconditions.checkNotNull(password);
        Preconditions.checkState(getKeyCrypter() != nil, "Key chain not encrypted");

        return checkAESKey(getKeyCrypter().deriveKey(password));
    )

#_override
#_public
    boolean checkAESKey(KeyParameter aesKey)
    (§
        Preconditions.checkState(rootKey != nil, "Can't check password for a watching chain");
        Preconditions.checkNotNull(aesKey);
        Preconditions.checkState(getKeyCrypter() != nil, "Key chain not encrypted");

        try
        (§
            return rootKey.decrypt(aesKey).getPubKeyPoint().equals(rootKey.getPubKeyPoint());
        )
        catch (KeyCrypterException _)
        (§
            return false;
        )
    )

#_nilable
#_override
#_public
    KeyCrypter getKeyCrypter()
    (§
        return basicKeyChain.getKeyCrypter();
    )

#_override
#_public
    int numBloomFilterEntries()
    (§
        return numKeys() * 2;
    )

#_override
#_public
    BloomFilter getFilter(int size, double falsePositiveRate, long tweak)
    (§
        lock.lock();
        try
        (§
            Preconditions.checkArgument(numBloomFilterEntries() <= size);
            maybeLookAhead();
            return basicKeyChain.getFilter(size, falsePositiveRate, tweak);
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; <p>The number of public keys we should pre-generate on each path before they are requested by the app.  This is
     ; required so that when scanning through the chain given only a seed, we can give enough keys to the remote node
     ; via the Bloom filter such that we see transactions that are "from the future", for example transactions created
     ; by a different app that's sharing the same seed, or transactions we made before but we're replaying the chain
     ; given just the seed. The default is 100.</p>
     ;;
#_public
    int getLookaheadSize()
    (§
        lock.lock();
        try
        (§
            return lookaheadSize;
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Sets a new lookahead size.  See {@link #getLookaheadSize()} for details on what this is.  Setting a new size
     ; that's larger than the current size will return immediately and the new size will only take effect next time
     ; a fresh filter is requested (e.g. due to a new peer being connected).  So you should set this before starting
     ; to sync the chain, if you want to modify it.  If you haven't modified the lookahead threshold manually then
     ; it will be automatically set to be a third of the new size.
     ;;
#_public
    void setLookaheadSize(int lookaheadSize)
    (§
        lock.lock();
        try
        (§
            boolean readjustThreshold = (this.lookaheadThreshold == calcDefaultLookaheadThreshold());
            this.lookaheadSize = lookaheadSize;
            if (readjustThreshold)
                this.lookaheadThreshold = calcDefaultLookaheadThreshold();
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Sets the threshold for the key pre-generation.  This is used to avoid adding new keys and thus re-calculating
     ; Bloom filters every time a new key is calculated.  Without a lookahead threshold, every time we received
     ; a relevant transaction, we'd extend the lookahead zone and generate a new filter, which is inefficient.
     ;;
#_public
    void setLookaheadThreshold(int num)
    (§
        lock.lock();
        try
        (§
            if (lookaheadSize <= num)
                throw new IllegalArgumentException("Threshold larger or equal to the lookaheadSize");

            this.lookaheadThreshold = num;
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Gets the threshold for the key pre-generation.  See {@link #setLookaheadThreshold(int)} for details on what
     ; this is.  The default is a third of the lookahead size (100 / 3 == 33).  If you don't modify it explicitly,
     ; then this value will always be one third of the lookahead size.
     ;;
#_public
    int getLookaheadThreshold()
    (§
        lock.lock();
        try
        (§
            return (lookaheadThreshold < lookaheadSize) ? lookaheadThreshold : 0;
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Pre-generate enough keys to reach the lookahead size.  You can call this if you need to explicitly invoke
     ; the lookahead procedure, but it's normally unnecessary as it will be done automatically when needed.
     ;;
#_public
    void maybeLookAhead()
    (§
        lock.lock();
        try
        (§
            List<DeterministicKey> keys = maybeLookAhead(externalParentKey, issuedExternalKeys);
            keys.addAll(maybeLookAhead(internalParentKey, issuedInternalKeys));
            if (keys.isEmpty())
                return;

            keyLookaheadEpoch++;
            ;; Batch add all keys at once so there's only one event listener invocation, as this will be listened to
            ;; by the wallet and used to rebuild/broadcast the Bloom filter.  That's expensive so we don't want to do
            ;; it more often than necessary.
            basicKeyChain.importKeys(keys);
        )
        finally
        (§
            lock.unlock();
        )
    )

#_private
    List<DeterministicKey> maybeLookAhead(DeterministicKey parent, int issued)
    (§
        Preconditions.checkState(lock.isHeldByCurrentThread());

        return maybeLookAhead(parent, issued, getLookaheadSize(), getLookaheadThreshold());
    )

    ;;;
     ; Pre-generate enough keys to reach the lookahead size, but only if there are more than the lookaheadThreshold
     ; to be generated, so that the Bloom filter does not have to be regenerated that often.
     ;
     ; The returned mutable list of keys must be inserted into the basic key chain.
     ;;
#_private
    List<DeterministicKey> maybeLookAhead(DeterministicKey parent, int issued, int lookaheadSize, int lookaheadThreshold)
    (§
        Preconditions.checkState(lock.isHeldByCurrentThread());

#_final
        int numChildren = hierarchy.getNumChildren(parent.getPath());
#_final
        int needed = issued + lookaheadSize + lookaheadThreshold - numChildren;

        if (needed <= lookaheadThreshold)
            return new ArrayList<>();

        log.info("{} keys needed for {} = {} issued + {} lookahead size + {} lookahead threshold - {} num children",
                needed, parent.getPathAsString(), issued, lookaheadSize, lookaheadThreshold, numChildren);

        List<DeterministicKey> result  = new ArrayList<>(needed);
#_final
        Stopwatch watch = Stopwatch.createStarted();
        int nextChild = numChildren;
        for (int i = 0; i < needed; i++)
        (§
            DeterministicKey key = HDKeyDerivation.deriveThisOrNextChildKey(parent, nextChild);
            key = key.dropPrivateBytes();
            hierarchy.putKey(key);
            result.add(key);
            nextChild = key.getChildNumber().num() + 1;
        )
        watch.stop();
        log.info("Took {}", watch);
        return result;
    )

    ;;; Housekeeping call to call when lookahead might be needed.  Normally called automatically by KeychainGroup. ;;
#_public
    void maybeLookAheadScripts()
    (§
    )

    ;;;
     ; Returns number of keys used on external path.  This may be fewer than the number that have been deserialized
     ; or held in memory, because of the lookahead zone.
     ;;
#_public
    int getIssuedExternalKeys()
    (§
        lock.lock();
        try
        (§
            return issuedExternalKeys;
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Returns number of keys used on internal path.  This may be fewer than the number that have been deserialized
     ; or held in memory, because of the lookahead zone.
     ;;
#_public
    int getIssuedInternalKeys()
    (§
        lock.lock();
        try
        (§
            return issuedInternalKeys;
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;; Returns the seed or null if this chain is a watching chain. ;;
#_nilable
#_public
    DeterministicSeed getSeed()
    (§
        lock.lock();
        try
        (§
            return seed;
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;; For internal usage only.
    List<ECKey> getKeys(boolean includeLookahead, boolean includeParents)
    (§
        List<ECKey> keys = basicKeyChain.getKeys();
        if (!includeLookahead)
        (§
            int treeSize = internalParentKey.getPath().size();
            List<ECKey> issuedKeys = new LinkedList<>();
            for (ECKey key : keys)
            (§
                DeterministicKey detkey = (DeterministicKey)key;
                DeterministicKey parent = detkey.getParent();
                if (!includeParents && parent == nil)
                    continue;
                if (!includeParents && detkey.getPath().size() <= treeSize)
                    continue;
                if (internalParentKey.equals(parent) && issuedInternalKeys <= detkey.getChildNumber().i())
                    continue;
                if (externalParentKey.equals(parent) && issuedExternalKeys <= detkey.getChildNumber().i())
                    continue;
                issuedKeys.add(detkey);
            )
            return issuedKeys;
        )
        return keys;
    )

    ;;;
     ; Returns only the external keys that have been issued by this chain, lookahead not included.
     ;;
#_public
    List<ECKey> getIssuedReceiveKeys()
    (§
#_final
        List<ECKey> keys = new ArrayList<>(getKeys(false, false));
        for (Iterator<ECKey> i = keys.iterator(); i.hasNext(); )
        (§
            DeterministicKey parent = ((DeterministicKey)i.next()).getParent();
            if (parent == nil || !externalParentKey.equals(parent))
                i.remove();
        )
        return keys;
    )

    ;;;
     ; Returns leaf keys issued by this chain (including lookahead zone).
     ;;
#_public
    List<DeterministicKey> getLeafKeys()
    (§
        ImmutableList.Builder<DeterministicKey> keys = ImmutableList.builder();
        for (ECKey key : getKeys(true, false))
        (§
            DeterministicKey dKey = (DeterministicKey)key;
            if (dKey.getPath().size() == getAccountPath().size() + 2)
                keys.add(dKey);
        )
        return keys.build();
    )

#_static
    void serializeSeedEncryptableItem(DeterministicSeed seed, Protos.Key.Builder proto)
    (§
        ;; The seed can be missing if we have not derived it yet from the mnemonic.
        ;; This will not normally happen once all the wallets are on the latest code that caches the seed.
        if (seed.isEncrypted() && seed.getEncryptedSeedData() != nil)
        (§
            EncryptedData data = seed.getEncryptedSeedData();
            proto.getEncryptedDeterministicSeedBuilder()
                    .setEncryptedPrivateKey(ByteString.copyFrom(data.encryptedBytes))
                    .setInitialisationVector(ByteString.copyFrom(data.initialisationVector));
            ;; We don't allow mixing of encryption types at the moment.
            Preconditions.checkState(seed.getEncryptionType() == Protos.Wallet.EncryptionType.ENCRYPTED_SCRYPT_AES);
        )
        else
        (§
#_final
            byte[] secret = seed.getSeedBytes();
            if (secret != nil)
                proto.setDeterministicSeed(ByteString.copyFrom(secret));
        )
    )

    ;;;
     ; Returns a counter that is incremented each time new keys are generated due to lookahead.
     ; Used by the network code to learn whether to discard the current block and await calculation
     ; of a new filter.
     ;;
#_public
    int getKeyLookaheadEpoch()
    (§
        lock.lock();
        try
        (§
            return keyLookaheadEpoch;
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Whether the keychain is married.  A keychain is married when it vends P2SH addresses from
     ; multiple keychains in a multisig relationship.
     ; @see org.bitcoinj.wallet.MarriedKeyChain
     ;;
#_public
    boolean isMarried()
    (§
        return false;
    )

    ;;; Get redeem data for a key.  Only applicable to married keychains. ;;
#_public
    RedeemData getRedeemData(DeterministicKey followedKey)
    (§
        throw new UnsupportedOperationException();
    )

    ;;; Create a new key and return the matching output script.  Only applicable to married keychains. ;;
#_public
    Script freshOutputScript(KeyPurpose purpose)
    (§
        throw new UnsupportedOperationException();
    )

#_public
    String toString(boolean includePrivateKeys, NetworkParameters params)
    (§
#_final
        DeterministicKey watchingKey = getWatchingKey();
#_final
        StringBuilder sb = new StringBuilder();
        if (seed != nil)
        (§
            if (seed.isEncrypted())
            (§
                sb.append("Seed is encrypted\n");
            )
            else if (includePrivateKeys)
            (§
#_final
                List<String> words = seed.getMnemonicCode();
                sb.append("Seed as words: ").append(Utils.SPACE_JOINER.join(words)).append('\n');
                sb.append("Seed as hex:   ").append(seed.toHexString()).append('\n');
            )
            sb.append("Seed birthday: ").append(seed.getCreationTimeSeconds()).append("  [")
                .append(Utils.dateTimeFormat(seed.getCreationTimeSeconds() * 1000)).append("]\n");
        )
        else
        (§
            sb.append("Key birthday:  ").append(watchingKey.getCreationTimeSeconds()).append("  [")
                .append(Utils.dateTimeFormat(watchingKey.getCreationTimeSeconds() * 1000)).append("]\n");
        )
        sb.append("Key to watch:  ").append(watchingKey.serializePubB58(params)).append('\n');
        formatAddresses(includePrivateKeys, params, sb);
        return sb.toString();
    )

#_protected
    void formatAddresses(boolean includePrivateKeys, NetworkParameters params, StringBuilder builder)
    (§
        for (ECKey key : getKeys(false, true))
            key.formatKeyWithAddress(includePrivateKeys, builder, params);
    )

    ;;; The number of signatures required to spend coins received by this keychain. ;;
#_public
    void setSigsRequiredToSpend(int sigsRequiredToSpend)
    (§
        this.sigsRequiredToSpend = sigsRequiredToSpend;
    )

    ;;;
     ; Returns the number of signatures required to spend transactions for this KeyChain.
     ; It's the N from N-of-M CHECKMULTISIG script for P2SH transactions and always 1 for other transaction types.
     ;;
#_public
    int getSigsRequiredToSpend()
    (§
        return sigsRequiredToSpend;
    )

    ;;; Returns the redeem script by its hash or null if this keychain did not generate the script. ;;
#_nilable
#_public
    RedeemData findRedeemDataByScriptHash(ByteString bytes)
    (§
        return nil;
    )
)

(ns org.bitcoinj.wallet #_"DeterministicSeed"
    (:import [java.security SecureRandom]
             [java.util List])
    (:import [com.google.common.base Charsets Objects Preconditions Splitter]
             [org.spongycastle.crypto.params KeyParameter])
  #_(:require [org.bitcoinj.core Utils]
             #_static #_[org.bitcoinj.core.Utils HEX]
             #_[org.bitcoinj.crypto *]))

;;;
 ; Holds the seed bytes for the BIP32 deterministic wallet algorithm, inside a {@link DeterministicKeyChain}.
 ; The purpose of this wrapper is to simplify the encryption code.
 ;;
#_public
class DeterministicSeed implements EncryptableItem
(§
    ;; It would take more than 10^12 years to brute-force a 128 bit seed using $1B worth of computing equipment.
#_public
#_static
#_final
    int DEFAULT_SEED_ENTROPY_BITS = 128;
#_public
#_static
#_final
    int MAX_SEED_ENTROPY_BITS = 512;

#_nilable
#_private
#_final
    byte[] seed;
#_nilable
#_private
#_final
    List<String> mnemonicCode; ;; only one of mnemonicCode/encryptedMnemonicCode will be set
#_nilable
#_private
#_final
    EncryptedData encryptedMnemonicCode;
#_nilable
#_private
    EncryptedData encryptedSeed;
#_private
    long creationTimeSeconds;

#_public
    DeterministicSeed(String mnemonicCode, byte[] seed, String passphrase, long creationTimeSeconds)
        throws UnreadableWalletException
    (§
        this(decodeMnemonicCode(mnemonicCode), seed, passphrase, creationTimeSeconds);
    )

#_public
    DeterministicSeed(byte[] seed, List<String> mnemonic, long creationTimeSeconds)
    (§
        this.seed = Preconditions.checkNotNull(seed);
        this.mnemonicCode = Preconditions.checkNotNull(mnemonic);
        this.encryptedMnemonicCode = nil;
        this.creationTimeSeconds = creationTimeSeconds;
    )

#_public
    DeterministicSeed(EncryptedData encryptedMnemonic, #_nilable EncryptedData encryptedSeed, long creationTimeSeconds)
    (§
        this.seed = nil;
        this.mnemonicCode = nil;
        this.encryptedMnemonicCode = Preconditions.checkNotNull(encryptedMnemonic);
        this.encryptedSeed = encryptedSeed;
        this.creationTimeSeconds = creationTimeSeconds;
    )

    ;;;
     ; Constructs a seed from a BIP 39 mnemonic code.
     ; See {@link org.bitcoinj.crypto.MnemonicCode} for more details on this scheme.
     ; @param mnemonicCode A list of words.
     ; @param seed The derived seed, or pass null to derive it from mnemonicCode (slow).
     ; @param passphrase A user supplied passphrase, or an empty string if there is no passphrase.
     ; @param creationTimeSeconds When the seed was originally created, UNIX time.
     ;;
#_public
    DeterministicSeed(List<String> mnemonicCode, #_nilable byte[] seed, String passphrase, long creationTimeSeconds)
    (§
        this((seed != nil) ? seed : MnemonicCode.toSeed(mnemonicCode, Preconditions.checkNotNull(passphrase)), mnemonicCode, creationTimeSeconds);
    )

    ;;;
     ; Constructs a seed from a BIP 39 mnemonic code.
     ; See {@link org.bitcoinj.crypto.MnemonicCode} for more details on this scheme.
     ; @param random Entropy source.
     ; @param bits Number of bits, must be divisible by 32.
     ; @param passphrase A user supplied passphrase, or an empty string if there is no passphrase.
     ; @param creationTimeSeconds When the seed was originally created, UNIX time.
     ;;
#_public
    DeterministicSeed(SecureRandom random, int bits, String passphrase, long creationTimeSeconds)
    (§
        this(getEntropy(random, bits), Preconditions.checkNotNull(passphrase), creationTimeSeconds);
    )

    ;;;
     ; Constructs a seed from a BIP 39 mnemonic code.
     ; See {@link org.bitcoinj.crypto.MnemonicCode} for more details on this scheme.
     ; @param entropy Entropy bits, length must be divisible by 32.
     ; @param passphrase A user supplied passphrase, or an empty string if there is no passphrase.
     ; @param creationTimeSeconds When the seed was originally created, UNIX time.
     ;;
#_public
    DeterministicSeed(byte[] entropy, String passphrase, long creationTimeSeconds)
    (§
        Preconditions.checkArgument(entropy.length % 4 == 0, "entropy size in bits not divisible by 32");
        Preconditions.checkArgument(DEFAULT_SEED_ENTROPY_BITS <= entropy.length * 8, "entropy size too small");
        Preconditions.checkNotNull(passphrase);

        try
        (§
            this.mnemonicCode = MnemonicCode.INSTANCE.toMnemonic(entropy);
        )
        catch (MnemonicException.MnemonicLengthException e)
        (§
            throw new RuntimeException(e); ;; Cannot happen.
        )
        this.seed = MnemonicCode.toSeed(mnemonicCode, passphrase);
        this.encryptedMnemonicCode = nil;
        this.creationTimeSeconds = creationTimeSeconds;
    )

#_private
#_static
    byte[] getEntropy(SecureRandom random, int bits)
    (§
        Preconditions.checkArgument(bits <= MAX_SEED_ENTROPY_BITS, "requested entropy size too large");

        byte[] seed = new byte[bits / 8];
        random.nextBytes(seed);
        return seed;
    )

#_override
#_public
    boolean isEncrypted()
    (§
        Preconditions.checkState(mnemonicCode != nil || encryptedMnemonicCode != nil);
        return encryptedMnemonicCode != nil;
    )

#_override
#_public
    String toString()
    (§
        return isEncrypted()
            ? "DeterministicSeed [encrypted]"
            : "DeterministicSeed " + toHexString() + " " + Utils.SPACE_JOINER.join(mnemonicCode);
    )

    ;;; Returns the seed as hex or null if encrypted. ;;
#_nilable
#_public
    String toHexString()
    (§
        return (seed != nil) ? HEX.encode(seed) : nil;
    )

#_nilable
#_override
#_public
    byte[] getSecretBytes()
    (§
        return getMnemonicAsBytes();
    )

#_nilable
#_public
    byte[] getSeedBytes()
    (§
        return seed;
    )

#_nilable
#_override
#_public
    EncryptedData getEncryptedData()
    (§
        return encryptedMnemonicCode;
    )

#_override
#_public
    Protos.Wallet.EncryptionType getEncryptionType()
    (§
        return Protos.Wallet.EncryptionType.ENCRYPTED_SCRYPT_AES;
    )

#_nilable
#_public
    EncryptedData getEncryptedSeedData()
    (§
        return encryptedSeed;
    )

#_override
#_public
    long getCreationTimeSeconds()
    (§
        return creationTimeSeconds;
    )

#_public
    void setCreationTimeSeconds(long creationTimeSeconds)
    (§
        this.creationTimeSeconds = creationTimeSeconds;
    )

#_public
    DeterministicSeed encrypt(KeyCrypter keyCrypter, KeyParameter aesKey)
    (§
        Preconditions.checkState(encryptedMnemonicCode == nil, "Trying to encrypt seed twice");
        Preconditions.checkState(mnemonicCode != nil, "Mnemonic missing so cannot encrypt");

        EncryptedData encryptedMnemonic = keyCrypter.encrypt(getMnemonicAsBytes(), aesKey);
        EncryptedData encryptedSeed = keyCrypter.encrypt(seed, aesKey);
        return new DeterministicSeed(encryptedMnemonic, encryptedSeed, creationTimeSeconds);
    )

#_private
    byte[] getMnemonicAsBytes()
    (§
        return Utils.SPACE_JOINER.join(mnemonicCode).getBytes(Charsets.UTF_8);
    )

#_public
    DeterministicSeed decrypt(KeyCrypter crypter, String passphrase, KeyParameter aesKey)
    (§
        Preconditions.checkState(isEncrypted());
        Preconditions.checkNotNull(encryptedMnemonicCode);

        List<String> mnemonic = decodeMnemonicCode(crypter.decrypt(encryptedMnemonicCode, aesKey));
        byte[] seed = (encryptedSeed != nil) ? crypter.decrypt(encryptedSeed, aesKey) : nil;
        return new DeterministicSeed(mnemonic, seed, passphrase, creationTimeSeconds);
    )

#_override
#_public
    boolean equals(Object o)
    (§
        if (this == o)
            return true;
        if (o == nil || getClass() != o.getClass())
            return false;
        DeterministicSeed other = (DeterministicSeed)o;
        return (creationTimeSeconds == other.creationTimeSeconds && Objects.equal(encryptedMnemonicCode, other.encryptedMnemonicCode) && Objects.equal(mnemonicCode, other.mnemonicCode));
    )

#_override
#_public
    int hashCode()
    (§
        return Objects.hashCode(creationTimeSeconds, encryptedMnemonicCode, mnemonicCode);
    )

    ;;;
     ; Check if our mnemonic is a valid mnemonic phrase for our word list.
     ; Does nothing if we are encrypted.
     ;
     ; @throws org.bitcoinj.crypto.MnemonicException if check fails.
     ;;
#_public
    void check()
        throws MnemonicException
    (§
        if (mnemonicCode != nil)
            MnemonicCode.INSTANCE.check(mnemonicCode);
    )

    byte[] getEntropyBytes()
        throws MnemonicException
    (§
        return MnemonicCode.INSTANCE.toEntropy(mnemonicCode);
    )

    ;;; Get the mnemonic code, or null if unknown. ;;
#_nilable
#_public
    List<String> getMnemonicCode()
    (§
        return mnemonicCode;
    )

#_private
#_static
    List<String> decodeMnemonicCode(byte[] mnemonicCode)
    (§
        return decodeMnemonicCode(Utils.toString(mnemonicCode, "UTF-8"));
    )

#_private
#_static
    List<String> decodeMnemonicCode(String mnemonicCode)
    (§
        return Splitter.on(" ").splitToList(mnemonicCode);
    )
)

(ns org.bitcoinj.wallet #_"DeterministicUpgradeRequiredException"
)

;;;
 ; Indicates that an attempt was made to use HD wallet features on a wallet that was deserialized from an old,
 ; pre-HD random wallet without calling upgradeToDeterministic() beforehand.
 ;;
#_public
class DeterministicUpgradeRequiredException extends RuntimeException
(§
)

(ns org.bitcoinj.wallet #_"DeterministicUpgradeRequiresPassword"
)

;;;
 ; Indicates that the pre-HD random wallet is encrypted, so you should try the upgrade again after getting the
 ; users password.  This is required because HD wallets are upgraded from random using the private key bytes of
 ; the oldest non-rotating key, in order to make the upgrade process itself deterministic.
 ;;
#_public
class DeterministicUpgradeRequiresPassword extends RuntimeException
(§
)

(ns org.bitcoinj.wallet #_"EncryptableKeyChain"
    (:import [org.spongycastle.crypto.params KeyParameter])
  #_(:require [org.bitcoinj.crypto KeyCrypter KeyCrypterException]))

;;;
 ; An encryptable key chain is a key-chain that can be encrypted with a user-provided password or AES key.
 ;;
#_public
interface EncryptableKeyChain extends KeyChain
(§
    ;;;
     ; Takes the given password, which should be strong, derives a key from it and then invokes
     ; {@link #toEncrypted(org.bitcoinj.crypto.KeyCrypter, org.spongycastle.crypto.params.KeyParameter)}
     ; with {@link org.bitcoinj.crypto.KeyCrypterScrypt} as the crypter.
     ;
     ; @return the derived key, in case you wish to cache it for future use.
     ;;
    EncryptableKeyChain toEncrypted(CharSequence password);

    ;;;
     ; Returns a new keychain holding identical/cloned keys to this chain, but encrypted under the given key.
     ; Old keys and keychains remain valid and so you should ensure you don't accidentally hold references to them.
     ;;
    EncryptableKeyChain toEncrypted(KeyCrypter keyCrypter, KeyParameter aesKey);

    ;;;
     ; Decrypts the key chain with the given password.
     ; See {@link #toDecrypted(org.spongycastle.crypto.params.KeyParameter)} for details.
     ;;
    EncryptableKeyChain toDecrypted(CharSequence password);

    ;;;
     ; Decrypt the key chain with the given AES key and whatever {@link KeyCrypter} is already set.  Note that
     ; if you just want to spend money from an encrypted wallet, don't decrypt the whole thing first.  Instead,
     ; set the {@link org.bitcoinj.wallet.SendRequest#aesKey} field before asking the wallet to build the send.
     ;
     ; @param aesKey AES key to use (normally created using KeyCrypter#deriveKey and cached as it is time
     ;               consuming to create from a password).
     ; @throws KeyCrypterException if the wallet decryption fails.  If so, the wallet state is unchanged.
     ;;
    EncryptableKeyChain toDecrypted(KeyParameter aesKey);

    boolean checkPassword(CharSequence password);
    boolean checkAESKey(KeyParameter aesKey);

    ;;; Returns the key crypter used by this key chain, or null if it's not encrypted. ;;
#_nilable
    KeyCrypter getKeyCrypter();
)

(ns org.bitcoinj.wallet #_"FilteringCoinSelector"
    (:import [java.util HashSet Iterator List])
  #_(:require #_[org.bitcoinj.core *]))

;;;
 ; A filtering coin selector delegates to another coin selector, but won't select outputs spent by the given transactions.
 ;;
#_public
class FilteringCoinSelector implements CoinSelector
(§
#_protected
    CoinSelector delegate;
#_protected
    HashSet<TransactionOutPoint> spent = new HashSet<>();

#_public
    FilteringCoinSelector(CoinSelector delegate)
    (§
        this.delegate = delegate;
    )

#_public
    void excludeOutputsSpentBy(Transaction tx)
    (§
        for (TransactionInput input : tx.getInputs())
            spent.add(input.getOutpoint());
    )

#_override
#_public
    CoinSelection select(Coin target, List<TransactionOutput> candidates)
    (§
        Iterator<TransactionOutput> iter = candidates.iterator();
        while (iter.hasNext())
        (§
            TransactionOutput output = iter.next();
            if (spent.contains(output.getOutPointFor()))
                iter.remove();
        )
        return delegate.select(target, candidates);
    )
)

(ns org.bitcoinj.wallet #_"KeyBag"
  #_(:require [org.bitcoinj.core ECKey]))

;;;
 ; A KeyBag is simply an object that can map public keys, their 160-bit hashes and script hashes to ECKey
 ; and {@link RedeemData} objects.
 ;;
#_public
interface KeyBag
(§
    ;;;
     ; Locates a keypair from the keychain given the hash of the public key.  This is needed when finding out
     ; which key we need to use to redeem a transaction output.
     ;
     ; @return ECKey object or null if no such key was found.
     ;;
#_nilable
    ECKey findKeyFromPubHash(byte[] pubkeyHash);

    ;;;
     ; Locates a keypair from the keychain given the raw public key bytes.
     ;
     ; @return ECKey or null if no such key was found.
     ;;
#_nilable
    ECKey findKeyFromPubKey(byte[] pubkey);

    ;;;
     ; Locates a redeem data (redeem script and keys) from the keychain given the hash of the script.
     ; This is needed when finding out which key and script we need to use to locally sign a P2SH transaction input.
     ; It is assumed that wallet should not have more than one private key for a single P2SH tx for security reasons.
     ;
     ; @return RedeemData object or null if no such data was found.
     ;;
#_nilable
    RedeemData findRedeemDataFromScriptHash(byte[] scriptHash);
)

(ns org.bitcoinj.wallet #_"KeyChain"
    (:import [java.util List]
             [java.util.concurrent Executor])
  #_(:require [org.bitcoinj.core BloomFilter ECKey]
             [org.bitcoinj.wallet.listeners KeyChainEventListener]))

;;;
 ; <p>A KeyChain is a class that stores a collection of keys for a {@link org.bitcoinj.wallet.Wallet}.  Key chains
 ; are expected to be able to look up keys given a hash (i.e. address) or pubkey bytes, and provide keys on request
 ; for a given purpose.  They can inform event listeners about new keys being added.</p>
 ;
 ; <p>However it is important to understand what this interface does <i>not</i> provide.  It cannot encrypt or decrypt
 ; keys, for instance you need an implementor of {@link EncryptableKeyChain}.  It cannot have keys imported into it,
 ; that you to use a method of a specific key chain instance, such as {@link BasicKeyChain}.  The reason for these
 ; restrictions is to support key chains that may be handled by external hardware or software, or which are derived
 ; deterministically from a seed (and thus the notion of importing a key is meaningless).</p>
 ;;
#_public
interface KeyChain
(§
    ;;; Returns true if the given key is in the chain. ;;
    boolean hasKey(ECKey key);

    enum KeyPurpose
    (§
        RECEIVE_FUNDS,
        CHANGE,
        REFUND,
        AUTHENTICATION
    )

    ;;;
     ; Obtains a number of key/s intended for the given purpose.
     ; The chain may create new key/s, derive, or re-use an old one.
     ;;
    List<? extends ECKey> getKeys(KeyPurpose purpose, int numberOfKeys);

    ;;;
     ; Obtains a key intended for the given purpose.
     ; The chain may create a new key, derive one, or re-use an old one.
     ;;
    ECKey getKey(KeyPurpose purpose);

    ;;; Returns a list of keys serialized to the bitcoinj protobuf format. ;;
    List<Protos.Key> serializeToProtobuf();

    ;;; Adds a listener for events that are run when keys are added, on the user thread. ;;
    void addEventListener(KeyChainEventListener listener);

    ;;; Adds a listener for events that are run when keys are added, on the given executor. ;;
    void addEventListener(KeyChainEventListener listener, Executor executor);

    ;;; Removes a listener for events that are run when keys are added. ;;
    boolean removeEventListener(KeyChainEventListener listener);

    ;;; Returns the number of keys this key chain manages. ;;
    int numKeys();

    ;;;
     ; Returns the number of elements this chain wishes to insert into the Bloom filter.
     ; The size passed to {@link #getFilter(int, double, long)} should be at least this large.
     ;;
    int numBloomFilterEntries();

    ;;;
     ; Returns the earliest creation time of keys in this chain, in seconds since the epoch.  This can return
     ; zero if at least one key does not have that data (was created before key timestamping was implemented).
     ; If there are no keys in the wallet, {@link Long#MAX_VALUE} is returned.
     ;;
    long getEarliestKeyCreationTime();

    ;;;
     ; <p>Gets a bloom filter that contains all of the public keys from this chain, and which will provide the given
     ; false-positive rate if it has size elements.  Keep in mind that you will get 2 elements in the bloom filter for
     ; each key in the key chain, for the public key and the hash of the public key (address form).  For this reason
     ; size should be <i>at least</i> 2x the result of {@link #numKeys()}.</p>
     ;
     ; <p>This is used to generate a {@link BloomFilter} which can be {@link BloomFilter#merge(BloomFilter)}d with
     ; another.  It could also be used if you have a specific target for the filter's size.</p>
     ;
     ; <p>See the docs for {@link org.bitcoinj.core.BloomFilter#BloomFilter(int, double, long)} for a brief
     ; explanation of anonymity when using bloom filters, and for the meaning of these parameters.</p>
     ;;
    BloomFilter getFilter(int size, double falsePositiveRate, long tweak);
)

(ns org.bitcoinj.wallet #_"KeyChainFactory"
  #_(:require [org.bitcoinj.crypto DeterministicKey KeyCrypter]))

;;;
 ; Factory interface for creation keychains while de-serializing a wallet.
 ;;
#_public
interface KeyChainFactory
(§
    ;;;
     ; Make a keychain (but not a watching one).
     ;
     ; @param key The protobuf for the root key.
     ; @param firstSubKey The protobuf for the first child key (normally the parent of the external subchain).
     ; @param seed The seed.
     ; @param crypter The encrypted/decrypter.
     ; @param isMarried Whether the keychain is leading in a marriage.
     ;;
    DeterministicKeyChain makeKeyChain(Protos.Key key, Protos.Key firstSubKey, DeterministicSeed seed, KeyCrypter crypter, boolean isMarried);

    ;;;
     ; Make a watching keychain.
     ;
     ; isMarried and isFollowingKey must not be true at the same time.
     ;
     ; @param key The protobuf for the account key.
     ; @param firstSubKey The protobuf for the first child key (normally the parent of the external subchain).
     ; @param accountKey The account extended public key.
     ; @param isFollowingKey Whether the keychain is following in a marriage.
     ; @param isMarried Whether the keychain is leading in a marriage.
     ;;
    DeterministicKeyChain makeWatchingKeyChain(Protos.Key key, Protos.Key firstSubKey, DeterministicKey accountKey, boolean isFollowingKey, boolean isMarried)
        throws UnreadableWalletException;
)

(ns org.bitcoinj.wallet #_"KeyChainGroup"
    (:import #_[java.security *]
             #_[java.util *]
             #_[java.util.concurrent *])
    (:import [com.google.common.base Preconditions]
             #_[com.google.common.collect *]
             #_[com.google.protobuf *]
             #_[org.slf4j *]
             #_[org.spongycastle.crypto.params *])
  #_(:require #_[org.bitcoinj.core *]
             #_[org.bitcoinj.crypto *]
             #_[org.bitcoinj.script *]
             #_[org.bitcoinj.utils *]
             [org.bitcoinj.wallet.listeners KeyChainEventListener]))

;;;
 ; <p>A KeyChainGroup is used by the {@link org.bitcoinj.wallet.Wallet} and manages: a {@link BasicKeyChain} object
 ; (which will normally be empty), and zero or more {@link DeterministicKeyChain}s.  A deterministic key chain will be
 ; created lazily/on demand when a fresh or current key is requested, possibly being initialized from the private key
 ; bytes of the earliest non rotating key in the basic key chain if one is available, or from a fresh random seed if not.</p>
 ;
 ; <p>If a key rotation time is set, it may be necessary to add a new DeterministicKeyChain with a fresh seed and
 ; also preserve the old one, so funds can be swept from the rotating keys.  In this case, there may be more than
 ; one deterministic chain.  The latest chain is called the active chain and is where new keys are served from.</p>
 ;
 ; <p>The wallet delegates most key management tasks to this class.  It is <b>not</b> thread safe and requires external
 ; locking, i.e. by the wallet lock.  The group then in turn delegates most operations to the key chain objects,
 ; combining their responses together when necessary.</p>
 ;
 ; <p>Deterministic key chains have a concept of a lookahead size and threshold.  Please see the discussion in the
 ; class docs for {@link DeterministicKeyChain} for more information on this topic.</p>
 ;;
#_public
class KeyChainGroup implements KeyBag
(§
    #_static
    (§
        ;; Init proper random number generator, as some old Android installations have bugs that make it unsecure.
        if (Utils.isAndroidRuntime())
            new LinuxSecureRandom();
    )

#_private
#_static
#_final
    Logger log = LoggerFactory.getLogger(KeyChainGroup.class);

#_private
    BasicKeyChain basic;
#_private
    NetworkParameters params;
#_protected
#_final
    LinkedList<DeterministicKeyChain> chains;
    ;; currentKeys is used for normal, non-multisig/married wallets.
    ;; currentAddresses is used when we're handing out P2SH addresses.
    ;; They're mutually exclusive.
#_private
#_final
    EnumMap<KeyChain.KeyPurpose, DeterministicKey> currentKeys;
#_private
#_final
    EnumMap<KeyChain.KeyPurpose, Address> currentAddresses;

#_nilable
#_private
    KeyCrypter keyCrypter;
#_private
    int lookaheadSize = -1;
#_private
    int lookaheadThreshold = -1;

    ;;; Creates a keychain group with no basic chain, and a single, lazily created HD chain. ;;
#_public
    KeyChainGroup(NetworkParameters params)
    (§
        this(params, nil, new ArrayList<DeterministicKeyChain>(1), nil, nil);
    )

    ;;; Creates a keychain group with no basic chain, and an HD chain initialized from the given seed. ;;
#_public
    KeyChainGroup(NetworkParameters params, DeterministicSeed seed)
    (§
        this(params, nil, ImmutableList.of(new DeterministicKeyChain(seed)), nil, nil);
    )

    ;;;
     ; Creates a keychain group with no basic chain, and an HD chain that is watching the given watching key.
     ; This HAS to be an account key as returned by {@link DeterministicKeyChain#getWatchingKey()}.
     ;;
#_public
    KeyChainGroup(NetworkParameters params, DeterministicKey watchKey)
    (§
        this(params, nil, ImmutableList.of(DeterministicKeyChain.watch(watchKey)), nil, nil);
    )

    ;; Used for deserialization.
#_private
    KeyChainGroup(NetworkParameters params, #_nilable BasicKeyChain basicKeyChain, List<DeterministicKeyChain> chains, #_nilable EnumMap<KeyChain.KeyPurpose, DeterministicKey> currentKeys, #_nilable KeyCrypter crypter)
    (§
        this.params = params;
        this.basic = (basicKeyChain == nil) ? new BasicKeyChain() : basicKeyChain;
        this.chains = new LinkedList<>(Preconditions.checkNotNull(chains));
        this.keyCrypter = crypter;
        this.currentKeys = (currentKeys == nil) ? new EnumMap<KeyChain.KeyPurpose, DeterministicKey>(KeyChain.KeyPurpose.class) : currentKeys;
        this.currentAddresses = new EnumMap<>(KeyChain.KeyPurpose.class);
        maybeLookaheadScripts();

        if (isMarried())
        (§
            for (Map.Entry<KeyChain.KeyPurpose, DeterministicKey> entry : this.currentKeys.entrySet())
            (§
                Address address = makeP2SHOutputScript(entry.getValue(), getActiveKeyChain()).getToAddress(params);
                currentAddresses.put(entry.getKey(), address);
            )
        )
    )

    ;; This keeps married redeem data in sync with the number of keys issued.
#_private
    void maybeLookaheadScripts()
    (§
        for (DeterministicKeyChain chain : chains)
            chain.maybeLookAheadScripts();
    )

    ;;; Adds a new HD chain to the chains list, and make it the default chain (from which keys are issued). ;;
#_public
    void createAndActivateNewHDChain()
    (§
        ;; We can't do auto upgrade here because we don't know the rotation time, if any.
#_final
        DeterministicKeyChain chain = new DeterministicKeyChain(new SecureRandom());
        addAndActivateHDChain(chain);
    )

    ;;;
     ; Adds an HD chain to the chains list, and make it the default chain (from which keys are issued).
     ; Useful for adding a complex pre-configured keychain, such as a married wallet.
     ;;
#_public
    void addAndActivateHDChain(DeterministicKeyChain chain)
    (§
        log.info("Creating and activating a new HD chain: {}", chain);
        for (ListenerRegistration<KeyChainEventListener> registration : basic.getListeners())
            chain.addEventListener(registration.listener, registration.executor);
        if (0 <= lookaheadSize)
            chain.setLookaheadSize(lookaheadSize);
        if (0 <= lookaheadThreshold)
            chain.setLookaheadThreshold(lookaheadThreshold);
        chains.add(chain);
    )

    ;;;
     ; Returns a key that hasn't been seen in a transaction yet, and which is suitable for displaying in a wallet
     ; user interface as "a convenient key to receive funds on" when the purpose parameter is
     ; {@link KeyChain.KeyPurpose#RECEIVE_FUNDS}.  The returned key is stable until it's actually seen in a pending
     ; or confirmed transaction, at which point this method will start returning a different key (for each purpose
     ; independently).
     ;
     ; <p>This method is not supposed to be used for married keychains and will throw UnsupportedOperationException
     ; if the active chain is married.
     ; For married keychains use {@link #currentAddress(KeyChain.KeyPurpose)} to get a proper P2SH address.</p>
     ;;
#_public
    DeterministicKey currentKey(KeyChain.KeyPurpose purpose)
    (§
        DeterministicKeyChain chain = getActiveKeyChain();
        if (chain.isMarried())
            throw new UnsupportedOperationException("Key is not suitable to receive coins for married keychains. Use freshAddress to get P2SH address instead.");

        DeterministicKey current = currentKeys.get(purpose);
        if (current == nil)
        (§
            current = freshKey(purpose);
            currentKeys.put(purpose, current);
        )
        return current;
    )

    ;;;
     ; Returns address for a {@link #currentKey(KeyChain.KeyPurpose)}.
     ;;
#_public
    Address currentAddress(KeyChain.KeyPurpose purpose)
    (§
        DeterministicKeyChain chain = getActiveKeyChain();
        if (chain.isMarried())
        (§
            Address current = currentAddresses.get(purpose);
            if (current == nil)
            (§
                current = freshAddress(purpose);
                currentAddresses.put(purpose, current);
            )
            return current;
        )

        return currentKey(purpose).toAddress(params);
    )

    ;;;
     ; Returns a key that has not been returned by this method before (fresh).  You can think of this as being a newly
     ; created key, although the notion of "create" is not really valid for a {@link DeterministicKeyChain}.  When the
     ; parameter is {@link KeyChain.KeyPurpose#RECEIVE_FUNDS}, the returned key is suitable for being put into a receive
     ; coins wizard type UI.  You should use this when the user is definitely going to hand this key out to someone who
     ; wishes to send money.
     ; <p>This method is not supposed to be used for married keychains and will throw UnsupportedOperationException if
     ; the active chain is married.
     ; For married keychains use {@link #freshAddress(KeyChain.KeyPurpose)} to get a proper P2SH address.</p>
     ;;
#_public
    DeterministicKey freshKey(KeyChain.KeyPurpose purpose)
    (§
        return freshKeys(purpose, 1).get(0);
    )

    ;;;
     ; Returns a key/s that have not been returned by this method before (fresh).  You can think of this as being newly
     ; created key/s, although the notion of "create" is not really valid for a {@link DeterministicKeyChain}.  When the
     ; parameter is {@link KeyChain.KeyPurpose#RECEIVE_FUNDS}, the returned key is suitable for being put into a receive
     ; coins wizard type UI.  You should use this when the user is definitely going to hand this key out to someone who
     ; wishes to send money.
     ; <p>This method is not supposed to be used for married keychains and will throw UnsupportedOperationException if
     ; the active chain is married.
     ; For married keychains use {@link #freshAddress(KeyChain.KeyPurpose)} to get a proper P2SH address.</p>
     ;;
#_public
    List<DeterministicKey> freshKeys(KeyChain.KeyPurpose purpose, int numberOfKeys)
    (§
        DeterministicKeyChain chain = getActiveKeyChain();
        if (chain.isMarried())
            throw new UnsupportedOperationException("Key is not suitable to receive coins for married keychains. Use freshAddress to get P2SH address instead.");

        return chain.getKeys(purpose, numberOfKeys); ;; Always returns the next key along the key chain.
    )

    ;;;
     ; Returns address for a {@link #freshKey(KeyChain.KeyPurpose)}.
     ;;
#_public
    Address freshAddress(KeyChain.KeyPurpose purpose)
    (§
        DeterministicKeyChain chain = getActiveKeyChain();
        if (chain.isMarried())
        (§
            Script outputScript = chain.freshOutputScript(purpose);
            Preconditions.checkState(outputScript.isPayToScriptHash()); ;; Only handle P2SH for now.
            Address freshAddress = Address.fromP2SHScript(params, outputScript);
            maybeLookaheadScripts();
            currentAddresses.put(purpose, freshAddress);
            return freshAddress;
        )

        return freshKey(purpose).toAddress(params);
    )

    ;;; Returns the key chain that's used for generation of fresh/current keys.  This is always the newest HD chain. ;;
#_public
#_final
    DeterministicKeyChain getActiveKeyChain()
    (§
        if (chains.isEmpty())
        (§
            if (0 < basic.numKeys())
            (§
                log.warn("No HD chain present but random keys are: you probably deserialized an old wallet.");
                ;; If called from the wallet (most likely) it'll try to upgrade us, as it knows the rotation time but not the password.
                throw new DeterministicUpgradeRequiredException();
            )
            ;; Otherwise we have no HD chains and no random keys: we are a new born!  So a random seed is fine.
            createAndActivateNewHDChain();
        )
        return chains.get(chains.size() - 1);
    )

    ;;;
     ; Sets the lookahead buffer size for ALL deterministic key chains as well as for following key chains if any exist.
     ; See {@link DeterministicKeyChain#setLookaheadSize(int)} for more information.
     ;;
#_public
    void setLookaheadSize(int lookaheadSize)
    (§
        this.lookaheadSize = lookaheadSize;
        for (DeterministicKeyChain chain : chains)
            chain.setLookaheadSize(lookaheadSize);
    )

    ;;;
     ; Gets the current lookahead size being used for ALL deterministic key chains.
     ; See {@link DeterministicKeyChain#setLookaheadSize(int)} for more information.
     ;;
#_public
    int getLookaheadSize()
    (§
        return (lookaheadSize == -1) ? getActiveKeyChain().getLookaheadSize() : lookaheadSize;
    )

    ;;;
     ; Sets the lookahead buffer threshold for ALL deterministic key chains.
     ; See {@link DeterministicKeyChain#setLookaheadThreshold(int)} for more information.
     ;;
#_public
    void setLookaheadThreshold(int num)
    (§
        for (DeterministicKeyChain chain : chains)
            chain.setLookaheadThreshold(num);
    )

    ;;;
     ; Gets the current lookahead threshold being used for ALL deterministic key chains.
     ; See {@link DeterministicKeyChain#setLookaheadThreshold(int)} for more information.
     ;;
#_public
    int getLookaheadThreshold()
    (§
        return (lookaheadThreshold == -1) ? getActiveKeyChain().getLookaheadThreshold() : lookaheadThreshold;
    )

    ;;; Imports the given keys into the basic chain, creating it if necessary. ;;
#_public
    int importKeys(List<ECKey> keys)
    (§
        return basic.importKeys(keys);
    )

    ;;; Imports the given keys into the basic chain, creating it if necessary. ;;
#_public
    int importKeys(ECKey... keys)
    (§
        return importKeys(ImmutableList.copyOf(keys));
    )

#_public
    boolean checkPassword(CharSequence password)
    (§
        Preconditions.checkState(keyCrypter != nil, "Not encrypted");

        return checkAESKey(keyCrypter.deriveKey(password));
    )

#_public
    boolean checkAESKey(KeyParameter aesKey)
    (§
        Preconditions.checkState(keyCrypter != nil, "Not encrypted");

        return (0 < basic.numKeys()) ? basic.checkAESKey(aesKey) : getActiveKeyChain().checkAESKey(aesKey);
    )

    ;;; Imports the given unencrypted keys into the basic chain, encrypting them along the way with the given key. ;;
#_public
    int importKeysAndEncrypt(final List<ECKey> keys, KeyParameter aesKey)
    (§
        ;; TODO: Firstly check if the aes key can decrypt any of the existing keys successfully.
        Preconditions.checkState(keyCrypter != nil, "Not encrypted");

        LinkedList<ECKey> encryptedKeys = Lists.newLinkedList();
        for (ECKey key : keys)
        (§
            if (key.isEncrypted())
                throw new IllegalArgumentException("Cannot provide already encrypted keys");

            encryptedKeys.add(key.encrypt(keyCrypter, aesKey));
        )
        return importKeys(encryptedKeys);
    )

#_override
#_nilable
#_public
    RedeemData findRedeemDataFromScriptHash(byte[] scriptHash)
    (§
        ;; Iterate in reverse order, since the active keychain is the one most likely to have the hit.
        for (Iterator<DeterministicKeyChain> iter = chains.descendingIterator(); iter.hasNext(); )
        (§
            DeterministicKeyChain chain = iter.next();
            RedeemData redeemData = chain.findRedeemDataByScriptHash(ByteString.copyFrom(scriptHash));
            if (redeemData != nil)
                return redeemData;
        )
        return nil;
    )

#_public
    void markP2SHAddressAsUsed(Address address)
    (§
        Preconditions.checkArgument(address.isP2SHAddress());

        RedeemData data = findRedeemDataFromScriptHash(address.getHash160());
        if (data == nil)
            return; ;; Not our P2SH address.

        for (ECKey key : data.keys)
        (§
            for (DeterministicKeyChain chain : chains)
            (§
                DeterministicKey k = chain.findKeyFromPubKey(key.getPubKey());
                if (k != nil)
                (§
                    chain.markKeyAsUsed(k);
                    maybeMarkCurrentAddressAsUsed(address);
                )
            )
        )
    )

#_nilable
#_override
#_public
    ECKey findKeyFromPubHash(byte[] pubkeyHash)
    (§
        ECKey result = basic.findKeyFromPubHash(pubkeyHash);
        if (result != nil)
            return result;

        for (DeterministicKeyChain chain : chains)
        (§
            result = chain.findKeyFromPubHash(pubkeyHash);
            if (result != nil)
                return result;
        )

        return nil;
    )

    ;;;
     ; Mark the DeterministicKeys as used, if they match the pubkeyHash.
     ; See {@link DeterministicKeyChain#markKeyAsUsed(DeterministicKey)} for more info on this.
     ;;
#_public
    void markPubKeyHashAsUsed(byte[] pubkeyHash)
    (§
        for (DeterministicKeyChain chain : chains)
        (§
            DeterministicKey key = chain.markPubHashAsUsed(pubkeyHash);
            if (key != nil)
            (§
                maybeMarkCurrentKeyAsUsed(key);
                return;
            )
        )
    )

    ;;; If the given P2SH address is "current", advance it to a new one. ;;
#_private
    void maybeMarkCurrentAddressAsUsed(Address address)
    (§
        Preconditions.checkArgument(address.isP2SHAddress());

        for (Map.Entry<KeyChain.KeyPurpose, Address> entry : currentAddresses.entrySet())
        (§
            if (entry.getValue() != nil && entry.getValue().equals(address))
            (§
                log.info("Marking P2SH address as used: {}", address);
                currentAddresses.put(entry.getKey(), freshAddress(entry.getKey()));
                return;
            )
        )
    )

    ;;; If the given key is "current", advance the current key to a new one. ;;
#_private
    void maybeMarkCurrentKeyAsUsed(DeterministicKey key)
    (§
        ;; It's OK for currentKeys to be empty here: it means we're a married wallet and the key may be a part of a rotating chain.
        for (Map.Entry<KeyChain.KeyPurpose, DeterministicKey> entry : currentKeys.entrySet())
        (§
            if (entry.getValue() != nil && entry.getValue().equals(key))
            (§
                log.info("Marking key as used: {}", key);
                currentKeys.put(entry.getKey(), freshKey(entry.getKey()));
                return;
            )
        )
    )

#_public
    boolean hasKey(ECKey key)
    (§
        if (basic.hasKey(key))
            return true;
        for (DeterministicKeyChain chain : chains)
            if (chain.hasKey(key))
                return true;
        return false;
    )

#_nilable
#_override
#_public
    ECKey findKeyFromPubKey(byte[] pubkey)
    (§
        ECKey result = basic.findKeyFromPubKey(pubkey);
        if (result != nil)
            return result;

        for (DeterministicKeyChain chain : chains)
        (§
            result = chain.findKeyFromPubKey(pubkey);
            if (result != nil)
                return result;
        )

        return nil;
    )

    ;;;
     ; Mark the DeterministicKeys as used, if they match the pubkey.
     ; See {@link DeterministicKeyChain#markKeyAsUsed(DeterministicKey)} for more info on this.
     ;;
#_public
    void markPubKeyAsUsed(byte[] pubkey)
    (§
        for (DeterministicKeyChain chain : chains)
        (§
            DeterministicKey key = chain.markPubKeyAsUsed(pubkey);
            if (key != nil)
            (§
                maybeMarkCurrentKeyAsUsed(key);
                return;
            )
        )
    )

    ;;; Returns the number of keys managed by this group, including the lookahead buffers. ;;
#_public
    int numKeys()
    (§
        int result = basic.numKeys();
        for (DeterministicKeyChain chain : chains)
            result += chain.numKeys();
        return result;
    )

    ;;;
     ; Removes a key that was imported into the basic key chain.  You cannot remove deterministic keys.
     ; @throws java.lang.IllegalArgumentException if the key is deterministic.
     ;;
#_public
    boolean removeImportedKey(ECKey key)
    (§
        Preconditions.checkNotNull(key);
        Preconditions.checkArgument(!(key instanceof DeterministicKey));

        return basic.removeKey(key);
    )

    ;;;
     ; Whether the active keychain is married.  A keychain is married when it vends P2SH addresses
     ; from multiple keychains in a multisig relationship.
     ; @see org.bitcoinj.wallet.MarriedKeyChain
     ;;
#_public
#_final
    boolean isMarried()
    (§
        return !chains.isEmpty() && getActiveKeyChain().isMarried();
    )

    ;;;
     ; Encrypt the keys in the group using the KeyCrypter and the AES key.
     ; A good default KeyCrypter to use is {@link org.bitcoinj.crypto.KeyCrypterScrypt}.
     ;
     ; @throws org.bitcoinj.crypto.KeyCrypterException if the wallet encryption fails for some reason,
     ;         leaving the group unchanged.
     ; @throws DeterministicUpgradeRequiredException if there are random keys but no HD chain.
     ;;
#_public
    void encrypt(KeyCrypter keyCrypter, KeyParameter aesKey)
    (§
        Preconditions.checkNotNull(keyCrypter);
        Preconditions.checkNotNull(aesKey);

        ;; This code must be exception safe.
        BasicKeyChain newBasic = basic.toEncrypted(keyCrypter, aesKey);
        List<DeterministicKeyChain> newChains = new ArrayList<>(chains.size());
        if (chains.isEmpty() && basic.numKeys() == 0)
        (§
            ;; No HD chains and no random keys: encrypting an entirely empty keychain group.
            ;; But we can't do that, we must have something to encrypt: so instantiate a new HD chain here.
            createAndActivateNewHDChain();
        )
        for (DeterministicKeyChain chain : chains)
            newChains.add(chain.toEncrypted(keyCrypter, aesKey));
        this.keyCrypter = keyCrypter;
        basic = newBasic;
        chains.clear();
        chains.addAll(newChains);
    )

    ;;;
     ; Decrypt the keys in the group using the previously given key crypter and the AES key.
     ; A good default KeyCrypter to use is {@link org.bitcoinj.crypto.KeyCrypterScrypt}.
     ;
     ; @throws org.bitcoinj.crypto.KeyCrypterException if the wallet decryption fails for some reason, leaving the group unchanged.
     ;;
#_public
    void decrypt(KeyParameter aesKey)
    (§
        ;; This code must be exception safe.
        Preconditions.checkNotNull(aesKey);

        BasicKeyChain newBasic = basic.toDecrypted(aesKey);
        List<DeterministicKeyChain> newChains = new ArrayList<>(chains.size());
        for (DeterministicKeyChain chain : chains)
            newChains.add(chain.toDecrypted(aesKey));

        this.keyCrypter = nil;
        basic = newBasic;
        chains.clear();
        chains.addAll(newChains);
    )

    ;;; Returns true if the group is encrypted. ;;
#_public
    boolean isEncrypted()
    (§
        return (keyCrypter != nil);
    )

    ;;;
     ; Returns whether this chain has only watching keys (unencrypted keys with no private part).
     ; Mixed chains are forbidden.
     ;
     ; @throws IllegalStateException if there are no keys, or if there is a mix between watching and non-watching keys.
     ;;
#_public
    boolean isWatching()
    (§
        BasicKeyChain.State activeState = BasicKeyChain.State.EMPTY;
        if (!chains.isEmpty())
            activeState = getActiveKeyChain().isWatching() ? BasicKeyChain.State.WATCHING : BasicKeyChain.State.REGULAR;

        BasicKeyChain.State basicState = basic.isWatching();
        if (basicState == BasicKeyChain.State.EMPTY)
        (§
            if (activeState == BasicKeyChain.State.EMPTY)
                throw new IllegalStateException("Empty key chain group: cannot answer isWatching() query");

            return (activeState == BasicKeyChain.State.WATCHING);
        )

        if (activeState == BasicKeyChain.State.EMPTY)
            return (basicState == BasicKeyChain.State.WATCHING);

        if (activeState != basicState)
            throw new IllegalStateException("Mix of watching and non-watching keys in wallet");

        return (activeState == BasicKeyChain.State.WATCHING);
    )

    ;;; Returns the key crypter or null if the group is not encrypted. ;;
#_nilable
#_public
    KeyCrypter getKeyCrypter()
    (§
        return keyCrypter;
    )

    ;;;
     ; Returns a list of the non-deterministic keys that have been imported into the wallet, or the empty list if none.
     ;;
#_public
    List<ECKey> getImportedKeys()
    (§
        return basic.getKeys();
    )

#_public
    long getEarliestKeyCreationTime()
    (§
        long time = basic.getEarliestKeyCreationTime(); ;; Long.MAX_VALUE if empty.
        for (DeterministicKeyChain chain : chains)
            time = Math.min(time, chain.getEarliestKeyCreationTime());
        return time;
    )

#_public
    int getBloomFilterElementCount()
    (§
        int result = basic.numBloomFilterEntries();
        for (DeterministicKeyChain chain : chains)
            result += chain.numBloomFilterEntries();
        return result;
    )

#_public
    BloomFilter getBloomFilter(int size, double falsePositiveRate, long nTweak)
    (§
        BloomFilter filter = new BloomFilter(size, falsePositiveRate, nTweak);
        if (0 < basic.numKeys())
            filter.merge(basic.getFilter(size, falsePositiveRate, nTweak));

        for (DeterministicKeyChain chain : chains)
            filter.merge(chain.getFilter(size, falsePositiveRate, nTweak));
        return filter;
    )

#_private
    Script makeP2SHOutputScript(DeterministicKey followedKey, DeterministicKeyChain chain)
    (§
        return ScriptBuilder.createP2SHOutputScript(chain.getRedeemData(followedKey).redeemScript);
    )

    ;;; Adds a listener for events that are run when keys are added, on the user thread. ;;
#_public
    void addEventListener(KeyChainEventListener listener)
    (§
        addEventListener(listener, Threading.USER_THREAD);
    )

    ;;; Adds a listener for events that are run when keys are added, on the given executor. ;;
#_public
    void addEventListener(KeyChainEventListener listener, Executor executor)
    (§
        Preconditions.checkNotNull(listener);
        Preconditions.checkNotNull(executor);

        basic.addEventListener(listener, executor);
        for (DeterministicKeyChain chain : chains)
            chain.addEventListener(listener, executor);
    )

    ;;; Removes a listener for events that are run when keys are added. ;;
#_public
    boolean removeEventListener(KeyChainEventListener listener)
    (§
        Preconditions.checkNotNull(listener);

        for (DeterministicKeyChain chain : chains)
            chain.removeEventListener(listener);
        return basic.removeEventListener(listener);
    )

    ;;; Returns a list of key protobufs obtained by merging the chains. ;;
#_public
    List<Protos.Key> serializeToProtobuf()
    (§
        List<Protos.Key> result = (basic != nil) ? basic.serializeToProtobuf() : Lists.newArrayList();

        for (DeterministicKeyChain chain : chains)
        (§
            List<Protos.Key> protos = chain.serializeToProtobuf();
            result.addAll(protos);
        )
        return result;
    )

#_static
    KeyChainGroup fromProtobufUnencrypted(NetworkParameters params, List<Protos.Key> keys)
        throws UnreadableWalletException
    (§
        return fromProtobufUnencrypted(params, keys, new DefaultKeyChainFactory());
    )

#_public
#_static
    KeyChainGroup fromProtobufUnencrypted(NetworkParameters params, List<Protos.Key> keys, KeyChainFactory factory)
        throws UnreadableWalletException
    (§
        BasicKeyChain basicKeyChain = BasicKeyChain.fromProtobufUnencrypted(keys);
        List<DeterministicKeyChain> chains = DeterministicKeyChain.fromProtobuf(keys, nil, factory);
        EnumMap<KeyChain.KeyPurpose, DeterministicKey> currentKeys = nil;
        if (!chains.isEmpty())
            currentKeys = createCurrentKeysMap(chains);
        extractFollowingKeychains(chains);
        return new KeyChainGroup(params, basicKeyChain, chains, currentKeys, nil);
    )

#_static
    KeyChainGroup fromProtobufEncrypted(NetworkParameters params, List<Protos.Key> keys, KeyCrypter crypter)
        throws UnreadableWalletException
    (§
        return fromProtobufEncrypted(params, keys, crypter, new DefaultKeyChainFactory());
    )

#_public
#_static
    KeyChainGroup fromProtobufEncrypted(NetworkParameters params, List<Protos.Key> keys, KeyCrypter crypter, KeyChainFactory factory)
        throws UnreadableWalletException
    (§
        Preconditions.checkNotNull(crypter);

        BasicKeyChain basicKeyChain = BasicKeyChain.fromProtobufEncrypted(keys, crypter);
        List<DeterministicKeyChain> chains = DeterministicKeyChain.fromProtobuf(keys, crypter, factory);
        EnumMap<KeyChain.KeyPurpose, DeterministicKey> currentKeys = nil;
        if (!chains.isEmpty())
            currentKeys = createCurrentKeysMap(chains);
        extractFollowingKeychains(chains);
        return new KeyChainGroup(params, basicKeyChain, chains, currentKeys, crypter);
    )

    ;;;
     ; If the key chain contains only random keys and no deterministic key chains, this method will create a chain
     ; based on the oldest non-rotating private key (i.e. the seed is derived from the old wallet).
     ;
     ; @param keyRotationTimeSecs If non-zero, UNIX time for which keys created before this are assumed to be
     ;                            compromised or weak, those keys will not be used for deterministic upgrade.
     ; @param aesKey If non-null, the encryption key the keychain is encrypted under.  If the keychain is encrypted
     ;               and this is not supplied, an exception is thrown letting you know you should ask the user for
     ;               their password, turn it into a key, and then try again.
     ; @throws java.lang.IllegalStateException if there is already a deterministic key chain present or if there are
     ;                                         no random keys (i.e. this is not an upgrade scenario), or if aesKey is
     ;                                         provided but the wallet is not encrypted.
     ; @throws java.lang.IllegalArgumentException if the rotation time specified excludes all keys.
     ; @throws DeterministicUpgradeRequiresPassword if the key chain group is encrypted
     ;         and you should provide the users encryption key.
     ; @return the DeterministicKeyChain that was created by the upgrade.
     ;;
#_public
    DeterministicKeyChain upgradeToDeterministic(long keyRotationTimeSecs, #_nilable KeyParameter aesKey)
        throws DeterministicUpgradeRequiresPassword, AllRandomKeysRotating
    (§
        Preconditions.checkState(0 < basic.numKeys());
        Preconditions.checkArgument(0 <= keyRotationTimeSecs);

        ;; Subtract one because the key rotation time might have been set to the creation time of the first known
        ;; good key, in which case, that's the one we want to find.
        ECKey keyToUse = basic.findOldestKeyAfter(keyRotationTimeSecs - 1);
        if (keyToUse == nil)
            throw new AllRandomKeysRotating();

        if (keyToUse.isEncrypted())
        (§
            if (aesKey == nil)
            (§
                ;; We can't auto upgrade because we don't know the users password at this point.  We throw an exception
                ;; so the calling code knows to abort the load and ask the user for their password, they can then try
                ;; loading the wallet again passing in the AES key.
                ;;
                ;; There are a few different approaches we could have used here, but they all suck.  The most obvious
                ;; is to try and be as lazy as possible, running in the old random-wallet mode until the user enters
                ;; their password for some other reason and doing the upgrade then.  But this could result in strange
                ;; and unexpected UI flows for the user, as well as complicating the job of wallet developers who then
                ;; have to support both "old" and "new" UI modes simultaneously, switching them on the fly.  Given that
                ;; this is a one-off transition, it seems more reasonable to just ask the user for their password
                ;; on startup, and then the wallet app can have all the widgets for accessing seed words etc active
                ;; all the time.
                throw new DeterministicUpgradeRequiresPassword();
            )
            keyToUse = keyToUse.decrypt(aesKey);
        )
        else if (aesKey != nil)
        (§
            throw new IllegalStateException("AES Key was provided but wallet is not encrypted.");
        )

        if (chains.isEmpty())
            log.info("Auto-upgrading pre-HD wallet to HD!");
        else
            log.info("Wallet with existing HD chain is being re-upgraded due to change in key rotation time.");

        log.info("Instantiating new HD chain using oldest non-rotating private key (address: {})", keyToUse.toAddress(params));
        byte[] entropy = Preconditions.checkNotNull(keyToUse.getSecretBytes());
        ;; Private keys should be at least 128 bits long.
        Preconditions.checkState(DeterministicSeed.DEFAULT_SEED_ENTROPY_BITS / 8 <= entropy.length);
        ;; We reduce the entropy here to 128 bits because people like to write their seeds down on paper,
        ;; and 128 bits should be sufficient forever unless the laws of the universe change or ECC is broken;
        ;; in either case we all have bigger problems.
        entropy = Arrays.copyOfRange(entropy, 0, DeterministicSeed.DEFAULT_SEED_ENTROPY_BITS / 8); ;; Final argument is exclusive range.
        Preconditions.checkState(entropy.length == DeterministicSeed.DEFAULT_SEED_ENTROPY_BITS / 8);
        String passphrase = ""; ;; FIXME allow non-empty passphrase
        DeterministicKeyChain chain = new DeterministicKeyChain(entropy, passphrase, keyToUse.getCreationTimeSeconds());
        if (aesKey != nil)
            chain = chain.toEncrypted(Preconditions.checkNotNull(basic.getKeyCrypter()), aesKey);
        chains.add(chain);
        return chain;
    )

    ;;; Returns true if the group contains random keys but no HD chains. ;;
#_public
    boolean isDeterministicUpgradeRequired()
    (§
        return (0 < basic.numKeys() && chains.isEmpty());
    )

#_private
#_static
    EnumMap<KeyChain.KeyPurpose, DeterministicKey> createCurrentKeysMap(List<DeterministicKeyChain> chains)
    (§
        DeterministicKeyChain activeChain = chains.get(chains.size() - 1);

        EnumMap<KeyChain.KeyPurpose, DeterministicKey> currentKeys = new EnumMap<>(KeyChain.KeyPurpose.class);

        ;; Assuming that only RECEIVE and CHANGE keys are being used at the moment, we will treat the latest issued
        ;; external key as current RECEIVE key and latest issued internal key as CHANGE key.  This should be changed
        ;; as soon as other kinds of KeyPurpose are introduced.
        if (0 < activeChain.getIssuedExternalKeys())
        (§
            DeterministicKey currentExternalKey = activeChain.getKeyByPath(HDUtils.append(HDUtils.concat(activeChain.getAccountPath(), DeterministicKeyChain.EXTERNAL_SUBPATH), new ChildNumber(activeChain.getIssuedExternalKeys() - 1)));
            currentKeys.put(KeyChain.KeyPurpose.RECEIVE_FUNDS, currentExternalKey);
        )

        if (0 < activeChain.getIssuedInternalKeys())
        (§
            DeterministicKey currentInternalKey = activeChain.getKeyByPath(HDUtils.append(HDUtils.concat(activeChain.getAccountPath(), DeterministicKeyChain.INTERNAL_SUBPATH), new ChildNumber(activeChain.getIssuedInternalKeys() - 1)));
            currentKeys.put(KeyChain.KeyPurpose.CHANGE, currentInternalKey);
        )

        return currentKeys;
    )

#_private
#_static
    void extractFollowingKeychains(List<DeterministicKeyChain> chains)
    (§
        ;; Look for following key chains and map them to the watch keys of followed keychains.
        List<DeterministicKeyChain> followingChains = Lists.newArrayList();
        for (Iterator<DeterministicKeyChain> it = chains.iterator(); it.hasNext(); )
        (§
            DeterministicKeyChain chain = it.next();
            if (chain.isFollowing())
            (§
                followingChains.add(chain);
                it.remove();
            )
            else if (!followingChains.isEmpty())
            (§
                if (!(chain instanceof MarriedKeyChain))
                    throw new IllegalStateException();

                ((MarriedKeyChain)chain).setFollowingKeyChains(followingChains);
                followingChains = Lists.newArrayList();
            )
        )
    )

#_public
    String toString(boolean includePrivateKeys)
    (§
#_final
        StringBuilder sb = new StringBuilder();
        if (basic != nil)
        (§
            List<ECKey> keys = basic.getKeys();
            Collections.sort(keys, ECKey.AGE_COMPARATOR);
            for (ECKey key : keys)
                key.formatKeyWithAddress(includePrivateKeys, sb, params);
        )
        for (DeterministicKeyChain chain : chains)
            sb.append(chain.toString(includePrivateKeys, params)).append('\n');
        return sb.toString();
    )

    ;;; Returns a copy of the current list of chains. ;;
#_public
    List<DeterministicKeyChain> getDeterministicKeyChains()
    (§
        return new ArrayList<>(chains);
    )

    ;;;
     ; Returns a counter that increases (by an arbitrary amount) each time new keys have been calculated
     ; due to lookahead and thus the Bloom filter that was previously calculated has become stale.
     ;;
#_public
    int getCombinedKeyLookaheadEpochs()
    (§
        int epoch = 0;
        for (DeterministicKeyChain chain : chains)
            epoch += chain.getKeyLookaheadEpoch();
        return epoch;
    )
)

(ns org.bitcoinj.wallet #_"KeyTimeCoinSelector"
    (:import [java.util LinkedList List])
    (:import [com.google.common.base Preconditions]
             [com.google.common.collect Lists]
             [org.slf4j Logger LoggerFactory])
  #_(:require #_[org.bitcoinj.core *]
             [org.bitcoinj.script Script]))

;;;
 ; A coin selector that takes all coins assigned to keys created before the given timestamp.
 ; Used as part of the implementation of {@link Wallet#setKeyRotationTime(java.util.Date)}.
 ;;
#_public
class KeyTimeCoinSelector implements CoinSelector
(§
#_private
#_static
#_final
    Logger log = LoggerFactory.getLogger(KeyTimeCoinSelector.class);

    ;;; A number of inputs chosen to avoid hitting {@link org.bitcoinj.core.Transaction#MAX_STANDARD_TX_SIZE}. ;;
#_public
#_static
#_final
    int MAX_SIMULTANEOUS_INPUTS = 600;

#_private
#_final
    long unixTimeSeconds;
#_private
#_final
    Wallet wallet;
#_private
#_final
    boolean ignorePending;

#_public
    KeyTimeCoinSelector(Wallet wallet, long unixTimeSeconds, boolean ignorePending)
    (§
        this.unixTimeSeconds = unixTimeSeconds;
        this.wallet = wallet;
        this.ignorePending = ignorePending;
    )

#_override
#_public
    CoinSelection select(Coin target, List<TransactionOutput> candidates)
    (§
        try
        (§
            LinkedList<TransactionOutput> gathered = Lists.newLinkedList();
            Coin valueGathered = Coin.ZERO;
            for (TransactionOutput output : candidates)
            (§
                if (ignorePending && !isConfirmed(output))
                    continue;

                ;; Find the key that controls output, assuming it's a regular pay-to-pubkey or pay-to-address output.
                ;; We ignore any other kind of exotic output on the assumption we can't spend it ourselves.
#_final
                Script scriptPubKey = output.getScriptPubKey();
                ECKey controllingKey;
                if (scriptPubKey.isSentToRawPubKey())
                    controllingKey = wallet.findKeyFromPubKey(scriptPubKey.getPubKey());
                else if (scriptPubKey.isSentToAddress())
                    controllingKey = wallet.findKeyFromPubHash(scriptPubKey.getPubKeyHash());
                else
                (§
                    log.info("Skipping tx output {} because it's not of simple form.", output);
                    continue;
                )

                Preconditions.checkNotNull(controllingKey, "Coin selector given output as candidate for which we lack the key");
                if (unixTimeSeconds <= controllingKey.getCreationTimeSeconds())
                    continue;

                ;; It's older than the cutoff time so select.
                valueGathered = valueGathered.add(output.getValue());
                gathered.push(output);
                if (MAX_SIMULTANEOUS_INPUTS <= gathered.size())
                (§
                    log.warn("Reached {} inputs, going further would yield a tx that is too large, stopping here.", gathered.size());
                    break;
                )
            )
            return new CoinSelection(valueGathered, gathered);
        )
        catch (ScriptException e)
        (§
            throw new RuntimeException(e); ;; We should never have problems understanding scripts in our wallet.
        )
    )

#_private
    boolean isConfirmed(TransactionOutput output)
    (§
        return output.getParentTransaction().getConfidence().getConfidenceType().equals(TransactionConfidence.ConfidenceType.BUILDING);
    )
)

(ns org.bitcoinj.wallet #_"MarriedKeyChain"
    (:import [java.security SecureRandom]
             [java.util LinkedHashMap List Map])
    (:import [com.google.common.base Preconditions]
             [com.google.common.collect ImmutableList Lists]
             #_static #_[com.google.common.collect.Lists newArrayList]
             [com.google.protobuf ByteString])
  #_(:require [org.bitcoinj.core BloomFilter ECKey NetworkParameters Utils]
             [org.bitcoinj.crypto DeterministicKey KeyCrypter]
             [org.bitcoinj.script Script ScriptBuilder]))

;;;
 ; <p>A multi-signature keychain using synchronized HD keys (a.k.a HDM).</p>
 ;
 ; <p>This keychain keeps track of following keychains that follow the account key of this keychain.  You can get P2SH
 ; addresses to receive coins to from this chain.  The threshold - sigsRequiredToSpend specifies how many signatures
 ; required to spend transactions for this married keychain.  This value should not exceed the total number of keys
 ; involved (one followed key plus number of following keys), otherwise IllegalArgumentException will be thrown.</p>
 ;
 ; <p>IMPORTANT: As of Bitcoin Core 0.9 all multisig transactions which require more than 3 public keys are non-standard and
 ; such spends won't be processed by peers with default settings, essentially making such transactions almost nonspendable.</p>
 ;
 ; <p>This method will throw an IllegalStateException, if the keychain is already married or already has leaf keys issued.</p>
 ;;
#_public
class MarriedKeyChain extends DeterministicKeyChain
(§
    ;; The map holds P2SH redeem script and corresponding ECKeys issued by this KeyChainGroup (including lookahead)
    ;; mapped to redeem script hashes.
#_private
    LinkedHashMap<ByteString, RedeemData> marriedKeysRedeemData = new LinkedHashMap<>();

#_private
    List<DeterministicKeyChain> followingKeyChains;

    ;;; Builds a {@link MarriedKeyChain}. ;;
#_public
#_static
    class Builder<T extends Builder<T>> extends DeterministicKeyChain.Builder<T>
    (§
#_private
        List<DeterministicKey> followingKeys;
#_private
        int threshold;

#_protected
        Builder()
        (§
        )

#_public
        T followingKeys(List<DeterministicKey> followingKeys)
        (§
            this.followingKeys = followingKeys;
            return self();
        )

#_public
        T followingKeys(DeterministicKey followingKey, DeterministicKey ...followingKeys)
        (§
            this.followingKeys = Lists.asList(followingKey, followingKeys);
            return self();
        )

        ;;;
         ; Threshold, or <code>(followingKeys.size() + 1) / 2 + 1)</code> (majority) if unspecified.
         ;
         ; IMPORTANT: As of Bitcoin Core 0.9 all multisig transactions which require more than 3 public keys are non-standard and
         ; such spends won't be processed by peers with default settings, essentially making such transactions almost nonspendable.
         ;;
#_public
        T threshold(int threshold)
        (§
            this.threshold = threshold;
            return self();
        )

#_override
#_public
        MarriedKeyChain build()
        (§
            Preconditions.checkState(random != nil || entropy != nil || seed != nil || watchingKey!= nil, "Must provide either entropy or random or seed or watchingKey");
            Preconditions.checkNotNull(followingKeys, "followingKeys must be provided");

            MarriedKeyChain chain;
            if (threshold == 0)
                threshold = (followingKeys.size() + 1) / 2 + 1;

            if (random != nil)
            (§
                chain = new MarriedKeyChain(random, bits, getPassphrase(), seedCreationTimeSecs);
            )
            else if (entropy != nil)
            (§
                chain = new MarriedKeyChain(entropy, getPassphrase(), seedCreationTimeSecs);
            )
            else if (seed != nil)
            (§
                seed.setCreationTimeSeconds(seedCreationTimeSecs);
                chain = new MarriedKeyChain(seed);
            )
            else
            (§
                watchingKey.setCreationTimeSeconds(seedCreationTimeSecs);
                chain = new MarriedKeyChain(watchingKey);
            )

            chain.addFollowingAccountKeys(followingKeys, threshold);
            return chain;
        )
    )

#_public
#_static
    Builder<?> builder()
    (§
        return new Builder();
    )

    ;; Protobuf deserialization constructors.
    MarriedKeyChain(DeterministicKey accountKey)
    (§
        super(accountKey, false);
    )

    MarriedKeyChain(DeterministicSeed seed, KeyCrypter crypter)
    (§
        super(seed, crypter);
    )

    ;; Builder constructors.
#_private
    MarriedKeyChain(SecureRandom random, int bits, String passphrase, long seedCreationTimeSecs)
    (§
        super(random, bits, passphrase, seedCreationTimeSecs);
    )

#_private
    MarriedKeyChain(byte[] entropy, String passphrase, long seedCreationTimeSecs)
    (§
        super(entropy, passphrase, seedCreationTimeSecs);
    )

#_private
    MarriedKeyChain(DeterministicSeed seed)
    (§
        super(seed);
    )

    void setFollowingKeyChains(List<DeterministicKeyChain> followingKeyChains)
    (§
        Preconditions.checkArgument(!followingKeyChains.isEmpty());
        this.followingKeyChains = followingKeyChains;
    )

#_override
#_public
    boolean isMarried()
    (§
        return true;
    )

    ;;; Create a new married key and return the matching output script. ;;
#_override
#_public
    Script freshOutputScript(KeyPurpose purpose)
    (§
        DeterministicKey followedKey = getKey(purpose);
        ImmutableList.Builder<ECKey> keys = ImmutableList.<ECKey>builder().add(followedKey);
        for (DeterministicKeyChain keyChain : followingKeyChains)
        (§
            DeterministicKey followingKey = keyChain.getKey(purpose);
            Preconditions.checkState(followedKey.getChildNumber().equals(followingKey.getChildNumber()), "Following keychains should be in sync");
            keys.add(followingKey);
        )
        List<ECKey> marriedKeys = keys.build();
        Script redeemScript = ScriptBuilder.createRedeemScript(sigsRequiredToSpend, marriedKeys);
        return ScriptBuilder.createP2SHOutputScript(redeemScript);
    )

#_private
    List<ECKey> getMarriedKeysWithFollowed(DeterministicKey followedKey)
    (§
        ImmutableList.Builder<ECKey> keys = ImmutableList.builder();
        for (DeterministicKeyChain keyChain : followingKeyChains)
        (§
            keyChain.maybeLookAhead();
            keys.add(keyChain.getKeyByPath(followedKey.getPath()));
        )
        keys.add(followedKey);
        return keys.build();
    )

    ;;; Get the redeem data for a key in this married chain. ;;
#_override
#_public
    RedeemData getRedeemData(DeterministicKey followedKey)
    (§
        List<ECKey> marriedKeys = getMarriedKeysWithFollowed(followedKey);
        Script redeemScript = ScriptBuilder.createRedeemScript(sigsRequiredToSpend, marriedKeys);
        return RedeemData.of(marriedKeys, redeemScript);
    )

#_private
    void addFollowingAccountKeys(List<DeterministicKey> followingAccountKeys, int sigsRequiredToSpend)
    (§
        Preconditions.checkArgument(sigsRequiredToSpend <= followingAccountKeys.size() + 1, "Multisig threshold can't exceed total number of keys");
        Preconditions.checkState(numLeafKeysIssued() == 0, "Active keychain already has keys in use");
        Preconditions.checkState(followingKeyChains == nil);

        List<DeterministicKeyChain> followingKeyChains = Lists.newArrayList();

        for (DeterministicKey key : followingAccountKeys)
        (§
            Preconditions.checkArgument(key.getPath().size() == getAccountPath().size(), "Following keys have to be account keys");

            DeterministicKeyChain chain = DeterministicKeyChain.watchAndFollow(key);
            if (0 <= lookaheadSize)
                chain.setLookaheadSize(lookaheadSize);
            if (0 <= lookaheadThreshold)
                chain.setLookaheadThreshold(lookaheadThreshold);
            followingKeyChains.add(chain);
        )

        this.sigsRequiredToSpend = sigsRequiredToSpend;
        this.followingKeyChains = followingKeyChains;
    )

#_override
#_public
    void setLookaheadSize(int lookaheadSize)
    (§
        lock.lock();
        try
        (§
            super.setLookaheadSize(lookaheadSize);

            if (followingKeyChains != nil)
                for (DeterministicKeyChain followingChain : followingKeyChains)
                    followingChain.setLookaheadSize(lookaheadSize);
        )
        finally
        (§
            lock.unlock();
        )
    )

#_override
#_public
    List<Protos.Key> serializeToProtobuf()
    (§
        List<Protos.Key> result = newArrayList();
        lock.lock();
        try
        (§
            for (DeterministicKeyChain chain : followingKeyChains)
                result.addAll(chain.serializeMyselfToProtobuf());
            result.addAll(serializeMyselfToProtobuf());
        )
        finally
        (§
            lock.unlock();
        )
        return result;
    )

#_override
#_protected
    void formatAddresses(boolean includePrivateKeys, NetworkParameters params, StringBuilder sb)
    (§
        for (DeterministicKeyChain followingChain : followingKeyChains)
            sb.append("Following chain:  ").append(followingChain.getWatchingKey().serializePubB58(params)).append('\n');
        sb.append('\n');
        for (RedeemData redeemData : marriedKeysRedeemData.values())
            formatScript(ScriptBuilder.createP2SHOutputScript(redeemData.redeemScript), sb, params);
    )

#_private
    void formatScript(Script script, StringBuilder sb, NetworkParameters params)
    (§
        sb.append("  addr:").append(script.getToAddress(params));
        sb.append("  hash160:").append(Utils.HEX.encode(script.getPubKeyHash()));
        if (0 < script.getCreationTimeSeconds())
            sb.append("  creationTimeSeconds:").append(script.getCreationTimeSeconds());
        sb.append('\n');
    )

#_override
#_public
    void maybeLookAheadScripts()
    (§
        super.maybeLookAheadScripts();

        int numLeafKeys = getLeafKeys().size();
        Preconditions.checkState(marriedKeysRedeemData.size() <= numLeafKeys, "Number of scripts is greater than number of leaf keys");

        if (marriedKeysRedeemData.size() != numLeafKeys)
        (§
            maybeLookAhead();
            for (DeterministicKey followedKey : getLeafKeys())
            (§
                RedeemData redeemData = getRedeemData(followedKey);
                Script scriptPubKey = ScriptBuilder.createP2SHOutputScript(redeemData.redeemScript);
                marriedKeysRedeemData.put(ByteString.copyFrom(scriptPubKey.getPubKeyHash()), redeemData);
            )
        )
    )

#_nilable
#_override
#_public
    RedeemData findRedeemDataByScriptHash(ByteString bytes)
    (§
        return marriedKeysRedeemData.get(bytes);
    )

#_override
#_public
    BloomFilter getFilter(int size, double falsePositiveRate, long tweak)
    (§
        lock.lock();
        BloomFilter filter;
        try
        (§
            filter = new BloomFilter(size, falsePositiveRate, tweak);
            for (Map.Entry<ByteString, RedeemData> entry : marriedKeysRedeemData.entrySet())
            (§
                filter.insert(entry.getKey().toByteArray());
                filter.insert(entry.getValue().redeemScript.getProgram());
            )
        )
        finally
        (§
            lock.unlock();
        )
        return filter;
    )

#_override
#_public
    int numBloomFilterEntries()
    (§
        maybeLookAhead();
        return getLeafKeys().size() * 2;
    )
)

(ns org.bitcoinj.wallet #_"RedeemData"
    (:import [java.util ArrayList Collections List])
    (:import [com.google.common.base Preconditions])
  #_(:require [org.bitcoinj.core ECKey]
             [org.bitcoinj.script Script]))

;;;
 ; This class aggregates data required to spend transaction output.
 ;
 ; For pay-to-address and pay-to-pubkey transactions it will have only a single key and CHECKSIG program as redeemScript.
 ; For multisignature transactions there will be multiple keys one of which will be a full key and the rest are watch only,
 ; redeem script will be a CHECKMULTISIG program.  Keys will be sorted in the same order they appear in
 ; a program (lexicographical order).
 ;;
#_public
class RedeemData
(§
#_public
#_final
    Script redeemScript;
#_public
#_final
    List<ECKey> keys;

#_private
    RedeemData(List<ECKey> keys, Script redeemScript)
    (§
        this.redeemScript = redeemScript;
        List<ECKey> sortedKeys = new ArrayList<>(keys);
        Collections.sort(sortedKeys, ECKey.PUBKEY_COMPARATOR);
        this.keys = sortedKeys;
    )

#_public
#_static
    RedeemData of(List<ECKey> keys, Script redeemScript)
    (§
        return new RedeemData(keys, redeemScript);
    )

    ;;;
     ; Creates RedeemData for pay-to-address or pay-to-pubkey input.  Provided key is a single private key
     ; needed to spend such inputs and provided program should be a proper CHECKSIG program.
     ;;
#_public
#_static
    RedeemData of(ECKey key, Script program)
    (§
        Preconditions.checkArgument(program.isSentToAddress() || program.isSentToRawPubKey());

        return (key != nil) ? new RedeemData(Collections.singletonList(key), program) : nil;
    )

    ;;;
     ; Returns the first key that has private bytes.
     ;;
#_public
    ECKey getFullKey()
    (§
        for (ECKey key : keys)
            if (key.hasPrivKey())
                return key;
        return nil;
    )
)

(ns org.bitcoinj.wallet #_"RiskAnalysis"
    (:import [java.util List])
  #_(:require [org.bitcoinj.core Transaction]))

;;;
 ; <p>A RiskAnalysis represents an analysis of how likely it is that a transaction (and its dependencies)
 ; represents a possible double spending attack.  The wallet will create these to decide whether or not to accept
 ; a pending transaction.  Look at {@link DefaultRiskAnalysis} to see what is currently considered risky.</p>
 ;
 ; <p>The intention here is that implementing classes can expose more information and detail about the result,
 ; for app developers.  The core code needs only to know whether it's OK or not.</p>
 ;
 ; <p>A factory interface is provided.  The wallet will use this to analyze new pending transactions.</p>
 ;;
#_public
interface RiskAnalysis
(§
    enum Result
    (§
        OK,
        NON_FINAL,
        NON_STANDARD
    )

    Result analyze();

    interface Analyzer
    (§
        RiskAnalysis create(Wallet wallet, Transaction tx, List<Transaction> dependencies);
    )
)

(ns org.bitcoinj.wallet #_"SendRequest"
    (:import [java.math BigInteger]
             [java.util Date])
    (:import [com.google.common.base MoreObjects Preconditions]
             [org.spongycastle.crypto.params KeyParameter])
  #_(:require [org.bitcoinj.core Address Coin Context ECKey NetworkParameters Transaction TransactionOutput]
             [org.bitcoinj.script Script ScriptBuilder]
             [org.bitcoinj.utils ExchangeRate]
             [org.bitcoinj.wallet.KeyChain KeyPurpose]
             [org.bitcoinj.wallet.Wallet MissingSigsMode]))

;;;
 ; A SendRequest gives the wallet information about precisely how to send money to a recipient or set of recipients.
 ; Static methods are provided to help you create SendRequests and there are a few helper methods on the wallet that
 ; just simplify the most common use cases.  You may wish to customize a SendRequest if you want to attach a fee or
 ; modify the change address.
 ;;
#_public
class SendRequest
(§
    ;;;
     ; <p>A transaction, probably incomplete, that describes the outline of what you want to do.  This typically
     ; will mean it has some outputs to the intended destinations, but no inputs or change address (and therefore
     ; no fees) - the wallet will calculate all that for you and update tx later.</p>
     ;
     ; <p>Be careful when adding outputs that you check the min output value
     ; ({@link TransactionOutput#getMinNonDustValue(Coin)}) to avoid the whole transaction being rejected
     ; because one output is dust.</p>
     ;
     ; <p>If there are already inputs to the transaction, make sure their out point has a connected output,
     ; otherwise their value will be added to fee.  Also ensure they are either signed or are spendable by
     ; a wallet key, otherwise the behavior of {@link Wallet#completeTx(Wallet.SendRequest)} is undefined
     ; (likely RuntimeException).</p>
     ;;
#_public
    Transaction tx;

    ;;;
     ; When emptyWallet is set, all coins selected by the coin selector are sent to the first output in tx
     ; (its value is ignored and set to {@link org.bitcoinj.wallet.Wallet#getBalance()} - the fees required
     ; for the transaction).  Any additional outputs are removed.
     ;;
#_public
    boolean emptyWallet = false;

    ;;;
     ; "Change" means the difference between the value gathered by a transactions inputs (the size of which you
     ; don't really control as it depends on who sent you money), and the value being sent somewhere else.  The
     ; change address should be selected from this wallet, normally.  <b>If null this will be chosen for you.</b>
     ;;
#_public
    Address changeAddress = nil;

    ;;;
     ; <p>A transaction can have a fee attached, which is defined as the difference between the input values
     ; and output values.  Any value taken in that is not provided to an output can be claimed by a miner.  This
     ; is how mining is incentivized in later years of the Bitcoin system when inflation drops.  It also provides
     ; a way for people to prioritize their transactions over others and is used as a way to make denial of service
     ; attacks expensive.</p>
     ;
     ; <p>This is a dynamic fee (in satoshis) which will be added to the transaction for each kilobyte in size
     ; including the first.  This is useful as as miners usually sort pending transactions by their fee per unit size
     ; when choosing which transactions to add to a block.  Note that, to keep this equivalent to Bitcoin Core
     ; definition, a kilobyte is defined as 1000 bytes, not 1024.</p>
     ;;
#_public
    Coin feePerKb = Context.get().getFeePerKb();

    ;;;
     ; <p>Requires that there be enough fee for a default Bitcoin Core to at least relay the transaction.
     ; (i.e. ensure the transaction will not be outright rejected by the network).  Defaults to true,
     ; you should only set this to false if you know what you're doing.</p>
     ;
     ; <p>Note that this does not enforce certain fee rules that only apply to transactions which are larger
     ; than 26,000 bytes.  If you get a transaction which is that large, you should set a feePerKb of at least
     ; {@link Transaction#REFERENCE_DEFAULT_MIN_TX_FEE}.</p>
     ;;
#_public
    boolean ensureMinRequiredFee = Context.get().isEnsureMinRequiredFee();

    ;;;
     ; If true (the default), the inputs will be signed.
     ;;
#_public
    boolean signInputs = true;

    ;;;
     ; The AES key to use to decrypt the private keys before signing.
     ; If null then no decryption will be performed and if decryption is required an exception will be thrown.
     ; You can get this from a password by doing wallet.getKeyCrypter().deriveKey(password).
     ;;
#_public
    KeyParameter aesKey = nil;

    ;;;
     ; If not null, the {@link org.bitcoinj.wallet.CoinSelector} to use instead of the wallets default.
     ; Coin selectors are responsible for choosing which transaction outputs (coins) in a wallet to use given
     ; the desired send value amount.
     ;;
#_public
    CoinSelector coinSelector = nil;

    ;;;
     ; If true (the default), the outputs will be shuffled during completion to randomize the location
     ; of the change output, if any.  This is normally what you want for privacy reasons but in unit tests
     ; it can be annoying, so it can be disabled here.
     ;;
#_public
    boolean shuffleOutputs = true;

    ;;;
     ; Specifies what to do with missing signatures left after completing this request.  Default strategy is
     ; to throw an exception on missing signature ({@link MissingSigsMode#THROW}).
     ; @see MissingSigsMode
     ;;
#_public
    MissingSigsMode missingSigsMode = MissingSigsMode.THROW;

    ;;;
     ; If not null, this exchange rate is recorded with the transaction during completion.
     ;;
#_public
    ExchangeRate exchangeRate = nil;

    ;;;
     ; If not null, this memo is recorded with the transaction during completion.  It can be used to record
     ; the memo of the payment request that initiated the transaction.
     ;;
#_public
    String memo = nil;

    ;;;
     ; If false (default value), tx fee is paid by the sender.  If true, tx fee is paid by the recipient/s.
     ; If there is more than one recipient, the tx fee is split equally between them regardless of output
     ; value and size.
     ;;
#_public
    boolean recipientsPayFees = false;

    ;; Tracks if this has been passed to wallet.completeTx already: just a safety check.
    boolean completed;

#_private
    SendRequest()
    (§
    )

    ;;;
     ; <p>Creates a new SendRequest to the given address for the given value.</p>
     ;
     ; <p>Be very careful when value is smaller than {@link Transaction#MIN_NONDUST_OUTPUT} as the transaction
     ; will likely be rejected by the network in this case.</p>
     ;;
#_public
#_static
    SendRequest to(Address destination, Coin value)
    (§
        SendRequest req = new SendRequest();
#_final
        NetworkParameters parameters = destination.getParameters();

        Preconditions.checkNotNull(parameters, "Address is for an unknown network");

        req.tx = new Transaction(parameters);
        req.tx.addOutput(value, destination);
        return req;
    )

    ;;;
     ; <p>Creates a new SendRequest to the given pubkey for the given value.</p>
     ;
     ; <p>Be careful to check the output's value is reasonable using
     ; {@link TransactionOutput#getMinNonDustValue(Coin)} afterwards or you risk having the transaction
     ; rejected by the network.  Note that using {@link SendRequest#to(Address, Coin)} will result
     ; in a smaller output, and thus the ability to use a smaller output value without rejection.</p>
     ;;
#_public
#_static
    SendRequest to(NetworkParameters params, ECKey destination, Coin value)
    (§
        SendRequest req = new SendRequest();
        req.tx = new Transaction(params);
        req.tx.addOutput(value, destination);
        return req;
    )

    ;;; Simply wraps a pre-built incomplete transaction provided by you. ;;
#_public
#_static
    SendRequest forTx(Transaction tx)
    (§
        SendRequest req = new SendRequest();
        req.tx = tx;
        return req;
    )

#_public
#_static
    SendRequest emptyWallet(Address destination)
    (§
        SendRequest req = new SendRequest();
#_final
        NetworkParameters parameters = destination.getParameters();

        Preconditions.checkNotNull(parameters, "Address is for an unknown network");

        req.tx = new Transaction(parameters);
        req.tx.addOutput(Coin.ZERO, destination);
        req.emptyWallet = true;
        return req;
    )

    ;;;
     ; Construct a SendRequest for a CPFP (child-pays-for-parent) transaction.  The resulting transaction is
     ; already completed, so you should directly proceed to signing and broadcasting/committing the transaction.
     ; CPFP is currently only supported by a few miners, so use with care.
     ;;
#_public
#_static
    SendRequest childPaysForParent(Wallet wallet, Transaction parentTransaction, Coin feeRaise)
    (§
        TransactionOutput outputToSpend = nil;
        for (final TransactionOutput output : parentTransaction.getOutputs())
        (§
            if (output.isMine(wallet) && output.isAvailableForSpending() && output.getValue().isGreaterThan(feeRaise))
            (§
                outputToSpend = output;
                break;
            )
        )
        ;; TODO: Spend another confirmed output of own wallet if needed.
        Preconditions.checkNotNull(outputToSpend, "Can't find adequately sized output that spends to us");

#_final
        Transaction tx = new Transaction(parentTransaction.getParams());
        tx.addInput(outputToSpend);
        tx.addOutput(outputToSpend.getValue().subtract(feeRaise), wallet.freshAddress(KeyPurpose.CHANGE));
        tx.setPurpose(Transaction.Purpose.RAISE_FEE);
#_final
        SendRequest req = forTx(tx);
        req.completed = true;
        return req;
    )

#_public
#_static
    SendRequest toCLTVPaymentChannel(NetworkParameters params, Date releaseTime, ECKey from, ECKey to, Coin value)
    (§
        long time = releaseTime.getTime() / 1000L;

        Preconditions.checkArgument(Transaction.LOCKTIME_THRESHOLD <= time, "Release time was too small");

        return toCLTVPaymentChannel(params, BigInteger.valueOf(time), from, to, value);
    )

#_public
#_static
    SendRequest toCLTVPaymentChannel(NetworkParameters params, int releaseBlock, ECKey from, ECKey to, Coin value)
    (§
        Preconditions.checkArgument(0 <= releaseBlock && releaseBlock < Transaction.LOCKTIME_THRESHOLD, "Block number was too large");

        return toCLTVPaymentChannel(params, BigInteger.valueOf(releaseBlock), from, to, value);
    )

#_public
#_static
    SendRequest toCLTVPaymentChannel(NetworkParameters params, BigInteger time, ECKey from, ECKey to, Coin value)
    (§
        SendRequest req = new SendRequest();
        Script output = ScriptBuilder.createCLTVPaymentChannelOutput(time, from, to);
        req.tx = new Transaction(params);
        req.tx.addOutput(value, output);
        return req;
    )

#_override
#_public
    String toString()
    (§
        ;; Print only the user-settable fields.
        MoreObjects.ToStringHelper helper = MoreObjects.toStringHelper(this).omitNullValues();
        helper.add("emptyWallet", emptyWallet);
        helper.add("changeAddress", changeAddress);
        helper.add("feePerKb", feePerKb);
        helper.add("ensureMinRequiredFee", ensureMinRequiredFee);
        helper.add("signInputs", signInputs);
        helper.add("aesKey", (aesKey != nil) ? "set" : nil); ;; Careful to not leak the key.
        helper.add("coinSelector", coinSelector);
        helper.add("shuffleOutputs", shuffleOutputs);
        helper.add("recipientsPayFees", recipientsPayFees);
        return helper.toString();
    )
)

(ns org.bitcoinj.wallet #_"UnreadableWalletException"
)

;;;
 ; Thrown by the {@link WalletProtobufSerializer} when the serialized protocol buffer is either corrupted,
 ; internally inconsistent or appears to be from the future.
 ;;
#_public
class UnreadableWalletException extends Exception
(§
#_public
    UnreadableWalletException(String s)
    (§
        super(s);
    )

#_public
    UnreadableWalletException(String s, Throwable t)
    (§
        super(s, t);
    )

#_public
#_static
    class BadPassword extends UnreadableWalletException
    (§
#_public
        BadPassword()
        (§
            super("Password incorrect");
        )
    )

#_public
#_static
    class FutureVersion extends UnreadableWalletException
    (§
#_public
        FutureVersion()
        (§
            super("Unknown wallet version from the future.");
        )
    )

#_public
#_static
    class WrongNetwork extends UnreadableWalletException
    (§
#_public
        WrongNetwork()
        (§
            super("Mismatched network ID");
        )
    )
)

(ns org.bitcoinj.wallet #_"Wallet"
    (:import #_[java.io *]
             [java.math BigInteger]
             #_[java.util *]
             #_[java.util.concurrent *]
             #_[java.util.concurrent.atomic *]
             #_[java.util.concurrent.locks *])
    (:import #_[com.google.common.annotations *]
             #_[com.google.common.base *]
             #_[com.google.common.collect *]
             #_[com.google.common.primitives *]
             #_[com.google.common.util.concurrent *]
             #_[com.google.protobuf *]
             #_[net.jcip.annotations *]
             #_[org.slf4j *]
             #_[org.spongycastle.crypto.params *])
  #_(:require [org.bitcoinj.core AbstractBlockChain Address BlockChain BloomFilter Coin Context ECKey FilteredBlock InsufficientMoneyException Message NetworkParameters Peer PeerFilterProvider PeerGroup ScriptException Sha256Hash StoredBlock Transaction TransactionBag TransactionBroadcast TransactionBroadcaster TransactionConfidence TransactionInput TransactionOutPoint TransactionOutput UTXO Utils VarInt VerificationException]
             #_[org.bitcoinj.core.TransactionConfidence *]
             #_[org.bitcoinj.core.listeners *]
             #_[org.bitcoinj.crypto *]
             #_[org.bitcoinj.script *]
             #_[org.bitcoinj.signers *]
             #_[org.bitcoinj.utils *]
             #_[org.bitcoinj.wallet.Protos.Wallet *]
             #_[org.bitcoinj.wallet.WalletTransaction *]
             [org.bitcoinj.wallet.listeners KeyChainEventListener WalletChangeEventListener WalletCoinsReceivedEventListener WalletCoinsSentEventListener WalletReorganizeEventListener]))

;; To do list:
;;
;; - Take all wallet-relevant data out of Transaction and put it into WalletTransaction.  Make Transaction immutable.
;; - Only store relevant transaction outputs, don't bother storing the rest of the data.  Big RAM saving.
;; - Split block chain and tx output tracking into a superclass that doesn't have any key or spending related code.
;; - Simplify how transactions are tracked and stored: in particular, have the wallet maintain positioning information
;;   for transactions independent of the transactions themselves, so the timeline can be walked without having to
;;   process and sort every single transaction.
;; - Split data persistence out into a backend class and make the wallet transactional, so we can store a wallet
;;   in a database not just in RAM.
;; - Make clearing of transactions able to only rewind the wallet a certain distance instead of all blocks.
;; - Make it scale:
;;     - eliminate all the algorithms with quadratic complexity (or worse).
;;     - don't require everything to be held in RAM at once.
;;     - consider allowing eviction of no longer re-orgable transactions or keys that were used up.
;;
;; Finally, find more ways to break the class up and decompose it.  Currently every time we move code out, other code
;; fills up the lines saved!

;;;
 ; <p>A Wallet stores keys and a record of transactions that send and receive value from those keys.  Using these,
 ; it is able to create new transactions that spend the recorded transactions, and this is the fundamental operation
 ; of the Bitcoin protocol.</p>
 ;
 ; <p>To learn more about this class, read <b><a href="https://bitcoinj.github.io/working-with-the-wallet">working with the wallet.</a></b></p>
 ;
 ; <p>To fill up a Wallet with transactions, you need to use it in combination with a {@link BlockChain} and various
 ; other objects, see the <a href="https://bitcoinj.github.io/getting-started">Getting started</a> tutorial
 ; on the website to learn more about how to set everything up.</p>
 ;
 ; <p>Wallets can be serialized using protocol buffers.  You need to save the wallet whenever it changes, there is an
 ; auto-save feature that simplifies this for you although you're still responsible for manually triggering a save when
 ; your app is about to quit because the auto-save feature waits a moment before actually committing to disk to avoid IO
 ; thrashing when the wallet is changing very fast (e.g. due to a block chain sync).  See
 ; {@link Wallet#autosaveToFile(java.io.File, long, java.util.concurrent.TimeUnit, org.bitcoinj.wallet.WalletFiles.Listener)}
 ; for more information about this.</p>
 ;;
#_public
class Wallet extends BaseTaggableObject
    implements NewBestBlockListener, TransactionReceivedInBlockListener, PeerFilterProvider, KeyBag, TransactionBag, ReorganizeListener
(§
#_private
#_static
#_final
    Logger log = LoggerFactory.getLogger(Wallet.class);
#_private
#_static
#_final
    int MINIMUM_BLOOM_DATA_LENGTH = 8;

    ;; Ordering: lock > keyChainGroupLock.  KeyChainGroup is protected separately to allow fast querying of current receive
    ;; address even if the wallet itself is busy e.g. saving or processing a big reorg.  Useful for reducing UI latency.
#_protected
#_final
    ReentrantLock lock = Threading.lock("wallet");
#_protected
#_final
    ReentrantLock keyChainGroupLock = Threading.lock("wallet-keychaingroup");

    ;; The various pools below give quick access to wallet-relevant transactions by the state they're in:
    ;;
    ;; Pending:  Transactions that didn't make it into the best chain yet.  Pending transactions can be killed if a
    ;;           double spend against them appears in the best chain, in which case they move to the dead pool.
    ;;           If a double spend appears in the pending state as well, we update the confidence type
    ;;           of all txns in conflict to IN_CONFLICT and wait for the miners to resolve the race.
    ;; Unspent:  Transactions that appeared in the best chain and have outputs we can spend.  Note that we store the
    ;;           entire transaction in memory even though for spending purposes we only really need the outputs, the
    ;;           reason being that this simplifies handling of re-orgs.  It would be worth fixing this in future.
    ;; Spent:    Transactions that appeared in the best chain but don't have any spendable outputs.  They're stored
    ;;           here for history browsing/auditing reasons only and in future will probably be flushed out to some
    ;;           other kind of cold storage or just removed.
    ;; Dead:     Transactions that we believe will never confirm get moved here, out of pending.  Note that Bitcoin
    ;;           Core has no notion of dead-ness: the assumption is that double spends won't happen so there's no
    ;;           need to notify the user about them.  We take a more pessimistic approach and try to track the fact
    ;;           that transactions have been double spent so applications can do something intelligent (cancel orders,
    ;;           show to the user in the UI, etc).  A transaction can leave dead and move into spent/unspent if there
    ;;           is a re-org to a chain that doesn't include the double spend.

#_private
#_final
    Map<Sha256Hash, Transaction> pending;
#_private
#_final
    Map<Sha256Hash, Transaction> unspent;
#_private
#_final
    Map<Sha256Hash, Transaction> spent;
#_private
#_final
    Map<Sha256Hash, Transaction> dead;

    ;; All transactions together.
#_protected
#_final
    Map<Sha256Hash, Transaction> transactions;

    ;; All the TransactionOutput objects that we could spend (ignoring whether we have the private key or not).
    ;; Used to speed up various calculations.
#_protected
#_final
    HashSet<TransactionOutput> myUnspents = Sets.newHashSet();

    ;; Transactions that were dropped by the risk analysis system.  These are not in any pools and not serialized
    ;; to disk.  We have to keep them around because if we ignore a tx because we think it will never confirm, but
    ;; then it actually does confirm and does so within the same network session, remote peers will not resend us
    ;; the tx data along with the Bloom filtered block, as they know we already received it once before
    ;; (so it would be wasteful to repeat).  Thus we keep them around here for a while.  If we drop our network
    ;; connections then the remote peers will forget that we were sent the tx data previously and send it again
    ;; when relaying a filtered merkleblock.
#_private
#_final
    LinkedHashMap<Sha256Hash, Transaction> riskDropped = new LinkedHashMap<Sha256Hash, Transaction>()
    (§
#_override
#_protected
        boolean removeEldestEntry(Map.Entry<Sha256Hash, Transaction> eldest)
        (§
            return (1000 < size());
        )
    );

    ;; The key chain group is not thread safe, and generally the whole hierarchy of objects should not be mutated
    ;; outside the wallet lock.  So don't expose this object directly via any accessors!
#_guarded-by("keyChainGroupLock")
#_private
    KeyChainGroup keyChainGroup;

#_protected
#_final
    Context context;
#_protected
#_final
    NetworkParameters params;

#_nilable
#_private
    Sha256Hash lastBlockSeenHash;
#_private
    int lastBlockSeenHeight;
#_private
    long lastBlockSeenTimeSecs;

#_private
#_final
    CopyOnWriteArrayList<ListenerRegistration<WalletChangeEventListener>> changeListeners = new CopyOnWriteArrayList<>();
#_private
#_final
    CopyOnWriteArrayList<ListenerRegistration<WalletCoinsReceivedEventListener>> coinsReceivedListeners = new CopyOnWriteArrayList<>();
#_private
#_final
    CopyOnWriteArrayList<ListenerRegistration<WalletCoinsSentEventListener>> coinsSentListeners = new CopyOnWriteArrayList<>();
#_private
#_final
    CopyOnWriteArrayList<ListenerRegistration<WalletReorganizeEventListener>> reorganizeListeners = new CopyOnWriteArrayList<>();
#_private
#_final
    CopyOnWriteArrayList<ListenerRegistration<TransactionConfidenceEventListener>> transactionConfidenceListeners = new CopyOnWriteArrayList<>();

    ;; A listener that relays confidence changes from the transaction confidence object to the wallet event listener,
    ;; as a convenience to API users so they don't have to register on every transaction themselves.
#_private
    TransactionConfidence.Listener txConfidenceListener;

    ;; If a TX hash appears in this set then notifyNewBestBlock will ignore it, as its confidence was already set up
    ;; in receive() via Transaction.setBlockAppearance().  As the BlockChain always calls notifyNewBestBlock even if
    ;; it sent transactions to the wallet, without this we'd double count.
#_private
    HashSet<Sha256Hash> ignoreNextNewBlock;
    ;; Whether or not to ignore pending transactions that are considered risky by the configured risk analyzer.
#_private
    boolean acceptRiskyTransactions;
    ;; Object that performs risk analysis of pending transactions.  We might reject transactions that seem like
    ;; a high risk of being a double spending attack.
#_private
    RiskAnalysis.Analyzer riskAnalyzer = DefaultRiskAnalysis.FACTORY;

    ;; Stuff for notifying transaction objects that we changed their confidences.  The purpose of this is to avoid
    ;; spuriously sending lots of repeated notifications to listeners that API users aren't really interested in as
    ;; a side effect of how the code is written (e.g. during re-orgs confidence data gets adjusted multiple times).
#_private
    int onWalletChangedSuppressions;
#_private
    boolean insideReorg;
#_private
    Map<Transaction, TransactionConfidence.Listener.ChangeReason> confidenceChanged;
#_protected
#_volatile
    WalletFiles vFileManager;
    ;; Object that is used to send transactions asynchronously when the wallet requires it.
#_protected
#_volatile
    TransactionBroadcaster vTransactionBroadcaster;
    ;; UNIX time in seconds.  Money controlled by keys created before this time will be automatically respent to
    ;; a key that was created after it.  Useful when you believe some keys have been compromised.
#_private
#_volatile
    long vKeyRotationTimestamp;

#_protected
    CoinSelector coinSelector = new DefaultCoinSelector();

    ;; The wallet version.  This is an int that can be used to track breaking changes in the wallet format.
    ;; You can also use it to detect wallets that come from the future (i.e. they contain features you
    ;; do not know how to deal with).
#_private
    int version;
    ;; User-provided description that may help people keep track of what a wallet is for.
#_private
    String description;

    ;; Objects that perform transaction signing.  Applied subsequently one after another.
#_guarded-by("lock")
#_private
    List<TransactionSigner> signers;

    ;;;
     ; Creates a new, empty wallet with a randomly chosen seed and no transactions.  Make sure to provide for
     ; sufficient backup!  Any keys will be derived from the seed.  If you want to restore a wallet from disk
     ; instead, see {@link #loadFromFile}.
     ;;
#_public
    Wallet(NetworkParameters params)
    (§
        this(Context.getOrCreate(params));
    )

    ;;;
     ; Creates a new, empty wallet with a randomly chosen seed and no transactions.  Make sure to provide for
     ; sufficient backup!  Any keys will be derived from the seed.  If you want to restore a wallet from disk
     ; instead, see {@link #loadFromFile}.
     ;;
#_public
    Wallet(Context context)
    (§
        this(context, new KeyChainGroup(context.getParams()));
    )

#_public
#_static
    Wallet fromSeed(NetworkParameters params, DeterministicSeed seed)
    (§
        return new Wallet(params, new KeyChainGroup(params, seed));
    )

    ;;;
     ; Creates a wallet that tracks payments to and from the HD key hierarchy rooted by the given watching key.
     ; A watching key corresponds to account zero in the recommended BIP32 key hierarchy.
     ;;
#_public
#_static
    Wallet fromWatchingKey(NetworkParameters params, DeterministicKey watchKey)
    (§
        return new Wallet(params, new KeyChainGroup(params, watchKey));
    )

    ;;;
     ; Creates a wallet that tracks payments to and from the HD key hierarchy rooted by the given watching key.
     ; A watching key corresponds to account zero in the recommended BIP32 key hierarchy.  The key is specified
     ; in base58 notation and the creation time of the key.  If you don't know the creation time, you can pass
     ; {@link DeterministicHierarchy#BIP32_STANDARDISATION_TIME_SECS}.
     ;;
#_public
#_static
    Wallet fromWatchingKeyB58(NetworkParameters params, String watchKeyB58, long creationTimeSeconds)
    (§
#_final
        DeterministicKey watchKey = DeterministicKey.deserializeB58(nil, watchKeyB58, params);
        watchKey.setCreationTimeSeconds(creationTimeSeconds);
        return fromWatchingKey(params, watchKey);
    )

    ;;;
     ; Creates a wallet containing a given set of keys.  All further keys will be derived from the oldest key.
     ;;
#_public
#_static
    Wallet fromKeys(NetworkParameters params, List<ECKey> keys)
    (§
        for (ECKey key : keys)
            Preconditions.checkArgument(!(key instanceof DeterministicKey));

        KeyChainGroup group = new KeyChainGroup(params);
        group.importKeys(keys);
        return new Wallet(params, group);
    )

#_public
    Wallet(NetworkParameters params, KeyChainGroup keyChainGroup)
    (§
        this(Context.getOrCreate(params), keyChainGroup);
    )

#_private
    Wallet(Context context, KeyChainGroup keyChainGroup)
    (§
        this.context = context;
        this.params = context.getParams();
        this.keyChainGroup = Preconditions.checkNotNull(keyChainGroup);
        if (params.getId().equals(NetworkParameters.ID_UNITTESTNET))
            this.keyChainGroup.setLookaheadSize(5); ;; Cut down excess computation for unit tests.
        ;; If this keyChainGroup was created fresh just now (new wallet), make HD so a backup can be made immediately
        ;; without having to call current/freshReceiveKey.  If there are already keys in the chain of any kind then
        ;; we're probably being deserialized so leave things alone: the API user can upgrade later.
        if (this.keyChainGroup.numKeys() == 0)
            this.keyChainGroup.createAndActivateNewHDChain();
        unspent = new HashMap<>();
        spent = new HashMap<>();
        pending = new HashMap<>();
        dead = new HashMap<>();
        transactions = new HashMap<>();
        ;; Use a linked hash map to ensure ordering of event listeners is correct.
        confidenceChanged = new LinkedHashMap<>();
        signers = new ArrayList<>();
        addTransactionSigner(new LocalTransactionSigner());
        createTransientState();
    )

#_private
    void createTransientState()
    (§
        ignoreNextNewBlock = new HashSet<>();
        txConfidenceListener = new TransactionConfidence.Listener()
        (§
#_override
#_public
            void onConfidenceChanged(TransactionConfidence confidence, TransactionConfidence.Listener.ChangeReason reason)
            (§
                ;; This will run on the user code thread so we shouldn't do anything too complicated here.
                ;; We only want to queue a wallet changed event and auto-save if the number of peers announcing
                ;; the transaction has changed, as that confidence change is made by the networking code which
                ;; doesn't necessarily know at that point which wallets contain which transactions, so it's up
                ;; to us to listen for that.  Other types of confidence changes (type, etc.) are triggered by us,
                ;; so we'll queue up a wallet change event in other parts of the code.
                if (reason == ChangeReason.SEEN_PEERS)
                (§
                    lock.lock();
                    try
                    (§
                        checkBalanceFuturesLocked(nil);
                        Transaction tx = getTransaction(confidence.getTransactionHash());
                        queueOnTransactionConfidenceChanged(tx);
                        maybeQueueOnWalletChanged();
                    )
                    finally
                    (§
                        lock.unlock();
                    )
                )
            )
        );
        acceptRiskyTransactions = false;
    )

#_public
    NetworkParameters getNetworkParameters()
    (§
        return params;
    )

    ;;;
     ; Gets the active keychain via {@link KeyChainGroup#getActiveKeyChain()}.
     ;;
#_public
    DeterministicKeyChain getActiveKeyChain()
    (§
        return keyChainGroup.getActiveKeyChain();
    )

    ;;;
     ; <p>Adds given transaction signer to the list of signers.  It will be added to the end of the signers list,
     ; so if this wallet already has some signers added, given signer will be executed after all of them.</p>
     ; <p>Transaction signer should be fully initialized before adding to the wallet, otherwise
     ; {@link IllegalStateException} will be thrown</p>
     ;;
#_public
#_final
    void addTransactionSigner(TransactionSigner signer)
    (§
        lock.lock();
        try
        (§
            if (signer.isReady())
                signers.add(signer);
            else
                throw new IllegalStateException("Signer instance is not ready to be added into Wallet: " + signer.getClass());
        )
        finally
        (§
            lock.unlock();
        )
    )

#_public
    List<TransactionSigner> getTransactionSigners()
    (§
        lock.lock();
        try
        (§
            return ImmutableList.copyOf(signers);
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Returns a key that hasn't been seen in a transaction yet, and which is suitable for displaying
     ; in a wallet user interface as "a convenient key to receive funds on" when the purpose parameter
     ; is {@link org.bitcoinj.wallet.KeyChain.KeyPurpose#RECEIVE_FUNDS}.  The returned key is stable
     ; until it's actually seen in a pending or confirmed transaction, at which point this method will
     ; start returning a different key (for each purpose independently).
     ;;
#_public
    DeterministicKey currentKey(KeyChain.KeyPurpose purpose)
    (§
        keyChainGroupLock.lock();
        try
        (§
            maybeUpgradeToHD();
            return keyChainGroup.currentKey(purpose);
        )
        finally
        (§
            keyChainGroupLock.unlock();
        )
    )

    ;;;
     ; An alias for calling {@link #currentKey(org.bitcoinj.wallet.KeyChain.KeyPurpose)} with
     ; {@link org.bitcoinj.wallet.KeyChain.KeyPurpose#RECEIVE_FUNDS} as the parameter.
     ;;
#_public
    DeterministicKey currentReceiveKey()
    (§
        return currentKey(KeyChain.KeyPurpose.RECEIVE_FUNDS);
    )

    ;;;
     ; Returns address for a {@link #currentKey(org.bitcoinj.wallet.KeyChain.KeyPurpose)}.
     ;;
#_public
    Address currentAddress(KeyChain.KeyPurpose purpose)
    (§
        keyChainGroupLock.lock();
        try
        (§
            maybeUpgradeToHD();
            return keyChainGroup.currentAddress(purpose);
        )
        finally
        (§
            keyChainGroupLock.unlock();
        )
    )

    ;;;
     ; An alias for calling {@link #currentAddress(org.bitcoinj.wallet.KeyChain.KeyPurpose)} with
     ; {@link org.bitcoinj.wallet.KeyChain.KeyPurpose#RECEIVE_FUNDS} as the parameter.
     ;;
#_public
    Address currentReceiveAddress()
    (§
        return currentAddress(KeyChain.KeyPurpose.RECEIVE_FUNDS);
    )

    ;;;
     ; Returns a key that has not been returned by this method before (fresh).  You can think of this
     ; as being a newly created key, although the notion of "create" is not really valid for a
     ; {@link org.bitcoinj.wallet.DeterministicKeyChain}.  When the parameter is
     ; {@link org.bitcoinj.wallet.KeyChain.KeyPurpose#RECEIVE_FUNDS} the returned key is suitable for
     ; being put into a receive coins wizard type UI.  You should use this when the user is definitely
     ; going to hand this key out to someone who wishes to send money.
     ;;
#_public
    DeterministicKey freshKey(KeyChain.KeyPurpose purpose)
    (§
        return freshKeys(purpose, 1).get(0);
    )

    ;;;
     ; Returns a key/s that has not been returned by this method before (fresh).  You can think of this
     ; as being a newly created key/s, although the notion of "create" is not really valid for a
     ; {@link org.bitcoinj.wallet.DeterministicKeyChain}.  When the parameter is
     ; {@link org.bitcoinj.wallet.KeyChain.KeyPurpose#RECEIVE_FUNDS} the returned key is suitable for
     ; being put into a receive coins wizard type UI. You should use this when the user is definitely
     ; going to hand this key/s out to someone who wishes to send money.
     ;;
#_public
    List<DeterministicKey> freshKeys(KeyChain.KeyPurpose purpose, int numberOfKeys)
    (§
        List<DeterministicKey> keys;
        keyChainGroupLock.lock();
        try
        (§
            maybeUpgradeToHD();
            keys = keyChainGroup.freshKeys(purpose, numberOfKeys);
        )
        finally
        (§
            keyChainGroupLock.unlock();
        )
        ;; Do we really need an immediate hard save?  Arguably all this is doing is saving the 'current' key
        ;; and that's not quite so important, so we could coalesce for more performance.
        saveNow();
        return keys;
    )

    ;;;
     ; An alias for calling {@link #freshKey(org.bitcoinj.wallet.KeyChain.KeyPurpose)} with
     ; {@link org.bitcoinj.wallet.KeyChain.KeyPurpose#RECEIVE_FUNDS} as the parameter.
     ;;
#_public
    DeterministicKey freshReceiveKey()
    (§
        return freshKey(KeyChain.KeyPurpose.RECEIVE_FUNDS);
    )

    ;;;
     ; Returns address for a {@link #freshKey(org.bitcoinj.wallet.KeyChain.KeyPurpose)}.
     ;;
#_public
    Address freshAddress(KeyChain.KeyPurpose purpose)
    (§
        Address key;
        keyChainGroupLock.lock();
        try
        (§
            key = keyChainGroup.freshAddress(purpose);
        )
        finally
        (§
            keyChainGroupLock.unlock();
        )
        saveNow();
        return key;
    )

    ;;;
     ; An alias for calling {@link #freshAddress(org.bitcoinj.wallet.KeyChain.KeyPurpose)} with
     ; {@link org.bitcoinj.wallet.KeyChain.KeyPurpose#RECEIVE_FUNDS} as the parameter.
     ;;
#_public
    Address freshReceiveAddress()
    (§
        return freshAddress(KeyChain.KeyPurpose.RECEIVE_FUNDS);
    )

    ;;;
     ; Returns only the keys that have been issued by {@link #freshReceiveKey()}, {@link #freshReceiveAddress()},
     ; {@link #currentReceiveKey()} or {@link #currentReceiveAddress()}.
     ;;
#_public
    List<ECKey> getIssuedReceiveKeys()
    (§
        keyChainGroupLock.lock();
        try
        (§
            return keyChainGroup.getActiveKeyChain().getIssuedReceiveKeys();
        )
        finally
        (§
            keyChainGroupLock.unlock();
        )
    )

    ;;;
     ; Returns only the addresses that have been issued by {@link #freshReceiveKey()}, {@link #freshReceiveAddress()},
     ; {@link #currentReceiveKey()} or {@link #currentReceiveAddress()}.
     ;;
#_public
    List<Address> getIssuedReceiveAddresses()
    (§
#_final
        List<ECKey> keys = getIssuedReceiveKeys();
        List<Address> addresses = new ArrayList<>(keys.size());
        for (ECKey key : keys)
            addresses.add(key.toAddress(getParams()));
        return addresses;
    )

    ;;;
     ; Upgrades the wallet to be deterministic (BIP32).  You should call this, possibly providing the users encryption
     ; key, after loading a wallet produced by previous versions of bitcoinj.  If the wallet is encrypted the key
     ; <b>must</b> be provided, due to the way the seed is derived deterministically from private key bytes: failing
     ; to do this will result in an exception being thrown.  For non-encrypted wallets, the upgrade will be done for
     ; you automatically the first time a new key is requested (this happens when spending due to the change address).
     ;;
#_public
    void upgradeToDeterministic(#_nilable KeyParameter aesKey)
        throws DeterministicUpgradeRequiresPassword
    (§
        keyChainGroupLock.lock();
        try
        (§
            keyChainGroup.upgradeToDeterministic(vKeyRotationTimestamp, aesKey);
        )
        finally
        (§
            keyChainGroupLock.unlock();
        )
    )

    ;;;
     ; Returns true if the wallet contains random keys and no HD chains, in which case you should call
     ; {@link #upgradeToDeterministic(org.spongycastle.crypto.params.KeyParameter)} before attempting
     ; to do anything that would require a new address or key.
     ;;
#_public
    boolean isDeterministicUpgradeRequired()
    (§
        keyChainGroupLock.lock();
        try
        (§
            return keyChainGroup.isDeterministicUpgradeRequired();
        )
        finally
        (§
            keyChainGroupLock.unlock();
        )
    )

#_private
    void maybeUpgradeToHD()
        throws DeterministicUpgradeRequiresPassword
    (§
        maybeUpgradeToHD(nil);
    )

#_guarded-by("keyChainGroupLock")
#_private
    void maybeUpgradeToHD(#_nilable KeyParameter aesKey)
        throws DeterministicUpgradeRequiresPassword
    (§
        Preconditions.checkState(keyChainGroupLock.isHeldByCurrentThread());
        if (keyChainGroup.isDeterministicUpgradeRequired())
        (§
            log.info("Upgrade to HD wallets is required, attempting to do so.");
            try
            (§
                upgradeToDeterministic(aesKey);
            )
            catch (DeterministicUpgradeRequiresPassword e)
            (§
                log.error("Failed to auto upgrade due to encryption. You should call wallet.upgradeToDeterministic with the users AES key to avoid this error.");
                throw e;
            )
        )
    )

    ;;;
     ; Removes the given key from the basicKeyChain.  Be very careful with this - losing a private key
     ; <b>destroys the money associated with it</b>.
     ; @return whether the key was removed or not.
     ;;
#_public
    boolean removeKey(ECKey key)
    (§
        keyChainGroupLock.lock();
        try
        (§
            return keyChainGroup.removeImportedKey(key);
        )
        finally
        (§
            keyChainGroupLock.unlock();
        )
    )

    ;;;
     ; Returns the number of keys in the key chain group, including lookahead keys.
     ;;
#_public
    int getKeyChainGroupSize()
    (§
        keyChainGroupLock.lock();
        try
        (§
            return keyChainGroup.numKeys();
        )
        finally
        (§
            keyChainGroupLock.unlock();
        )
    )

#_testing
#_public
    int getKeyChainGroupCombinedKeyLookaheadEpochs()
    (§
        keyChainGroupLock.lock();
        try
        (§
            return keyChainGroup.getCombinedKeyLookaheadEpochs();
        )
        finally
        (§
            keyChainGroupLock.unlock();
        )
    )

    ;;;
     ; Returns a list of the non-deterministic keys that have been imported into the wallet, or the empty list if none.
     ;;
#_public
    List<ECKey> getImportedKeys()
    (§
        keyChainGroupLock.lock();
        try
        (§
            return keyChainGroup.getImportedKeys();
        )
        finally
        (§
            keyChainGroupLock.unlock();
        )
    )

    ;;; Returns the address used for change outputs.  Note: this will probably go away in future. ;;
#_public
    Address currentChangeAddress()
    (§
        return currentAddress(KeyChain.KeyPurpose.CHANGE);
    )

    ;;;
     ; <p>Imports the given ECKey to the wallet.</p>
     ;
     ; <p>If the wallet is configured to auto save to a file, triggers a save immediately.  Runs the onKeysAdded event
     ; handler.  If the key already exists in the wallet, does nothing and returns false.</p>
     ;;
#_public
    boolean importKey(ECKey key)
    (§
        return (importKeys(Lists.newArrayList(key)) == 1);
    )

    ;;;
     ; Imports the given keys to the wallet.
     ; If {@link Wallet#autosaveToFile(java.io.File, long, java.util.concurrent.TimeUnit, org.bitcoinj.wallet.WalletFiles.Listener)}
     ; has been called, triggers an auto save bypassing the normal coalescing delay and event handlers.
     ; Returns the number of keys added, after duplicates are ignored.  The onKeyAdded event will be called
     ; for each key in the list that was not already present.
     ;;
#_public
    int importKeys(final List<ECKey> keys)
    (§
        ;; API usage check.
        checkNoDeterministicKeys(keys);
        int result;
        keyChainGroupLock.lock();
        try
        (§
            result = keyChainGroup.importKeys(keys);
        )
        finally
        (§
            keyChainGroupLock.unlock();
        )
        saveNow();
        return result;
    )

#_private
    void checkNoDeterministicKeys(List<ECKey> keys)
    (§
        ;; Watch out for someone doing wallet.importKey(wallet.freshReceiveKey()); or equivalent: we never tested this.
        for (ECKey key : keys)
            if (key instanceof DeterministicKey)
                throw new IllegalArgumentException("Cannot import HD keys back into the wallet");
    )

    ;;; Takes a list of keys and a password, then encrypts and imports them in one step using the current keycrypter. ;;
#_public
    int importKeysAndEncrypt(final List<ECKey> keys, CharSequence password)
    (§
        keyChainGroupLock.lock();
        try
        (§
            Preconditions.checkNotNull(getKeyCrypter(), "Wallet is not encrypted");
            return importKeysAndEncrypt(keys, getKeyCrypter().deriveKey(password));
        )
        finally
        (§
            keyChainGroupLock.unlock();
        )
    )

    ;;; Takes a list of keys and an AES key, then encrypts and imports them in one step using the current keycrypter. ;;
#_public
    int importKeysAndEncrypt(final List<ECKey> keys, KeyParameter aesKey)
    (§
        keyChainGroupLock.lock();
        try
        (§
            checkNoDeterministicKeys(keys);
            return keyChainGroup.importKeysAndEncrypt(keys, aesKey);
        )
        finally
        (§
            keyChainGroupLock.unlock();
        )
    )

    ;;;
     ; Add a pre-configured keychain to the wallet.  Useful for setting up a complex keychain,
     ; such as for a married wallet.  For example:
     ; <pre>
     ; MarriedKeyChain chain = MarriedKeyChain.builder()
     ;     .random(new SecureRandom())
     ;     .followingKeys(followingKeys)
     ;     .threshold(2).build();
     ; wallet.addAndActivateHDChain(chain);
     ; </p>
     ;;
#_public
    void addAndActivateHDChain(DeterministicKeyChain chain)
    (§
        keyChainGroupLock.lock();
        try
        (§
            keyChainGroup.addAndActivateHDChain(chain);
        )
        finally
        (§
            keyChainGroupLock.unlock();
        )
    )

    ;;; See {@link org.bitcoinj.wallet.DeterministicKeyChain#setLookaheadSize(int)} for more info on this. ;;
#_public
    void setKeyChainGroupLookaheadSize(int lookaheadSize)
    (§
        keyChainGroupLock.lock();
        try
        (§
            keyChainGroup.setLookaheadSize(lookaheadSize);
        )
        finally
        (§
            keyChainGroupLock.unlock();
        )
    )

    ;;; See {@link org.bitcoinj.wallet.DeterministicKeyChain#setLookaheadSize(int)} for more info on this. ;;
#_public
    int getKeyChainGroupLookaheadSize()
    (§
        keyChainGroupLock.lock();
        try
        (§
            return keyChainGroup.getLookaheadSize();
        )
        finally
        (§
            keyChainGroupLock.unlock();
        )
    )

    ;;; See {@link org.bitcoinj.wallet.DeterministicKeyChain#setLookaheadThreshold(int)} for more info on this. ;;
#_public
    void setKeyChainGroupLookaheadThreshold(int num)
    (§
        keyChainGroupLock.lock();
        try
        (§
            maybeUpgradeToHD();
            keyChainGroup.setLookaheadThreshold(num);
        )
        finally
        (§
            keyChainGroupLock.unlock();
        )
    )

    ;;; See {@link org.bitcoinj.wallet.DeterministicKeyChain#setLookaheadThreshold(int)} for more info on this. ;;
#_public
    int getKeyChainGroupLookaheadThreshold()
    (§
        keyChainGroupLock.lock();
        try
        (§
            maybeUpgradeToHD();
            return keyChainGroup.getLookaheadThreshold();
        )
        finally
        (§
            keyChainGroupLock.unlock();
        )
    )

    ;;;
     ; Returns a public-only DeterministicKey that can be used to set up a watching wallet: that is, a wallet that
     ; can import transactions from the block chain just as the normal wallet can, but which cannot spend.  Watching
     ; wallets are very useful for things like web servers that accept payments.  This key corresponds to the account
     ; zero key in the recommended BIP32 hierarchy.
     ;;
#_public
    DeterministicKey getWatchingKey()
    (§
        keyChainGroupLock.lock();
        try
        (§
            maybeUpgradeToHD();
            return keyChainGroup.getActiveKeyChain().getWatchingKey();
        )
        finally
        (§
            keyChainGroupLock.unlock();
        )
    )

    ;;;
     ; Returns whether this wallet consists entirely of watching keys (unencrypted keys with no private part).
     ; Mixed wallets are forbidden.
     ;
     ; @throws IllegalStateException if there are no keys, or if there is a mix between watching and non-watching keys.
     ;;
#_public
    boolean isWatching()
    (§
        keyChainGroupLock.lock();
        try
        (§
            maybeUpgradeToHD();
            return keyChainGroup.isWatching();
        )
        finally
        (§
            keyChainGroupLock.unlock();
        )
    )

    ;;;
     ; Locates a keypair from the basicKeyChain given the hash of the public key.  This is needed when finding out
     ; which key we need to use to redeem a transaction output.
     ;
     ; @return ECKey object or null if no such key was found.
     ;;
#_override
#_nilable
#_public
    ECKey findKeyFromPubHash(byte[] pubkeyHash)
    (§
        keyChainGroupLock.lock();
        try
        (§
            return keyChainGroup.findKeyFromPubHash(pubkeyHash);
        )
        finally
        (§
            keyChainGroupLock.unlock();
        )
    )

    ;;; Returns true if the given key is in the wallet, false otherwise.  Currently an O(N) operation. ;;
#_public
    boolean hasKey(ECKey key)
    (§
        keyChainGroupLock.lock();
        try
        (§
            return keyChainGroup.hasKey(key);
        )
        finally
        (§
            keyChainGroupLock.unlock();
        )
    )

    ;;; {@inheritDoc} ;;
#_override
#_public
    boolean isPubKeyHashMine(byte[] pubkeyHash)
    (§
        return (findKeyFromPubHash(pubkeyHash) != nil);
    )

    ;;;
     ; Locates a keypair from the basicKeyChain given the raw public key bytes.
     ; @return ECKey or null if no such key was found.
     ;;
#_override
#_nilable
#_public
    ECKey findKeyFromPubKey(byte[] pubkey)
    (§
        keyChainGroupLock.lock();
        try
        (§
            return keyChainGroup.findKeyFromPubKey(pubkey);
        )
        finally
        (§
            keyChainGroupLock.unlock();
        )
    )

    ;;; {@inheritDoc} ;;
#_override
#_public
    boolean isPubKeyMine(byte[] pubkey)
    (§
        return (findKeyFromPubKey(pubkey) != nil);
    )

    ;;;
     ; Locates a redeem data (redeem script and keys) from the keyChainGroup given the hash of the script.
     ; @return RedeemData object or null if no such data was found.
     ;;
#_nilable
#_override
#_public
    RedeemData findRedeemDataFromScriptHash(byte[] payToScriptHash)
    (§
        keyChainGroupLock.lock();
        try
        (§
            return keyChainGroup.findRedeemDataFromScriptHash(payToScriptHash);
        )
        finally
        (§
            keyChainGroupLock.unlock();
        )
    )

    ;;; {@inheritDoc} ;;
#_override
#_public
    boolean isPayToScriptHashMine(byte[] payToScriptHash)
    (§
        return (findRedeemDataFromScriptHash(payToScriptHash) != nil);
    )

    ;;;
     ; Marks all keys used in the transaction output as used in the wallet.
     ; See {@link org.bitcoinj.wallet.DeterministicKeyChain#markKeyAsUsed(DeterministicKey)} for more info on this.
     ;;
#_private
    void markKeysAsUsed(Transaction tx)
    (§
        keyChainGroupLock.lock();
        try
        (§
            for (TransactionOutput o : tx.getOutputs())
            (§
                try
                (§
                    Script script = o.getScriptPubKey();
                    if (script.isSentToRawPubKey())
                    (§
                        byte[] pubkey = script.getPubKey();
                        keyChainGroup.markPubKeyAsUsed(pubkey);
                    )
                    else if (script.isSentToAddress())
                    (§
                        byte[] pubkeyHash = script.getPubKeyHash();
                        keyChainGroup.markPubKeyHashAsUsed(pubkeyHash);
                    )
                    else if (script.isPayToScriptHash())
                    (§
                        Address a = Address.fromP2SHScript(tx.getParams(), script);
                        keyChainGroup.markP2SHAddressAsUsed(a);
                    )
                )
                catch (ScriptException e)
                (§
                    ;; Just means we didn't understand the output of this transaction: ignore it.
                    log.warn("Could not parse tx output script: {}", e.toString());
                )
            )
        )
        finally
        (§
            keyChainGroupLock.unlock();
        )
    )

    ;;;
     ; Returns the immutable seed for the current active HD chain.
     ; @throws org.bitcoinj.core.ECKey.MissingPrivateKeyException if the seed is unavailable (watching wallet).
     ;;
#_public
    DeterministicSeed getKeyChainSeed()
    (§
        keyChainGroupLock.lock();
        try
        (§
            DeterministicSeed seed = keyChainGroup.getActiveKeyChain().getSeed();
            if (seed == nil)
                throw new ECKey.MissingPrivateKeyException();
            return seed;
        )
        finally
        (§
            keyChainGroupLock.unlock();
        )
    )

    ;;;
     ; Returns a key for the given HD path, assuming it's already been derived.  You normally shouldn't use this:
     ; use currentReceiveKey/freshReceiveKey instead.
     ;;
#_public
    DeterministicKey getKeyByPath(List<ChildNumber> path)
    (§
        keyChainGroupLock.lock();
        try
        (§
            maybeUpgradeToHD();
            return keyChainGroup.getActiveKeyChain().getKeyByPath(path, false);
        )
        finally
        (§
            keyChainGroupLock.unlock();
        )
    )

    ;;;
     ; Convenience wrapper around
     ; {@link Wallet#encrypt(org.bitcoinj.crypto.KeyCrypter, org.spongycastle.crypto.params.KeyParameter)}
     ; which uses the default Scrypt key derivation algorithm and parameters to derive a key from the given password.
     ;;
#_public
    void encrypt(CharSequence password)
    (§
        keyChainGroupLock.lock();
        try
        (§
#_final
            KeyCrypterScrypt scrypt = new KeyCrypterScrypt();
            keyChainGroup.encrypt(scrypt, scrypt.deriveKey(password));
        )
        finally
        (§
            keyChainGroupLock.unlock();
        )
        saveNow();
    )

    ;;;
     ; Encrypt the wallet using the KeyCrypter and the AES key.
     ; A good default KeyCrypter to use is {@link org.bitcoinj.crypto.KeyCrypterScrypt}.
     ;
     ; @param keyCrypter The KeyCrypter that specifies how to encrypt/ decrypt a key.
     ; @param aesKey AES key to use (normally created using KeyCrypter#deriveKey and cached as it is time consuming to create from a password).
     ; @throws KeyCrypterException if the wallet encryption fails.  If so, the wallet state is unchanged.
     ;;
#_public
    void encrypt(KeyCrypter keyCrypter, KeyParameter aesKey)
    (§
        keyChainGroupLock.lock();
        try
        (§
            keyChainGroup.encrypt(keyCrypter, aesKey);
        )
        finally
        (§
            keyChainGroupLock.unlock();
        )
        saveNow();
    )

    ;;;
     ; Decrypt the wallet with the wallets keyCrypter and password.
     ; @throws KeyCrypterException if the wallet decryption fails.  If so, the wallet state is unchanged.
     ;;
#_public
    void decrypt(CharSequence password)
    (§
        keyChainGroupLock.lock();
        try
        (§
#_final
            KeyCrypter crypter = keyChainGroup.getKeyCrypter();
            Preconditions.checkState(crypter != nil, "Not encrypted");
            keyChainGroup.decrypt(crypter.deriveKey(password));
        )
        finally
        (§
            keyChainGroupLock.unlock();
        )
        saveNow();
    )

    ;;;
     ; Decrypt the wallet with the wallets keyCrypter and AES key.
     ;
     ; @param aesKey AES key to use (normally created using KeyCrypter#deriveKey and cached as it is time consuming to create from a password).
     ; @throws KeyCrypterException if the wallet decryption fails. If so, the wallet state is unchanged.
     ;;
#_public
    void decrypt(KeyParameter aesKey)
    (§
        keyChainGroupLock.lock();
        try
        (§
            keyChainGroup.decrypt(aesKey);
        )
        finally
        (§
            keyChainGroupLock.unlock();
        )
        saveNow();
    )

    ;;;
     ;  Check whether the password can decrypt the first key in the wallet.
     ;  This can be used to check the validity of an entered password.
     ;
     ;  @return true if the password supplied can decrypt the first private key in the wallet, false otherwise.
     ;  @throws IllegalStateException if the wallet is not encrypted.
     ;;
#_public
    boolean checkPassword(CharSequence password)
    (§
        keyChainGroupLock.lock();
        try
        (§
            return keyChainGroup.checkPassword(password);
        )
        finally
        (§
            keyChainGroupLock.unlock();
        )
    )

    ;;;
     ;  Check whether the AES key can decrypt the first encrypted key in the wallet.
     ;
     ;  @return true if AES key supplied can decrypt the first encrypted private key in the wallet, false otherwise.
     ;;
#_public
    boolean checkAESKey(KeyParameter aesKey)
    (§
        keyChainGroupLock.lock();
        try
        (§
            return keyChainGroup.checkAESKey(aesKey);
        )
        finally
        (§
            keyChainGroupLock.unlock();
        )
    )

    ;;;
     ; Get the wallet's KeyCrypter, or null if the wallet is not encrypted.
     ; (Used in encrypting/decrypting an ECKey).
     ;;
#_nilable
#_public
    KeyCrypter getKeyCrypter()
    (§
        keyChainGroupLock.lock();
        try
        (§
            return keyChainGroup.getKeyCrypter();
        )
        finally
        (§
            keyChainGroupLock.unlock();
        )
    )

    ;;;
     ; Get the type of encryption used for this wallet.
     ;
     ; (This is a convenience method - the encryption type is actually stored in the keyCrypter).
     ;;
#_public
    EncryptionType getEncryptionType()
    (§
        keyChainGroupLock.lock();
        try
        (§
            KeyCrypter crypter = keyChainGroup.getKeyCrypter();
            return (crypter != nil) ? crypter.getUnderstoodEncryptionType() : EncryptionType.UNENCRYPTED;
        )
        finally
        (§
            keyChainGroupLock.unlock();
        )
    )

    ;;; Returns true if the wallet is encrypted using any scheme, false if not. ;;
#_public
    boolean isEncrypted()
    (§
        return (getEncryptionType() != EncryptionType.UNENCRYPTED);
    )

    ;;; Changes wallet encryption password, this is atomic operation. ;;
#_public
    void changeEncryptionPassword(CharSequence currentPassword, CharSequence newPassword)
    (§
        keyChainGroupLock.lock();
        try
        (§
            decrypt(currentPassword);
            encrypt(newPassword);
        )
        finally
        (§
            keyChainGroupLock.unlock();
        )
    )

    ;;; Changes wallet AES encryption key, this is atomic operation. ;;
#_public
    void changeEncryptionKey(KeyCrypter keyCrypter, KeyParameter currentAesKey, KeyParameter newAesKey)
    (§
        keyChainGroupLock.lock();
        try
        (§
            decrypt(currentAesKey);
            encrypt(keyCrypter, newAesKey);
        )
        finally
        (§
            keyChainGroupLock.unlock();
        )
    )

    ;; TODO: Make this package private once the classes finish moving around.
    ;;; Internal use only. ;;
#_public
    List<Protos.Key> serializeKeyChainGroupToProtobuf()
    (§
        keyChainGroupLock.lock();
        try
        (§
            return keyChainGroup.serializeToProtobuf();
        )
        finally
        (§
            keyChainGroupLock.unlock();
        )
    )

    ;;; Saves the wallet first to the given temp file, then renames to the dest file. ;;
#_public
    void saveToFile(File temp, File destFile)
        throws IOException
    (§
        FileOutputStream stream = nil;
        lock.lock();
        try
        (§
            stream = new FileOutputStream(temp);
            saveToFileStream(stream);
            ;; Attempt to force the bits to hit the disk.  In reality the OS or hard disk itself may still decide
            ;; to not write through to physical media for at least a few seconds, but this is the best we can do.
            stream.flush();
            stream.getFD().sync();
            stream.close();
            stream = nil;
            if (Utils.isWindows())
            (§
                ;; Work around an issue on Windows whereby you can't rename over existing files.
                File canonical = destFile.getCanonicalFile();
                if (canonical.exists() && !canonical.delete())
                    throw new IOException("Failed to delete canonical wallet file for replacement with autosave");
                if (temp.renameTo(canonical))
                    return; ;; else fall through
                throw new IOException("Failed to rename " + temp + " to " + canonical);
            )
            else if (!temp.renameTo(destFile))
            (§
                throw new IOException("Failed to rename " + temp + " to " + destFile);
            )
        )
        catch (RuntimeException e)
        (§
            log.error("Failed whilst saving wallet", e);
            throw e;
        )
        finally
        (§
            lock.unlock();
            if (stream != nil)
                stream.close();
            if (temp.exists())
                log.warn("Temp file still exists after failed save.");
        )
    )

    ;;;
     ; Uses protobuf serialization to save the wallet to the given file.  To learn more about this file format, see
     ; {@link WalletProtobufSerializer}.  Writes out first to a temporary file in the same directory and then renames
     ; once written.
     ;;
#_public
    void saveToFile(File f)
        throws IOException
    (§
        File directory = f.getAbsoluteFile().getParentFile();
        File temp = File.createTempFile("wallet", nil, directory);
        saveToFile(temp, f);
    )

    ;;;
     ; <p>Whether or not the wallet will ignore pending transactions that fail the selected {@link RiskAnalysis}.
     ; By default, if a transaction is considered risky then it won't enter the wallet and won't trigger any event
     ; listeners.  If you set this property to true, then all transactions will be allowed in regardless of risk.
     ; For example, the {@link DefaultRiskAnalysis} checks for non-finality of transactions.</p>
     ;
     ; <p>Note that this property is not serialized.  You have to set it each time a Wallet object is constructed,
     ; even if it's loaded from a protocol buffer.</p>
     ;;
#_public
    void setAcceptRiskyTransactions(boolean acceptRiskyTransactions)
    (§
        lock.lock();
        try
        (§
            this.acceptRiskyTransactions = acceptRiskyTransactions;
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; See {@link Wallet#setAcceptRiskyTransactions(boolean)} for an explanation of this property.
     ;;
#_public
    boolean isAcceptRiskyTransactions()
    (§
        lock.lock();
        try
        (§
            return acceptRiskyTransactions;
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Sets the {@link RiskAnalysis} implementation to use for deciding whether received pending transactions are
     ; risky or not.  If the analyzer says a transaction is risky, by default it will be dropped. You can customize
     ; this behaviour with {@link #setAcceptRiskyTransactions(boolean)}.
     ;;
#_public
    void setRiskAnalyzer(RiskAnalysis.Analyzer analyzer)
    (§
        lock.lock();
        try
        (§
            this.riskAnalyzer = Preconditions.checkNotNull(analyzer);
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Gets the current {@link RiskAnalysis} implementation.  The default is {@link DefaultRiskAnalysis}.
     ;;
#_public
    RiskAnalysis.Analyzer getRiskAnalyzer()
    (§
        lock.lock();
        try
        (§
            return riskAnalyzer;
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; <p>Sets up the wallet to auto-save itself to the given file, using temp files with atomic renames to ensure
     ; consistency.  After connecting to a file, you no longer need to save the wallet manually, it will do it
     ; whenever necessary.  Protocol buffer serialization will be used.</p>
     ;
     ; <p>If delayTime is set, a background thread will be created and the wallet will only be saved to disk
     ; every so many time units.  If no changes have occurred for the given time period, nothing will be written.
     ; In this way disk IO can be rate limited.  It's a good idea to set this as otherwise the wallet can change very
     ; frequently, e.g. if there are a lot of transactions in it or during block sync, and there will be a lot of redundant
     ; writes.  Note that when a new key is added, that always results in an immediate save regardless of delayTime.
     ; <b>You should still save the wallet manually when your program is about to shut down as the JVM will not
     ; wait for the background thread.</b></p>
     ;
     ; <p>An event listener can be provided.  If a delay >0 was specified, it will be called on a background thread
     ; with the wallet locked when an auto-save occurs.  If delay is zero or you do something that always triggers
     ; an immediate save, like adding a key, the event listener will be invoked on the calling threads.</p>
     ;
     ; @param f The destination file to save to.
     ; @param delayTime How many time units to wait until saving the wallet on a background thread.
     ; @param timeUnit The unit of measurement for delayTime.
     ; @param eventListener Callback to be informed when the auto-save thread does things, or null.
     ;;
#_public
    WalletFiles autosaveToFile(File f, long delayTime, TimeUnit timeUnit, #_nilable WalletFiles.Listener eventListener)
    (§
        lock.lock();
        try
        (§
            Preconditions.checkState(vFileManager == nil, "Already auto saving this wallet.");
            WalletFiles manager = new WalletFiles(this, f, delayTime, timeUnit);
            if (eventListener != nil)
                manager.setListener(eventListener);
            vFileManager = manager;
            return manager;
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Disables auto-saving, after it had been enabled with
     ; {@link Wallet#autosaveToFile(java.io.File, long, java.util.concurrent.TimeUnit, org.bitcoinj.wallet.WalletFiles.Listener)}
     ; before.  This method blocks until finished.
     ;;
#_public
    void shutdownAutosaveAndWait()
    (§
        lock.lock();
        try
        (§
            WalletFiles files = vFileManager;
            vFileManager = nil;
            Preconditions.checkState(files != nil, "Auto saving not enabled.");
            files.shutdownAndWait();
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;; Requests an asynchronous save on a background thread. ;;
#_protected
    void saveLater()
    (§
        WalletFiles files = vFileManager;
        if (files != nil)
            files.saveLater();
    )

    ;;; If auto saving is enabled, do an immediate sync write to disk ignoring any delays. ;;
#_protected
    void saveNow()
    (§
        WalletFiles files = vFileManager;
        if (files != nil)
        (§
            try
            (§
                files.saveNow(); ;; This calls back into saveToFile().
            )
            catch (IOException e)
            (§
                ;; Can't really do much at this point, just let the API user know.
                log.error("Failed to save wallet to disk!", e);
                Thread.UncaughtExceptionHandler handler = Threading.uncaughtExceptionHandler;
                if (handler != nil)
                    handler.uncaughtException(Thread.currentThread(), e);
            )
        )
    )

    ;;;
     ; Uses protobuf serialization to save the wallet to the given file stream.
     ; To learn more about this file format, see {@link WalletProtobufSerializer}.
     ;;
#_public
    void saveToFileStream(OutputStream f)
        throws IOException
    (§
        lock.lock();
        try
        (§
            new WalletProtobufSerializer().writeWallet(this, f);
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;; Returns the parameters this wallet was created with. ;;
#_public
    NetworkParameters getParams()
    (§
        return params;
    )

    ;;; Returns the API context that this wallet was created with. ;;
#_public
    Context getContext()
    (§
        return context;
    )

    ;;;
     ; Returns a wallet deserialized from the given file.
     ;
     ; @param file The wallet file to be read.
     ;;
#_public
#_static
    Wallet loadFromFile(File file)
        throws UnreadableWalletException
    (§
        try
        (§
            FileInputStream stream = nil;
            try
            (§
                stream = new FileInputStream(file);
                return loadFromFileStream(stream);
            )
            finally
            (§
                if (stream != nil)
                    stream.close();
            )
        )
        catch (IOException e)
        (§
            throw new UnreadableWalletException("Could not open file", e);
        )
    )

    ;;;
     ; Returns if this wallet is structurally consistent, so e.g. no duplicate transactions.
     ; First inconsistency and a dump of the wallet will be logged.
     ;;
#_public
    boolean isConsistent()
    (§
        try
        (§
            isConsistentOrThrow();
            return true;
        )
        catch (IllegalStateException e1)
        (§
            log.error(e1.getMessage());
            try
            (§
                log.error(toString());
            )
            catch (RuntimeException e2)
            (§
                log.error("Printing inconsistent wallet failed", e2);
            )
            return false;
        )
    )

    ;;;
     ; Variant of {@link Wallet#isConsistent()} that throws an {@link IllegalStateException} describing
     ; the first inconsistency.
     ;;
#_public
    void isConsistentOrThrow()
        throws IllegalStateException
    (§
        lock.lock();
        try
        (§
            Set<Transaction> transactions = getTransactions(true);

            Set<Sha256Hash> hashes = new HashSet<>();
            for (Transaction tx : transactions)
                hashes.add(tx.getHash());

            int size1 = transactions.size();
            if (size1 != hashes.size())
                throw new IllegalStateException("Two transactions with same hash");

            int size2 = unspent.size() + spent.size() + pending.size() + dead.size();
            if (size1 != size2)
                throw new IllegalStateException("Inconsistent wallet sizes: " + size1 + ", " + size2);

            for (Transaction tx : unspent.values())
            (§
                if (!isTxConsistent(tx, false))
                    throw new IllegalStateException("Inconsistent unspent tx: " + tx.getHashAsString());
            )

            for (Transaction tx : spent.values())
            (§
                if (!isTxConsistent(tx, true))
                    throw new IllegalStateException("Inconsistent spent tx: " + tx.getHashAsString());
            )
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;; If isSpent, check that all my outputs spent, otherwise check that there at least one unspent.
#_testing
    boolean isTxConsistent(final Transaction tx, final boolean isSpent)
    (§
        boolean isActuallySpent = true;
        for (TransactionOutput o : tx.getOutputs())
        (§
            if (o.isAvailableForSpending())
            (§
                if (o.isMine(this))
                    isActuallySpent = false;
                if (o.getSpentBy() != nil)
                (§
                    log.error("isAvailableForSpending != spentBy");
                    return false;
                )
            )
            else
            (§
                if (o.getSpentBy() == nil)
                (§
                    log.error("isAvailableForSpending != spentBy");
                    return false;
                )
            )
        )
        return (isActuallySpent == isSpent);
    )

    ;;; Returns a wallet deserialized from the given input stream. ;;
#_public
#_static
    Wallet loadFromFileStream(InputStream stream)
        throws UnreadableWalletException
    (§
        Wallet wallet = new WalletProtobufSerializer().readWallet(stream);
        if (!wallet.isConsistent())
            log.error("Loaded an inconsistent wallet");
        return wallet;
    )

    ;;;
     ; Called by the {@link BlockChain} when we receive a new filtered block that contains a transactions previously
     ; received by a call to {@link #receivePending}.
     ;
     ; This is necessary for the internal book-keeping Wallet does.  When a transaction is received that sends us
     ; coins it is added to a pool so we can use it later to create spends.  When a transaction is received that
     ; consumes outputs they are marked as spent so they won't be used in future.
     ;
     ; A transaction that spends our own coins can be received either because a spend we created was accepted by
     ; the network and thus made it into a block, or because our keys are being shared between multiple instances
     ; and some other node spent the coins instead.  We still have to know about that to avoid accidentally trying
     ; to double spend.
     ;
     ; A transaction may be received multiple times if is included into blocks in parallel chains.  The blockType
     ; parameter describes whether the containing block is on the main/best chain or whether it's on a presently
     ; inactive side chain.  We must still record these transactions and the blocks they appear in because a future
     ; block might change which chain is best causing a reorganize.  A re-org can totally change our balance!
     ;;
#_override
#_public
    boolean notifyTransactionIsInBlock(Sha256Hash txHash, StoredBlock block, BlockChain.NewBlockType blockType, int relativityOffset)
        throws VerificationException
    (§
        lock.lock();
        try
        (§
            Transaction tx = transactions.get(txHash);
            if (tx == nil)
            (§
                tx = riskDropped.get(txHash);
                if (tx != nil)
                (§
                    ;; If this happens our risk analysis is probably wrong and should be improved.
                    log.info("Risk analysis dropped tx {} but was included in block anyway", tx.getHash());
                )
                else
                (§
                    ;; False positive that was broadcast to us and ignored by us because it was irrelevant to our keys.
                    return false;
                )
            )
            receive(tx, block, blockType, relativityOffset);
            return true;
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; <p>Called when we have found a transaction (via network broadcast or otherwise) that is relevant to this wallet
     ; and want to record it.  Note that we <b>cannot verify these transactions at all</b>, they may spend fictional
     ; coins or be otherwise invalid.  They are useful to inform the user about coins they can expect to receive soon,
     ; and if you trust the sender of the transaction you can choose to assume they are in fact valid and will not
     ; be double spent as an optimization.</p>
     ;
     ; <p>This is the same as {@link Wallet#receivePending(Transaction, java.util.List)} but allows you to override the
     ; {@link Wallet#isPendingTransactionRelevant(Transaction)} sanity-check to keep track of transactions that are not
     ; spendable or spend our coins.  This can be useful when you want to keep track of transaction confidence on
     ; arbitrary transactions.  Note that transactions added in this way will still be relayed to peers and appear in
     ; transaction lists like any other pending transaction (even when not relevant).</p>
     ;;
#_public
    void receivePending(Transaction tx, #_nilable List<Transaction> dependencies, boolean overrideIsRelevant)
        throws VerificationException
    (§
        ;; Can run in a peer thread.  This method will only be called if a prior call to isPendingTransactionRelevant
        ;; returned true, so we already know by this point that it sends coins to or from our wallet, or is a double
        ;; spend against one of our other pending transactions.
        lock.lock();
        try
        (§
            tx.verify();
            ;; Ignore it if we already know about this transaction.  Receiving a pending transaction never moves it
            ;; between pools.
            EnumSet<Pool> containingPools = getContainingPools(tx);
            if (!containingPools.equals(EnumSet.noneOf(Pool.class)))
            (§
                log.debug("Received tx we already saw in a block or created ourselves: " + tx.getHashAsString());
                return;
            )
            ;; Repeat the check of relevancy here, even though the caller may have already done so - this is to avoid
            ;; race conditions where receivePending may be being called in parallel.
            if (!overrideIsRelevant && !isPendingTransactionRelevant(tx))
                return;

            if (isTransactionRisky(tx, dependencies) && !acceptRiskyTransactions)
            (§
                ;; isTransactionRisky already logged the reason.
                riskDropped.put(tx.getHash(), tx);
                log.warn("There are now {} risk dropped transactions being kept in memory", riskDropped.size());
                return;
            )

            Coin valueSentToMe = tx.getValueSentToMe(this);
            Coin valueSentFromMe = tx.getValueSentFromMe(this);
            if (log.isInfoEnabled())
            (§
                log.info(String.format(Locale.US, "Received a pending transaction %s that spends %s from our own wallet, and sends us %s",
                            tx.getHashAsString(), valueSentFromMe.toFriendlyString(), valueSentToMe.toFriendlyString()));
            )
            if (tx.getConfidence().getSource().equals(TransactionConfidence.Source.UNKNOWN))
            (§
                log.warn("Wallet received transaction with an unknown source. Consider tagging it!");
            )
            ;; If this tx spends any of our unspent outputs, mark them as spent now, then add to the pending pool.  This
            ;; ensures that if some other client that has our keys broadcasts a spend we stay in sync.  Also updates the
            ;; timestamp on the transaction and registers/runs event listeners.
            commitTx(tx);
        )
        finally
        (§
            lock.unlock();
        )
        ;; maybeRotateKeys() will ignore pending transactions, so we don't bother calling it here (see the comments
        ;; in that function for an explanation of why).
    )

    ;;;
     ; Given a transaction and an optional list of dependencies (recursive/flattened), returns true if the given
     ; transaction would be rejected by the analyzer, or false otherwise.  The result of this call is independent
     ; of the value of {@link #isAcceptRiskyTransactions()}.  Risky transactions yield a logged warning.  If you
     ; want to know the reason why a transaction is risky, create an instance of the {@link RiskAnalysis} yourself
     ; using the factory returned by {@link #getRiskAnalyzer()} and use it directly.
     ;;
#_public
    boolean isTransactionRisky(Transaction tx, #_nilable List<Transaction> dependencies)
    (§
        lock.lock();
        try
        (§
            if (dependencies == nil)
                dependencies = ImmutableList.of();
            RiskAnalysis analysis = riskAnalyzer.create(this, tx, dependencies);
            RiskAnalysis.Result result = analysis.analyze();
            if (result != RiskAnalysis.Result.OK)
            (§
                log.warn("Pending transaction was considered risky: {}\n{}", analysis, tx);
                return true;
            )
            return false;
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; <p>Called when we have found a transaction (via network broadcast or otherwise) that is relevant to this wallet
     ; and want to record it.  Note that we <b>cannot verify these transactions at all</b>, they may spend fictional
     ; coins or be otherwise invalid.  They are useful to inform the user about coins they can expect to receive soon,
     ; and if you trust the sender of the transaction you can choose to assume they are in fact valid and will not
     ; be double spent as an optimization.</p>
     ;
     ; <p>Before this method is called, {@link Wallet#isPendingTransactionRelevant(Transaction)} should have been
     ; called to decide whether the wallet cares about the transaction - if it does, then this method expects the
     ; transaction and any dependencies it has which are still in the memory pool.</p>
     ;;
#_public
    void receivePending(Transaction tx, #_nilable List<Transaction> dependencies)
        throws VerificationException
    (§
        receivePending(tx, dependencies, false);
    )

    ;;;
     ; This method is used by a {@link Peer} to find out if a transaction that has been announced is interesting,
     ; that is, whether we should bother downloading its dependencies and exploring the transaction to decide how
     ; risky it is.  If this method returns true then {@link Wallet#receivePending(Transaction, java.util.List)}
     ; will soon be called with the transactions dependencies as well.
     ;;
#_public
    boolean isPendingTransactionRelevant(Transaction tx)
        throws ScriptException
    (§
        lock.lock();
        try
        (§
            ;; Ignore it if we already know about this transaction.  Receiving a pending transaction never moves it
            ;; between pools.
            EnumSet<Pool> containingPools = getContainingPools(tx);
            if (!containingPools.equals(EnumSet.noneOf(Pool.class)))
            (§
                log.debug("Received tx we already saw in a block or created ourselves: " + tx.getHashAsString());
                return false;
            )

            ;; We only care about transactions that:
            ;;   - Send us coins.
            ;;   - Spend our coins.
            ;;   - Double spend a tx in our wallet.
            if (!isTransactionRelevant(tx))
            (§
                log.debug("Received tx that isn't relevant to this wallet, discarding.");
                return false;
            )
            return true;
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; <p>Returns true if the given transaction sends coins to any of our keys, or has inputs spending any of our outputs,
     ; and also returns true if tx has inputs that are spending outputs which are
     ; not ours but which are spent by pending transactions.</p>
     ;
     ; <p>Note that if the tx has inputs containing one of our keys, but the connected transaction is not in the wallet,
     ; it will not be considered relevant.</p>
     ;;
#_public
    boolean isTransactionRelevant(Transaction tx)
        throws ScriptException
    (§
        lock.lock();
        try
        (§
            return (0 < tx.getValueSentFromMe(this).signum() || 0 < tx.getValueSentToMe(this).signum() || !findDoubleSpendsAgainst(tx, transactions).isEmpty());
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Finds transactions in the specified candidates that double spend "tx".  Not a general check, but it can work even
     ; if the double spent inputs are not ours.
     ; @return the set of transactions that double spend "tx".
     ;;
#_private
    Set<Transaction> findDoubleSpendsAgainst(Transaction tx, Map<Sha256Hash, Transaction> candidates)
    (§
        Preconditions.checkState(lock.isHeldByCurrentThread());
        if (tx.isCoinBase())
            return Sets.newHashSet();

        ;; Compile a set of outpoints that are spent by tx.
        HashSet<TransactionOutPoint> outpoints = new HashSet<>();
        for (TransactionInput input : tx.getInputs())
            outpoints.add(input.getOutpoint());

        ;; Now for each pending transaction, see if it shares any outpoints with this tx.
        Set<Transaction> doubleSpendTxns = Sets.newHashSet();
        for (Transaction p : candidates.values())
        (§
            if (p.equals(tx))
                continue;

            for (TransactionInput input : p.getInputs())
            (§
                ;; This relies on the fact that TransactionOutPoint equality is defined at the protocol not object
                ;; level - outpoints from two different inputs that point to the same output compare the same.
                TransactionOutPoint outpoint = input.getOutpoint();
                ;; If does, it's a double spend against the candidates, which makes it relevant.
                if (outpoints.contains(outpoint))
                    doubleSpendTxns.add(p);
            )
        )
        return doubleSpendTxns;
    )

    ;;;
     ; Adds to txSet all the txns in txPool spending outputs of txns in txSet,
     ; and all txns spending the outputs of those txns, recursively.
     ;;
    void addTransactionsDependingOn(Set<Transaction> txSet, Set<Transaction> txPool)
    (§
        Map<Sha256Hash, Transaction> txQueue = new LinkedHashMap<>();
        for (Transaction tx : txSet)
            txQueue.put(tx.getHash(), tx);

        while (!txQueue.isEmpty())
        (§
            Transaction tx = txQueue.remove(txQueue.keySet().iterator().next());
            for (Transaction anotherTx : txPool)
            (§
                if (anotherTx.equals(tx))
                    continue;

                for (TransactionInput input : anotherTx.getInputs())
                    if (input.getOutpoint().getHash().equals(tx.getHash()))
                        if (txQueue.get(anotherTx.getHash()) == nil)
                        (§
                            txQueue.put(anotherTx.getHash(), anotherTx);
                            txSet.add(anotherTx);
                        )
            )
        )
    )

    ;;;
     ; Called by the {@link BlockChain} when we receive a new block that sends coins to one of our addresses or
     ; spends coins from one of our addresses (note that a single transaction can do both).
     ;
     ; This is necessary for the internal book-keeping Wallet does.  When a transaction is received that sends us
     ; coins it is added to a pool so we can use it later to create spends.  When a transaction is received that
     ; consumes outputs they are marked as spent so they won't be used in future.
     ;
     ; A transaction that spends our own coins can be received either because a spend we created was accepted by
     ; the network and thus made it into a block, or because our keys are being shared between multiple instances
     ; and some other node spent the coins instead.  We still have to know about that to avoid accidentally trying
     ; to double spend.
     ;
     ; A transaction may be received multiple times if is included into blocks in parallel chains.  The blockType
     ; parameter describes whether the containing block is on the main/best chain or whether it's on a presently
     ; inactive side chain.  We must still record these transactions and the blocks they appear in because a future
     ; block might change which chain is best causing a reorganize.  A re-org can totally change our balance!
     ;;
#_override
#_public
    void receiveFromBlock(Transaction tx, StoredBlock block, BlockChain.NewBlockType blockType, int relativityOffset)
        throws VerificationException
    (§
        lock.lock();
        try
        (§
            if (isTransactionRelevant(tx))
                receive(tx, block, blockType, relativityOffset);
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;; Whether to do a saveNow or saveLater when we are notified of the next best block.
#_private
    boolean hardSaveOnNextBlock = false;

#_private
    void receive(Transaction tx, StoredBlock block, BlockChain.NewBlockType blockType, int relativityOffset)
        throws VerificationException
    (§
        ;; Runs in a peer thread.
        Preconditions.checkState(lock.isHeldByCurrentThread());

        Coin prevBalance = getBalance();
        Sha256Hash txHash = tx.getHash();
        boolean bestChain = (blockType == BlockChain.NewBlockType.BEST_CHAIN);
        boolean sideChain = (blockType == BlockChain.NewBlockType.SIDE_CHAIN);

        Coin valueSentFromMe = tx.getValueSentFromMe(this);
        Coin valueSentToMe = tx.getValueSentToMe(this);
        Coin valueDifference = valueSentToMe.subtract(valueSentFromMe);

        log.info("Received tx{} for {}: {} [{}] in block {}", sideChain ? " on a side chain" : "", valueDifference.toFriendlyString(),
                tx.getHashAsString(), relativityOffset, (block != nil) ? block.getHeader().getHash() : "(unit test)");

        ;; Inform the key chains that the issued keys were observed in a transaction, so they know to
        ;; calculate more keys for the next Bloom filters.
        markKeysAsUsed(tx);

        onWalletChangedSuppressions++;

        ;; If this transaction is already in the wallet, we may need to move it into a different pool.
        ;; At the very least we need to ensure we're manipulating the canonical object rather than a duplicate.
        (§
            Transaction tmp = transactions.get(tx.getHash());
            if (tmp != nil)
                tx = tmp;
        )

        boolean wasPending = (pending.remove(txHash) != nil);
        if (wasPending)
            log.info("  <-pending");

        if (bestChain)
        (§
            boolean wasDead = (dead.remove(txHash) != nil);
            if (wasDead)
                log.info("  <-dead");
            if (wasPending)
            (§
                ;; Was pending and is now confirmed.  Disconnect the outputs in case we spent any already:
                ;; they will be re-connected by processTxFromBestChain below.
                for (TransactionOutput output : tx.getOutputs())
                (§
#_final
                    TransactionInput spentBy = output.getSpentBy();
                    if (spentBy != nil)
                    (§
                        Preconditions.checkState(myUnspents.add(output));
                        spentBy.disconnect();
                    )
                )
            )
            processTxFromBestChain(tx, wasPending || wasDead);
        )
        else
        (§
            Preconditions.checkState(sideChain);
            ;; Transactions that appear in a side chain will have that appearance recorded below - we assume
            ;; that some miners are also trying to include the transaction into the current best chain too,
            ;; so let's treat it as pending, except we don't need to do any risk analysis on it.
            if (wasPending)
            (§
                ;; Just put it back in without touching the connections or confidence.
                addWalletTransaction(Pool.PENDING, tx);
                log.info("  ->pending");
            )
            else
            (§
                ;; Ignore the case where a tx appears on a side chain at the same time as the best chain
                ;; (this is quite normal and expected).
                Sha256Hash hash = tx.getHash();
                if (!unspent.containsKey(hash) && !spent.containsKey(hash) && !dead.containsKey(hash))
                (§
                    ;; Otherwise put it (possibly back) into pending.
                    ;; Committing it updates the spent flags and inserts into the pool as well.
                    commitTx(tx);
                )
            )
        )

        if (block != nil)
        (§
            ;; Mark the tx as appearing in this block so we can find it later after a re-org.  This also tells
            ;; the tx confidence object about the block and sets its depth appropriately.
            tx.setBlockAppearance(block, bestChain, relativityOffset);
            if (bestChain)
            (§
                ;; Don't notify this tx of work done in notifyNewBestBlock which will be called immediately
                ;; after this method has been called by BlockChain for all relevant transactions.  Otherwise
                ;; we'd double count.
                ignoreNextNewBlock.add(txHash);

                ;; When a tx is received from the best chain, if other txns that spend this tx are IN_CONFLICT,
                ;; change its confidence to PENDING (Unless they are also spending other txns IN_CONFLICT).
                ;; Consider dependency chains.
                Set<Transaction> currentTxDependencies = Sets.newHashSet(tx);
                addTransactionsDependingOn(currentTxDependencies, getTransactions(true));
                currentTxDependencies.remove(tx);
                List<Transaction> currentTxDependenciesSorted = sortTxnsByDependency(currentTxDependencies);
                for (Transaction txDependency : currentTxDependenciesSorted)
                    if (txDependency.getConfidence().getConfidenceType().equals(ConfidenceType.IN_CONFLICT))
                        if (isNotSpendingTxnsInConfidenceType(txDependency, ConfidenceType.IN_CONFLICT))
                        (§
                            txDependency.getConfidence().setConfidenceType(ConfidenceType.PENDING);
                            confidenceChanged.put(txDependency, TransactionConfidence.Listener.ChangeReason.TYPE);
                        )
            )
        )

        onWalletChangedSuppressions--;

        ;; Side chains don't affect confidence.
        if (bestChain)
        (§
            ;; notifyNewBestBlock will be invoked next and will then call maybeQueueOnWalletChanged for us.
            confidenceChanged.put(tx, TransactionConfidence.Listener.ChangeReason.TYPE);
        )
        else
        (§
            maybeQueueOnWalletChanged();
        )

        ;; Inform anyone interested that we have received or sent coins but only if:
        ;;  - This is not due to a re-org.
        ;;  - The coins appeared on the best chain.
        ;;  - We did in fact receive some new money.
        ;;  - We have not already informed the user about the coins when we received the tx broadcast,
        ;;    or for our own spends.  If users want to know when a broadcast tx becomes confirmed,
        ;;    they need to use tx confidence listeners.
        if (!insideReorg && bestChain)
        (§
            Coin newBalance = getBalance(); ;; This is slow.
            log.info("Balance is now: " + newBalance.toFriendlyString());
            if (!wasPending)
            (§
                int diff = valueDifference.signum();
                ;; We pick one callback based on the value difference, though a tx can of course both
                ;; send and receive coins from the wallet.
                if (0 < diff)
                (§
                    queueOnCoinsReceived(tx, prevBalance, newBalance);
                )
                else if (diff < 0)
                (§
                    queueOnCoinsSent(tx, prevBalance, newBalance);
                )
            )
            checkBalanceFuturesLocked(newBalance);
        )

        informConfidenceListenersIfNotReorganizing();
        isConsistentOrThrow();
        ;; Optimization for the case where a block has tons of relevant transactions.
        saveLater();
        hardSaveOnNextBlock = true;
    )

    ;;; Finds if tx is NOT spending other txns which are in the specified confidence type. ;;
#_private
    boolean isNotSpendingTxnsInConfidenceType(Transaction tx, ConfidenceType confidenceType)
    (§
        for (TransactionInput txInput : tx.getInputs())
        (§
            Transaction connectedTx = this.getTransaction(txInput.getOutpoint().getHash());
            if (connectedTx != nil && connectedTx.getConfidence().getConfidenceType().equals(confidenceType))
                return false;
        )
        return true;
    )

    ;;;
     ; Creates and returns a new List with the same txns as inputSet, but txns are sorted by depencency
     ; (a topological sort).  If tx B spends tx A, then tx A should be before tx B on the returned List.
     ; Several invocations to this method with the same inputSet could result in lists with txns in different
     ; order, as there is no guarantee on the order of the returned txns besides what was already stated.
     ;;
    List<Transaction> sortTxnsByDependency(Set<Transaction> inputSet)
    (§
        ArrayList<Transaction> result = new ArrayList<>(inputSet);
        for (int i = 0; i < result.size() - 1; i++)
        (§
            boolean txAtISpendsOtherTxInTheList;
            do
            (§
                txAtISpendsOtherTxInTheList = false;
                for (int j = i + 1; j < result.size(); j++)
                (§
                    if (spends(result.get(i), result.get(j)))
                    (§
                        Transaction transactionAtI = result.remove(i);
                        result.add(j, transactionAtI);
                        txAtISpendsOtherTxInTheList = true;
                        break;
                    )
                )
            )
            while (txAtISpendsOtherTxInTheList);
        )
        return result;
    )

    ;;; Finds whether txA spends txB. ;;
    boolean spends(Transaction txA, Transaction txB)
    (§
        for (TransactionInput txInput : txA.getInputs())
            if (txInput.getOutpoint().getHash().equals(txB.getHash()))
                return true;

        return false;
    )

#_private
    void informConfidenceListenersIfNotReorganizing()
    (§
        if (insideReorg)
            return;

        for (Map.Entry<Transaction, TransactionConfidence.Listener.ChangeReason> entry : confidenceChanged.entrySet())
        (§
#_final
            Transaction tx = entry.getKey();
            tx.getConfidence().queueListeners(entry.getValue());
            queueOnTransactionConfidenceChanged(tx);
        )
        confidenceChanged.clear();
    )

    ;;;
     ; Called by the {@link BlockChain} when a new block on the best chain is seen, AFTER relevant wallet
     ; transactions are extracted and sent to us UNLESS the new block caused a re-org, in which case this will
     ; not be called (the {@link Wallet#reorganize(StoredBlock, java.util.List, java.util.List)} method will
     ; call this one in that case).
     ;
     ; Used to update confidence data in each transaction and last seen block hash.  Triggers auto saving.
     ; Invokes the onWalletChanged event listener if there were any affected transactions.
     ;;
#_override
#_public
    void notifyNewBestBlock(StoredBlock block)
        throws VerificationException
    (§
        ;; Check to see if this block has been seen before.
        Sha256Hash newBlockHash = block.getHeader().getHash();
        if (newBlockHash.equals(getLastBlockSeenHash()))
            return;

        lock.lock();
        try
        (§
            ;; Store the new block hash.
            setLastBlockSeenHash(newBlockHash);
            setLastBlockSeenHeight(block.getHeight());
            setLastBlockSeenTimeSecs(block.getHeader().getTimeSeconds());
            ;; Notify all the BUILDING transactions of the new block.
            ;; This is so that they can update their depth.
            Set<Transaction> transactions = getTransactions(true);
            for (Transaction tx : transactions)
            (§
                if (ignoreNextNewBlock.contains(tx.getHash()))
                (§
                    ;; tx was already processed in receive() due to it appearing in this block, so we don't want
                    ;; to increment the tx confidence depth twice, it'd result in miscounting.
                    ignoreNextNewBlock.remove(tx.getHash());
                )
                else
                (§
                    TransactionConfidence confidence = tx.getConfidence();
                    if (confidence.getConfidenceType() == ConfidenceType.BUILDING)
                    (§
                        ;; Erase the set of seen peers once the tx is so deep that it seems unlikely to ever go
                        ;; pending again.  We could clear this data the moment a tx is seen in the block chain,
                        ;; but in cases where the chain re-orgs, this would mean that wallets would perceive a
                        ;; newly pending tx has zero confidence at all, which would not be right: we expect it to
                        ;; be included once again.  We could have a separate was-in-chain-and-now-isn't confidence
                        ;; type, but this way is backwards compatible with existing software, and the new state
                        ;; probably wouldn't mean anything different to just remembering peers anyway.
                        if (context.getEventHorizon() < confidence.incrementDepthInBlocks())
                            confidence.clearBroadcastBy();
                        confidenceChanged.put(tx, TransactionConfidence.Listener.ChangeReason.DEPTH);
                    )
                )
            )

            informConfidenceListenersIfNotReorganizing();
            maybeQueueOnWalletChanged();

            if (hardSaveOnNextBlock)
            (§
                saveNow();
                hardSaveOnNextBlock = false;
            )
            else
            (§
                ;; Coalesce writes to avoid throttling on disk access when catching up with the chain.
                saveLater();
            )
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Handle when a transaction becomes newly active on the best chain, either due to receiving a new block or a
     ; re-org.  Places the tx into the right pool, handles coinbase transactions, handles double-spends and so on.
     ;;
#_private
    void processTxFromBestChain(Transaction tx, boolean forceAddToPool)
        throws VerificationException
    (§
        Preconditions.checkState(lock.isHeldByCurrentThread());
        Preconditions.checkState(!pending.containsKey(tx.getHash()));

        ;; This TX may spend our existing outputs even though it was not pending.  This can happen in unit tests,
        ;; if keys are moved between wallets, if we're catching up to the chain given only a set of keys,
        ;; or if a dead coinbase transaction has moved back onto the main chain.
        boolean isDeadCoinbase = (tx.isCoinBase() && dead.containsKey(tx.getHash()));
        if (isDeadCoinbase)
        (§
            ;; There is a dead coinbase tx being received on the best chain.  A coinbase tx is made dead when it moves
            ;; to a side chain but it can be switched back on a reorg and resurrected back to spent or unspent.
            ;; So take it out of the dead pool.  Note that we don't resurrect dependent transactions here, even though
            ;; we could.  Bitcoin Core nodes on the network have deleted the dependent transactions from their mempools
            ;; entirely by this point.  We could and maybe should rebroadcast them so the network remembers and tries
            ;; to confirm them again.  But this is a deeply unusual edge case that due to the maturity rule should never
            ;; happen in practice, thus for simplicities sake we ignore it here.
            log.info("  coinbase tx <-dead: confidence {}", tx.getHashAsString(), tx.getConfidence().getConfidenceType().name());
            dead.remove(tx.getHash());
        )

        ;; Update tx and other unspent/pending transactions by connecting inputs/outputs.
        updateForSpends(tx, true);

        ;; Now make sure it ends up in the right pool.  Also, handle the case where this TX is double-spending
        ;; against our pending transactions.  Note that a tx may double spend our pending transactions and also
        ;; send us money/spend our money.
        boolean hasOutputsToMe = (0 < tx.getValueSentToMe(this).signum());
        boolean hasOutputsFromMe = false;
        if (hasOutputsToMe)
        (§
            ;; Needs to go into either unspent or spent (if the outputs were already spent by a pending tx).
            if (tx.isEveryOwnedOutputSpent(this))
            (§
                log.info("  tx {} ->spent (by pending)", tx.getHashAsString());
                addWalletTransaction(Pool.SPENT, tx);
            )
            else
            (§
                log.info("  tx {} ->unspent", tx.getHashAsString());
                addWalletTransaction(Pool.UNSPENT, tx);
            )
        )
        else if (0 < tx.getValueSentFromMe(this).signum())
        (§
            hasOutputsFromMe = true;
            ;; Didn't send us any money, but did spend some.  Keep it around for record keeping purposes.
            log.info("  tx {} ->spent", tx.getHashAsString());
            addWalletTransaction(Pool.SPENT, tx);
        )
        else if (forceAddToPool)
        (§
            ;; Was manually added to pending, so we should keep it to notify the user of confidence information.
            log.info("  tx {} ->spent (manually added)", tx.getHashAsString());
            addWalletTransaction(Pool.SPENT, tx);
        )

        ;; Kill txns in conflict with this tx.
        Set<Transaction> doubleSpendTxns = findDoubleSpendsAgainst(tx, pending);
        if (!doubleSpendTxns.isEmpty())
        (§
            ;; No need to addTransactionsDependingOn(doubleSpendTxns), because killTxns() already kills dependencies.
            killTxns(doubleSpendTxns, tx);
        )
        if (!hasOutputsToMe && !hasOutputsFromMe && !forceAddToPool && !findDoubleSpendsAgainst(tx, transactions).isEmpty())
        (§
            ;; Disconnect irrelevant inputs (otherwise might cause protobuf serialization issue).
            for (TransactionInput input : tx.getInputs())
            (§
                TransactionOutput output = input.getConnectedOutput();
                if (output != nil && !output.isMine(this))
                    input.disconnect();
            )
        )
    )

    ;;;
     ; <p>Updates the wallet by checking if this TX spends any of our outputs, and marking them as spent if so.
     ; If fromChain is true, also checks to see if any pending transaction spends outputs of this transaction and marks
     ; the spent flags appropriately.</p>
     ;
     ; <p>It can be called in two contexts.  One is when we receive a transaction on the best chain but it wasn't pending,
     ; this most commonly happens when we have a set of keys but the wallet transactions were wiped and we are catching
     ; up with the block chain.  It can also happen if a block includes a transaction we never saw at broadcast time.
     ; If this tx double spends, it takes precedence over our pending transactions and the pending tx goes dead.</p>
     ;
     ; <p>The other context it can be called is from {@link Wallet#receivePending(Transaction, java.util.List)},
     ; i.e. we saw a tx be broadcast or one was submitted directly that spends our own coins.  If this tx double spends,
     ; it does NOT take precedence because the winner will be resolved by the miners - we assume that our version will
     ; win, if we are wrong then when a block appears the tx will go dead.</p>
     ;
     ; @param tx The transaction which is being updated.
     ; @param fromChain If true, the tx appeared on the current best chain, if false it was pending.
     ;;
#_private
    void updateForSpends(Transaction tx, boolean fromChain)
        throws VerificationException
    (§
        Preconditions.checkState(lock.isHeldByCurrentThread());
        if (fromChain)
            Preconditions.checkState(!pending.containsKey(tx.getHash()));

        for (TransactionInput input : tx.getInputs())
        (§
            TransactionInput.ConnectionResult result = input.connect(unspent, TransactionInput.ConnectMode.ABORT_ON_CONFLICT);
            if (result == TransactionInput.ConnectionResult.NO_SUCH_TX)
            (§
                ;; Not found in the unspent map.  Try again with the spent map.
                result = input.connect(spent, TransactionInput.ConnectMode.ABORT_ON_CONFLICT);
                if (result == TransactionInput.ConnectionResult.NO_SUCH_TX)
                (§
                    ;; Not found in the unspent and spent maps.  Try again with the pending map.
                    result = input.connect(pending, TransactionInput.ConnectMode.ABORT_ON_CONFLICT);
                    if (result == TransactionInput.ConnectionResult.NO_SUCH_TX)
                    (§
                        ;; Doesn't spend any of our outputs or is coinbase.
                        continue;
                    )
                )
            )

            TransactionOutput output = Preconditions.checkNotNull(input.getConnectedOutput());
            if (result == TransactionInput.ConnectionResult.ALREADY_SPENT)
            (§
                if (fromChain)
                (§
                    ;; Can be:
                    ;; (1) We already marked this output as spent when we saw the pending transaction (most likely).
                    ;;     Now it's being confirmed of course, we cannot mark it as spent again.
                    ;; (2) A double spend from chain: this will be handled later by findDoubleSpendsAgainst()/killTxns().
                    ;;
                    ;; In any case, nothing to do here.
                )
                else
                (§
                    ;; We saw two pending transactions that double spend each other.  We don't know which will win.
                    ;; This can happen in the case of bad network nodes that mutate transactions.  Do a hex dump
                    ;; so the exact nature of the mutation can be examined.
                    log.warn("Saw two pending transactions double spend each other");
                    log.warn("  offending input is input {}", tx.getInputs().indexOf(input));
                    log.warn("{}: {}", tx.getHash(), Utils.HEX.encode(tx.unsafeBitcoinSerialize()));
                    Transaction other = output.getSpentBy().getParentTransaction();
                    log.warn("{}: {}", other.getHash(), Utils.HEX.encode(other.unsafeBitcoinSerialize()));
                )
            )
            else if (result == TransactionInput.ConnectionResult.SUCCESS)
            (§
                ;; Otherwise we saw a transaction spend our coins, but we didn't try and spend them ourselves yet.
                ;; The outputs are already marked as spent by the connect call above, so check if there are any more for
                ;; us to use.  Move if not.
                Transaction connected = Preconditions.checkNotNull(input.getConnectedTransaction());
                log.info("  marked {} as spent by {}", input.getOutpoint(), tx.getHashAsString());
                maybeMovePool(connected, "prevtx");
                ;; Just because it's connected, doesn't mean it's actually ours: sometimes we have total visibility.
                if (output.isMine(this))
                    Preconditions.checkState(myUnspents.remove(output));
            )
        )

        ;; Now check each output and see if there is a pending transaction which spends it.  This shouldn't normally
        ;; ever occur because we expect transactions to arrive in temporal order, but this assumption can be violated
        ;; when we receive a pending transaction from the mempool that is relevant to us, which spends coins that we
        ;; didn't see arrive on the best chain yet.  For instance, because of a chain replay or because of our keys were
        ;; used by another wallet somewhere else.  Also, unconfirmed transactions can arrive from the mempool in more
        ;; or less random order.
        for (Transaction pendingTx : pending.values())
        (§
            for (TransactionInput input : pendingTx.getInputs())
            (§
                TransactionInput.ConnectionResult result = input.connect(tx, TransactionInput.ConnectMode.ABORT_ON_CONFLICT);
                if (fromChain)
                (§
                    ;; This TX is supposed to have just appeared on the best chain, so its outputs should not be marked
                    ;; as spent yet.  If they are, it means something is happening out of order.
                    Preconditions.checkState(result != TransactionInput.ConnectionResult.ALREADY_SPENT);
                )
                if (result == TransactionInput.ConnectionResult.SUCCESS)
                (§
                    log.info("Connected pending tx input {}:{}", pendingTx.getHashAsString(), pendingTx.getInputs().indexOf(input));
                    ;; The unspents map might not have it if we never saw this tx until it was included in the chain
                    ;; and thus becomes spent the moment we become aware of it.
                    if (myUnspents.remove(input.getConnectedOutput()))
                        log.info("Removed from UNSPENTS: {}", input.getConnectedOutput());
                )
            )
        )
        if (!fromChain)
        (§
            maybeMovePool(tx, "pendingtx");
        )
        else
        (§
            ;; If the transactions outputs are now all spent, it will be moved into the spent pool by the
            ;; processTxFromBestChain method.
        )
    )

    ;; Updates the wallet when a double spend occurs.  overridingTx can be null for the case of coinbases.
#_private
    void killTxns(Set<Transaction> txnsToKill, #_nilable Transaction overridingTx)
    (§
        LinkedList<Transaction> work = new LinkedList<>(txnsToKill);
        while (!work.isEmpty())
        (§
#_final
            Transaction tx = work.poll();
            log.warn("TX {} killed{}", tx.getHashAsString(), (overridingTx != nil) ? " by " + overridingTx.getHashAsString() : "");
            log.warn("Disconnecting each input and moving connected transactions.");
            ;; TX could be pending (finney attack), or in unspent/spent (coinbase killed by reorg).
            pending.remove(tx.getHash());
            unspent.remove(tx.getHash());
            spent.remove(tx.getHash());
            addWalletTransaction(Pool.DEAD, tx);
            for (TransactionInput deadInput : tx.getInputs())
            (§
                Transaction connected = deadInput.getConnectedTransaction();
                if (connected == nil)
                    continue;
                if (connected.getConfidence().getConfidenceType() != ConfidenceType.DEAD && deadInput.getConnectedOutput().getSpentBy() != nil && deadInput.getConnectedOutput().getSpentBy().equals(deadInput))
                (§
                    Preconditions.checkState(myUnspents.add(deadInput.getConnectedOutput()));
                    log.info("Added to UNSPENTS: {} in {}", deadInput.getConnectedOutput(), deadInput.getConnectedOutput().getParentTransaction().getHash());
                )
                deadInput.disconnect();
                maybeMovePool(connected, "kill");
            )
            tx.getConfidence().setOverridingTransaction(overridingTx);
            confidenceChanged.put(tx, TransactionConfidence.Listener.ChangeReason.TYPE);
            ;; Now kill any transactions we have that depended on this one.
            for (TransactionOutput deadOutput : tx.getOutputs())
            (§
                if (myUnspents.remove(deadOutput))
                    log.info("XX Removed from UNSPENTS: {}", deadOutput);
                TransactionInput connected = deadOutput.getSpentBy();
                if (connected == nil)
                    continue;
#_final
                Transaction parentTransaction = connected.getParentTransaction();
                log.info("This death invalidated dependent tx {}", parentTransaction.getHash());
                work.push(parentTransaction);
            )
        )
        if (overridingTx == nil)
            return;

        log.warn("Now attempting to connect the inputs of the overriding transaction.");
        for (TransactionInput input : overridingTx.getInputs())
        (§
            TransactionInput.ConnectionResult result = input.connect(unspent, TransactionInput.ConnectMode.DISCONNECT_ON_CONFLICT);
            if (result == TransactionInput.ConnectionResult.SUCCESS)
            (§
                maybeMovePool(input.getConnectedTransaction(), "kill");
                myUnspents.remove(input.getConnectedOutput());
                log.info("Removing from UNSPENTS: {}", input.getConnectedOutput());
            )
            else
            (§
                result = input.connect(spent, TransactionInput.ConnectMode.DISCONNECT_ON_CONFLICT);
                if (result == TransactionInput.ConnectionResult.SUCCESS)
                (§
                    maybeMovePool(input.getConnectedTransaction(), "kill");
                    myUnspents.remove(input.getConnectedOutput());
                    log.info("Removing from UNSPENTS: {}", input.getConnectedOutput());
                )
            )
        )
    )

    ;;;
     ; If the transactions outputs are all marked as spent, and it's in the unspent map, move it.
     ; If the owned transactions outputs are not all marked as spent, and it's in the spent map, move it.
     ;;
#_private
    void maybeMovePool(Transaction tx, String context)
    (§
        Preconditions.checkState(lock.isHeldByCurrentThread());

        if (tx.isEveryOwnedOutputSpent(this))
        (§
            ;; There's nothing left I can spend in this transaction.
            if (unspent.remove(tx.getHash()) != nil)
            (§
                if (log.isInfoEnabled())
                    log.info("  {} {} <-unspent ->spent", tx.getHashAsString(), context);
                spent.put(tx.getHash(), tx);
            )
        )
        else
        (§
            if (spent.remove(tx.getHash()) != nil)
            (§
                if (log.isInfoEnabled())
                    log.info("  {} {} <-spent ->unspent", tx.getHashAsString(), context);
                unspent.put(tx.getHash(), tx);
            )
        )
    )

    ;;;
     ; Calls {@link Wallet#commitTx} if tx is not already in the pending pool.
     ;
     ; @return true if the tx was added to the wallet, or false if it was already in the pending pool.
     ;;
#_public
    boolean maybeCommitTx(Transaction tx)
        throws VerificationException
    (§
        tx.verify();
        lock.lock();
        try
        (§
            if (pending.containsKey(tx.getHash()))
                return false;

            log.info("commitTx of {}", tx.getHashAsString());
            Coin balance = getBalance();
            tx.setUpdateTime(Utils.now());
            ;; Put any outputs that are sending money back to us into the unspents map, and calculate their total value.
            Coin valueSentToMe = Coin.ZERO;
            for (TransactionOutput o : tx.getOutputs())
            (§
                if (o.isMine(this))
                    valueSentToMe = valueSentToMe.add(o.getValue());
            )
            ;; Mark the outputs we're spending as spent so we won't try and use them in future creations.  This will also
            ;; move any transactions that are now fully spent to the spent map so we can skip them when creating future
            ;; spends.
            updateForSpends(tx, false);

            Set<Transaction> doubleSpendPendingTxns = findDoubleSpendsAgainst(tx, pending);
            Set<Transaction> doubleSpendUnspentTxns = findDoubleSpendsAgainst(tx, unspent);
            Set<Transaction> doubleSpendSpentTxns = findDoubleSpendsAgainst(tx, spent);

            if (!doubleSpendUnspentTxns.isEmpty() || !doubleSpendSpentTxns.isEmpty() || !isNotSpendingTxnsInConfidenceType(tx, ConfidenceType.DEAD))
            (§
                ;; tx is a double spend against a tx already in the best chain or spends outputs of a DEAD tx.
                ;; Add tx to the dead pool and schedule confidence listener notifications.
                log.info("->dead: {}", tx.getHashAsString());
                tx.getConfidence().setConfidenceType(ConfidenceType.DEAD);
                confidenceChanged.put(tx, TransactionConfidence.Listener.ChangeReason.TYPE);
                addWalletTransaction(Pool.DEAD, tx);
            )
            else if (!doubleSpendPendingTxns.isEmpty() || !isNotSpendingTxnsInConfidenceType(tx, ConfidenceType.IN_CONFLICT))
            (§
                ;; tx is a double spend against a pending tx or spends outputs of a tx already IN_CONFLICT.
                ;; Add tx to the pending pool.  Update the confidence type of tx, the txns in conflict with tx
                ;; and all their dependencies to IN_CONFLICT and schedule confidence listener notifications.
                log.info("->pending (IN_CONFLICT): {}", tx.getHashAsString());
                addWalletTransaction(Pool.PENDING, tx);
                doubleSpendPendingTxns.add(tx);
                addTransactionsDependingOn(doubleSpendPendingTxns, getTransactions(true));
                for (Transaction doubleSpendTx : doubleSpendPendingTxns)
                (§
                    doubleSpendTx.getConfidence().setConfidenceType(ConfidenceType.IN_CONFLICT);
                    confidenceChanged.put(doubleSpendTx, TransactionConfidence.Listener.ChangeReason.TYPE);
                )
            )
            else
            (§
                ;; No conflict detected.
                ;; Add to the pending pool and schedule confidence listener notifications.
                log.info("->pending: {}", tx.getHashAsString());
                tx.getConfidence().setConfidenceType(ConfidenceType.PENDING);
                confidenceChanged.put(tx, TransactionConfidence.Listener.ChangeReason.TYPE);
                addWalletTransaction(Pool.PENDING, tx);
            )
            if (log.isInfoEnabled())
                log.info("Estimated balance is now: {}", getBalance(BalanceType.ESTIMATED).toFriendlyString());

            ;; Mark any keys used in the outputs as "used", this allows wallet UI's to auto-advance the current key
            ;; they are showing to the user in qr codes etc.
            markKeysAsUsed(tx);
            try
            (§
                Coin valueSentFromMe = tx.getValueSentFromMe(this);
                Coin newBalance = balance.add(valueSentToMe).subtract(valueSentFromMe);
                if (0 < valueSentToMe.signum())
                (§
                    checkBalanceFuturesLocked(nil);
                    queueOnCoinsReceived(tx, balance, newBalance);
                )
                if (0 < valueSentFromMe.signum())
                    queueOnCoinsSent(tx, balance, newBalance);

                maybeQueueOnWalletChanged();
            )
            catch (ScriptException e)
            (§
                ;; Cannot happen as we just created this transaction ourselves.
                throw new RuntimeException(e);
            )

            isConsistentOrThrow();
            informConfidenceListenersIfNotReorganizing();
            saveNow();
        )
        finally
        (§
            lock.unlock();
        )
        return true;
    )

    ;;;
     ; <p>Updates the wallet with the given transaction: puts it into the pending pool, sets the spent flags
     ; and runs the onCoinsSent/onCoinsReceived event listener.  Used in two situations:</p>
     ;
     ; <ol>
     ;     <li>When we have just successfully transmitted the tx we created to the network.</li>
     ;     <li>When we receive a pending transaction that didn't appear in the chain yet, and we did not create it.</li>
     ; </ol>
     ;
     ; <p>Triggers an auto save.</p>
     ;;
#_public
    void commitTx(Transaction tx)
        throws VerificationException
    (§
        Preconditions.checkArgument(maybeCommitTx(tx), "commitTx called on the same transaction twice");
    )

    ;;;
     ; Adds an event listener object.  Methods on this object are called when something interesting happens,
     ; like receiving money.  Runs the listener methods in the user thread.
     ;;
#_public
    void addChangeEventListener(WalletChangeEventListener listener)
    (§
        addChangeEventListener(Threading.USER_THREAD, listener);
    )

    ;;;
     ; Adds an event listener object.  Methods on this object are called when something interesting happens,
     ; like receiving money.  The listener is executed by the given executor.
     ;;
#_public
    void addChangeEventListener(Executor executor, WalletChangeEventListener listener)
    (§
        ;; This is thread safe, so we don't need to take the lock.
        changeListeners.add(new ListenerRegistration<>(listener, executor));
    )

    ;;;
     ; Adds an event listener object called when coins are received.
     ; Runs the listener methods in the user thread.
     ;;
#_public
    void addCoinsReceivedEventListener(WalletCoinsReceivedEventListener listener)
    (§
        addCoinsReceivedEventListener(Threading.USER_THREAD, listener);
    )

    ;;;
     ; Adds an event listener object called when coins are received.
     ; The listener is executed by the given executor.
     ;;
#_public
    void addCoinsReceivedEventListener(Executor executor, WalletCoinsReceivedEventListener listener)
    (§
        ;; This is thread safe, so we don't need to take the lock.
        coinsReceivedListeners.add(new ListenerRegistration<>(listener, executor));
    )

    ;;;
     ; Adds an event listener object called when coins are sent.
     ; Runs the listener methods in the user thread.
     ;;
#_public
    void addCoinsSentEventListener(WalletCoinsSentEventListener listener)
    (§
        addCoinsSentEventListener(Threading.USER_THREAD, listener);
    )

    ;;;
     ; Adds an event listener object called when coins are sent.
     ; The listener is executed by the given executor.
     ;;
#_public
    void addCoinsSentEventListener(Executor executor, WalletCoinsSentEventListener listener)
    (§
        ;; This is thread safe, so we don't need to take the lock.
        coinsSentListeners.add(new ListenerRegistration<>(listener, executor));
    )

    ;;;
     ; Adds an event listener object.  Methods on this object are called when keys are
     ; added.  The listener is executed in the user thread.
     ;;
#_public
    void addKeyChainEventListener(KeyChainEventListener listener)
    (§
        keyChainGroup.addEventListener(listener, Threading.USER_THREAD);
    )

    ;;;
     ; Adds an event listener object.  Methods on this object are called when keys are
     ; added.  The listener is executed by the given executor.
     ;;
#_public
    void addKeyChainEventListener(Executor executor, KeyChainEventListener listener)
    (§
        keyChainGroup.addEventListener(listener, executor);
    )

    ;;;
     ; Adds an event listener object.  Methods on this object are called when something interesting happens,
     ; like receiving money.  Runs the listener methods in the user thread.
     ;;
#_public
    void addReorganizeEventListener(WalletReorganizeEventListener listener)
    (§
        addReorganizeEventListener(Threading.USER_THREAD, listener);
    )

    ;;;
     ; Adds an event listener object.  Methods on this object are called when something interesting happens,
     ; like receiving money.  The listener is executed by the given executor.
     ;;
#_public
    void addReorganizeEventListener(Executor executor, WalletReorganizeEventListener listener)
    (§
        ;; This is thread safe, so we don't need to take the lock.
        reorganizeListeners.add(new ListenerRegistration<>(listener, executor));
    )

    ;;;
     ; Adds an event listener object.  Methods on this object are called when confidence
     ; of a transaction changes.  Runs the listener methods in the user thread.
     ;;
#_public
    void addTransactionConfidenceEventListener(TransactionConfidenceEventListener listener)
    (§
        addTransactionConfidenceEventListener(Threading.USER_THREAD, listener);
    )

    ;;;
     ; Adds an event listener object.  Methods on this object are called when confidence
     ; of a transaction changes.  The listener is executed by the given executor.
     ;;
#_public
    void addTransactionConfidenceEventListener(Executor executor, TransactionConfidenceEventListener listener)
    (§
        ;; This is thread safe, so we don't need to take the lock.
        transactionConfidenceListeners.add(new ListenerRegistration<>(listener, executor));
    )

    ;;;
     ; Removes the given event listener object.  Returns true if the listener was removed,
     ; false if that listener was never added.
     ;;
#_public
    boolean removeChangeEventListener(WalletChangeEventListener listener)
    (§
        return ListenerRegistration.removeFromList(listener, changeListeners);
    )

    ;;;
     ; Removes the given event listener object.  Returns true if the listener was removed,
     ; false if that listener was never added.
     ;;
#_public
    boolean removeCoinsReceivedEventListener(WalletCoinsReceivedEventListener listener)
    (§
        return ListenerRegistration.removeFromList(listener, coinsReceivedListeners);
    )

    ;;;
     ; Removes the given event listener object.  Returns true if the listener was removed,
     ; false if that listener was never added.
     ;;
#_public
    boolean removeCoinsSentEventListener(WalletCoinsSentEventListener listener)
    (§
        return ListenerRegistration.removeFromList(listener, coinsSentListeners);
    )

    ;;;
     ; Removes the given event listener object.  Returns true if the listener was removed,
     ; false if that listener was never added.
     ;;
#_public
    boolean removeKeyChainEventListener(KeyChainEventListener listener)
    (§
        return keyChainGroup.removeEventListener(listener);
    )

    ;;;
     ; Removes the given event listener object.  Returns true if the listener was removed,
     ; false if that listener was never added.
     ;;
#_public
    boolean removeReorganizeEventListener(WalletReorganizeEventListener listener)
    (§
        return ListenerRegistration.removeFromList(listener, reorganizeListeners);
    )

    ;;;
     ; Removes the given event listener object.  Returns true if the listener was removed,
     ; false if that listener was never added.
     ;;
#_public
    boolean removeTransactionConfidenceEventListener(TransactionConfidenceEventListener listener)
    (§
        return ListenerRegistration.removeFromList(listener, transactionConfidenceListeners);
    )

#_private
    void queueOnTransactionConfidenceChanged(final Transaction tx)
    (§
        Preconditions.checkState(lock.isHeldByCurrentThread());

        for (final ListenerRegistration<TransactionConfidenceEventListener> registration : transactionConfidenceListeners)
        (§
            if (registration.executor == Threading.SAME_THREAD)
            (§
                registration.listener.onTransactionConfidenceChanged(this, tx);
            )
            else
            (§
                registration.executor.execute(new Runnable()
                (§
#_override
#_public
                    void run()
                    (§
                        registration.listener.onTransactionConfidenceChanged(Wallet.this, tx);
                    )
                ));
            )
        )
    )

#_protected
    void maybeQueueOnWalletChanged()
    (§
        ;; Don't invoke the callback in some circumstances, e.g. whilst we are re-organizing or fiddling
        ;; with transactions due to a new block arriving.  It will be called later instead.
        Preconditions.checkState(lock.isHeldByCurrentThread());
        Preconditions.checkState(0 <= onWalletChangedSuppressions);

        if (0 < onWalletChangedSuppressions)
            return;

        for (final ListenerRegistration<WalletChangeEventListener> registration : changeListeners)
        (§
            registration.executor.execute(new Runnable()
            (§
#_override
#_public
                void run()
                (§
                    registration.listener.onWalletChanged(Wallet.this);
                )
            ));
        )
    )

#_protected
    void queueOnCoinsReceived(final Transaction tx, final Coin balance, final Coin newBalance)
    (§
        Preconditions.checkState(lock.isHeldByCurrentThread());

        for (final ListenerRegistration<WalletCoinsReceivedEventListener> registration : coinsReceivedListeners)
        (§
            registration.executor.execute(new Runnable()
            (§
#_override
#_public
                void run()
                (§
                    registration.listener.onCoinsReceived(Wallet.this, tx, balance, newBalance);
                )
            ));
        )
    )

#_protected
    void queueOnCoinsSent(final Transaction tx, final Coin prevBalance, final Coin newBalance)
    (§
        Preconditions.checkState(lock.isHeldByCurrentThread());

        for (final ListenerRegistration<WalletCoinsSentEventListener> registration : coinsSentListeners)
        (§
            registration.executor.execute(new Runnable()
            (§
#_override
#_public
                void run()
                (§
                    registration.listener.onCoinsSent(Wallet.this, tx, prevBalance, newBalance);
                )
            ));
        )
    )

#_protected
    void queueOnReorganize()
    (§
        Preconditions.checkState(lock.isHeldByCurrentThread());
        Preconditions.checkState(insideReorg);

        for (final ListenerRegistration<WalletReorganizeEventListener> registration : reorganizeListeners)
        (§
            registration.executor.execute(new Runnable()
            (§
#_override
#_public
                void run()
                (§
                    registration.listener.onReorganize(Wallet.this);
                )
            ));
        )
    )

    ;;;
     ; Returns a set of all transactions in the wallet.
     ; @param includeDead If true, transactions that were overridden by a double spend are included.
     ;;
#_public
    Set<Transaction> getTransactions(boolean includeDead)
    (§
        lock.lock();
        try
        (§
            Set<Transaction> all = new HashSet<>();
            all.addAll(unspent.values());
            all.addAll(spent.values());
            all.addAll(pending.values());
            if (includeDead)
                all.addAll(dead.values());
            return all;
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Returns a set of all WalletTransactions in the wallet.
     ;;
#_public
    Iterable<WalletTransaction> getWalletTransactions()
    (§
        lock.lock();
        try
        (§
            Set<WalletTransaction> all = new HashSet<>();
            addWalletTransactionsToSet(all, Pool.UNSPENT, unspent.values());
            addWalletTransactionsToSet(all, Pool.SPENT, spent.values());
            addWalletTransactionsToSet(all, Pool.DEAD, dead.values());
            addWalletTransactionsToSet(all, Pool.PENDING, pending.values());
            return all;
        )
        finally
        (§
            lock.unlock();
        )
    )

#_private
#_static
    void addWalletTransactionsToSet(Set<WalletTransaction> txns, Pool poolType, Collection<Transaction> pool)
    (§
        for (Transaction tx : pool)
            txns.add(new WalletTransaction(poolType, tx));
    )

    ;;;
     ; Adds a transaction that has been associated with a particular wallet pool.  This is intended for usage by
     ; deserialization code, such as the {@link WalletProtobufSerializer} class.  It isn't normally useful for
     ; applications.  It does not trigger auto saving.
     ;;
#_public
    void addWalletTransaction(WalletTransaction wtx)
    (§
        lock.lock();
        try
        (§
            addWalletTransaction(wtx.getPool(), wtx.getTransaction());
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Adds the given transaction to the given pools and registers a confidence change listener on it.
     ;;
#_private
    void addWalletTransaction(Pool pool, Transaction tx)
    (§
        Preconditions.checkState(lock.isHeldByCurrentThread());

        transactions.put(tx.getHash(), tx);
        switch (pool)
        (§
        case UNSPENT:
            Preconditions.checkState(unspent.put(tx.getHash(), tx) == nil);
            break;
        case SPENT:
            Preconditions.checkState(spent.put(tx.getHash(), tx) == nil);
            break;
        case PENDING:
            Preconditions.checkState(pending.put(tx.getHash(), tx) == nil);
            break;
        case DEAD:
            Preconditions.checkState(dead.put(tx.getHash(), tx) == nil);
            break;
        default:
            throw new RuntimeException("Unknown wallet transaction type " + pool);
        )

        if (pool == Pool.UNSPENT || pool == Pool.PENDING)
        (§
            for (TransactionOutput output : tx.getOutputs())
                if (output.isAvailableForSpending() && output.isMine(this))
                    myUnspents.add(output);
        )
        ;; This is safe even if the listener has been added before, as TransactionConfidence ignores duplicate
        ;; registration requests.  That makes the code in the wallet simpler.
        tx.getConfidence().addEventListener(Threading.SAME_THREAD, txConfidenceListener);
    )

    ;;;
     ; Returns all non-dead, active transactions ordered by recency.
     ;;
#_public
    List<Transaction> getTransactionsByTime()
    (§
        return getRecentTransactions(0, false);
    )

    ;;;
     ; Returns an list of N transactions, ordered by increasing age.  Transactions on side chains are not included.
     ; Dead transactions (overridden by double spends) are optionally included.
     ;
     ; Note: the current implementation is O(num transactions in wallet).  Regardless of how many transactions are
     ; requested, the cost is always the same.  In future, requesting smaller numbers of transactions may be faster
     ; depending on how the wallet is implemented (e.g. if backed by a database).
     ;;
#_public
    List<Transaction> getRecentTransactions(int numTransactions, boolean includeDead)
    (§
        lock.lock();
        try
        (§
            Preconditions.checkArgument(0 <= numTransactions);

            ;; Firstly, put all transactions into an array.
            int size = unspent.size() + spent.size() + pending.size();
            if (size < numTransactions || numTransactions == 0)
                numTransactions = size;

            ArrayList<Transaction> all = new ArrayList<>(getTransactions(includeDead));
            ;; Order by update time.
            Collections.sort(all, Transaction.SORT_TX_BY_UPDATE_TIME);
            if (numTransactions == all.size())
                return all;

            all.subList(numTransactions, all.size()).clear();
            return all;
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Returns a transaction object given its hash, if it exists in this wallet, or null otherwise.
     ;;
#_nilable
#_public
    Transaction getTransaction(Sha256Hash hash)
    (§
        lock.lock();
        try
        (§
            return transactions.get(hash);
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;; {@inheritDoc} ;;
#_override
#_public
    Map<Sha256Hash, Transaction> getTransactionPool(Pool pool)
    (§
        lock.lock();
        try
        (§
            switch (pool)
            (§
                case UNSPENT:
                    return unspent;
                case SPENT:
                    return spent;
                case PENDING:
                    return pending;
                case DEAD:
                    return dead;
                default:
                    throw new RuntimeException("Unknown wallet transaction type " + pool);
            )
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Prepares the wallet for a blockchain replay.  Removes all transactions (as they would
     ; get in the way of the replay) and makes the wallet think it has never seen a block.
     ;;
#_public
    void reset()
    (§
        lock.lock();
        try
        (§
            clearTransactions();
            lastBlockSeenHash = nil;
            lastBlockSeenHeight = -1; ;; Magic value for 'never'.
            lastBlockSeenTimeSecs = 0;
            saveLater();
            maybeQueueOnWalletChanged();
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Deletes transactions which appeared above the given block height from the wallet, but does not touch the keys.
     ; This is useful if you have some keys and wish to replay the block chain into the wallet in order to pick them up.
     ; Triggers auto saving.
     ;;
#_public
    void clearTransactions(int fromHeight)
    (§
        lock.lock();
        try
        (§
            if (fromHeight == 0)
            (§
                clearTransactions();
                saveLater();
            )
            else
            (§
                throw new UnsupportedOperationException();
            )
        )
        finally
        (§
            lock.unlock();
        )
    )

#_private
    void clearTransactions()
    (§
        unspent.clear();
        spent.clear();
        pending.clear();
        dead.clear();
        transactions.clear();
        myUnspents.clear();
    )

    ;;;
     ; Clean up the wallet.  Currently, it only removes risky pending transaction from the wallet and only
     ; if their outputs have not been spent.
     ;;
#_public
    void cleanup()
    (§
        lock.lock();
        try
        (§
            boolean dirty = false;
            for (Iterator<Transaction> i = pending.values().iterator(); i.hasNext(); )
            (§
                Transaction tx = i.next();
                if (isTransactionRisky(tx, nil) && !acceptRiskyTransactions)
                (§
                    log.debug("Found risky transaction {} in wallet during cleanup.", tx.getHashAsString());
                    if (!tx.isAnyOutputSpent())
                    (§
                        ;; Sync myUnspents with the change.
                        for (TransactionInput input : tx.getInputs())
                        (§
                            TransactionOutput output = input.getConnectedOutput();
                            if (output == nil)
                                continue;
                            if (output.isMine(this))
                                Preconditions.checkState(myUnspents.add(output));
                            input.disconnect();
                        )
                        for (TransactionOutput output : tx.getOutputs())
                            myUnspents.remove(output);

                        i.remove();
                        transactions.remove(tx.getHash());
                        dirty = true;
                        log.info("Removed transaction {} from pending pool during cleanup.", tx.getHashAsString());
                    )
                    else
                    (§
                        log.info("Cannot remove transaction {} from pending pool during cleanup, as it's already spent partially.", tx.getHashAsString());
                    )
                )
            )
            if (dirty)
            (§
                isConsistentOrThrow();
                saveLater();
                if (log.isInfoEnabled())
                    log.info("Estimated balance is now: {}", getBalance(BalanceType.ESTIMATED).toFriendlyString());
            )
        )
        finally
        (§
            lock.unlock();
        )
    )

    EnumSet<Pool> getContainingPools(Transaction tx)
    (§
        lock.lock();
        try
        (§
            EnumSet<Pool> result = EnumSet.noneOf(Pool.class);
            Sha256Hash txHash = tx.getHash();
            if (unspent.containsKey(txHash))
                result.add(Pool.UNSPENT);
            if (spent.containsKey(txHash))
                result.add(Pool.SPENT);
            if (pending.containsKey(txHash))
                result.add(Pool.PENDING);
            if (dead.containsKey(txHash))
                result.add(Pool.DEAD);
            return result;
        )
        finally
        (§
            lock.unlock();
        )
    )

#_testing
#_public
    int getPoolSize(WalletTransaction.Pool pool)
    (§
        lock.lock();
        try
        (§
            switch (pool)
            (§
                case UNSPENT:
                    return unspent.size();
                case SPENT:
                    return spent.size();
                case PENDING:
                    return pending.size();
                case DEAD:
                    return dead.size();
            )
            throw new RuntimeException("Unreachable");
        )
        finally
        (§
            lock.unlock();
        )
    )

#_testing
#_public
    boolean poolContainsTxHash(final WalletTransaction.Pool pool, final Sha256Hash txHash)
    (§
        lock.lock();
        try
        (§
            switch (pool)
            (§
                case UNSPENT:
                    return unspent.containsKey(txHash);
                case SPENT:
                    return spent.containsKey(txHash);
                case PENDING:
                    return pending.containsKey(txHash);
                case DEAD:
                    return dead.containsKey(txHash);
            )
            throw new RuntimeException("Unreachable");
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;; Returns a copy of the internal unspent outputs list. ;;
#_public
    List<TransactionOutput> getUnspents()
    (§
        lock.lock();
        try
        (§
            return new ArrayList<>(myUnspents);
        )
        finally
        (§
            lock.unlock();
        )
    )

#_override
#_public
    String toString()
    (§
        return toString(false, true, nil);
    )

    ;;;
     ; Formats the wallet as a human readable piece of text.  Intended for debugging, the format is
     ; not meant to be stable or human readable.
     ; @param includePrivateKeys Whether raw private key data should be included.
     ; @param includeTransactions Whether to print transaction data.
     ; @param chain If set, will be used to estimate lock times for block timelocked transactions.
     ;;
#_public
    String toString(boolean includePrivateKeys, boolean includeTransactions, #_nilable AbstractBlockChain chain)
    (§
        lock.lock();
        keyChainGroupLock.lock();
        try
        (§
            StringBuilder sb = new StringBuilder();
            Coin estimatedBalance = getBalance(BalanceType.ESTIMATED);
            Coin availableBalance = getBalance(BalanceType.AVAILABLE_SPENDABLE);
            sb.append("Wallet containing ").append(estimatedBalance.toFriendlyString()).append(" (spendable: ")
                    .append(availableBalance.toFriendlyString()).append(") in:\n");
            sb.append("  ").append(pending.size()).append(" pending transactions\n");
            sb.append("  ").append(unspent.size()).append(" unspent transactions\n");
            sb.append("  ").append(spent.size()).append(" spent transactions\n");
            sb.append("  ").append(dead.size()).append(" dead transactions\n");
#_final
            Date lastBlockSeenTime = getLastBlockSeenTime();
            sb.append("Last seen best block: ").append(getLastBlockSeenHeight()).append(" (")
                    .append((lastBlockSeenTime == nil) ? "time unknown" : Utils.dateTimeFormat(lastBlockSeenTime))
                    .append("): ").append(getLastBlockSeenHash()).append('\n');
#_final
            KeyCrypter crypter = keyChainGroup.getKeyCrypter();
            if (crypter != nil)
                sb.append("Encryption: ").append(crypter).append('\n');
            if (isWatching())
                sb.append("Wallet is watching.\n");

            ;; Do the keys.
            sb.append("\nKeys:\n");
            sb.append("Earliest creation time: ").append(Utils.dateTimeFormat(getEarliestKeyCreationTime() * 1000)).append('\n');
#_final
            Date keyRotationTime = getKeyRotationTime();
            if (keyRotationTime != nil)
                sb.append("Key rotation time:      ").append(Utils.dateTimeFormat(keyRotationTime)).append('\n');
            sb.append(keyChainGroup.toString(includePrivateKeys));

            if (includeTransactions)
            (§
                ;; Print the transactions themselves.
                if (0 < pending.size())
                (§
                    sb.append("\n>>> PENDING:\n");
                    toStringHelper(sb, pending, chain, Transaction.SORT_TX_BY_UPDATE_TIME);
                )
                if (0 < unspent.size())
                (§
                    sb.append("\n>>> UNSPENT:\n");
                    toStringHelper(sb, unspent, chain, Transaction.SORT_TX_BY_HEIGHT);
                )
                if (0 < spent.size())
                (§
                    sb.append("\n>>> SPENT:\n");
                    toStringHelper(sb, spent, chain, Transaction.SORT_TX_BY_HEIGHT);
                )
                if (0 < dead.size())
                (§
                    sb.append("\n>>> DEAD:\n");
                    toStringHelper(sb, dead, chain, Transaction.SORT_TX_BY_UPDATE_TIME);
                )
            )
            return sb.toString();
        )
        finally
        (§
            keyChainGroupLock.unlock();
            lock.unlock();
        )
    )

#_private
    void toStringHelper(StringBuilder sb, Map<Sha256Hash, Transaction> transactionMap, #_nilable AbstractBlockChain chain, #_nilable Comparator<Transaction> sortOrder)
    (§
        Preconditions.checkState(lock.isHeldByCurrentThread());

#_final
        Collection<Transaction> txns;
        if (sortOrder != nil)
        (§
            txns = new TreeSet<>(sortOrder);
            txns.addAll(transactionMap.values());
        )
        else
        (§
            txns = transactionMap.values();
        )

        for (Transaction tx : txns)
        (§
            try
            (§
                sb.append(tx.getValue(this).toFriendlyString());
                sb.append(" total value (sends ");
                sb.append(tx.getValueSentFromMe(this).toFriendlyString());
                sb.append(" and receives ");
                sb.append(tx.getValueSentToMe(this).toFriendlyString());
                sb.append(")\n");
            )
            catch (ScriptException _)
            (§
                ;; Ignore and don't print this line.
            )
            if (tx.hasConfidence())
                sb.append("  confidence: ").append(tx.getConfidence()).append('\n');
            sb.append(tx.toString(chain));
        )
    )

    ;;;
     ; Returns an immutable view of the transactions currently waiting for network confirmations.
     ;;
#_public
    Collection<Transaction> getPendingTransactions()
    (§
        lock.lock();
        try
        (§
            return Collections.unmodifiableCollection(pending.values());
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Returns the earliest creation time of keys or watched scripts in this wallet, in seconds since the epoch,
     ; i.e. the min of {@link org.bitcoinj.core.ECKey#getCreationTimeSeconds()}.  This can return zero if at least
     ; one key does not have that data (was created before key timestamping was implemented).
     ;
     ; This method is most often used in conjunction with {@link PeerGroup#setFastCatchupTimeSecs(long)} in order to
     ; optimize chain download for new users of wallet apps.  Backwards compatibility notice: if you get zero from this
     ; method, you can instead use the time of the first release of your software, as it's guaranteed no users will
     ; have wallets pre-dating this time.
     ;
     ; If there are no keys in the wallet, the current time is returned.
     ;;
#_override
#_public
    long getEarliestKeyCreationTime()
    (§
        keyChainGroupLock.lock();
        try
        (§
            long earliestTime = keyChainGroup.getEarliestKeyCreationTime();
            return (earliestTime == Long.MAX_VALUE) ? Utils.currentTimeSeconds() : earliestTime;
        )
        finally
        (§
            keyChainGroupLock.unlock();
        )
    )

    ;;; Returns the hash of the last seen best-chain block, or null if the wallet is too old to store this data. ;;
#_nilable
#_public
    Sha256Hash getLastBlockSeenHash()
    (§
        lock.lock();
        try
        (§
            return lastBlockSeenHash;
        )
        finally
        (§
            lock.unlock();
        )
    )

#_public
    void setLastBlockSeenHash(#_nilable Sha256Hash lastBlockSeenHash)
    (§
        lock.lock();
        try
        (§
            this.lastBlockSeenHash = lastBlockSeenHash;
        )
        finally
        (§
            lock.unlock();
        )
    )

#_public
    void setLastBlockSeenHeight(int lastBlockSeenHeight)
    (§
        lock.lock();
        try
        (§
            this.lastBlockSeenHeight = lastBlockSeenHeight;
        )
        finally
        (§
            lock.unlock();
        )
    )

#_public
    void setLastBlockSeenTimeSecs(long timeSecs)
    (§
        lock.lock();
        try
        (§
            lastBlockSeenTimeSecs = timeSecs;
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Returns the UNIX time in seconds since the epoch extracted from the last best seen block header.  This timestamp
     ; is <b>not</b> the local time at which the block was first observed by this application but rather what the block
     ; (i.e. miner) self declares.  It is allowed to have some significant drift from the real time at which the block
     ; was found, although most miners do use accurate times.  If this wallet is old and does not have a recorded
     ; time then this method returns zero.
     ;;
#_public
    long getLastBlockSeenTimeSecs()
    (§
        lock.lock();
        try
        (§
            return lastBlockSeenTimeSecs;
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Returns a {@link Date} representing the time extracted from the last best seen block header.  This timestamp
     ; is <b>not</b> the local time at which the block was first observed by this application but rather what the block
     ; (i.e. miner) self declares.  It is allowed to have some significant drift from the real time at which the block
     ; was found, although most miners do use accurate times.  If this wallet is old and does not have a recorded
     ; time then this method returns null.
     ;;
#_nilable
#_public
    Date getLastBlockSeenTime()
    (§
#_final
        long secs = getLastBlockSeenTimeSecs();
        return (secs == 0) ? nil : new Date(secs * 1000);
    )

    ;;;
     ; Returns the height of the last seen best-chain block.  Can be 0 if a wallet is brand new or -1 if the wallet
     ; is old and doesn't have that data.
     ;;
#_public
    int getLastBlockSeenHeight()
    (§
        lock.lock();
        try
        (§
            return lastBlockSeenHeight;
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Get the version of the Wallet.
     ; This is an int you can use to indicate which versions of wallets your code understands,
     ; and which come from the future (and hence cannot be safely loaded).
     ;;
#_public
    int getVersion()
    (§
        return version;
    )

    ;;;
     ; Set the version number of the wallet.  See {@link Wallet#getVersion()}.
     ;;
#_public
    void setVersion(int version)
    (§
        this.version = version;
    )

    ;;;
     ; Set the description of the wallet.
     ; This is a Unicode encoding string typically entered by the user as descriptive text for the wallet.
     ;;
#_public
    void setDescription(String description)
    (§
        this.description = description;
    )

    ;;;
     ; Get the description of the wallet.  See {@link Wallet#setDescription(String))}.
     ;;
#_public
    String getDescription()
    (§
        return description;
    )

    ;;;
     ; <p>It's possible to calculate a wallets balance from multiple points of view.  This enum selects which
     ; {@link #getBalance(BalanceType)} should use.</p>
     ;
     ; <p>Consider a real-world example: you buy a snack costing $5 but you only have a $10 bill.  At the start
     ; you have $10 viewed from every possible angle.  After you order the snack you hand over your $10 bill.
     ; From the perspective of your wallet you have zero dollars (AVAILABLE).  But you know in a few seconds the
     ; shopkeeper will give you back $5 change so most people in practice would say they have $5 (ESTIMATED).</p>
     ;
     ; <p>The fact that the wallet can track transactions which are not spendable by itself ("watching wallets")
     ; adds another type of balance to the mix.  Although the wallet won't do this by default, advanced use cases
     ; that override the relevancy checks can end up with a mix of spendable and unspendable transactions.</p>
     ;;
#_public
    enum BalanceType
    (§
        ;;;
         ; Balance calculated assuming all pending transactions are in fact included into the best chain by miners.
         ; This includes the value of immature coinbase transactions.
         ;;
        ESTIMATED,

        ;;;
         ; Balance that could be safely used to create new spends, if we had all the needed private keys.  This is
         ; whatever the default coin selector would make available, which by default means transaction outputs with at
         ; least 1 confirmation and pending transactions created by our own wallet which have been propagated across
         ; the network.  Whether we <i>actually</i> have the private keys or not is irrelevant for this balance type.
         ;;
        AVAILABLE,

        ;;; Same as ESTIMATED but only for outputs we have the private keys for and can sign ourselves. ;;
        ESTIMATED_SPENDABLE,
        ;;; Same as AVAILABLE but only for outputs we have the private keys for and can sign ourselves. ;;
        AVAILABLE_SPENDABLE
    )

    ;;;
     ; Returns the AVAILABLE balance of this wallet.
     ; See {@link BalanceType#AVAILABLE} for details on what this means.
     ;;
#_public
    Coin getBalance()
    (§
        return getBalance(BalanceType.AVAILABLE);
    )

    ;;;
     ; Returns the balance of this wallet as calculated by the provided balanceType.
     ;;
#_public
    Coin getBalance(BalanceType balanceType)
    (§
        lock.lock();
        try
        (§
            if (balanceType == BalanceType.AVAILABLE || balanceType == BalanceType.AVAILABLE_SPENDABLE)
            (§
                List<TransactionOutput> candidates = calculateAllSpendCandidates(true, balanceType == BalanceType.AVAILABLE_SPENDABLE);
                CoinSelection selection = coinSelector.select(NetworkParameters.MAX_MONEY, candidates);
                return selection.valueGathered;
            )
            else if (balanceType == BalanceType.ESTIMATED || balanceType == BalanceType.ESTIMATED_SPENDABLE)
            (§
                List<TransactionOutput> all = calculateAllSpendCandidates(false, balanceType == BalanceType.ESTIMATED_SPENDABLE);
                Coin value = Coin.ZERO;
                for (TransactionOutput out : all)
                    value = value.add(out.getValue());
                return value;
            )
            else
            (§
                throw new AssertionError("Unknown balance type"); ;; Unreachable.
            )
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Returns the balance that would be considered spendable by the given coin selector, including watched outputs
     ; (i.e. balance includes outputs we don't have the private keys for).  Just asks it to select as many coins as
     ; possible and returns the total.
     ;;
#_public
    Coin getBalance(CoinSelector selector)
    (§
        lock.lock();
        try
        (§
            Preconditions.checkNotNull(selector);

            List<TransactionOutput> candidates = calculateAllSpendCandidates(true, false);
            CoinSelection selection = selector.select(params.getMaxMoney(), candidates);
            return selection.valueGathered;
        )
        finally
        (§
            lock.unlock();
        )
    )

#_private
#_static
    class BalanceFutureRequest
    (§
#_public
        SettableFuture<Coin> future;
#_public
        Coin value;
#_public
        BalanceType type;
    )
#_guarded-by("lock")
#_private
    List<BalanceFutureRequest> balanceFutureRequests = Lists.newLinkedList();

    ;;;
     ; <p>Returns a future that will complete when the balance of the given type has become equal or larger to the
     ; given value.  If the wallet already has a large enough balance the future is returned in a pre-completed state.
     ; Note that this method is not blocking, if you want to actually wait immediately, you have to call .get() on
     ; the result.</p>
     ;
     ; <p>Also note that by the time the future completes, the wallet may have changed yet again if something else
     ; is going on in parallel, so you should treat the returned balance as advisory and be prepared for sending
     ; money to fail!  Finally please be aware that any listeners on the future will run either on the calling thread
     ; if it completes immediately, or eventually on a background thread if the balance is not yet at the right
     ; level.  If you do something that means you know the balance should be sufficient to trigger the future,
     ; you can use {@link org.bitcoinj.utils.Threading#waitForUserCode()} to block until the future had a
     ; chance to be updated.</p>
     ;;
#_public
    ListenableFuture<Coin> getBalanceFuture(final Coin value, final BalanceType type)
    (§
        lock.lock();
        try
        (§
#_final
            SettableFuture<Coin> future = SettableFuture.create();
#_final
            Coin current = getBalance(type);
            if (0 <= current.compareTo(value))
            (§
                ;; Already have enough.
                future.set(current);
            )
            else
            (§
                ;; Will be checked later in checkBalanceFutures.  We don't just add an event listener for ourselves
                ;; here so that running getBalanceFuture().get() in the user code thread works - generally we must
                ;; avoid giving the user back futures that require the user code thread to be free.
                BalanceFutureRequest req = new BalanceFutureRequest();
                req.future = future;
                req.value = value;
                req.type = type;
                balanceFutureRequests.add(req);
            )
            return future;
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;; Runs any balance futures in the user code thread.
#_suppress("FieldAccessNotGuarded")
#_private
    void checkBalanceFuturesLocked(#_nilable Coin avail)
    (§
        Preconditions.checkState(lock.isHeldByCurrentThread());

#_final
        ListIterator<BalanceFutureRequest> it = balanceFutureRequests.listIterator();
        while (it.hasNext())
        (§
#_final
            BalanceFutureRequest req = it.next();
            Coin val = getBalance(req.type); ;; This could be slow for lots of futures.
            if (val.compareTo(req.value) < 0)
                continue;
            ;; Found one that's finished.
            it.remove();
#_final
            Coin v = val;
            ;; Don't run any user-provided future listeners with our lock held.
            Threading.USER_THREAD.execute(new Runnable()
            (§
#_override
#_public
                void run()
                (§
                    req.future.set(v);
                )
            ));
        )
    )

    ;;;
     ; Returns the amount of bitcoin ever received via output.  <b>This is not the balance!</b>  If an output
     ; spends from a transaction whose inputs are also to our wallet, the input amounts are deducted from the
     ; outputs contribution, with a minimum of zero contribution.  The idea behind this is we avoid double
     ; counting money sent to us.
     ; @return the total amount of satoshis received, regardless of whether it was spent or not.
     ;;
#_public
    Coin getTotalReceived()
    (§
        Coin total = Coin.ZERO;

        ;; Include outputs to us if they were not just change outputs, i.e. the inputs to us summed to less
        ;; than the outputs to us.
        for (Transaction tx: transactions.values())
        (§
            Coin txTotal = Coin.ZERO;
            for (TransactionOutput output : tx.getOutputs())
            (§
                if (output.isMine(this))
                    txTotal = txTotal.add(output.getValue());
            )
            for (TransactionInput in : tx.getInputs())
            (§
                TransactionOutput prevOut = in.getConnectedOutput();
                if (prevOut != nil && prevOut.isMine(this))
                    txTotal = txTotal.subtract(prevOut.getValue());
            )
            if (txTotal.isPositive())
                total = total.add(txTotal);
        )
        return total;
    )

    ;;;
     ; Returns the amount of bitcoin ever sent via output.  If an output is sent to our own wallet, because of
     ; change or rotating keys or whatever, we do not count it.  If the wallet was involved in a shared transaction,
     ; i.e. there is some input to the transaction that we don't have the key for, then we multiply the sum of
     ; the output values by the proportion of satoshi coming in to our inputs.  Essentially we treat inputs as
     ; pooling into the transaction, becoming fungible and being equally distributed to all outputs.
     ; @return the total amount of satoshis sent by us.
     ;;
#_public
    Coin getTotalSent()
    (§
        Coin total = Coin.ZERO;

        for (Transaction tx : transactions.values())
        (§
            ;; Count spent outputs to only if they were not to us.  This means we don't count change outputs.
            Coin txOutputTotal = Coin.ZERO;
            for (TransactionOutput out : tx.getOutputs())
            (§
                if (!out.isMine(this))
                    txOutputTotal = txOutputTotal.add(out.getValue());
            )

            ;; Count the input values to us
            Coin txOwnedInputsTotal = Coin.ZERO;
            for (TransactionInput in : tx.getInputs())
            (§
                TransactionOutput prevOut = in.getConnectedOutput();
                if (prevOut != nil && prevOut.isMine(this))
                    txOwnedInputsTotal = txOwnedInputsTotal.add(prevOut.getValue());
            )

            ;; If there is an input that isn't from us, i.e. this is a shared transaction.
            Coin txInputsTotal = tx.getInputSum();
            if (txOwnedInputsTotal != txInputsTotal)
            (§
                ;; Multiply our output total by the appropriate proportion to account for the inputs that we don't own.
                BigInteger txOutputTotalNum = new BigInteger(txOutputTotal.toString());
                txOutputTotalNum = txOutputTotalNum.multiply(new BigInteger(txOwnedInputsTotal.toString()));
                txOutputTotalNum = txOutputTotalNum.divide(new BigInteger(txInputsTotal.toString()));
                txOutputTotal = Coin.valueOf(txOutputTotalNum.longValue());
            )
            total = total.add(txOutputTotal);
        )
        return total;
    )

    ;;; A SendResult is returned to you as part of sending coins to a recipient. ;;
#_public
#_static
    class SendResult
    (§
        ;;; The Bitcoin transaction message that moves the money. ;;
#_public
        Transaction tx;
        ;;;
         ; A future that will complete once the tx message has been successfully broadcast to the network.
         ; This is just the result of calling broadcast.future().
         ;;
#_public
        ListenableFuture<Transaction> broadcastComplete;
        ;;; The broadcast object returned by the linked TransactionBroadcaster. ;;
#_public
        TransactionBroadcast broadcast;
    )

    ;;;
     ; Enumerates possible resolutions for missing signatures.
     ;;
#_public
    enum MissingSigsMode
    (§
        ;;; Input script will have OP_0 instead of missing signatures. ;;
        USE_OP_ZERO,
        ;;;
         ; Missing signatures will be replaced by dummy sigs.  This is useful when you'd like to know the
         ; fee for a transaction without knowing the user's password, as fee depends on size.
         ;;
        USE_DUMMY_SIG,
        ;;;
         ; If signature is missing, {@link org.bitcoinj.signers.TransactionSigner.MissingSignatureException}
         ; will be thrown for P2SH and {@link ECKey.MissingPrivateKeyException} for other tx types.
         ;;
        THROW
    )

    ;;;
     ; <p>Statelessly creates a transaction that sends the given value to address.  The change is sent to
     ; {@link Wallet#currentChangeAddress()}, so you must have added at least one key.</p>
     ;
     ; <p>If you just want to send money quickly, you probably want
     ; {@link Wallet#sendCoins(TransactionBroadcaster, Address, Coin)} instead.  That will create the sending
     ; transaction, commit to the wallet and broadcast it to the network all in one go.  This method is lower
     ; level and lets you see the proposed transaction before anything is done with it.</p>
     ;
     ; <p>This is a helper method that is equivalent to using {@link SendRequest#to(Address, Coin)}
     ; followed by {@link Wallet#completeTx(Wallet.SendRequest)} and returning the requests transaction object.
     ; Note that this means a fee may be automatically added if required, if you want more control over the process,
     ; just do those two steps yourself.</p>
     ;
     ; <p>IMPORTANT: This method does NOT update the wallet.  If you call createSend again you may get two transactions
     ; that spend the same coins.  You have to call {@link Wallet#commitTx(Transaction)} on the created transaction to
     ; prevent this, but that should only occur once the transaction has been accepted by the network.  This implies
     ; you cannot have more than one outstanding sending tx at once.</p>
     ;
     ; <p>You MUST ensure that the value is not smaller than {@link Transaction#MIN_NONDUST_OUTPUT} or the transaction
     ; will almost certainly be rejected by the network as dust.</p>
     ;
     ; @param address The Bitcoin address to send the money to.
     ; @param value How much currency to send.
     ; @return either the created Transaction or null if there are insufficient coins.
     ; @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
     ; @throws DustySendRequested if the resultant transaction would violate the dust rules.
     ; @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
     ; @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process.
     ; @throws MultipleOpReturnRequested if there is more than one OP_RETURN output for the resultant transaction.
     ;;
#_public
    Transaction createSend(Address address, Coin value)
        throws InsufficientMoneyException
    (§
        SendRequest req = SendRequest.to(address, value);
        if (params.getId().equals(NetworkParameters.ID_UNITTESTNET))
            req.shuffleOutputs = false;
        completeTx(req);
        return req.tx;
    )

    ;;;
     ; Sends coins to the given address but does not broadcast the resulting pending transaction.  It is still
     ; stored in the wallet, so when the wallet is added to a {@link PeerGroup} or {@link Peer} the transaction
     ; will be announced to the network.  The given {@link SendRequest} is completed first using
     ; {@link Wallet#completeTx(Wallet.SendRequest)} to make it valid.
     ;
     ; @return the Transaction that was created.
     ; @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
     ; @throws IllegalArgumentException if you try and complete the same SendRequest twice.
     ; @throws DustySendRequested if the resultant transaction would violate the dust rules.
     ; @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
     ; @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process.
     ; @throws MultipleOpReturnRequested if there is more than one OP_RETURN output for the resultant transaction.
     ;;
#_public
    Transaction sendCoinsOffline(SendRequest request)
        throws InsufficientMoneyException
    (§
        lock.lock();
        try
        (§
            completeTx(request);
            commitTx(request.tx);
            return request.tx;
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; <p>Sends coins to the given address, via the given {@link PeerGroup}.  Change is returned to
     ; {@link Wallet#currentChangeAddress()}.  Note that a fee may be automatically added if one may be required
     ; for the transaction to be confirmed.</p>
     ;
     ; <p>The returned object provides both the transaction, and a future that can be used to learn when the broadcast
     ; is complete.  Complete means, if the PeerGroup is limited to only one connection, when it was written out to
     ; the socket.  Otherwise when the transaction is written out and we heard it back from a different peer.</p>
     ;
     ; <p>Note that the sending transaction is committed to the wallet immediately, not when the transaction is
     ; successfully broadcast.  This means that even if the network hasn't heard about your transaction you won't be
     ; able to spend those same coins again.</p>
     ;
     ; <p>You MUST ensure that value is not smaller than {@link Transaction#MIN_NONDUST_OUTPUT} or the transaction will
     ; almost certainly be rejected by the network as dust.</p>
     ;
     ; @param broadcaster A {@link TransactionBroadcaster} to use to send the transactions out.
     ; @param to Which address to send coins to.
     ; @param value How much value to send.
     ; @return an object containing the transaction that was created, and a future for the broadcast of it.
     ; @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
     ; @throws DustySendRequested if the resultant transaction would violate the dust rules.
     ; @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
     ; @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process.
     ; @throws MultipleOpReturnRequested if there is more than one OP_RETURN output for the resultant transaction.
     ;;
#_public
    SendResult sendCoins(TransactionBroadcaster broadcaster, Address to, Coin value)
        throws InsufficientMoneyException
    (§
        SendRequest request = SendRequest.to(to, value);
        return sendCoins(broadcaster, request);
    )

    ;;;
     ; <p>Sends coins according to the given request, via the given {@link TransactionBroadcaster}.</p>
     ;
     ; <p>The returned object provides both the transaction, and a future that can be used to learn when the broadcast
     ; is complete.  Complete means, if the PeerGroup is limited to only one connection, when it was written out to
     ; the socket.  Otherwise when the transaction is written out and we heard it back from a different peer.</p>
     ;
     ; <p>Note that the sending transaction is committed to the wallet immediately, not when the transaction is
     ; successfully broadcast.  This means that even if the network hasn't heard about your transaction you won't be
     ; able to spend those same coins again.</p>
     ;
     ; @param broadcaster The target to use for broadcast.
     ; @param request The SendRequest that describes what to do, get one using static methods on SendRequest itself.
     ; @return an object containing the transaction that was created, and a future for the broadcast of it.
     ; @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
     ; @throws IllegalArgumentException if you try and complete the same SendRequest twice.
     ; @throws DustySendRequested if the resultant transaction would violate the dust rules.
     ; @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
     ; @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process.
     ; @throws MultipleOpReturnRequested if there is more than one OP_RETURN output for the resultant transaction.
     ;;
#_public
    SendResult sendCoins(TransactionBroadcaster broadcaster, SendRequest request)
        throws InsufficientMoneyException
    (§
        ;; Should not be locked here, as we're going to call into the broadcaster and that might want to hold its
        ;; own lock.  sendCoinsOffline handles everything that needs to be locked.
        Preconditions.checkState(!lock.isHeldByCurrentThread());

        ;; Commit the TX to the wallet immediately so the spent coins won't be reused.
        ;; TODO: We should probably allow the request to specify tx commit only after the network has accepted it.
        Transaction tx = sendCoinsOffline(request);
        SendResult result = new SendResult();
        result.tx = tx;
        ;; The tx has been committed to the pending pool by this point (via sendCoinsOffline -> commitTx), so it has
        ;; a txConfidenceListener registered.  Once the tx is broadcast the peers will update the memory pool with the
        ;; count of seen peers, the memory pool will update the transaction confidence object, that will invoke the
        ;; txConfidenceListener which will in turn invoke the wallets event listener onTransactionConfidenceChanged
        ;; method.
        result.broadcast = broadcaster.broadcastTransaction(tx);
        result.broadcastComplete = result.broadcast.future();
        return result;
    )

    ;;;
     ; Satisfies the given {@link SendRequest} using the default transaction broadcaster configured either via
     ; {@link PeerGroup#addWallet(Wallet)} or directly with {@link #setTransactionBroadcaster(TransactionBroadcaster)}.
     ;
     ; @param request The SendRequest that describes what to do, get one using static methods on SendRequest itself.
     ; @return an object containing the transaction that was created, and a future for the broadcast of it.
     ; @throws IllegalStateException if no transaction broadcaster has been configured.
     ; @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
     ; @throws IllegalArgumentException if you try and complete the same SendRequest twice.
     ; @throws DustySendRequested if the resultant transaction would violate the dust rules.
     ; @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
     ; @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process.
     ; @throws MultipleOpReturnRequested if there is more than one OP_RETURN output for the resultant transaction.
     ;;
#_public
    SendResult sendCoins(SendRequest request)
        throws InsufficientMoneyException
    (§
        TransactionBroadcaster broadcaster = vTransactionBroadcaster;
        Preconditions.checkState(broadcaster != nil, "No transaction broadcaster is configured");
        return sendCoins(broadcaster, request);
    )

    ;;;
     ; Sends coins to the given address, via the given {@link Peer}.  Change is returned to {@link Wallet#currentChangeAddress()}.
     ; If an exception is thrown by {@link Peer#sendMessage(Message)} the transaction is still committed, so the pending
     ; transaction must be broadcast <b>by you</b> at some other time.  Note that a fee may be automatically added
     ; if one may be required for the transaction to be confirmed.
     ;
     ; @return the {@link Transaction} that was created or null if there was insufficient balance to send the coins.
     ; @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
     ; @throws IllegalArgumentException if you try and complete the same SendRequest twice.
     ; @throws DustySendRequested if the resultant transaction would violate the dust rules.
     ; @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
     ; @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process.
     ; @throws MultipleOpReturnRequested if there is more than one OP_RETURN output for the resultant transaction.
     ;;
#_public
    Transaction sendCoins(Peer peer, SendRequest request)
        throws InsufficientMoneyException
    (§
        Transaction tx = sendCoinsOffline(request);
        peer.sendMessage(tx);
        return tx;
    )

    ;;;
     ; Class of exceptions thrown in {@link Wallet#completeTx(SendRequest)}.
     ;;
#_public
#_static
    class CompletionException extends RuntimeException {}

    ;;;
     ; Thrown if the resultant transaction would violate the dust rules (an output that's too small to be worthwhile).
     ;;
#_public
#_static
    class DustySendRequested extends CompletionException {}

    ;;;
     ; Thrown if there is more than one OP_RETURN output for the resultant transaction.
     ;;
#_public
#_static
    class MultipleOpReturnRequested extends CompletionException {}

    ;;;
     ; Thrown when we were trying to empty the wallet, and the total amount of money we were trying to empty after
     ; being reduced for the fee was smaller than the min payment.
     ; Note that the missing field will be null in this case.
     ;;
#_public
#_static
    class CouldNotAdjustDownwards extends CompletionException {}

    ;;;
     ; Thrown if the resultant transaction is too big for Bitcoin to process.  Try breaking up the amounts of value.
     ;;
#_public
#_static
    class ExceededMaxTransactionSize extends CompletionException {}

    ;;;
     ; Given a spend request containing an incomplete transaction, makes it valid by adding outputs and signed inputs
     ; according to the instructions in the request.  The transaction in the request is modified by this method.
     ;
     ; @param req A SendRequest that contains the incomplete transaction and details for how to make it valid.
     ; @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
     ; @throws IllegalArgumentException if you try and complete the same SendRequest twice.
     ; @throws DustySendRequested if the resultant transaction would violate the dust rules.
     ; @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
     ; @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process.
     ; @throws MultipleOpReturnRequested if there is more than one OP_RETURN output for the resultant transaction.
     ;;
#_public
    void completeTx(SendRequest req)
        throws InsufficientMoneyException
    (§
        lock.lock();
        try
        (§
            Preconditions.checkArgument(!req.completed, "Given SendRequest has already been completed.");

            ;; Calculate the amount of value we need to import.
            Coin value = Coin.ZERO;
            for (TransactionOutput output : req.tx.getOutputs())
                value = value.add(output.getValue());

            log.info("Completing send tx with {} outputs totalling {} and a fee of {}/kB", req.tx.getOutputs().size(), value.toFriendlyString(), req.feePerKb.toFriendlyString());

            ;; If any inputs have already been added, we don't need to get their value from wallet.
            Coin totalInput = Coin.ZERO;
            for (TransactionInput input : req.tx.getInputs())
            (§
                if (input.getConnectedOutput() != nil)
                    totalInput = totalInput.add(input.getConnectedOutput().getValue());
                else
                    log.warn("SendRequest transaction already has inputs but we don't know how much they are worth - they will be added to fee.");
            )
            value = value.subtract(totalInput);

            List<TransactionInput> originalInputs = new ArrayList<>(req.tx.getInputs());

            ;; Check for dusty sends and the OP_RETURN limit.
            if (req.ensureMinRequiredFee && !req.emptyWallet) ;; Min fee checking is handled later for emptyWallet.
            (§
                int opReturnCount = 0;
                for (TransactionOutput output : req.tx.getOutputs())
                (§
                    if (output.isDust())
                        throw new DustySendRequested();
                    if (output.getScriptPubKey().isOpReturn())
                        ++opReturnCount;
                )
                if (1 < opReturnCount) ;; Only 1 OP_RETURN per transaction allowed.
                    throw new MultipleOpReturnRequested();
            )

            ;; Calculate a list of ALL potential candidates for spending and then ask a coin selector to provide us
            ;; with the actual outputs that'll be used to gather the required amount of value.  In this way, users
            ;; can customize coin selection policies.  The call below will ignore immature coinbases and outputs
            ;; we don't have the keys for.
            List<TransactionOutput> candidates = calculateAllSpendCandidates(true, req.missingSigsMode == MissingSigsMode.THROW);

            CoinSelection bestCoinSelection;
            TransactionOutput bestChangeOutput = nil;
            List<Coin> updatedOutputValues = nil;
            if (!req.emptyWallet)
            (§
                ;; This can throw InsufficientMoneyException.
                FeeCalculation feeCalculation = calculateFee(req, value, originalInputs, req.ensureMinRequiredFee, candidates);
                bestCoinSelection = feeCalculation.bestCoinSelection;
                bestChangeOutput = feeCalculation.bestChangeOutput;
                updatedOutputValues = feeCalculation.updatedOutputValues;
            )
            else
            (§
                ;; We're being asked to empty the wallet.  What this means is ensuring "tx" has only a single output
                ;; of the total value we can currently spend as determined by the selector, and then subtracting the fee.
                Preconditions.checkState(req.tx.getOutputs().size() == 1, "Empty wallet TX must have a single output only.");

                CoinSelector selector = (req.coinSelector == nil) ? coinSelector : req.coinSelector;
                bestCoinSelection = selector.select(params.getMaxMoney(), candidates);
                candidates = nil; ;; Selector took ownership and might have changed candidates.  Don't access again.
                req.tx.getOutput(0).setValue(bestCoinSelection.valueGathered);
                log.info("  emptying {}", bestCoinSelection.valueGathered.toFriendlyString());
            )

            for (TransactionOutput output : bestCoinSelection.gathered)
                req.tx.addInput(output);

            if (req.emptyWallet)
            (§
#_final
                Coin feePerKb = (req.feePerKb == nil) ? Coin.ZERO : req.feePerKb;
                if (!adjustOutputDownwardsForFee(req.tx, bestCoinSelection, feePerKb, req.ensureMinRequiredFee))
                    throw new CouldNotAdjustDownwards();
            )

            if (updatedOutputValues != nil)
            (§
                for (int i = 0; i < updatedOutputValues.size(); i++)
                    req.tx.getOutput(i).setValue(updatedOutputValues.get(i));
            )

            if (bestChangeOutput != nil)
            (§
                req.tx.addOutput(bestChangeOutput);
                log.info("  with {} change", bestChangeOutput.getValue().toFriendlyString());
            )

            ;; Now shuffle the outputs to obfuscate which is the change.
            if (req.shuffleOutputs)
                req.tx.shuffleOutputs();

            ;; Now sign the inputs, thus proving that we are entitled to redeem the connected outputs.
            if (req.signInputs)
                signTransaction(req);

            ;; Check size.
#_final
            int size = req.tx.unsafeBitcoinSerialize().length;
            if (Transaction.MAX_STANDARD_TX_SIZE < size)
                throw new ExceededMaxTransactionSize();

            ;; Label the transaction as being self created.  We can use this later to spend its change output even before
            ;; the transaction is confirmed.  We deliberately won't bother notifying listeners here as there's not much
            ;; point - the user isn't interested in a confidence transition they made themselves.
            req.tx.getConfidence().setSource(TransactionConfidence.Source.SELF);
            ;; Label the transaction as being a user requested payment.  This can be used to render GUI wallet
            ;; transaction lists more appropriately, especially when the wallet starts to generate transactions itself
            ;; for internal purposes.
            req.tx.setPurpose(Transaction.Purpose.USER_PAYMENT);
            ;; Record the exchange rate that was valid when the transaction was completed.
            req.tx.setExchangeRate(req.exchangeRate);
            req.tx.setMemo(req.memo);
            req.completed = true;
            log.info("  completed: {}", req.tx);
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; <p>Given a send request containing transaction, attempts to sign it's inputs.  This method expects
     ; the transaction to have all necessary inputs connected or they will be ignored.</p>
     ; <p>Actual signing is done by pluggable {@link #signers} and it's not guaranteed that
     ; the transaction will be complete in the end.</p>
     ;;
#_public
    void signTransaction(SendRequest req)
    (§
        lock.lock();
        try
        (§
            Transaction tx = req.tx;
            List<TransactionInput> inputs = tx.getInputs();
            List<TransactionOutput> outputs = tx.getOutputs();
            Preconditions.checkState(0 < inputs.size());
            Preconditions.checkState(0 < outputs.size());

            KeyBag maybeDecryptingKeyBag = new DecryptingKeyBag(this, req.aesKey);

            int numInputs = tx.getInputs().size();
            for (int i = 0; i < numInputs; i++)
            (§
                TransactionInput txIn = tx.getInput(i);
                ;; Missing connected output, assuming already signed.
                if (txIn.getConnectedOutput() == nil)
                    continue;

                try
                (§
                    ;; We assume if its already signed, its hopefully got a SIGHASH type that will not invalidate when
                    ;; we sign missing pieces (to check this would require either assuming any signatures are signing
                    ;; standard output types or a way to get processed signatures out of script execution).
                    txIn.getScriptSig().correctlySpends(tx, i, txIn.getConnectedOutput().getScriptPubKey());
                    log.warn("Input {} already correctly spends output, assuming SIGHASH type used will be safe and skipping signing.", i);
                    continue;
                )
                catch (ScriptException e)
                (§
                    log.debug("Input contained an incorrect signature", e);
                    ;; Expected.
                )

                Script scriptPubKey = txIn.getConnectedOutput().getScriptPubKey();
                RedeemData redeemData = txIn.getConnectedRedeemData(maybeDecryptingKeyBag);
                Preconditions.checkNotNull(redeemData, "Transaction exists in wallet that we cannot redeem: %s", txIn.getOutpoint().getHash());
                txIn.setScriptSig(scriptPubKey.createEmptyInputScript(redeemData.keys.get(0), redeemData.redeemScript));
            )

            TransactionSigner.ProposedTransaction proposal = new TransactionSigner.ProposedTransaction(tx);
            for (TransactionSigner signer : signers)
            (§
                if (!signer.signInputs(proposal, maybeDecryptingKeyBag))
                    log.info("{} returned false for the tx", signer.getClass().getName());
            )

            ;; Resolve missing sigs if any.
            new MissingSigResolutionSigner(req.missingSigsMode).signInputs(proposal, maybeDecryptingKeyBag);
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;; Reduce the value of the first output of a transaction to pay the given feePerKb as appropriate for its size. ;;
#_private
    boolean adjustOutputDownwardsForFee(Transaction tx, CoinSelection coinSelection, Coin feePerKb, boolean ensureMinRequiredFee)
    (§
#_final
        int size = tx.unsafeBitcoinSerialize().length + estimateBytesForSigning(coinSelection);
        Coin fee = feePerKb.multiply(size).divide(1000);
        if (ensureMinRequiredFee && fee.compareTo(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE) < 0)
            fee = Transaction.REFERENCE_DEFAULT_MIN_TX_FEE;
        TransactionOutput output = tx.getOutput(0);
        output.setValue(output.getValue().subtract(fee));
        return !output.isDust();
    )

    ;;;
     ; Returns a list of the outputs that can potentially be spent, i.e. that we have the keys for and are unspent
     ; according to our knowledge of the block chain.
     ;;
#_public
    List<TransactionOutput> calculateAllSpendCandidates()
    (§
        return calculateAllSpendCandidates(true, true);
    )

    ;;;
     ; Returns a list of all outputs that are being tracked by this wallet taking into account the flags.
     ;
     ; @param excludeImmatureCoinbases Whether to ignore coinbase outputs that we will be able to spend in future once they mature.
     ; @param excludeUnsignable Whether to ignore outputs that we are tracking but don't have the keys to sign for.
     ;;
#_public
    List<TransactionOutput> calculateAllSpendCandidates(boolean excludeImmatureCoinbases, boolean excludeUnsignable)
    (§
        lock.lock();
        try
        (§
            List<TransactionOutput> candidates = new ArrayList<>(myUnspents.size());
            for (TransactionOutput output : myUnspents)
            (§
                if (excludeUnsignable && !canSignFor(output.getScriptPubKey()))
                    continue;
                Transaction transaction = Preconditions.checkNotNull(output.getParentTransaction());
                if (excludeImmatureCoinbases && !transaction.isMature())
                    continue;
                candidates.add(output);
            )
            return candidates;
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Returns true if this wallet has at least one of the private keys needed to sign for this scriptPubKey.
     ; Returns false if the form of the script is not known or if the script is OP_RETURN.
     ;;
#_public
    boolean canSignFor(Script script)
    (§
        if (script.isSentToRawPubKey())
        (§
            byte[] pubkey = script.getPubKey();
            ECKey key = findKeyFromPubKey(pubkey);
            return (key != nil && (key.isEncrypted() || key.hasPrivKey()));
        )

        if (script.isPayToScriptHash())
        (§
            RedeemData data = findRedeemDataFromScriptHash(script.getPubKeyHash());
            return (data != nil && canSignFor(data.redeemScript));
        )

        if (script.isSentToAddress())
        (§
            ECKey key = findKeyFromPubHash(script.getPubKeyHash());
            return (key != nil && (key.isEncrypted() || key.hasPrivKey()));
        )

        if (script.isSentToMultiSig())
        (§
            for (ECKey pubkey : script.getPubKeys())
            (§
                ECKey key = findKeyFromPubKey(pubkey.getPubKey());
                if (key != nil && (key.isEncrypted() || key.hasPrivKey()))
                    return true;
            )
        )
        else if (script.isSentToCLTVPaymentChannel())
        (§
            ;; Any script for which we are the recipient or sender counts.
            byte[] sender = script.getCLTVPaymentChannelSenderPubKey();
            ECKey senderKey = findKeyFromPubKey(sender);
            if (senderKey != nil && (senderKey.isEncrypted() || senderKey.hasPrivKey()))
                return true;

            byte[] recipient = script.getCLTVPaymentChannelRecipientPubKey();
            ECKey recipientKey = findKeyFromPubKey(sender);
            if (recipientKey != nil && (recipientKey.isEncrypted() || recipientKey.hasPrivKey()))
                return true;
        )
        return false;
    )

    ;;; Returns the {@link CoinSelector} object which controls which outputs can be spent by this wallet. ;;
#_public
    CoinSelector getCoinSelector()
    (§
        lock.lock();
        try
        (§
            return coinSelector;
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; A coin selector is responsible for choosing which outputs to spend when creating transactions.  The default
     ; selector implements a policy of spending transactions that appeared in the best chain and pending transactions
     ; that were created by this wallet, but not others.  You can override the coin selector for any given send
     ; operation by changing {@link SendRequest#coinSelector}.
     ;;
#_public
    void setCoinSelector(CoinSelector coinSelector)
    (§
        lock.lock();
        try
        (§
            this.coinSelector = Preconditions.checkNotNull(coinSelector);
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Convenience wrapper for <tt>setCoinSelector(Wallet.AllowUnconfirmedCoinSelector.get())</tt>.  If this method
     ; is called on the wallet then transactions will be used for spending regardless of their confidence.  This can
     ; be dangerous - only use this if you absolutely know what you're doing!
     ;;
#_public
    void allowSpendingUnconfirmedTransactions()
    (§
        setCoinSelector(AllowUnconfirmedCoinSelector.get());
    )

    ;;;
     ; A custom {@link TransactionOutput} that is free standing.  This contains all the information
     ; required for spending without actually having all the linked data (i.e parent tx).
     ;
     ;;
#_private
    class FreeStandingTransactionOutput extends TransactionOutput
    (§
#_private
        UTXO output;
#_private
        int chainHeight;

        ;;;
         ; Construct a free standing Transaction Output.
         ; @param params The network parameters.
         ; @param output The stored output (free standing).
         ;;
#_public
        FreeStandingTransactionOutput(NetworkParameters params, UTXO output, int chainHeight)
        (§
            super(params, nil, output.getValue(), output.getScript().getProgram());

            this.output = output;
            this.chainHeight = chainHeight;
        )

        ;;;
         ; Get the {@link UTXO}.
         ; @return the stored output.
         ;;
#_public
        UTXO getUTXO()
        (§
            return output;
        )

        ;;;
         ; Get the depth within the chain of the parent tx, depth is 1 if the output height is the height
         ; of the latest block.
         ; @return the depth.
         ;;
#_override
#_public
        int getParentTransactionDepthInBlocks()
        (§
            return chainHeight - output.getHeight() + 1;
        )

#_override
#_public
        int getIndex()
        (§
            return (int) output.getIndex();
        )

#_override
#_public
        Sha256Hash getParentTransactionHash()
        (§
            return output.getHash();
        )
    )

#_private
#_static
    class TxOffsetPair implements Comparable<TxOffsetPair>
    (§
#_public
#_final
        Transaction tx;
#_public
#_final
        int offset;

#_public
        TxOffsetPair(Transaction tx, int offset)
        (§
            this.tx = tx;
            this.offset = offset;
        )

#_override
#_public
        int compareTo(TxOffsetPair o)
        (§
            ;; Note that in this implementation compareTo() is not consistent with equals().
            return Ints.compare(offset, o.offset);
        )
    )

    ;;;
     ; <p>Don't call this directly.  It's not intended for API users.</p>
     ;
     ; <p>Called by the {@link BlockChain} when the best chain (representing total work done) has changed.
     ; This can cause the number of confirmations of a transaction to go higher, lower, drop to zero and
     ; can even result in a transaction going dead (will never confirm) due to a double spend.</p>
     ;
     ; <p>The oldBlocks/newBlocks lists are ordered height-wise from top first to bottom last.</p>
     ;;
#_override
#_public
    void reorganize(StoredBlock splitPoint, List<StoredBlock> oldBlocks, List<StoredBlock> newBlocks)
        throws VerificationException
    (§
        lock.lock();
        try
        (§
            ;; This runs on any peer thread with the block chain locked.
            ;;
            ;; The reorganize functionality of the wallet is tested in ChainSplitTest.java
            ;;
            ;; receive() has been called on the block that is triggering the re-org before this is called,
            ;; with type of SIDE_CHAIN.
            ;;
            ;; Note that this code assumes blocks are not invalid - if blocks contain duplicated transactions,
            ;; transactions that double spend etc then we can calculate the incorrect result.  This could open up
            ;; obscure DoS attacks if someone successfully mines a throwaway invalid block and feeds it to us, just
            ;; to try and corrupt the internal data structures.  We should try harder to avoid this but it's tricky
            ;; because there are so many ways the block can be invalid.

            ;; Avoid spuriously informing the user of wallet/tx confidence changes whilst we're re-organizing.
            Preconditions.checkState(confidenceChanged.size() == 0);
            Preconditions.checkState(!insideReorg);
            insideReorg = true;
            Preconditions.checkState(onWalletChangedSuppressions == 0);
            onWalletChangedSuppressions++;

            ;; Map block hash to transactions that appear in it.  We ensure that the map values are sorted according
            ;; to their relative position within those blocks.
            ArrayListMultimap<Sha256Hash, TxOffsetPair> mapBlockTx = ArrayListMultimap.create();
            for (Transaction tx : getTransactions(true))
            (§
                Map<Sha256Hash, Integer> appearsIn = tx.getAppearsInHashes();
                if (appearsIn == nil)
                    continue; ;; Pending.
                for (Map.Entry<Sha256Hash, Integer> block : appearsIn.entrySet())
                    mapBlockTx.put(block.getKey(), new TxOffsetPair(tx, block.getValue()));
            )
            for (Sha256Hash blockHash : mapBlockTx.keySet())
                Collections.sort(mapBlockTx.get(blockHash));

            List<Sha256Hash> oldBlockHashes = new ArrayList<>(oldBlocks.size());
            log.info("Old part of chain (top to bottom):");
            for (StoredBlock b : oldBlocks)
            (§
                log.info("  {}", b.getHeader().getHashAsString());
                oldBlockHashes.add(b.getHeader().getHash());
            )
            log.info("New part of chain (top to bottom):");
            for (StoredBlock b : newBlocks)
                log.info("  {}", b.getHeader().getHashAsString());

            Collections.reverse(newBlocks); ;; Need bottom-to-top but we get top-to-bottom.

            ;; For each block in the old chain, disconnect the transactions in reverse order.
            LinkedList<Transaction> oldChainTxns = Lists.newLinkedList();
            for (Sha256Hash blockHash : oldBlockHashes)
            (§
                for (TxOffsetPair pair : mapBlockTx.get(blockHash))
                (§
                    Transaction tx = pair.tx;
#_final
                    Sha256Hash txHash = tx.getHash();
                    if (tx.isCoinBase())
                    (§
                        ;; All the transactions that we have in our wallet which spent this coinbase are now invalid
                        ;; and will never confirm.  Hopefully this should never happen - that's the point of the maturity
                        ;; rule that forbids spending of coinbase transactions for 100 blocks.
                        ;;
                        ;; This could be recursive, although of course because we don't have the full transaction
                        ;; graph we can never reliably kill all transactions we might have that were rooted in
                        ;; this coinbase tx.  Some can just go pending forever, like the Bitcoin Core.  However we
                        ;; can do our best.
                        log.warn("Coinbase killed by re-org: {}", tx.getHashAsString());
                        killTxns(ImmutableSet.of(tx), nil);
                    )
                    else
                    (§
                        for (TransactionOutput output : tx.getOutputs())
                        (§
                            TransactionInput input = output.getSpentBy();
                            if (input != nil)
                            (§
                                if (output.isMine(this))
                                    Preconditions.checkState(myUnspents.add(output));
                                input.disconnect();
                            )
                        )
                        oldChainTxns.add(tx);
                        unspent.remove(txHash);
                        spent.remove(txHash);
                        Preconditions.checkState(!pending.containsKey(txHash));
                        Preconditions.checkState(!dead.containsKey(txHash));
                    )
                )
            )

            ;; Put all the disconnected transactions back into the pending pool and re-connect them.
            for (Transaction tx : oldChainTxns)
            (§
                ;; Coinbase transactions on the old part of the chain are dead for good and won't come back unless
                ;; there's another re-org.
                if (tx.isCoinBase())
                    continue;
                log.info("  ->pending {}", tx.getHash());

                tx.getConfidence().setConfidenceType(ConfidenceType.PENDING); ;; Wipe height/depth/work data.
                confidenceChanged.put(tx, TransactionConfidence.Listener.ChangeReason.TYPE);
                addWalletTransaction(Pool.PENDING, tx);
                updateForSpends(tx, false);
            )

            ;; Note that dead transactions stay dead.  Consider a chain that Finney attacks T1 and replaces it with
            ;; T2, so we move T1 into the dead pool.  If there's now a re-org to a chain that doesn't include T2, it
            ;; doesn't matter - the miners deleted T1 from their mempool, will resurrect T2 and put that into the
            ;; mempool and so T1 is still seen as a losing double spend.

            ;; The old blocks have contributed to the depth for all the transactions in the
            ;; wallet that are in blocks up to and including the chain split block.
            ;; The total depth is calculated here and then subtracted from the appropriate transactions.
            int depthToSubtract = oldBlocks.size();
            log.info("depthToSubtract = " + depthToSubtract);
            ;; Remove depthToSubtract from all transactions in the wallet except for pending.
            subtractDepth(depthToSubtract, spent.values());
            subtractDepth(depthToSubtract, unspent.values());
            subtractDepth(depthToSubtract, dead.values());

            ;; The effective last seen block is now the split point so set the lastSeenBlockHash.
            setLastBlockSeenHash(splitPoint.getHeader().getHash());

            ;; For each block in the new chain, work forwards calling receive() and notifyNewBestBlock().
            ;; This will pull them back out of the pending pool, or if the tx didn't appear in the old chain
            ;; and does appear in the new chain, will treat it as such and possibly kill pending transactions
            ;; that conflict.
            for (StoredBlock block : newBlocks)
            (§
                log.info("Replaying block {}", block.getHeader().getHashAsString());
                for (TxOffsetPair pair : mapBlockTx.get(block.getHeader().getHash()))
                (§
                    log.info("  tx {}", pair.tx.getHash());
                    try
                    (§
                        receive(pair.tx, block, BlockChain.NewBlockType.BEST_CHAIN, pair.offset);
                    )
                    catch (ScriptException e)
                    (§
                        throw new RuntimeException(e); ;; Cannot happen as these blocks were already verified.
                    )
                )
                notifyNewBestBlock(block);
            )
            isConsistentOrThrow();
#_final
            Coin balance = getBalance();
            log.info("post-reorg balance is {}", balance.toFriendlyString());
            ;; Inform event listeners that a re-org took place.
            queueOnReorganize();
            insideReorg = false;
            onWalletChangedSuppressions--;
            maybeQueueOnWalletChanged();
            checkBalanceFuturesLocked(balance);
            informConfidenceListenersIfNotReorganizing();
            saveLater();
        )
        finally
        (§
            lock.unlock();
        )
    )

    ;;;
     ; Subtract the supplied depth from the given transactions.
     ;;
#_private
    void subtractDepth(int depthToSubtract, Collection<Transaction> transactions)
    (§
        for (Transaction tx : transactions)
        (§
            if (tx.getConfidence().getConfidenceType() == ConfidenceType.BUILDING)
            (§
                tx.getConfidence().setDepthInBlocks(tx.getConfidence().getDepthInBlocks() - depthToSubtract);
                confidenceChanged.put(tx, TransactionConfidence.Listener.ChangeReason.DEPTH);
            )
        )
    )

#_private
#_final
    ArrayList<TransactionOutPoint> bloomOutPoints = Lists.newArrayList();
    ;; Used to track whether we must automatically begin/end a filter calculation and calc outpoints/take the locks.
#_private
#_final
    AtomicInteger bloomFilterGuard = new AtomicInteger(0);

#_override
#_public
    void beginBloomFilterCalculation()
    (§
        if (1 < bloomFilterGuard.incrementAndGet())
            return;

        lock.lock();
        keyChainGroupLock.lock();
        ;; noinspection FieldAccessNotGuarded
        calcBloomOutPointsLocked();
    )

#_private
    void calcBloomOutPointsLocked()
    (§
        ;; TODO: This could be done once and then kept up to date.
        bloomOutPoints.clear();
        Set<Transaction> all = new HashSet<>();
        all.addAll(unspent.values());
        all.addAll(spent.values());
        all.addAll(pending.values());

        for (Transaction tx : all)
        (§
            for (TransactionOutput out : tx.getOutputs())
            (§
                try
                (§
                    if (isTxOutputBloomFilterable(out))
                        bloomOutPoints.add(out.getOutPointFor());
                )
                catch (ScriptException e)
                (§
                    ;; If it is ours, we parsed the script correctly, so this shouldn't happen.
                    throw new RuntimeException(e);
                )
            )
        )
    )

#_override
#_guarded-by("keyChainGroupLock")
#_public
    void endBloomFilterCalculation()
    (§
        if (0 < bloomFilterGuard.decrementAndGet())
            return;

        bloomOutPoints.clear();
        keyChainGroupLock.unlock();
        lock.unlock();
    )

    ;;;
     ; Returns the number of distinct data items (note: NOT keys) that will be inserted into a bloom filter,
     ; when it is constructed.
     ;;
#_override
#_public
    int getBloomFilterElementCount()
    (§
        beginBloomFilterCalculation();
        try
        (§
            return bloomOutPoints.size() + keyChainGroup.getBloomFilterElementCount();
        )
        finally
        (§
            endBloomFilterCalculation();
        )
    )

    ;;;
     ; Gets a bloom filter that contains all of the public keys from this wallet, and which will provide the given
     ; false-positive rate.  See the docs for {@link BloomFilter} for a brief explanation of anonymity when using filters.
     ;;
#_public
    BloomFilter getBloomFilter(double falsePositiveRate)
    (§
        beginBloomFilterCalculation();
        try
        (§
            return getBloomFilter(getBloomFilterElementCount(), falsePositiveRate, (long)(Math.random() * Long.MAX_VALUE));
        )
        finally
        (§
            endBloomFilterCalculation();
        )
    )

    ;;;
     ; <p>Gets a bloom filter that contains all of the public keys from this wallet, and which will provide the given
     ; false-positive rate if it has size elements.  Keep in mind that you will get 2 elements in the bloom filter for
     ; each key in the wallet, for the public key and the hash of the public key (address form).</p>
     ;
     ; <p>This is used to generate a BloomFilter which can be {@link BloomFilter#merge(BloomFilter)}d with another.
     ; It could also be used if you have a specific target for the filter's size.</p>
     ;
     ; <p>See the docs for {@link BloomFilter(int, double)} for a brief explanation of anonymity when using bloom
     ; filters.</p>
     ;;
#_override
#_guarded-by("keyChainGroupLock")
#_public
    BloomFilter getBloomFilter(int size, double falsePositiveRate, long nTweak)
    (§
        beginBloomFilterCalculation();
        try
        (§
            BloomFilter filter = keyChainGroup.getBloomFilter(size, falsePositiveRate, nTweak);
            for (TransactionOutPoint point : bloomOutPoints)
                filter.insert(point.unsafeBitcoinSerialize());
            return filter;
        )
        finally
        (§
            endBloomFilterCalculation();
        )
    )

    ;; Returns true if the output is one that won't be selected by a data element matching in the scriptSig.
#_private
    boolean isTxOutputBloomFilterable(TransactionOutput out)
    (§
        Script script = out.getScriptPubKey();
        boolean isScriptTypeSupported = (script.isSentToRawPubKey() || script.isPayToScriptHash());
        return (isScriptTypeSupported && myUnspents.contains(out));
    )

    ;;;
     ; Used by {@link Peer} to decide whether or not to discard this block and any blocks building upon it, in case
     ; the Bloom filter used to request them may be exhausted, that is, not have sufficient keys in the deterministic
     ; sequence within it to reliably find relevant transactions.
     ;;
#_public
    boolean checkForFilterExhaustion(FilteredBlock block)
    (§
        keyChainGroupLock.lock();
        try
        (§
            int epoch = keyChainGroup.getCombinedKeyLookaheadEpochs();
            for (Transaction tx : block.getAssociatedTransactions().values())
                markKeysAsUsed(tx);
            int newEpoch = keyChainGroup.getCombinedKeyLookaheadEpochs();
            Preconditions.checkState(epoch <= newEpoch);
            ;; If the key lookahead epoch has advanced, there was a call to importKeys and the PeerGroup already has a
            ;; pending request to recalculate the filter queued up on another thread.  The calling Peer should abandon
            ;; block at this point and await a new filter before restarting the download.
            return (epoch < newEpoch);
        )
        finally
        (§
            keyChainGroupLock.unlock();
        )
    )

#_override
#_public
    void setTag(String tag, ByteString value)
    (§
        super.setTag(tag, value);
        saveNow();
    )

#_private
#_static
    class FeeCalculation
    (§
        ;; Selected UTXOs to spend.
#_public
        CoinSelection bestCoinSelection;
        ;; Change output (may be null if no change).
#_public
        TransactionOutput bestChangeOutput;
        ;; List of output values adjusted downwards when recipients pay fees (may be null if no adjustment needed).
#_public
        List<Coin> updatedOutputValues;
    )

#_private
    FeeCalculation calculateFee(SendRequest req, Coin value, List<TransactionInput> originalInputs, boolean needAtLeastReferenceFee, List<TransactionOutput> candidates)
        throws InsufficientMoneyException
    (§
        Preconditions.checkState(lock.isHeldByCurrentThread());
        FeeCalculation result;
        Coin fee = Coin.ZERO;
        while (true)
        (§
            result = new FeeCalculation();
            Transaction tx = new Transaction(params);
            addSuppliedInputs(tx, req.tx.getInputs());

            Coin valueNeeded = value;
            if (!req.recipientsPayFees)
                valueNeeded = valueNeeded.add(fee);
            if (req.recipientsPayFees)
                result.updatedOutputValues = new ArrayList<Coin>();

            for (int i = 0; i < req.tx.getOutputs().size(); i++)
            (§
                TransactionOutput output = new TransactionOutput(params, tx, req.tx.getOutputs().get(i).bitcoinSerialize(), 0);
                if (req.recipientsPayFees)
                (§
                    ;; Subtract fee equally from each selected recipient.
                    output.setValue(output.getValue().subtract(fee.divide(req.tx.getOutputs().size())));
                    ;; First receiver pays the remainder not divisible by output count.
                    if (i == 0)
                    (§
                        ;; Subtract fee equally from each selected recipient.
                        output.setValue(output.getValue().subtract(fee.divideAndRemainder(req.tx.getOutputs().size())[1]));
                    )
                    result.updatedOutputValues.add(output.getValue());
                    if (output.getMinNonDustValue().isGreaterThan(output.getValue()))
                        throw new CouldNotAdjustDownwards();
                )
                tx.addOutput(output);
            )

            CoinSelector selector = (req.coinSelector == nil) ? coinSelector : req.coinSelector;
            ;; selector is allowed to modify candidates list.
            CoinSelection selection = selector.select(valueNeeded, new LinkedList<>(candidates));
            result.bestCoinSelection = selection;
            ;; Can we afford this?
            if (selection.valueGathered.compareTo(valueNeeded) < 0)
            (§
                Coin valueMissing = valueNeeded.subtract(selection.valueGathered);
                throw new InsufficientMoneyException(valueMissing);
            )

            Coin change = selection.valueGathered.subtract(valueNeeded);
            if (change.isGreaterThan(Coin.ZERO))
            (§
                ;; The value of the inputs is greater than what we want to send.  Just like in real life then,
                ;; we need to take back some coins ... this is called "change".  Add another output that sends the change
                ;; back to us.  The address comes either from the request or currentChangeAddress() as a default.
                Address changeAddress = req.changeAddress;
                if (changeAddress == nil)
                    changeAddress = currentChangeAddress();

                TransactionOutput changeOutput = new TransactionOutput(params, tx, change, changeAddress);
                if (req.recipientsPayFees && changeOutput.isDust())
                (§
                    ;; We do not move dust-change to fees, because the sender would end up paying more than requested.
                    ;; This would be against the purpose of the all-inclusive feature.
                    ;; So instead we raise the change and deduct from the first recipient.
                    Coin missingToNotBeDust = changeOutput.getMinNonDustValue().subtract(changeOutput.getValue());
                    changeOutput.setValue(changeOutput.getValue().add(missingToNotBeDust));
                    TransactionOutput firstOutput = tx.getOutputs().get(0);
                    firstOutput.setValue(firstOutput.getValue().subtract(missingToNotBeDust));
                    result.updatedOutputValues.set(0, firstOutput.getValue());
                    if (firstOutput.isDust())
                        throw new CouldNotAdjustDownwards();
                )

                if (changeOutput.isDust())
                (§
                    ;; Never create dust outputs; if we would, just add the dust to the fee.
                    ;; Oscar comment: This seems like a way to make the condition below "if (!fee.isLessThan(feeNeeded))" to become true.
                    ;; This is a non-easy to understand way to do that.
                    ;; Maybe there are other effects I am missing.
                    fee = fee.add(changeOutput.getValue());
                )
                else
                (§
                    tx.addOutput(changeOutput);
                    result.bestChangeOutput = changeOutput;
                )
            )

            for (TransactionOutput selectedOutput : selection.gathered)
            (§
                TransactionInput input = tx.addInput(selectedOutput);
                ;; If the scriptBytes don't default to none, our size calculations will be thrown off.
                Preconditions.checkState(input.getScriptBytes().length == 0);
            )

            int size = tx.unsafeBitcoinSerialize().length;
            size += estimateBytesForSigning(selection);

            Coin feePerKb = req.feePerKb;
            if (needAtLeastReferenceFee && feePerKb.compareTo(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE) < 0)
                feePerKb = Transaction.REFERENCE_DEFAULT_MIN_TX_FEE;

            Coin feeNeeded = feePerKb.multiply(size).divide(1000);

            if (!fee.isLessThan(feeNeeded))
            (§
                ;; Done, enough fee included.
                break;
            )

            ;; Include more fee and try again.
            fee = feeNeeded;
        )
        return result;
    )

#_private
    void addSuppliedInputs(Transaction tx, List<TransactionInput> originalInputs)
    (§
        for (TransactionInput input : originalInputs)
            tx.addInput(new TransactionInput(params, tx, input.bitcoinSerialize()));
    )

#_private
    int estimateBytesForSigning(CoinSelection selection)
    (§
        int size = 0;
        for (TransactionOutput output : selection.gathered)
        (§
            try
            (§
                Script script = output.getScriptPubKey();
                ECKey key = nil;
                Script redeemScript = nil;
                if (script.isSentToAddress())
                (§
                    key = findKeyFromPubHash(script.getPubKeyHash());
                    Preconditions.checkNotNull(key, "Coin selection includes unspendable outputs");
                )
                else if (script.isPayToScriptHash())
                (§
                    redeemScript = findRedeemDataFromScriptHash(script.getPubKeyHash()).redeemScript;
                    Preconditions.checkNotNull(redeemScript, "Coin selection includes unspendable outputs");
                )
                size += script.getNumberOfBytesRequiredToSpend(key, redeemScript);
            )
            catch (ScriptException e)
            (§
                ;; If this happens it means an output script in a wallet tx could not be understood.  That
                ;; should never happen, if it does it means the wallet has got into an inconsistent state.
                throw new IllegalStateException(e);
            )
        )
        return size;
    )

    ;; Wallet maintenance transactions.  These transactions may not be directly connected to a payment the user is
    ;; making.  They may be instead key rotation transactions for when old keys are suspected to be compromised,
    ;; de/re-fragmentation transactions for when our output sizes are inappropriate or suboptimal, privacy transactions
    ;; and so on.  Because these transactions may require user intervention in some way (e.g. entering their password)
    ;; the wallet application is expected to poll the Wallet class to get SendRequests.  Ideally security systems like
    ;; hardware wallets or risk analysis providers are programmed to auto-approve transactions that send from our own
    ;; keys back to our own keys.

    ;;;
     ; <p>Specifies that the given {@link TransactionBroadcaster}, typically a {@link PeerGroup}, should be used for
     ; sending transactions to the Bitcoin network by default.  Some sendCoins methods let you specify a broadcaster
     ; explicitly, in that case, they don't use this broadcaster.  If null is specified then the wallet won't attempt
     ; to broadcast transactions itself.</p>
     ;
     ; <p>You don't normally need to call this.  A {@link PeerGroup} will automatically set itself as the wallets
     ; broadcaster when you use {@link PeerGroup#addWallet(Wallet)}.  A wallet can use the broadcaster when you ask
     ; it to send money, but in future also at other times to implement various features that may require asynchronous
     ; re-organisation of the wallet contents on the block chain.  For instance, in future the wallet may choose to
     ; optimise itself to reduce fees or improve privacy.</p>
     ;;
#_public
    void setTransactionBroadcaster(#_nilable org.bitcoinj.core.TransactionBroadcaster broadcaster)
    (§
        Transaction[] toBroadcast = {};
        lock.lock();
        try
        (§
            if (vTransactionBroadcaster == broadcaster)
                return;
            vTransactionBroadcaster = broadcaster;
            if (broadcaster == nil)
                return;
            toBroadcast = pending.values().toArray(toBroadcast);
        )
        finally
        (§
            lock.unlock();
        )
        ;; Now use it to upload any pending transactions we have that are marked as not being seen by any peers yet.
        ;; Don't hold the wallet lock whilst doing this, so if the broadcaster accesses the wallet at some point there
        ;; is no inversion.
        for (Transaction tx : toBroadcast)
        (§
            ConfidenceType confidenceType = tx.getConfidence().getConfidenceType();
            Preconditions.checkState(confidenceType == ConfidenceType.PENDING || confidenceType == ConfidenceType.IN_CONFLICT, "Expected PENDING or IN_CONFLICT, was %s.", confidenceType);
            ;; Re-broadcast even if it's marked as already seen for two reasons:
            ;; 1) Old wallets may have transactions marked as broadcast by 1 peer when
            ;;    in reality the network never saw it, due to bugs.
            ;; 2) It can't really hurt.
            log.info("New broadcaster so uploading waiting tx {}", tx.getHash());
            broadcaster.broadcastTransaction(tx);
        )
    )

    ;;;
     ; When a key rotation time is set, and money controlled by keys created before the given timestamp T will be
     ; automatically respent to any key that was created after T.  This can be used to recover from a situation where
     ; a set of keys is believed to be compromised.  Once the time is set transactions will be created and broadcast
     ; immediately.  New coins that come in after calling this method will be automatically respent immediately.
     ; The rotation time is persisted to the wallet. You can stop key rotation by calling this method again with zero
     ; as the argument.
     ;;
#_public
    void setKeyRotationTime(Date time)
    (§
        setKeyRotationTime(time.getTime() / 1000);
    )

    ;;;
     ; Returns the key rotation time, or null if unconfigured.
     ; See {@link #setKeyRotationTime(Date)} for a description of the field.
     ;;
#_public
    #_nilable Date getKeyRotationTime()
    (§
#_final
        long keyRotationTimestamp = vKeyRotationTimestamp;
        return (keyRotationTimestamp != 0) ? new Date(keyRotationTimestamp * 1000) : nil;
    )

    ;;;
     ; <p>When a key rotation time is set, any money controlled by keys created before the given timestamp T will be
     ; automatically respent to any key that was created after T.  This can be used to recover from a situation where
     ; a set of keys is believed to be compromised.  You can stop key rotation by calling this method again with zero
     ; as the argument.  Once set up, calling {@link #doMaintenance(org.spongycastle.crypto.params.KeyParameter, boolean)}
     ; will create and possibly send rotation transactions: but it won't be done automatically (because you might have
     ; to ask for the users password).</p>
     ;
     ; <p>The given time cannot be in the future.</p>
     ;;
#_public
    void setKeyRotationTime(long unixTimeSeconds)
    (§
        Preconditions.checkArgument(unixTimeSeconds <= Utils.currentTimeSeconds(), "Given time (%s) cannot be in the future.", Utils.dateTimeFormat(unixTimeSeconds * 1000));
        vKeyRotationTimestamp = unixTimeSeconds;
        saveNow();
    )

    ;;; Returns whether the keys creation time is before the key rotation time, if one was set. ;;
#_public
    boolean isKeyRotating(ECKey key)
    (§
        long time = vKeyRotationTimestamp;
        return (time != 0 && key.getCreationTimeSeconds() < time);
    )

    ;;;
     ; A wallet app should call this from time to time in order to let the wallet craft and send transactions needed
     ; to re-organise coins internally.  A good time to call this would be after receiving coins for an unencrypted
     ; wallet, or after sending money for an encrypted wallet.  If you have an encrypted wallet and just want to know
     ; if some maintenance needs doing, call this method with andSend set to false and look at the returned list of
     ; transactions.  Maintenance might also include internal changes that involve some processing or work but
     ; which don't require making transactions - these will happen automatically unless the password is required
     ; in which case an exception will be thrown.
     ;
     ; @param aesKey The users password, if any.
     ; @param signAndSend If true, send the transactions via the tx broadcaster and return them, if false just return them.
     ; @return a list of transactions that the wallet just made/will make for internal maintenance.  Might be empty.
     ; @throws org.bitcoinj.wallet.DeterministicUpgradeRequiresPassword if key rotation requires the users password.
     ;;
#_public
    ListenableFuture<List<Transaction>> doMaintenance(#_nilable KeyParameter aesKey, boolean signAndSend)
        throws DeterministicUpgradeRequiresPassword
    (§
        List<Transaction> txns;
        lock.lock();
        keyChainGroupLock.lock();
        try
        (§
            txns = maybeRotateKeys(aesKey, signAndSend);
            if (!signAndSend)
                return Futures.immediateFuture(txns);
        )
        finally
        (§
            keyChainGroupLock.unlock();
            lock.unlock();
        )
        Preconditions.checkState(!lock.isHeldByCurrentThread());
        ArrayList<ListenableFuture<Transaction>> futures = new ArrayList<>(txns.size());
        TransactionBroadcaster broadcaster = vTransactionBroadcaster;
        for (Transaction tx : txns)
        (§
            try
            (§
#_final
                ListenableFuture<Transaction> future = broadcaster.broadcastTransaction(tx).future();
                futures.add(future);
                Futures.addCallback(future, new FutureCallback<Transaction>()
                (§
#_override
#_public
                    void onSuccess(Transaction transaction)
                    (§
                        log.info("Successfully broadcast key rotation tx: {}", transaction);
                    )

#_override
#_public
                    void onFailure(Throwable throwable)
                    (§
                        log.error("Failed to broadcast key rotation tx", throwable);
                    )
                ));
            )
            catch (Exception e)
            (§
                log.error("Failed to broadcast rekey tx", e);
            )
        )
        return Futures.allAsList(futures);
    )

    ;; Checks to see if any coins are controlled by rotating keys and if so, spends them.
#_guarded-by("keyChainGroupLock")
#_private
    List<Transaction> maybeRotateKeys(#_nilable KeyParameter aesKey, boolean sign)
        throws DeterministicUpgradeRequiresPassword
    (§
        Preconditions.checkState(lock.isHeldByCurrentThread());
        Preconditions.checkState(keyChainGroupLock.isHeldByCurrentThread());

        List<Transaction> results = Lists.newLinkedList();
        ;; TODO: Handle chain replays here.
#_final
        long keyRotationTimestamp = vKeyRotationTimestamp;
        if (keyRotationTimestamp == 0)
            return results; ;; Nothing to do.

        ;; We might have to create a new HD hierarchy if the previous ones are now rotating.
        boolean allChainsRotating = true;
        for (DeterministicKeyChain chain : keyChainGroup.getDeterministicKeyChains())
        (§
            if (keyRotationTimestamp <= chain.getEarliestKeyCreationTime())
            (§
                allChainsRotating = false;
                break;
            )
        )
        if (allChainsRotating)
        (§
            try
            (§
                if (keyChainGroup.getImportedKeys().isEmpty())
                (§
                    log.info("All HD chains are currently rotating and we have no random keys, creating fresh HD chain ...");
                    keyChainGroup.createAndActivateNewHDChain();
                )
                else
                (§
                    log.info("All HD chains are currently rotating, attempting to create a new one from the next oldest non-rotating key material ...");
                    keyChainGroup.upgradeToDeterministic(keyRotationTimestamp, aesKey);
                    log.info(" ... upgraded to HD again, based on next best oldest key.");
                )
            )
            catch (AllRandomKeysRotating _)
            (§
                log.info(" ... no non-rotating random keys available, generating entirely new HD tree: backup required after this.");
                keyChainGroup.createAndActivateNewHDChain();
            )
            saveNow();
        )

        ;; Because transactions are size limited, we might not be able to re-key the entire wallet in one go.  So loop
        ;; around here until we no longer produce transactions with the max number of inputs.  That means we're fully
        ;; done, at least for now (we may still get more transactions later and this method will be reinvoked).
        Transaction tx;
        do
        (§
            tx = rekeyOneBatch(keyRotationTimestamp, aesKey, results, sign);
            if (tx != nil)
                results.add(tx);
        )
        while (tx != nil && tx.getInputs().size() == KeyTimeCoinSelector.MAX_SIMULTANEOUS_INPUTS);

        return results;
    )

#_nilable
#_private
    Transaction rekeyOneBatch(long timeSecs, #_nilable KeyParameter aesKey, List<Transaction> others, boolean sign)
    (§
        lock.lock();
        try
        (§
            ;; Build the transaction using some custom logic for our special needs.  Last parameter to
            ;; KeyTimeCoinSelector is whether to ignore pending transactions or not.
            ;;
            ;; We ignore pending outputs because trying to rotate these is basically racing an attacker, and
            ;; we're quite likely to lose and create stuck double spends.  Also, some users who have 0.9 wallets
            ;; have already got stuck double spends in their wallet due to the Bloom-filtering block reordering
            ;; bug that was fixed in 0.10, thus, making a re-key transaction depend on those would cause it to
            ;; never confirm at all.
            CoinSelector keyTimeSelector = new KeyTimeCoinSelector(this, timeSecs, true);
            FilteringCoinSelector selector = new FilteringCoinSelector(keyTimeSelector);
            for (Transaction other : others)
                selector.excludeOutputsSpentBy(other);
            ;; TODO: Make this use the standard SendRequest.
            CoinSelection toMove = selector.select(Coin.ZERO, calculateAllSpendCandidates());
            if (toMove.valueGathered.equals(Coin.ZERO))
                return nil; ;; Nothing to do.

            maybeUpgradeToHD(aesKey);
            Transaction rekeyTx = new Transaction(params);
            for (TransactionOutput output : toMove.gathered)
                rekeyTx.addInput(output);
            ;; When not signing, don't waste addresses.
            rekeyTx.addOutput(toMove.valueGathered, sign ? freshReceiveAddress() : currentReceiveAddress());
            if (!adjustOutputDownwardsForFee(rekeyTx, toMove, Transaction.DEFAULT_TX_FEE, true))
            (§
                log.error("Failed to adjust rekey tx for fees.");
                return nil;
            )

            rekeyTx.getConfidence().setSource(TransactionConfidence.Source.SELF);
            rekeyTx.setPurpose(Transaction.Purpose.KEY_ROTATION);
            SendRequest req = SendRequest.forTx(rekeyTx);
            req.aesKey = aesKey;
            if (sign)
                signTransaction(req);
            ;; KeyTimeCoinSelector should never select enough inputs to push us oversize.
            Preconditions.checkState(rekeyTx.unsafeBitcoinSerialize().length < Transaction.MAX_STANDARD_TX_SIZE);
            return rekeyTx;
        )
        catch (VerificationException e)
        (§
            throw new RuntimeException(e); ;; Cannot happen.
        )
        finally
        (§
            lock.unlock();
        )
    )
)

(ns org.bitcoinj.wallet #_"WalletFiles"
    (:import #_[java.io *]
             [java.util Date]
             #_[java.util.concurrent *]
             #_[java.util.concurrent.atomic *])
    (:import [com.google.common.base Preconditions Stopwatch]
             #_[org.slf4j *])
  #_(:require #_[org.bitcoinj.core *]
             #_[org.bitcoinj.utils *]))

;;;
 ; A class that handles atomic and optionally delayed writing of the wallet file to disk.  In future: backups too.
 ; It can be useful to delay writing of a wallet file to disk on slow devices where disk and serialization overhead
 ; can come to dominate the chain processing speed, i.e. on Android phones.  By coalescing writes and doing
 ; serialization and disk IO on a background thread performance can be improved.
 ;;
#_public
class WalletFiles
(§
#_private
#_static
#_final
    Logger log = LoggerFactory.getLogger(WalletFiles.class);

#_private
#_final
    Wallet wallet;
#_private
#_final
    ScheduledThreadPoolExecutor executor;
#_private
#_final
    File file;
#_private
#_final
    AtomicBoolean savePending;
#_private
#_final
    long delay;
#_private
#_final
    TimeUnit delayTimeUnit;
#_private
#_final
    Callable<Void> saver;

#_private
#_volatile
    Listener vListener;

    ;;;
     ; Implementors can do pre/post treatment of the wallet file.  Useful for adjusting permissions and other things.
     ;;
#_public
    interface Listener
    (§
        ;;;
         ; Called on the auto-save thread when a new temporary file is created but before the wallet data is saved
         ; to it.  If you want to do something here like adjust permissions, go ahead and do so.
         ;;
        void onBeforeAutoSave(File tempFile);

        ;;;
         ; Called on the auto-save thread after the newly created temporary file has been filled with data and renamed.
         ;;
        void onAfterAutoSave(File newlySavedFile);
    )

    ;;;
     ; Initialize atomic and optionally delayed writing of the wallet file to disk.  Note the initial wallet state isn't
     ; saved automatically.  The {@link Wallet} calls {@link #saveNow()} or {@link #saveLater()} as wallet state changes,
     ; depending on the urgency of the changes.
     ;;
#_public
    WalletFiles(final Wallet wallet, File file, long delay, TimeUnit delayTimeUnit)
    (§
        ;; An executor that starts up threads when needed and shuts them down later.
        this.executor = new ScheduledThreadPoolExecutor(1, new ContextPropagatingThreadFactory("Wallet autosave thread", Thread.MIN_PRIORITY));
        this.executor.setKeepAliveTime(5, TimeUnit.SECONDS);
        this.executor.allowCoreThreadTimeOut(true);
        this.executor.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);
        this.wallet = Preconditions.checkNotNull(wallet);
        ;; File must only be accessed from the auto-save executor from now on, to avoid simultaneous access.
        this.file = Preconditions.checkNotNull(file);
        this.savePending = new AtomicBoolean();
        this.delay = delay;
        this.delayTimeUnit = Preconditions.checkNotNull(delayTimeUnit);

        this.saver = new Callable<Void>()
        (§
#_override
#_public
            Void call() throws Exception
            (§
                ;; Runs in an auto save thread.
                if (!savePending.getAndSet(false))
                (§
                    ;; Some other scheduled request already beat us to it.
                    return nil;
                )
                Date lastBlockSeenTime = wallet.getLastBlockSeenTime();
                log.info("Background saving wallet; last seen block is height {}, date {}, hash {}",
                        wallet.getLastBlockSeenHeight(),
                        (lastBlockSeenTime != nil) ? Utils.dateTimeFormat(lastBlockSeenTime) : "unknown",
                        wallet.getLastBlockSeenHash());
                saveNowInternal();
                return nil;
            )
        );
    )

    ;;;
     ; The given listener will be called on the autosave thread before and after the wallet is saved to disk.
     ;;
#_public
    void setListener(#_non-nil Listener listener)
    (§
        this.vListener = Preconditions.checkNotNull(listener);
    )

    ;;; Actually write the wallet file to disk, using an atomic rename when possible.  Runs on the current thread. ;;
#_public
    void saveNow()
        throws IOException
    (§
        ;; Can be called by any thread. However the wallet is locked whilst saving, so we can have two saves
        ;; in flight, but they will serialize (using different temp files).
        Date lastBlockSeenTime = wallet.getLastBlockSeenTime();
        log.info("Saving wallet; last seen block is height {}, date {}, hash {}",
                wallet.getLastBlockSeenHeight(),
                (lastBlockSeenTime != nil) ? Utils.dateTimeFormat(lastBlockSeenTime) : "unknown",
                wallet.getLastBlockSeenHash());
        saveNowInternal();
    )

#_private
    void saveNowInternal()
        throws IOException
    (§
#_final
        Stopwatch watch = Stopwatch.createStarted();
        File directory = file.getAbsoluteFile().getParentFile();
        File temp = File.createTempFile("wallet", nil, directory);
#_final
        Listener listener = vListener;
        if (listener != nil)
            listener.onBeforeAutoSave(temp);
        wallet.saveToFile(temp, file);
        if (listener != nil)
            listener.onAfterAutoSave(file);
        watch.stop();
        log.info("Save completed in {}", watch);
    )

    ;;; Queues up a save in the background.  Useful for not very important wallet changes. ;;
#_public
    void saveLater()
    (§
        if (savePending.getAndSet(true))
            return; ;; Already pending.

        executor.schedule(saver, delay, delayTimeUnit);
    )

    ;;; Shut down auto-saving. ;;
#_public
    void shutdownAndWait()
    (§
        executor.shutdown();
        try
        (§
            executor.awaitTermination(Long.MAX_VALUE, TimeUnit.DAYS); ;; forever
        )
        catch (InterruptedException e)
        (§
            throw new RuntimeException(e);
        )
    )
)

(ns org.bitcoinj.wallet #_"WalletProtobufSerializer"
    (:import [java.io IOException InputStream OutputStream]
             [java.math BigInteger]
             [java.net InetAddress UnknownHostException]
             #_[java.util *])
    (:import [com.google.common.base Preconditions]
             [com.google.common.collect Lists]
             [com.google.protobuf ByteString CodedInputStream CodedOutputStream TextFormat WireFormat]
             [org.slf4j Logger LoggerFactory])
  #_(:require #_[org.bitcoinj.core *]
             [org.bitcoinj.core.TransactionConfidence ConfidenceType]
             [org.bitcoinj.crypto KeyCrypter KeyCrypterScrypt]
             [org.bitcoinj.script Script]
             [org.bitcoinj.signers LocalTransactionSigner TransactionSigner]
             [org.bitcoinj.utils ExchangeRate Fiat]
             [org.bitcoinj.wallet.Protos.Wallet EncryptionType]))

;;;
 ; Serialize and de-serialize a wallet to a byte stream containing a
 ; <a href="https://developers.google.com/protocol-buffers/docs/overview">protocol buffer</a>.  Protocol buffers are
 ; a data interchange format developed by Google with an efficient binary representation, a type safe specification
 ; language and compilers that generate code to work with those data structures for many languages.  Protocol buffers
 ; can have their format evolved over time: conceptually they represent data using (tag, length, value) tuples.  The
 ; format is defined by the <tt>wallet.proto</tt> file in the bitcoinj source distribution.
 ;
 ; This class is used through its static methods.  The most common operations are writeWallet and readWallet, which do
 ; the obvious operations on Output/InputStreams.  You can use a {@link java.io.ByteArrayInputStream} and equivalent
 ; {@link java.io.ByteArrayOutputStream} if you'd like byte arrays instead.  The protocol buffer can also be manipulated
 ; in its object form if you'd like to modify the flattened data structure before serialization to binary.
 ;
 ; You can extend the wallet format with additional fields specific to your application if you want, but make sure
 ; to either put the extra data in the provided extension areas, or select tag numbers that are unlikely to be used
 ; by anyone else.
 ;
 ; @author Miron Cuperman
 ; @author Andreas Schildbach
 ;;
#_public
class WalletProtobufSerializer
(§
#_private
#_static
#_final
    Logger log = LoggerFactory.getLogger(WalletProtobufSerializer.class);

    ;;; Current version used for serializing wallets.  A version higher than this is considered from the future. ;;
#_public
#_static
#_final
    int CURRENT_WALLET_VERSION = Protos.Wallet.getDefaultInstance().getVersion();
    ;; 512 MB
#_private
#_static
#_final
    int WALLET_SIZE_LIMIT = 512 * 1024 * 1024;
    ;; Used for de-serialization.
#_protected
    Map<ByteString, Transaction> txMap;

#_private
    int walletWriteBufferSize = CodedOutputStream.DEFAULT_BUFFER_SIZE;

#_public
    interface WalletFactory
    (§
        Wallet create(NetworkParameters params, KeyChainGroup keyChainGroup);
    )

#_private
#_final
    WalletFactory factory;
#_private
    KeyChainFactory keyChainFactory;

#_public
    WalletProtobufSerializer()
    (§
        this(new WalletFactory()
        (§
#_override
#_public
            Wallet create(NetworkParameters params, KeyChainGroup keyChainGroup)
            (§
                return new Wallet(params, keyChainGroup);
            )
        ));
    )

#_public
    WalletProtobufSerializer(WalletFactory factory)
    (§
        txMap = new HashMap<>();
        this.factory = factory;
        this.keyChainFactory = new DefaultKeyChainFactory();
    )

#_public
    void setKeyChainFactory(KeyChainFactory keyChainFactory)
    (§
        this.keyChainFactory = keyChainFactory;
    )

    ;;;
     ; Change buffer size for writing wallet to output stream.
     ; Default is {@link com.google.protobuf.CodedOutputStream.DEFAULT_BUFFER_SIZE}.
     ; @param walletWriteBufferSize Buffer size in bytes.
     ;;
#_public
    void setWalletWriteBufferSize(int walletWriteBufferSize)
    (§
        this.walletWriteBufferSize = walletWriteBufferSize;
    )

    ;;;
     ; Formats the given wallet (transactions and keys) to the given output stream in protocol buffer format.
     ;
     ; Equivalent to <tt>walletToProto(wallet).writeTo(output)</tt>.
     ;;
#_public
    void writeWallet(Wallet wallet, OutputStream output)
        throws IOException
    (§
        Protos.Wallet walletProto = walletToProto(wallet);
#_final
        CodedOutputStream codedOutput = CodedOutputStream.newInstance(output, this.walletWriteBufferSize);
        walletProto.writeTo(codedOutput);
        codedOutput.flush();
    )

    ;;;
     ; Returns the given wallet formatted as text.  The text format is that used by protocol buffers and although
     ; it can also be parsed using {@link TextFormat#merge(CharSequence, com.google.protobuf.Message.Builder)},
     ; it is designed more for debugging than storage.  It is not well specified and wallets are largely binary data
     ; structures anyway, consisting as they do of keys (large random numbers) and {@link Transaction}s which also
     ; mostly contain keys and hashes.
     ;;
#_public
    String walletToText(Wallet wallet)
    (§
        Protos.Wallet walletProto = walletToProto(wallet);
        return TextFormat.printToString(walletProto);
    )

    ;;;
     ; Converts the given wallet to the object representation of the protocol buffers.  This can be modified, or
     ; additional data fields set, before serialization takes place.
     ;;
#_public
    Protos.Wallet walletToProto(Wallet wallet)
    (§
        Protos.Wallet.Builder walletBuilder = Protos.Wallet.newBuilder();
        walletBuilder.setNetworkIdentifier(wallet.getNetworkParameters().getId());
        if (wallet.getDescription() != nil)
            walletBuilder.setDescription(wallet.getDescription());

        for (WalletTransaction wtx : wallet.getWalletTransactions())
        (§
            Protos.Transaction txProto = makeTxProto(wtx);
            walletBuilder.addTransaction(txProto);
        )

        walletBuilder.addAllKey(wallet.serializeKeyChainGroupToProtobuf());

        ;; Populate the lastSeenBlockHash field.
        Sha256Hash lastSeenBlockHash = wallet.getLastBlockSeenHash();
        if (lastSeenBlockHash != nil)
        (§
            walletBuilder.setLastSeenBlockHash(hashToByteString(lastSeenBlockHash));
            walletBuilder.setLastSeenBlockHeight(wallet.getLastBlockSeenHeight());
        )
        if (0 < wallet.getLastBlockSeenTimeSecs())
            walletBuilder.setLastSeenBlockTimeSecs(wallet.getLastBlockSeenTimeSecs());

        ;; Populate the scrypt parameters.
        KeyCrypter keyCrypter = wallet.getKeyCrypter();
        if (keyCrypter == nil)
        (§
            ;; The wallet is unencrypted.
            walletBuilder.setEncryptionType(EncryptionType.UNENCRYPTED);
        )
        else
        (§
            ;; The wallet is encrypted.
            walletBuilder.setEncryptionType(keyCrypter.getUnderstoodEncryptionType());
            if (keyCrypter instanceof KeyCrypterScrypt)
            (§
                KeyCrypterScrypt keyCrypterScrypt = (KeyCrypterScrypt)keyCrypter;
                walletBuilder.setEncryptionParameters(keyCrypterScrypt.getScryptParameters());
            )
            else
            (§
                ;; Some other form of encryption has been specified that we do not know how to persist.
                throw new RuntimeException("The wallet has encryption of type '" + keyCrypter.getUnderstoodEncryptionType() + "' but this WalletProtobufSerializer does not know how to persist this.");
            )
        )

        if (wallet.getKeyRotationTime() != nil)
        (§
            long timeSecs = wallet.getKeyRotationTime().getTime() / 1000;
            walletBuilder.setKeyRotationTime(timeSecs);
        )

        for (Map.Entry<String, ByteString> entry : wallet.getTags().entrySet())
        (§
            Protos.Tag.Builder tag = Protos.Tag.newBuilder().setTag(entry.getKey()).setData(entry.getValue());
            walletBuilder.addTags(tag);
        )

        for (TransactionSigner signer : wallet.getTransactionSigners())
        (§
            ;; Do not serialize LocalTransactionSigner as it's being added implicitly.
            if (signer instanceof LocalTransactionSigner)
                continue;

            Protos.TransactionSigner.Builder protoSigner = Protos.TransactionSigner.newBuilder();
            protoSigner.setClassName(signer.getClass().getName());
            protoSigner.setData(ByteString.copyFrom(signer.serialize()));
            walletBuilder.addTransactionSigners(protoSigner);
        )

        ;; Populate the wallet version.
        walletBuilder.setVersion(wallet.getVersion());

        return walletBuilder.build();
    )

#_private
#_static
    Protos.Transaction makeTxProto(WalletTransaction wtx)
    (§
        Transaction tx = wtx.getTransaction();
        Protos.Transaction.Builder txBuilder = Protos.Transaction.newBuilder();

        txBuilder.setPool(getProtoPool(wtx))
                 .setHash(hashToByteString(tx.getHash()))
                 .setVersion((int)tx.getVersion());

        if (tx.getUpdateTime() != nil)
            txBuilder.setUpdatedAt(tx.getUpdateTime().getTime());

        if (0 < tx.getLockTime())
            txBuilder.setLockTime((int)tx.getLockTime());

        ;; Handle inputs.
        for (TransactionInput input : tx.getInputs())
        (§
            Protos.TransactionInput.Builder inputBuilder = Protos.TransactionInput.newBuilder()
                .setScriptBytes(ByteString.copyFrom(input.getScriptBytes()))
                .setTransactionOutPointHash(hashToByteString(input.getOutpoint().getHash()))
                .setTransactionOutPointIndex((int)input.getOutpoint().getIndex());
            if (input.hasSequence())
                inputBuilder.setSequence((int)input.getSequenceNumber());
            if (input.getValue() != nil)
                inputBuilder.setValue(input.getValue().value);
            txBuilder.addTransactionInput(inputBuilder);
        )

        ;; Handle outputs.
        for (TransactionOutput output : tx.getOutputs())
        (§
            Protos.TransactionOutput.Builder outputBuilder = Protos.TransactionOutput.newBuilder()
                .setScriptBytes(ByteString.copyFrom(output.getScriptBytes()))
                .setValue(output.getValue().value);
#_final
            TransactionInput spentBy = output.getSpentBy();
            if (spentBy != nil)
            (§
                Sha256Hash spendingHash = spentBy.getParentTransaction().getHash();
                int spentByTransactionIndex = spentBy.getParentTransaction().getInputs().indexOf(spentBy);
                outputBuilder.setSpentByTransactionHash(hashToByteString(spendingHash))
                             .setSpentByTransactionIndex(spentByTransactionIndex);
            )
            txBuilder.addTransactionOutput(outputBuilder);
        )

        ;; Handle which blocks tx was seen in.
#_final
        Map<Sha256Hash, Integer> appearsInHashes = tx.getAppearsInHashes();
        if (appearsInHashes != nil)
        (§
            for (Map.Entry<Sha256Hash, Integer> entry : appearsInHashes.entrySet())
            (§
                txBuilder.addBlockHash(hashToByteString(entry.getKey()));
                txBuilder.addBlockRelativityOffsets(entry.getValue());
            )
        )

        if (tx.hasConfidence())
        (§
            TransactionConfidence confidence = tx.getConfidence();
            Protos.TransactionConfidence.Builder confidenceBuilder = Protos.TransactionConfidence.newBuilder();
            writeConfidence(txBuilder, confidence, confidenceBuilder);
        )

        Protos.Transaction.Purpose purpose;
        switch (tx.getPurpose())
        (§
            case UNKNOWN: purpose = Protos.Transaction.Purpose.UNKNOWN; break;
            case USER_PAYMENT: purpose = Protos.Transaction.Purpose.USER_PAYMENT; break;
            case KEY_ROTATION: purpose = Protos.Transaction.Purpose.KEY_ROTATION; break;
            case ASSURANCE_CONTRACT_CLAIM: purpose = Protos.Transaction.Purpose.ASSURANCE_CONTRACT_CLAIM; break;
            case ASSURANCE_CONTRACT_PLEDGE: purpose = Protos.Transaction.Purpose.ASSURANCE_CONTRACT_PLEDGE; break;
            case ASSURANCE_CONTRACT_STUB: purpose = Protos.Transaction.Purpose.ASSURANCE_CONTRACT_STUB; break;
            case RAISE_FEE: purpose = Protos.Transaction.Purpose.RAISE_FEE; break;
            default:
                throw new RuntimeException("New tx purpose serialization not implemented.");
        )
        txBuilder.setPurpose(purpose);

        ExchangeRate exchangeRate = tx.getExchangeRate();
        if (exchangeRate != nil)
        (§
            Protos.ExchangeRate.Builder exchangeRateBuilder = Protos.ExchangeRate.newBuilder()
                    .setCoinValue(exchangeRate.coin.value).setFiatValue(exchangeRate.fiat.value)
                    .setFiatCurrencyCode(exchangeRate.fiat.currencyCode);
            txBuilder.setExchangeRate(exchangeRateBuilder);
        )

        if (tx.getMemo() != nil)
            txBuilder.setMemo(tx.getMemo());

        return txBuilder.build();
    )

#_private
#_static
    Protos.Transaction.Pool getProtoPool(WalletTransaction wtx)
    (§
        switch (wtx.getPool())
        (§
            case UNSPENT: return Protos.Transaction.Pool.UNSPENT;
            case SPENT: return Protos.Transaction.Pool.SPENT;
            case DEAD: return Protos.Transaction.Pool.DEAD;
            case PENDING: return Protos.Transaction.Pool.PENDING;
            default:
                throw new RuntimeException("Unreachable");
        )
    )

#_private
#_static
    void writeConfidence(Protos.Transaction.Builder txBuilder, TransactionConfidence confidence, Protos.TransactionConfidence.Builder confidenceBuilder)
    (§
#_synchronized
        (confidence)
        (§
            confidenceBuilder.setType(Protos.TransactionConfidence.Type.valueOf(confidence.getConfidenceType().getValue()));
            if (confidence.getConfidenceType() == ConfidenceType.BUILDING)
            (§
                confidenceBuilder.setAppearedAtHeight(confidence.getAppearedAtChainHeight());
                confidenceBuilder.setDepth(confidence.getDepthInBlocks());
            )
            if (confidence.getConfidenceType() == ConfidenceType.DEAD)
            (§
                ;; Copy in the overriding transaction, if available.
                ;; (A dead coinbase transaction has no overriding transaction).
                if (confidence.getOverridingTransaction() != nil)
                (§
                    Sha256Hash overridingHash = confidence.getOverridingTransaction().getHash();
                    confidenceBuilder.setOverridingTransaction(hashToByteString(overridingHash));
                )
            )
            TransactionConfidence.Source source = confidence.getSource();
            switch (source)
            (§
                case SELF: confidenceBuilder.setSource(Protos.TransactionConfidence.Source.SOURCE_SELF); break;
                case NETWORK: confidenceBuilder.setSource(Protos.TransactionConfidence.Source.SOURCE_NETWORK); break;
                case UNKNOWN:
                    ;; Fall through.
                default:
                    confidenceBuilder.setSource(Protos.TransactionConfidence.Source.SOURCE_UNKNOWN); break;
            )
        )

        for (PeerAddress address : confidence.getBroadcastBy())
        (§
            Protos.PeerAddress proto = Protos.PeerAddress.newBuilder()
                    .setIpAddress(ByteString.copyFrom(address.getAddr().getAddress()))
                    .setPort(address.getPort())
                    .setServices(address.getServices().longValue())
                    .build();
            confidenceBuilder.addBroadcastBy(proto);
        )
        Date lastBroadcastedAt = confidence.getLastBroadcastedAt();
        if (lastBroadcastedAt != nil)
            confidenceBuilder.setLastBroadcastedAt(lastBroadcastedAt.getTime());
        txBuilder.setConfidence(confidenceBuilder);
    )

#_public
#_static
    ByteString hashToByteString(Sha256Hash hash)
    (§
        return ByteString.copyFrom(hash.getBytes());
    )

#_public
#_static
    Sha256Hash byteStringToHash(ByteString bs)
    (§
        return Sha256Hash.wrap(bs.toByteArray());
    )

    ;;;
     ; <p>Loads wallet data from the given protocol buffer and inserts it into the given Wallet object.
     ; This is primarily useful when you wish to pre-register extension objects.  Note that if loading
     ; fails the provided Wallet object may be in an indeterminate state and should be thrown away.</p>
     ;
     ; <p>A wallet can be unreadable for various reasons, such as inability to open the file, corrupt data,
     ; internally inconsistent data and so on.  You should always handle
     ; {@link UnreadableWalletException} and communicate failure to the user in an appropriate manner.</p>
     ;
     ; @throws UnreadableWalletException in various error conditions (see description).
     ;;
#_public
    Wallet readWallet(InputStream input)
        throws UnreadableWalletException
    (§
        return readWallet(input, false);
    )

    ;;;
     ; <p>Loads wallet data from the given protocol buffer and inserts it into the given Wallet object.
     ; This is primarily useful when you wish to pre-register extension objects.  Note that if loading
     ; fails the provided Wallet object may be in an indeterminate state and should be thrown away.  Do not
     ; simply call this method again on the same Wallet object with {@code forceReset} set {@code true}.
     ; It won't work.</p>
     ;
     ; <p>If {@code forceReset} is {@code true}, then no transactions are loaded from the wallet, and
     ; it is configured to replay transactions from the blockchain (as if the wallet had been loaded and
     ; {@link Wallet.reset} had been called immediately thereafter).
     ;
     ; <p>A wallet can be unreadable for various reasons, such as inability to open the file, corrupt data,
     ; internally inconsistent data and so on. You should always handle
     ; {@link UnreadableWalletException} and communicate failure to the user in an appropriate manner.</p>
     ;
     ; @throws UnreadableWalletException in various error conditions (see description).
     ;;
#_public
    Wallet readWallet(InputStream input, boolean forceReset)
        throws UnreadableWalletException
    (§
        try
        (§
            Protos.Wallet walletProto = parseToProto(input);
#_final
            String paramsID = walletProto.getNetworkIdentifier();
            NetworkParameters params = NetworkParameters.fromID(paramsID);
            if (params == nil)
                throw new UnreadableWalletException("Unknown network parameters ID " + paramsID);

            return readWallet(params, walletProto, forceReset);
        )
        catch (IOException e)
        (§
            throw new UnreadableWalletException("Could not parse input stream to protobuf", e);
        )
        catch (IllegalStateException e)
        (§
            throw new UnreadableWalletException("Could not parse input stream to protobuf", e);
        )
        catch (IllegalArgumentException e)
        (§
            throw new UnreadableWalletException("Could not parse input stream to protobuf", e);
        )
    )

    ;;;
     ; <p>Loads wallet data from the given protocol buffer and inserts it into the given Wallet object.
     ; This is primarily useful when you wish to pre-register extension objects.  Note that if loading
     ; fails, the provided Wallet object may be in an indeterminate state and should be thrown away.</p>
     ;
     ; <p>A wallet can be unreadable for various reasons, such as inability to open the file, corrupt
     ; data, internally inconsistent data and so on.  You should always handle
     ; {@link UnreadableWalletException} and communicate failure to the user in an appropriate manner.</p>
     ;
     ; @throws UnreadableWalletException in various error conditions (see description).
     ;;
#_public
    Wallet readWallet(NetworkParameters params, Protos.Wallet walletProto)
        throws UnreadableWalletException
    (§
        return readWallet(params, walletProto, false);
    )

    ;;;
     ; <p>Loads wallet data from the given protocol buffer and inserts it into the given Wallet object.
     ; This is primarily useful when you wish to pre-register extension objects.  Note that if loading
     ; fails, the provided Wallet object may be in an indeterminate state and should be thrown away.  Do not
     ; simply call this method again on the same Wallet object with {@code forceReset} set {@code true}.
     ; It won't work.</p>
     ;
     ; <p>If {@code forceReset} is {@code true}, then no transactions are loaded from the wallet, and it is
     ; configured to replay transactions from the blockchain (as if the wallet had been loaded and
     ; {@link Wallet.reset} had been called immediately thereafter).
     ;
     ; <p>A wallet can be unreadable for various reasons, such as inability to open the file, corrupt data,
     ; internally inconsistent data and so on.  You should always handle
     ; {@link UnreadableWalletException} and communicate failure to the user in an appropriate manner.</p>
     ;
     ; @throws UnreadableWalletException in various error conditions (see description).
     ;;
#_public
    Wallet readWallet(NetworkParameters params, Protos.Wallet walletProto, boolean forceReset)
        throws UnreadableWalletException
    (§
        if (CURRENT_WALLET_VERSION < walletProto.getVersion())
            throw new UnreadableWalletException.FutureVersion();
        if (!walletProto.getNetworkIdentifier().equals(params.getId()))
            throw new UnreadableWalletException.WrongNetwork();

        ;; Read the scrypt parameters that specify how encryption and decryption is performed.
        KeyChainGroup keyChainGroup;
        if (walletProto.hasEncryptionParameters())
        (§
            Protos.ScryptParameters encryptionParameters = walletProto.getEncryptionParameters();
#_final
            KeyCrypterScrypt keyCrypter = new KeyCrypterScrypt(encryptionParameters);
            keyChainGroup = KeyChainGroup.fromProtobufEncrypted(params, walletProto.getKeyList(), keyCrypter, keyChainFactory);
        )
        else
        (§
            keyChainGroup = KeyChainGroup.fromProtobufUnencrypted(params, walletProto.getKeyList(), keyChainFactory);
        )

        Wallet wallet = factory.create(params, keyChainGroup);
        if (walletProto.hasDescription())
            wallet.setDescription(walletProto.getDescription());

        if (forceReset)
        (§
            ;; Should mirror Wallet.reset().
            wallet.setLastBlockSeenHash(nil);
            wallet.setLastBlockSeenHeight(-1);
            wallet.setLastBlockSeenTimeSecs(0);
        )
        else
        (§
            ;; Read all transactions and insert into the txMap.
            for (Protos.Transaction txProto : walletProto.getTransactionList())
                readTransaction(txProto, wallet.getParams());

            ;; Update transaction outputs to point to inputs that spend them.
            for (Protos.Transaction txProto : walletProto.getTransactionList())
            (§
                WalletTransaction wtx = connectTransactionOutputs(params, txProto);
                wallet.addWalletTransaction(wtx);
            )

            ;; Update the lastBlockSeenHash.
            if (!walletProto.hasLastSeenBlockHash())
                wallet.setLastBlockSeenHash(nil);
            else
                wallet.setLastBlockSeenHash(byteStringToHash(walletProto.getLastSeenBlockHash()));

            if (!walletProto.hasLastSeenBlockHeight())
                wallet.setLastBlockSeenHeight(-1);
            else
                wallet.setLastBlockSeenHeight(walletProto.getLastSeenBlockHeight());

            ;; Will default to zero if not present.
            wallet.setLastBlockSeenTimeSecs(walletProto.getLastSeenBlockTimeSecs());

            if (walletProto.hasKeyRotationTime())
                wallet.setKeyRotationTime(new Date(walletProto.getKeyRotationTime() * 1000));
        )

        for (Protos.Tag tag : walletProto.getTagsList())
            wallet.setTag(tag.getTag(), tag.getData());

        for (Protos.TransactionSigner signerProto : walletProto.getTransactionSignersList())
        (§
            try
            (§
                Class signerClass = Class.forName(signerProto.getClassName());
                TransactionSigner signer = (TransactionSigner)signerClass.newInstance();
                signer.deserialize(signerProto.getData().toByteArray());
                wallet.addTransactionSigner(signer);
            )
            catch (Exception e)
            (§
                throw new UnreadableWalletException("Unable to deserialize TransactionSigner instance: " + signerProto.getClassName(), e);
            )
        )

        if (walletProto.hasVersion())
            wallet.setVersion(walletProto.getVersion());

        ;; Make sure the object can be re-used to read another wallet without corruption.
        txMap.clear();

        return wallet;
    )

    ;;;
     ; Returns the loaded protocol buffer from the given byte stream.  You normally want
     ; {@link Wallet#loadFromFile(java.io.File)} instead - this method is designed for
     ; low level work involving the wallet file format itself.
     ;;
#_public
#_static
    Protos.Wallet parseToProto(InputStream input)
        throws IOException
    (§
        CodedInputStream codedInput = CodedInputStream.newInstance(input);
        codedInput.setSizeLimit(WALLET_SIZE_LIMIT);
        return Protos.Wallet.parseFrom(codedInput);
    )

#_private
    void readTransaction(Protos.Transaction txProto, NetworkParameters params)
        throws UnreadableWalletException
    (§
        Transaction tx = new Transaction(params);

        tx.setVersion(txProto.getVersion());

        if (txProto.hasUpdatedAt())
            tx.setUpdateTime(new Date(txProto.getUpdatedAt()));

        for (Protos.TransactionOutput outputProto : txProto.getTransactionOutputList())
        (§
            Coin value = Coin.valueOf(outputProto.getValue());
            byte[] scriptBytes = outputProto.getScriptBytes().toByteArray();
            TransactionOutput output = new TransactionOutput(params, tx, value, scriptBytes);
            tx.addOutput(output);
        )

        for (Protos.TransactionInput inputProto : txProto.getTransactionInputList())
        (§
            byte[] scriptBytes = inputProto.getScriptBytes().toByteArray();
            TransactionOutPoint outpoint = new TransactionOutPoint(params, inputProto.getTransactionOutPointIndex() & 0xffffffffL, byteStringToHash(inputProto.getTransactionOutPointHash()));
            Coin value = inputProto.hasValue() ? Coin.valueOf(inputProto.getValue()) : nil;
            TransactionInput input = new TransactionInput(params, tx, scriptBytes, outpoint, value);
            if (inputProto.hasSequence())
                input.setSequenceNumber(0xffffffffL & inputProto.getSequence());
            tx.addInput(input);
        )

        for (int i = 0; i < txProto.getBlockHashCount(); i++)
        (§
            ByteString blockHash = txProto.getBlockHash(i);
            int relativityOffset = 0;
            if (txProto.getBlockRelativityOffsetsCount() > 0)
                relativityOffset = txProto.getBlockRelativityOffsets(i);
            tx.addBlockAppearance(byteStringToHash(blockHash), relativityOffset);
        )

        if (txProto.hasLockTime())
            tx.setLockTime(0xffffffffL & txProto.getLockTime());

        if (txProto.hasPurpose())
        (§
            switch (txProto.getPurpose())
            (§
                case UNKNOWN: tx.setPurpose(Transaction.Purpose.UNKNOWN); break;
                case USER_PAYMENT: tx.setPurpose(Transaction.Purpose.USER_PAYMENT); break;
                case KEY_ROTATION: tx.setPurpose(Transaction.Purpose.KEY_ROTATION); break;
                case ASSURANCE_CONTRACT_CLAIM: tx.setPurpose(Transaction.Purpose.ASSURANCE_CONTRACT_CLAIM); break;
                case ASSURANCE_CONTRACT_PLEDGE: tx.setPurpose(Transaction.Purpose.ASSURANCE_CONTRACT_PLEDGE); break;
                case ASSURANCE_CONTRACT_STUB: tx.setPurpose(Transaction.Purpose.ASSURANCE_CONTRACT_STUB); break;
                case RAISE_FEE: tx.setPurpose(Transaction.Purpose.RAISE_FEE); break;
                default: throw new RuntimeException("New purpose serialization not implemented");
            )
        )
        else
        (§
            ;; Old wallet: assume a user payment as that's the only reason a new tx would have been created back then.
            tx.setPurpose(Transaction.Purpose.USER_PAYMENT);
        )

        if (txProto.hasExchangeRate())
        (§
            Protos.ExchangeRate exchangeRateProto = txProto.getExchangeRate();
            tx.setExchangeRate(new ExchangeRate(Coin.valueOf(exchangeRateProto.getCoinValue()), Fiat.valueOf(exchangeRateProto.getFiatCurrencyCode(), exchangeRateProto.getFiatValue())));
        )

        if (txProto.hasMemo())
            tx.setMemo(txProto.getMemo());

        ;; Transaction should now be complete.
        Sha256Hash protoHash = byteStringToHash(txProto.getHash());
        if (!tx.getHash().equals(protoHash))
            throw new UnreadableWalletException(String.format(Locale.US, "Transaction did not deserialize completely: %s vs %s", tx.getHash(), protoHash));
        if (txMap.containsKey(txProto.getHash()))
            throw new UnreadableWalletException("Wallet contained duplicate transaction " + byteStringToHash(txProto.getHash()));
        txMap.put(txProto.getHash(), tx);
    )

#_private
    WalletTransaction connectTransactionOutputs(final NetworkParameters params, final org.bitcoinj.wallet.Protos.Transaction txProto)
        throws UnreadableWalletException
    (§
        Transaction tx = txMap.get(txProto.getHash());
#_final
        WalletTransaction.Pool pool;
        switch (txProto.getPool())
        (§
            case DEAD: pool = WalletTransaction.Pool.DEAD; break;
            case PENDING: pool = WalletTransaction.Pool.PENDING; break;
            case SPENT: pool = WalletTransaction.Pool.SPENT; break;
            case UNSPENT: pool = WalletTransaction.Pool.UNSPENT; break;
            ;; Upgrade old wallets: inactive pool has been merged with the pending pool.
            ;; Remove this some time after 0.9 is old and everyone has upgraded.
            ;; There should not be any spent outputs in this tx as old wallets would not allow them to be spent in this state.
            case INACTIVE:
            case PENDING_INACTIVE:
                pool = WalletTransaction.Pool.PENDING;
                break;
            default:
                throw new UnreadableWalletException("Unknown transaction pool: " + txProto.getPool());
        )

        for (int i = 0; i < tx.getOutputs().size(); i++)
        (§
            TransactionOutput output = tx.getOutputs().get(i);
#_final
            Protos.TransactionOutput transactionOutput = txProto.getTransactionOutput(i);
            if (transactionOutput.hasSpentByTransactionHash())
            (§
#_final
                ByteString spentByTransactionHash = transactionOutput.getSpentByTransactionHash();
                Transaction spendingTx = txMap.get(spentByTransactionHash);
                if (spendingTx == nil)
                    throw new UnreadableWalletException(String.format(Locale.US, "Could not connect %s to %s", tx.getHashAsString(), byteStringToHash(spentByTransactionHash)));

#_final
                int spendingIndex = transactionOutput.getSpentByTransactionIndex();
                TransactionInput input = Preconditions.checkNotNull(spendingTx.getInput(spendingIndex));
                input.connect(output);
            )
        )

        if (txProto.hasConfidence())
        (§
            Protos.TransactionConfidence confidenceProto = txProto.getConfidence();
            TransactionConfidence confidence = tx.getConfidence();
            readConfidence(params, tx, confidenceProto, confidence);
        )

        return new WalletTransaction(pool, tx);
    )

#_private
    void readConfidence(final NetworkParameters params, final Transaction tx, final Protos.TransactionConfidence confidenceProto, final TransactionConfidence confidence)
        throws UnreadableWalletException
    (§
        ;; We are lenient here because tx confidence is not an essential part of the wallet.
        ;; If the tx has an unknown type of confidence, ignore.
        if (!confidenceProto.hasType())
        (§
            log.warn("Unknown confidence type for tx {}", tx.getHashAsString());
            return;
        )

        ConfidenceType confidenceType;
        switch (confidenceProto.getType())
        (§
            case BUILDING: confidenceType = ConfidenceType.BUILDING; break;
            case DEAD: confidenceType = ConfidenceType.DEAD; break;
            ;; These two are equivalent (must be able to read old wallets).
            case NOT_IN_BEST_CHAIN: confidenceType = ConfidenceType.PENDING; break;
            case PENDING: confidenceType = ConfidenceType.PENDING; break;
            case IN_CONFLICT: confidenceType = ConfidenceType.IN_CONFLICT; break;
            case UNKNOWN:
                ;; Fall through.
            default:
                confidenceType = ConfidenceType.UNKNOWN; break;
        )
        confidence.setConfidenceType(confidenceType);
        if (confidenceProto.hasAppearedAtHeight())
        (§
            if (confidence.getConfidenceType() != ConfidenceType.BUILDING)
            (§
                log.warn("Have appearedAtHeight but not BUILDING for tx {}", tx.getHashAsString());
                return;
            )
            confidence.setAppearedAtChainHeight(confidenceProto.getAppearedAtHeight());
        )

        if (confidenceProto.hasDepth())
        (§
            if (confidence.getConfidenceType() != ConfidenceType.BUILDING)
            (§
                log.warn("Have depth but not BUILDING for tx {}", tx.getHashAsString());
                return;
            )
            confidence.setDepthInBlocks(confidenceProto.getDepth());
        )

        if (confidenceProto.hasOverridingTransaction())
        (§
            if (confidence.getConfidenceType() != ConfidenceType.DEAD)
            (§
                log.warn("Have overridingTransaction but not OVERRIDDEN for tx {}", tx.getHashAsString());
                return;
            )
            Transaction overridingTransaction = txMap.get(confidenceProto.getOverridingTransaction());
            if (overridingTransaction == nil)
            (§
                log.warn("Have overridingTransaction that is not in wallet for tx {}", tx.getHashAsString());
                return;
            )
            confidence.setOverridingTransaction(overridingTransaction);
        )

        for (Protos.PeerAddress proto : confidenceProto.getBroadcastByList())
        (§
            InetAddress ip;
            try
            (§
                ip = InetAddress.getByAddress(proto.getIpAddress().toByteArray());
            )
            catch (UnknownHostException e)
            (§
                throw new UnreadableWalletException("Peer IP address does not have the right length", e);
            )

            int port = proto.getPort();
            int protocolVersion = params.getProtocolVersionNum(NetworkParameters.ProtocolVersion.CURRENT);
            BigInteger services = BigInteger.valueOf(proto.getServices());
            PeerAddress address = new PeerAddress(params, ip, port, protocolVersion, services);
            confidence.markBroadcastBy(address);
        )

        if (confidenceProto.hasLastBroadcastedAt())
            confidence.setLastBroadcastedAt(new Date(confidenceProto.getLastBroadcastedAt()));

        switch (confidenceProto.getSource())
        (§
            case SOURCE_SELF: confidence.setSource(TransactionConfidence.Source.SELF); break;
            case SOURCE_NETWORK: confidence.setSource(TransactionConfidence.Source.NETWORK); break;
            case SOURCE_UNKNOWN:
                ;; Fall through.
            default: confidence.setSource(TransactionConfidence.Source.UNKNOWN); break;
        )
    )

    ;;;
     ; Cheap test to see if input stream is a wallet.  This checks for a magic value at the beginning of the stream.
     ;
     ; @param is Input stream to test.
     ; @return true if input stream is a wallet.
     ;;
#_public
#_static
    boolean isWallet(InputStream is)
    (§
        try
        (§
#_final
            CodedInputStream cis = CodedInputStream.newInstance(is);
#_final
            int tag = cis.readTag();
#_final
            int field = WireFormat.getTagFieldNumber(tag);
            if (field != 1) ;; network_identifier
                return false;

#_final
            String network = cis.readString();
            return (NetworkParameters.fromID(network) != nil);
        )
        catch (IOException _)
        (§
            return false;
        )
    )
)

(ns org.bitcoinj.wallet #_"WalletTransaction"
    (:import [com.google.common.base Preconditions])
  #_(:require [org.bitcoinj.core Transaction]))

;;;
 ; Stores data about a transaction that is only relevant to the {@link org.bitcoinj.wallet.Wallet} class.
 ;;
#_public
class WalletTransaction
(§
#_public
    enum Pool
    (§
        UNSPENT, ;; unspent in best chain
        SPENT, ;; spent in best chain
        DEAD, ;; double-spend in alt chain
        PENDING ;; a pending tx we would like to go into the best chain
    )
#_private
#_final
    Transaction transaction;
#_private
#_final
    Pool pool;

#_public
    WalletTransaction(Pool pool, Transaction transaction)
    (§
        this.pool = Preconditions.checkNotNull(pool);
        this.transaction = transaction;
    )

#_public
    Transaction getTransaction()
    (§
        return transaction;
    )

#_public
    Pool getPool()
    (§
        return pool;
    )
)

(ns org.bitcoinj.wallet.listeners #_"AbstractKeyChainEventListener"
    (:import [java.util List])
  #_(:require [org.bitcoinj.core ECKey]))

#_public
class AbstractKeyChainEventListener implements KeyChainEventListener
(§
#_override
#_public
    void onKeysAdded(List<ECKey> keys)
    (§
    )
)

(ns org.bitcoinj.wallet.listeners #_"KeyChainEventListener"
    (:import [java.util List])
  #_(:require [org.bitcoinj.core ECKey]
             [org.bitcoinj.wallet KeyChain]))

#_public
interface KeyChainEventListener
(§
    ;;;
     ; Called whenever a new key is added to the key chain, whether that be via an explicit addition or due to some
     ; other automatic derivation.  See the documentation for your {@link KeyChain} implementation for details on
     ; what can trigger this event.
     ;;
    void onKeysAdded(List<ECKey> keys);
)

(ns org.bitcoinj.wallet.listeners #_"WalletChangeEventListener"
  #_(:require [org.bitcoinj.wallet Wallet]))

;;;
 ; <p>Implementors are called when the contents of the wallet changes, for instance due to receiving/sending money
 ; or a block chain re-organize.</p>
 ;;
#_public
interface WalletChangeEventListener
(§
    ;;;
     ; <p>Designed for GUI applications to refresh their transaction lists.  This callback is invoked in the following
     ; situations:</p>
     ;
     ; <ol>
     ;     <li>A new block is received (and thus building transactions got more confidence).</li>
     ;     <li>A pending transaction is received.</li>
     ;     <li>A pending transaction changes confidence due to some non-new-block related event,
     ;     such as being announced by more peers or by  a double-spend conflict being observed.</li>
     ;     <li>A re-organize occurs. Call occurs only if the re-org modified any of our transactions.</li>
     ;     <li>A new spend is committed to the wallet.</li>
     ;     <li>The wallet is reset and all transactions removed.<li>
     ; </ol>
     ;
     ; <p>When this is called you can refresh the UI contents from the wallet contents.  It's more efficient to use
     ; this rather than onTransactionConfidenceChanged() + onReorganize() because you only get one callback per block
     ; rather than one per transaction per block.  Note that this is <b>not</b> called when a key is added.</p>
     ;;
    void onWalletChanged(Wallet wallet);
)

(ns org.bitcoinj.wallet.listeners #_"WalletCoinsReceivedEventListener"
  #_(:require [org.bitcoinj.core Coin Transaction]
             [org.bitcoinj.wallet Wallet]))

;;;
 ; <p>Implementors are called when the contents of the wallet changes, for instance due to receiving/sending money
 ; or a block chain re-organize.</p>
 ;;
#_public
interface WalletCoinsReceivedEventListener
(§
    ;;;
     ; This is called when a transaction is seen that sends coins <b>to</b> this wallet, either because it was
     ; broadcast across the network or because a block was received.  If a transaction is seen when it was broadcast,
     ; onCoinsReceived won't be called again when a block containing it is received.  If you want to know when such
     ; a transaction receives its first confirmation, register a {@link TransactionConfidence} event listener using
     ; the object retrieved via {@link org.bitcoinj.core.Transaction#getConfidence()}.  It's safe to modify the
     ; wallet in this callback, for example, by spending the transaction just received.
     ;
     ; @param wallet The wallet object that received the coins.
     ; @param tx The transaction which sent us the coins.
     ; @param prevBalance Balance before the coins were received.
     ; @param newBalance This is the 'estimated' balance.
     ;;
    void onCoinsReceived(Wallet wallet, Transaction tx, Coin prevBalance, Coin newBalance);
)

(ns org.bitcoinj.wallet.listeners #_"WalletCoinsSentEventListener"
  #_(:require [org.bitcoinj.core Coin Transaction]
             [org.bitcoinj.wallet Wallet]))

;;;
 ; <p>Implementors are called when the contents of the wallet changes, for instance due to receiving/sending money
 ; or a block chain re-organize.</p>
 ;;
#_public
interface WalletCoinsSentEventListener
(§
    ;;;
     ; This is called when a transaction is seen that sends coins <b>from</b> this wallet, either because it
     ; was broadcast across the network or because a block was received.  This may at first glance seem useless,
     ; because in the common case you already know about such transactions because you created them with the
     ; Wallets createSend/sendCoins methods.  However when you have a wallet containing only keys, and you wish
     ; to replay the block chain to fill it with transactions, it's useful to find out when a transaction is
     ; discovered that sends coins from the wallet.
     ;
     ; It's safe to modify the wallet from inside this callback, but if you're replaying the block chain you should
     ; be careful to avoid such modifications.  Otherwise your changes may be overridden by new data from the chain.
     ;
     ; @param wallet The wallet object that this callback relates to (that sent the coins).
     ; @param tx The transaction that sent the coins to someone else.
     ; @param prevBalance The wallets balance before this transaction was seen.
     ; @param newBalance The wallets balance after this transaction was seen.  This is the 'estimated' balance.
     ;;
    void onCoinsSent(Wallet wallet, Transaction tx, Coin prevBalance, Coin newBalance);
)

(ns org.bitcoinj.wallet.listeners #_"WalletReorganizeEventListener"
  #_(:require [org.bitcoinj.wallet Wallet]))

;;;
 ; <p>Implementors are called when the wallet is reorganized.</p>
 ;;
#_public
interface WalletReorganizeEventListener
(§
    ;; TODO: Finish onReorganize to be more useful.
    ;;;
     ; <p>This is called when a block is received that triggers a block chain re-organization.</p>
     ;
     ; <p>A re-organize means that the consensus (chain) of the network has diverged and now changed from
     ; what we believed it was previously.  Usually this won't matter because the new consensus will include
     ; all our old transactions assuming we are playing by the rules.  However it's theoretically possible
     ; for our balance to change in arbitrary ways, most likely, we could lose some money we thought we had.</p>
     ;
     ; <p>It is safe to use methods of wallet whilst inside this callback.</p>
     ;;
    void onReorganize(Wallet wallet);
)
