(ns bitclojn.core)

(defmacro § [& _])
(defmacro ß [& _])

(defmacro def- [s i] `(def ~(vary-meta s assoc :private true) ~i))

(defmacro when' [y & w]
    (let [[_ & w] (if (= '=> (first w)) (rest w) (cons nil w))]
        `(if ~y (do ~@w) ~_)))
(defmacro let-when [x y & w]
    (let [[_ & w] (if (= '=> (first w)) (rest w) (cons nil w))]
        `(let [~@x] (if ~y (do ~@w) ~_))))

(defn -main [& args]
    )

#_(ns org.bitcoinj.core #_"AbstractBlockChain"
    (:import #_[java.util *]
             #_[java.util.concurrent *]
             #_[java.util.concurrent.locks *])
    (:import #_[com.google.common.base *]
             #_[com.google.common.collect *]
             #_[com.google.common.util.concurrent *]
             #_[org.slf4j *])
  #_(:require #_[org.bitcoinj.core.listeners *]
             #_[org.bitcoinj.store *]
             #_[org.bitcoinj.utils *]
             [org.bitcoinj.wallet Wallet]))

;;;
 ; <p>An AbstractBlockChain holds a series of {@link Block} objects, links them together, and knows how to verify that
 ; the chain follows the rules of the {@link NetworkParameters} for this chain.</p>
 ;
 ; <p>It can be connected to a {@link Wallet}, and also {@link TransactionReceivedInBlockListener}s that can receive
 ; transactions and notifications of re-organizations.</p>
 ;
 ; <p>An AbstractBlockChain implementation must be connected to a {@link BlockStore} implementation.  The chain object
 ; by itself doesn't store any data, that's delegated to the store.  Which store you use is a decision best made by
 ; reading the getting started guide, but briefly, fully validating block chains need fully validating stores.  In
 ; the lightweight SPV mode, a {@link org.bitcoinj.store.SPVBlockStore} is the right choice.</p>
 ;
 ; <p>This class implements an abstract class which makes it simple to create a BlockChain that does/doesn't do
 ; full verification.  It verifies headers and is implements most of what is required to implement SPV mode, but
 ; also provides callback hooks which can be used to do full verification.</p>
 ;
 ; <p>There are two subclasses of AbstractBlockChain that are useful: {@link BlockChain}, which is the simplest
 ; class and implements <i>simplified payment verification</i>.  This is a lightweight and efficient mode that
 ; does not verify the contents of blocks, just their headers.  A {@link FullPrunedBlockChain} paired with a
 ; {@link org.bitcoinj.store.H2FullPrunedBlockStore} implements full verification, which is equivalent to
 ; Bitcoin Core.  To learn more about the alternative security models, please consult the articles on the
 ; website.</p>
 ;
 ; <b>Theory</b>
 ;
 ; <p>The 'chain' is actually a tree although in normal operation it operates mostly as a list of {@link Block}s.
 ; When multiple new head blocks are found simultaneously, there are multiple stories of the economy competing to become
 ; the one true consensus.  This can happen naturally when two miners solve a block within a few seconds of each other,
 ; or it can happen when the chain is under attack.</p>
 ;
 ; <p>A reference to the head block of the best known chain is stored.  If you can reach the genesis block by repeatedly
 ; walking through the prevBlock pointers, then we say this is a full chain.  If you cannot reach the genesis block
 ; we say it is an orphan chain.  Orphan chains can occur when blocks are solved and received during the initial block
 ; chain download, or if we connect to a peer that doesn't send us blocks in order.</p>
 ;
 ; <p>A reorganize occurs when the blocks that make up the best known chain changes.  Note that simply adding a
 ; new block to the top of the best chain isn't as reorganize, but that a reorganize is always triggered by adding
 ; a new block that connects to some other (non best head) block.  By "best" we mean the chain representing the largest
 ; amount of work done.</p>
 ;
 ; <p>Every so often the block chain passes a difficulty transition point.  At that time, all the blocks in the last
 ; 2016 blocks are examined and a new difficulty target is calculated from them.</p>
 ;;
#_public
#_abstract
(§ class AbstractBlockChain
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(AbstractBlockChain.class))

    #_protected
    #_final
    (§ field ReentrantLock lock = Threading.lock("blockchain"))

    ;;; Keeps a map of block hashes to StoredBlocks. ;;
    #_private
    #_final
    (§ field BlockStore blockStore)

    ;;;
     ; Tracks the top of the best known chain.
     ;
     ; Following this one down to the genesis block produces the story of the economy from the creation of Bitcoin
     ; until the present day.  The chain head can change if a new set of blocks is received that results in a chain of
     ; greater work than the one obtained by following this one down.  In that case a reorganize is triggered,
     ; potentially invalidating transactions in our wallet.
     ;;
    #_protected
    (§ field StoredBlock chainHead)

    ;; TODO: Scrap this and use a proper read/write for all of the block chain objects.
    ;; The chainHead field is read/written synchronized with this object rather than BlockChain.  However writing is
    ;; also guaranteed to happen whilst BlockChain is synchronized (see setChainHead).  The goal of this is to let
    ;; clients quickly access the chain head even whilst the block chain is downloading and thus the BlockChain is
    ;; locked most of the time.
    #_private
    #_final
    (§ field Object chainHeadLock = new Object())

    #_protected
    #_final
    (§ field NetworkParameters params)
    #_private
    #_final
    (§ field CopyOnWriteArrayList<ListenerRegistration<NewBestBlockListener>> newBestBlockListeners)
    #_private
    #_final
    (§ field CopyOnWriteArrayList<ListenerRegistration<ReorganizeListener>> reorganizeListeners)
    #_private
    #_final
    (§ field CopyOnWriteArrayList<ListenerRegistration<TransactionReceivedInBlockListener>> transactionReceivedListeners)

    ;; Holds a block header and, optionally, a list of tx hashes or block's transactions.
    (§ class OrphanBlock
        #_final
        (§ field Block block)
        #_final
        (§ field List<Sha256Hash> filteredTxHashes)
        #_final
        (§ field Map<Sha256Hash, Transaction> filteredTxn)

        (§ constructor OrphanBlock(Block block, #_nilable List<Sha256Hash> filteredTxHashes, #_nilable Map<Sha256Hash, Transaction> filteredTxn))
        (ß
            #_final
            (§ var boolean filtered = (filteredTxHashes != nil && filteredTxn != nil))
            (§ call Preconditions.checkArgument((block.transactions == nil && filtered) || (block.transactions != nil && !filtered)))
            (§ ass this.block = block)
            (§ ass this.filteredTxHashes = filteredTxHashes)
            (§ ass this.filteredTxn = filteredTxn)
        )
    )
    ;; Holds blocks that we have received but can't plug into the chain yet, e.g. because they were created whilst we
    ;; were downloading the block chain.
    #_private
    #_final
    (§ field LinkedHashMap<Sha256Hash, OrphanBlock> orphanBlocks = new LinkedHashMap<>())

    ;;; False positive estimation uses a double exponential moving average. ;;
    #_public
    #_static
    #_final
    (§ field double FP_ESTIMATOR_ALPHA = 0.0001)
    ;;; False positive estimation uses a double exponential moving average. ;;
    #_public
    #_static
    #_final
    (§ field double FP_ESTIMATOR_BETA = 0.01)

    #_private
    (§ field double falsePositiveRate)
    #_private
    (§ field double falsePositiveTrend)
    #_private
    (§ field double previousFalsePositiveRate)

    #_private
    #_final
    (§ field VersionTally versionTally)

    ;;; See {@link #AbstractBlockChain(Context, List, BlockStore)} ;;
    #_public
    (§ constructor AbstractBlockChain(NetworkParameters params, List<? extends Wallet> transactionReceivedListeners, BlockStore blockStore))
        (§ throws BlockStoreException)
    (ß
        (§ this (Context.getOrCreate(params), transactionReceivedListeners, blockStore))
    )

    ;;;
     ; Constructs a BlockChain connected to the given list of listeners (e.g. wallets) and a store.
     ;;
    #_public
    (§ constructor AbstractBlockChain(Context context, List<? extends Wallet> wallets, BlockStore blockStore))
        (§ throws BlockStoreException)
    (ß
        (§ ass this.blockStore = blockStore)
        (§ ass chainHead = blockStore.getChainHead())
        (§ call log.info("chain head is at height {}:\n{}", chainHead.getHeight(), chainHead.getHeader()))
        (§ ass this.params = context.getParams())

        (§ ass this.newBestBlockListeners = new CopyOnWriteArrayList<>())
        (§ ass this.reorganizeListeners = new CopyOnWriteArrayList<>())
        (§ ass this.transactionReceivedListeners = new CopyOnWriteArrayList<>())
        (§ for (NewBestBlockListener l :for wallets))
            (§ call addNewBestBlockListener(Threading.SAME_THREAD, l))
        (§ for (ReorganizeListener l :for wallets))
            (§ call addReorganizeListener(Threading.SAME_THREAD, l))
        (§ for (TransactionReceivedInBlockListener l :for wallets))
            (§ call addTransactionReceivedListener(Threading.SAME_THREAD, l))

        (§ ass this.versionTally = new VersionTally(context.getParams()))
        (§ call this.versionTally.initialize(blockStore, chainHead))
    )

    ;;;
     ; Add a wallet to the BlockChain.  Note that the wallet will be unaffected by any blocks received while it
     ; was not part of this BlockChain.  This method is useful if the wallet has just been created, and its keys
     ; have never been in use, or if the wallet has been loaded along with the BlockChain.  Note that adding
     ; multiple wallets is not well tested!
     ;;
    #_public
    #_final
    (§ method void addWallet(Wallet wallet))
    (ß
        (§ call addNewBestBlockListener(Threading.SAME_THREAD, wallet))
        (§ call addReorganizeListener(Threading.SAME_THREAD, wallet))
        (§ call addTransactionReceivedListener(Threading.SAME_THREAD, wallet))

        (§ var int walletHeight = wallet.getLastBlockSeenHeight())
        (§ var int chainHeight = getBestChainHeight())
        (§ if (walletHeight != chainHeight))
        (ß
            (§ call log.warn("Wallet/chain height mismatch: {} vs {}", walletHeight, chainHeight))
            (§ call log.warn("Hashes: {} vs {}", wallet.getLastBlockSeenHash(), getChainHead().getHeader().getHash()))

            ;; This special case happens when the VM crashes because of a transaction received.  It causes the updated
            ;; block store to persist, but not the wallet.  In order to fix the issue, we roll back the block store to
            ;; the wallet height to make it look like as if the block has never been received.
            (§ if (0 < walletHeight && walletHeight < chainHeight))
            (ß
                (§ try)
                (ß
                    (§ call rollbackBlockStore(walletHeight))
                    (§ call log.info("Rolled back block store to height {}.", walletHeight))
                )
                (§ catch (BlockStoreException _))
                (ß
                    (§ call log.warn("Rollback of block store failed, continuing with mismatched heights. This can happen due to a replay."))
                )
            )
        )
    )

    ;;; Removes a wallet from the chain. ;;
    #_public
    (§ method void removeWallet(Wallet wallet))
    (ß
        (§ call removeNewBestBlockListener(wallet))
        (§ call removeReorganizeListener(wallet))
        (§ call removeTransactionReceivedListener(wallet))
    )

    ;;; Replaced with more specific listener methods: use them instead. ;;
    #_deprecated
    #_suppress(ß "deprecation")
    #_public
    (§ method void addListener(BlockChainListener listener))
    (ß
        (§ call addListener(listener, Threading.USER_THREAD))
    )

    ;;; Replaced with more specific listener methods: use them instead. ;;
    #_deprecated
    #_public
    (§ method void addListener(BlockChainListener listener, Executor executor))
    (ß
        (§ call addReorganizeListener(executor, listener))
        (§ call addNewBestBlockListener(executor, listener))
        (§ call addTransactionReceivedListener(executor, listener))
    )

    #_deprecated
    #_public
    (§ method void removeListener(BlockChainListener listener))
    (ß
        (§ call removeReorganizeListener(listener))
        (§ call removeNewBestBlockListener(listener))
        (§ call removeTransactionReceivedListener(listener))
    )

    ;;;
     ; Adds a {@link NewBestBlockListener} listener to the chain.
     ;;
    #_public
    (§ method void addNewBestBlockListener(NewBestBlockListener listener))
    (ß
        (§ call addNewBestBlockListener(Threading.USER_THREAD, listener))
    )

    ;;;
     ; Adds a {@link NewBestBlockListener} listener to the chain.
     ;;
    #_public
    #_final
    (§ method void addNewBestBlockListener(Executor executor, NewBestBlockListener listener))
    (ß
        (§ call newBestBlockListeners.add(new ListenerRegistration<>(listener, executor)))
    )

    ;;;
     ; Adds a generic {@link ReorganizeListener} listener to the chain.
     ;;
    #_public
    (§ method void addReorganizeListener(ReorganizeListener listener))
    (ß
        (§ call addReorganizeListener(Threading.USER_THREAD, listener))
    )

    ;;;
     ; Adds a generic {@link ReorganizeListener} listener to the chain.
     ;;
    #_public
    #_final
    (§ method void addReorganizeListener(Executor executor, ReorganizeListener listener))
    (ß
        (§ call reorganizeListeners.add(new ListenerRegistration<>(listener, executor)))
    )

    ;;;
     ; Adds a generic {@link TransactionReceivedInBlockListener} listener to the chain.
     ;;
    #_public
    (§ method void addTransactionReceivedListener(TransactionReceivedInBlockListener listener))
    (ß
        (§ call addTransactionReceivedListener(Threading.USER_THREAD, listener))
    )

    ;;;
     ; Adds a generic {@link TransactionReceivedInBlockListener} listener to the chain.
     ;;
    #_public
    #_final
    (§ method void addTransactionReceivedListener(Executor executor, TransactionReceivedInBlockListener listener))
    (ß
        (§ call transactionReceivedListeners.add(new ListenerRegistration<>(listener, executor)))
    )

    ;;;
     ; Removes the given {@link NewBestBlockListener} from the chain.
     ;;
    #_public
    (§ method void removeNewBestBlockListener(NewBestBlockListener listener))
    (ß
        (§ call ListenerRegistration.removeFromList(listener, newBestBlockListeners))
    )

    ;;;
     ; Removes the given {@link ReorganizeListener} from the chain.
     ;;
    #_public
    (§ method void removeReorganizeListener(ReorganizeListener listener))
    (ß
        (§ call ListenerRegistration.removeFromList(listener, reorganizeListeners))
    )

    ;;;
     ; Removes the given {@link TransactionReceivedInBlockListener} from the chain.
     ;;
    #_public
    (§ method void removeTransactionReceivedListener(TransactionReceivedInBlockListener listener))
    (ß
        (§ call ListenerRegistration.removeFromList(listener, transactionReceivedListeners))
    )

    ;;;
     ; Returns the {@link BlockStore} the chain was constructed with.  You can use this to iterate over the chain.
     ;;
    #_public
    (§ method BlockStore getBlockStore())
    (ß
        (§ return blockStore)
    )

    ;;;
     ; Adds/updates the given {@link Block} with the block store.
     ; This version is used when the transactions have not been verified.
     ; @param storedPrev The {@link StoredBlock} which immediately precedes block.
     ; @param block The {@link Block} to add/update.
     ; @return the newly created {@link StoredBlock}
     ;;
    #_protected
    #_abstract
    (§ method StoredBlock addToBlockStore(StoredBlock storedPrev, Block block))
        (§ throws BlockStoreException, VerificationException)

    ;;;
     ; Adds/updates the given {@link StoredBlock} with the block store.
     ; This version is used when the transactions have already been verified to properly spend txOutputChanges.
     ; @param storedPrev The {@link StoredBlock} which immediately precedes block.
     ; @param header The {@link StoredBlock} to add/update.
     ; @param txOutputChanges The total sum of all changes made by this block to the set of open transaction outputs
     ;                        (from a call to connectTransactions), if in fully verifying mode (null otherwise).
     ; @return the newly created {@link StoredBlock}
     ;;
    #_protected
    #_abstract
    (§ method StoredBlock addToBlockStore(StoredBlock storedPrev, Block header, #_nilable TransactionOutputChanges txOutputChanges))
        (§ throws BlockStoreException, VerificationException)

    ;;;
     ; Rollback the block store to a given height.  This is currently only supported by {@link BlockChain} instances.
     ;
     ; @throws BlockStoreException
     ;             if the operation fails or is unsupported.
     ;;
    #_protected
    #_abstract
    (§ method void rollbackBlockStore(int height))
        (§ throws BlockStoreException)

    ;;;
     ; Called before setting chain head in memory.
     ; Should write the new head to block store and then commit any database transactions
     ; that were started by disconnectTransactions/connectTransactions.
     ;;
    #_protected
    #_abstract
    (§ method void doSetChainHead(StoredBlock chainHead))
        (§ throws BlockStoreException)

    ;;;
     ; Called if we (possibly) previously called disconnectTransaction/connectTransactions,
     ; but will not be calling preSetChainHead as a block failed verification.
     ; Can be used to abort database transactions that were started by
     ; disconnectTransactions/connectTransactions.
     ;;
    #_protected
    #_abstract
    (§ method void notSettingChainHead())
        (§ throws BlockStoreException)

    ;;;
     ; For a standard BlockChain, this should return blockStore.get(hash),
     ; for a FullPrunedBlockChain blockStore.getOnceUndoableStoredBlock(hash)
     ;;
    #_protected
    #_abstract
    (§ method StoredBlock getStoredBlockInCurrentScope(Sha256Hash hash))
        (§ throws BlockStoreException)

    ;;;
     ; Processes a received block and tries to add it to the chain.  If there's something wrong with the block an
     ; exception is thrown.  If the block is OK but cannot be connected to the chain at this time, returns false.
     ; If the block can be connected to the chain, returns true.
     ; Accessing block's transactions in another thread while this method runs may result in undefined behavior.
     ;;
    #_public
    (§ method boolean add(Block block))
        (§ throws VerificationException, PrunedException)
    (ß
        (§ try)
        (ß
            (§ return add(block, true, nil, nil))
        )
        (§ catch (BlockStoreException e))
        (ß
            ;; TODO: Figure out a better way to propagate this exception to the user.
            (§ throw new RuntimeException(e))
        )
        (§ catch (VerificationException e))
        (ß
            (§ try)
            (ß
                (§ call notSettingChainHead())
            )
            (§ catch (BlockStoreException e1))
            (ß
                (§ throw new RuntimeException(e1))
            )
            (§ throw new VerificationException("Could not verify block:\n" + block, e))
        )
    )

    ;;;
     ; Processes a received block and tries to add it to the chain.  If there's something wrong with the block an
     ; exception is thrown.  If the block is OK but cannot be connected to the chain at this time, returns false.
     ; If the block can be connected to the chain, returns true.
     ;;
    #_public
    (§ method boolean add(FilteredBlock block))
        (§ throws VerificationException, PrunedException)
    (ß
        (§ try)
        (ß
            ;; The block has a list of hashes of transactions that matched the Bloom filter, and a list of associated
            ;; Transaction objects.  There may be fewer Transaction objects than hashes, this is expected.  It can happen
            ;; in the case where we were already around to witness the initial broadcast, so we downloaded the
            ;; transaction and sent it to the wallet before this point (the wallet may have thrown it away if it was
            ;; a false positive, as expected in any Bloom filtering scheme).  The filteredTxn list here will usually
            ;; only be full of data when we are catching up to the head of the chain and thus haven't witnessed any
            ;; of the transactions.
            (§ return add(block.getBlockHeader(), true, block.getTransactionHashes(), block.getAssociatedTransactions()))
        )
        (§ catch (BlockStoreException e))
        (ß
            ;; TODO: Figure out a better way to propagate this exception to the user.
            (§ throw new RuntimeException(e))
        )
        (§ catch (VerificationException e))
        (ß
            (§ try)
            (ß
                (§ call notSettingChainHead())
            )
            (§ catch (BlockStoreException e1))
            (ß
                (§ throw new RuntimeException(e1))
            )
            (§ throw new VerificationException("Could not verify block " + block.getHash() + "\n" + block, e))
        )
    )

    ;;;
     ; Whether or not we are maintaining a set of unspent outputs and are verifying all transactions.
     ; Also indicates that all calls to add() should provide a block containing transactions
     ;;
    #_protected
    #_abstract
    (§ method boolean shouldVerifyTransactions())

    ;;;
     ; Connect each transaction in block.transactions, verifying them as we go and removing spent outputs
     ; If an error is encountered in a transaction, no changes should be made to the underlying BlockStore
     ; and a VerificationException should be thrown.
     ; Only called if shouldVerifyTransactions().
     ; @throws VerificationException if an attempt was made to spend an already-spent output, or if a transaction incorrectly solved an output script.
     ; @throws BlockStoreException if the block store had an underlying error.
     ; @return The full set of all changes made to the set of open transaction outputs.
     ;;
    #_protected
    #_abstract
    (§ method TransactionOutputChanges connectTransactions(int height, Block block))
        (§ throws VerificationException, BlockStoreException)

    ;;;
     ; Load newBlock from BlockStore and connect its transactions, returning changes to the set of unspent transactions.
     ; If an error is encountered in a transaction, no changes should be made to the underlying BlockStore.
     ; Only called if shouldVerifyTransactions().
     ; @throws PrunedException if newBlock does not exist as a {@link StoredUndoableBlock} in the block store.
     ; @throws VerificationException if an attempt was made to spend an already-spent output, or if a transaction incorrectly solved an output script.
     ; @throws BlockStoreException if the block store had an underlying error or newBlock does not exist in the block store at all.
     ; @return The full set of all changes made to the set of open transaction outputs.
     ;;
    #_protected
    #_abstract
    (§ method TransactionOutputChanges connectTransactions(StoredBlock newBlock))
        (§ throws VerificationException, BlockStoreException, PrunedException)

    ;; filteredTxHashList contains all transactions, filteredTxn just a subset
    #_private
    (§ method boolean add(Block block, boolean tryConnecting, #_nilable List<Sha256Hash> filteredTxHashList, #_nilable Map<Sha256Hash, Transaction> filteredTxn))
        (§ throws BlockStoreException, VerificationException, PrunedException)
    (ß
        ;; TODO: Use read/write locks to ensure that during chain download properties are still low latency.
        (§ call lock.lock())
        (§ try)
        (ß
            ;; Quick check for duplicates to avoid an expensive check further down (in findSplit).
            ;; This can happen a lot when connecting orphan transactions due to the dumb brute force algorithm we use.
            (§ if (block.equals(getChainHead().getHeader())))
                (§ return true)
            (§ if (tryConnecting && orphanBlocks.containsKey(block.getHash())))
                (§ return false)

            ;; If we want to verify transactions (i.e. we are running with full blocks), verify that block has transactions.
            (§ if (shouldVerifyTransactions() && block.transactions == nil))
                (§ throw new VerificationException("Got a block header while running in full-block mode"))

            ;; Check for already-seen block, but only for full pruned mode, where the DB is
            ;; more likely able to handle these queries quickly.
            (§ if (shouldVerifyTransactions() && blockStore.get(block.getHash()) != nil))
                (§ return true)

            #_final
            (§ var StoredBlock storedPrev)
            #_final
            (§ var int height)
            #_final
            (§ var EnumSet<Block.VerifyFlag> flags)

            ;; Prove the block is internally valid: hash is lower than target, etc.  This only checks the block contents
            ;; if there is a tx sending or receiving coins using an address in one of our wallets.  And those transactions
            ;; are only lightly verified: presence in a valid connecting block is taken as proof of validity.  See the
            ;; article here for more details: https://bitcoinj.github.io/security-model
            (§ try)
            (ß
                (§ call block.verifyHeader())
                (§ ass storedPrev = getStoredBlockInCurrentScope(block.getPrevBlockHash()))
                (§ if (storedPrev != nil))
                    (§ ass height = storedPrev.getHeight() + 1)
                (§ else)
                    (§ ass height = Block.BLOCK_HEIGHT_UNKNOWN)
                (§ ass flags = params.getBlockVerificationFlags(block, versionTally, height))
                (§ if (shouldVerifyTransactions()))
                    (§ call block.verifyTransactions(height, flags))
            )
            (§ catch (VerificationException e))
            (ß
                (§ call log.error("Failed to verify block: ", e))
                (§ call log.error(block.getHashAsString()))
                (§ throw e)
            )

            ;; Try linking it to a place in the currently known blocks.

            (§ if (storedPrev == nil))
            (ß
                ;; We can't find the previous block.  Probably we are still in the process of downloading the chain and
                ;; a block was solved whilst we were doing it.  We put it to one side and try to connect it later when we
                ;; have more blocks.
                (§ call Preconditions.checkState(tryConnecting, "bug in tryConnectingOrphans"))
                (§ call log.warn("Block does not connect: {} prev {}", block.getHashAsString(), block.getPrevBlockHash()))
                (§ call orphanBlocks.put(block.getHash(), new OrphanBlock(block, filteredTxHashList, filteredTxn)))
                (§ return false)
            )

            (§ call Preconditions.checkState(lock.isHeldByCurrentThread()))
            ;; It connects to somewhere on the chain.  Not necessarily the top of the best known chain.
            (§ call params.checkDifficultyTransitions(storedPrev, block, blockStore))
            (§ call connectBlock(block, storedPrev, shouldVerifyTransactions(), filteredTxHashList, filteredTxn))

            (§ if (tryConnecting))
                (§ call tryConnectingOrphans())

            (§ return true)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Returns the hashes of the currently stored orphan blocks and then deletes them from this objects storage.
     ; Used by Peer when a filter exhaustion event has occurred and thus any orphan blocks that have been downloaded
     ; might be inaccurate/incomplete.
     ;;
    #_public
    (§ method Set<Sha256Hash> drainOrphanBlocks())
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ var Set<Sha256Hash> hashes = new HashSet<>(orphanBlocks.keySet()))
            (§ call orphanBlocks.clear())
            (§ return hashes)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;; expensiveChecks enables checks that require looking at blocks further back in the chain
    ;; than the previous one when connecting (e.g. median timestamp check)
    ;; It could be exposed, but for now we just set it to shouldVerifyTransactions()
    #_private
    (§ method void connectBlock(#_final Block block, StoredBlock storedPrev, boolean expensiveChecks, #_nilable #_final List<Sha256Hash> filteredTxHashList, #_nilable #_final Map<Sha256Hash, Transaction> filteredTxn))
        (§ throws BlockStoreException, VerificationException, PrunedException)
    (ß
        (§ call Preconditions.checkState(lock.isHeldByCurrentThread()))
        (§ var boolean filtered = (filteredTxHashList != nil && filteredTxn != nil))
        ;; Check that we aren't connecting a block that fails a checkpoint check.
        (§ if (!params.passesCheckpoint(storedPrev.getHeight() + 1, block.getHash())))
            (§ throw new VerificationException("Block failed checkpoint lockin at " + (storedPrev.getHeight() + 1)))
        (§ if (shouldVerifyTransactions()))
        (ß
            (§ call Preconditions.checkNotNull(block.transactions))
            (§ for (Transaction tx :for block.transactions))
                (§ if (!tx.isFinal(storedPrev.getHeight() + 1, block.getTimeSeconds())))
                   (§ throw new VerificationException("Block contains non-final transaction"))
        )

        (§ var StoredBlock head = getChainHead())
        (§ if (storedPrev.equals(head)))
        (ß
            (§ if (filtered && 0 < filteredTxn.size()))
            (ß
                (§ call log.debug("Block {} connects to top of best chain with {} transaction(s) of which we were sent {}", block.getHashAsString(), filteredTxHashList.size(), filteredTxn.size()))
                (§ for (Sha256Hash hash :for filteredTxHashList))
                    (§ call log.debug("  matched tx {}", hash))
            )
            (§ if (expensiveChecks && block.getTimeSeconds() <= getMedianTimestampOfRecentBlocks(head, blockStore)))
                (§ throw new VerificationException("Block's timestamp is too early"))

            ;; BIP 66 & 65: Enforce block version 3/4 once they are a supermajority of blocks.
            ;; NOTE: This requires 1,000 blocks since the last checkpoint (on main net, less on test) in order to be applied.
            ;; It is also limited to stopping addition of new v2/3 blocks to the tip of the chain.
            (§ if (block.getVersion() == Block.BLOCK_VERSION_BIP34 || block.getVersion() == Block.BLOCK_VERSION_BIP66))
            (ß
                #_final
                (§ var Integer count = versionTally.getCountAtOrAbove(block.getVersion() + 1))
                (§ if (count != nil && params.getMajorityRejectBlockOutdated() <= count))
                    (§ throw new VerificationException.BlockVersionOutOfDate(block.getVersion()))
            )

            ;; This block connects to the best known block, it is a normal continuation of the system.
            (§ var TransactionOutputChanges txOutChanges = nil)
            (§ if (shouldVerifyTransactions()))
                (§ ass txOutChanges = connectTransactions(storedPrev.getHeight() + 1, block))
            (§ var StoredBlock newStoredBlock = addToBlockStore(storedPrev, (block.transactions == nil) ? block :else block.cloneAsHeader(), txOutChanges))
            (§ call versionTally.add(block.getVersion()))
            (§ call setChainHead(newStoredBlock))
            (§ call log.debug("Chain is now {} blocks high, running listeners", newStoredBlock.getHeight()))
            (§ call informListenersForNewBlock(block, NewBlockType.BEST_CHAIN, filteredTxHashList, filteredTxn, newStoredBlock))
        )
        (§ else)
        (ß
            ;; This block connects to somewhere other than the top of the best known chain.  We treat these differently.
            ;;
            ;; Note that we send the transactions to the wallet FIRST, even if we're about to re-organize this block
            ;; to become the new best chain head.  This simplifies handling of the re-org in the Wallet class.
            (§ var StoredBlock newBlock = storedPrev.build(block))
            (§ var boolean haveNewBestChain = newBlock.moreWorkThan(head))
            (§ if (haveNewBestChain))
            (ß
                (§ call log.info("Block is causing a re-organize"))
            )
            (§ else)
            (ß
                (§ var StoredBlock splitPoint = findSplit(newBlock, head, blockStore))
                (§ if (splitPoint != nil && splitPoint.equals(newBlock)))
                (ß
                    ;; newStoredBlock is a part of the same chain, there's no fork.  This happens when we receive a block
                    ;; that we already saw and linked into the chain previously, which isn't the chain head.
                    ;; Re-processing it is confusing for the wallet so just skip.
                    (§ call log.warn("Saw duplicated block in main chain at height {}: {}", newBlock.getHeight(), newBlock.getHeader().getHash()))
                    (§ return)
                )

                (§ if (splitPoint == nil))
                (ß
                    ;; This should absolutely never happen.
                    ;; (lets not write the full block to disk to keep any bugs which allow this to happen from writing unreasonable amounts of data to disk)
                    (§ throw new VerificationException("Block forks the chain but splitPoint is nil"))
                )
                (§ else)
                (ß
                    ;; We aren't actually spending any transactions (yet) because we are on a fork.
                    (§ call addToBlockStore(storedPrev, block))
                    (§ var int splitPointHeight = splitPoint.getHeight())
                    (§ var String splitPointHash = splitPoint.getHeader().getHashAsString())
                    (§ call log.info("Block forks the chain at height {}/block {}, but it did not cause a reorganize:\n{}", splitPointHeight, splitPointHash, newBlock.getHeader().getHashAsString()))
                )
            )

            ;; We may not have any transactions if we received only a header, which can happen during fast catchup.
            ;; If we do, send them to the wallet but state that they are on a side chain so it knows not to try and
            ;; spend them until they become activated.
            (§ if (block.transactions != nil || filtered))
                (§ call informListenersForNewBlock(block, NewBlockType.SIDE_CHAIN, filteredTxHashList, filteredTxn, newBlock))

            (§ if (haveNewBestChain))
                (§ call handleNewBestChain(storedPrev, newBlock, block, expensiveChecks))
        )
    )

    #_private
    (§ method void informListenersForNewBlock(#_final Block block, #_final NewBlockType newBlockType, #_nilable #_final List<Sha256Hash> filteredTxHashList, #_nilable #_final Map<Sha256Hash, Transaction> filteredTxn, #_final StoredBlock newStoredBlock))
        (§ throws VerificationException)
    (ß
        ;; Notify the listeners of the new block, so the depth and workDone of stored transactions can be updated
        ;; (in the case of the listener being a wallet).  Wallets need to know how deep each transaction is, so
        ;; coinbases aren't used before maturity.
        (§ var boolean first = true)
        (§ var Set<Sha256Hash> falsePositives = Sets.newHashSet())
        (§ if (filteredTxHashList != nil))
            (§ call falsePositives.addAll(filteredTxHashList))

        (§ for (#_final ListenerRegistration<TransactionReceivedInBlockListener> registration :for transactionReceivedListeners))
        (ß
            (§ if (registration.executor == Threading.SAME_THREAD))
            (ß
                (§ call informListenerForNewTransactions(block, newBlockType, filteredTxHashList, filteredTxn, newStoredBlock, first, registration.listener, falsePositives))
            )
            (§ else)
            (ß
                ;; Listener wants to be run on some other thread, so marshal it across here.
                #_final
                (§ var boolean notFirst = !first)
                (§ call registration.executor.execute(new Runnable()
                (ß
                    #_override
                    #_public
                    (§ method void run())
                    (ß
                        (§ try)
                        (ß
                            ;; We can't do false-positive handling when executing on another thread.
                            (§ var Set<Sha256Hash> ignoredFalsePositives = Sets.newHashSet())
                            (§ call informListenerForNewTransactions(block, newBlockType, filteredTxHashList, filteredTxn, newStoredBlock, notFirst, registration.listener, ignoredFalsePositives))
                        )
                        (§ catch (VerificationException e))
                        (ß
                            (§ call log.error("Block chain listener threw exception: ", e))
                            ;; Don't attempt to relay this back to the original peer thread if this was an async listener invocation.
                            ;; TODO: Make exception reporting a global feature and use it here.
                        )
                    )
                )))
            )
            (§ ass first = false)
        )

        (§ for (#_final ListenerRegistration<NewBestBlockListener> registration :for newBestBlockListeners))
        (ß
            (§ if (registration.executor == Threading.SAME_THREAD))
            (ß
                (§ if (newBlockType == NewBlockType.BEST_CHAIN))
                    (§ call registration.listener.notifyNewBestBlock(newStoredBlock))
            )
            (§ else)
            (ß
                ;; Listener wants to be run on some other thread, so marshal it across here.
                (§ call registration.executor.execute(new Runnable()
                (ß
                    #_override
                    #_public
                    (§ method void run())
                    (ß
                        (§ try)
                        (ß
                            (§ if (newBlockType == NewBlockType.BEST_CHAIN))
                                (§ call registration.listener.notifyNewBestBlock(newStoredBlock))
                        )
                        (§ catch (VerificationException e))
                        (ß
                            (§ call log.error("Block chain listener threw exception: ", e))
                            ;; Don't attempt to relay this back to the original peer thread if this was an async listener invocation.
                            ;; TODO: Make exception reporting a global feature and use it here.
                        )
                    )
                )))
            )
            (§ ass first = false)
        )

        (§ call trackFalsePositives(falsePositives.size()))
    )

    #_private
    #_static
    (§ method void informListenerForNewTransactions(Block block, NewBlockType newBlockType, #_nilable List<Sha256Hash> filteredTxHashList, #_nilable Map<Sha256Hash, Transaction> filteredTxn, StoredBlock newStoredBlock, boolean first, TransactionReceivedInBlockListener listener, Set<Sha256Hash> falsePositives))
        (§ throws VerificationException)
    (ß
        (§ if (block.transactions != nil))
        (ß
            ;; If this is not the first wallet, ask for the transactions to be duplicated before being given
            ;; to the wallet when relevant.  This ensures that if we have two connected wallets and a tx that
            ;; is relevant to both of them, they don't end up accidentally sharing the same object (which can
            ;; result in temporary in-memory corruption during re-orgs).  See bug 257.  We only duplicate in
            ;; the case of multiple wallets to avoid an unnecessary efficiency hit in the common case.
            (§ call sendTransactionsToListener(newStoredBlock, newBlockType, listener, 0, block.transactions, !first, falsePositives))
        )
        (§ elseif (filteredTxHashList != nil))
        (ß
            (§ call Preconditions.checkNotNull(filteredTxn))
            ;; We must send transactions to listeners in the order they appeared in the block - thus we iterate over the
            ;; set of hashes and call sendTransactionsToListener with individual txn when they have not already been
            ;; seen in loose broadcasts - otherwise notifyTransactionIsInBlock on the hash.
            (§ var int relativityOffset = 0)
            (§ for (Sha256Hash hash :for filteredTxHashList))
            (ß
                (§ var Transaction tx = filteredTxn.get(hash))
                (§ if (tx != nil))
                (ß
                    (§ call sendTransactionsToListener(newStoredBlock, newBlockType, listener, relativityOffset, Collections.singletonList(tx), !first, falsePositives))
                )
                (§ elseif (listener.notifyTransactionIsInBlock(hash, newStoredBlock, newBlockType, relativityOffset)))
                (ß
                    (§ call falsePositives.remove(hash))
                )
                (§ ass relativityOffset = relativityOffset + 1)
            )
        )
    )

    ;;;
     ; Gets the median timestamp of the last 11 blocks.
     ;;
    #_private
    #_static
    (§ method long getMedianTimestampOfRecentBlocks(StoredBlock storedBlock, BlockStore store))
        (§ throws BlockStoreException)
    (ß
        (§ var long[] timestamps = new long[11])
        (§ var int unused = 9)
        (§ ass timestamps[10] = storedBlock.getHeader().getTimeSeconds())
        (§ for ( :for 0 <= unused && (storedBlock = storedBlock.getPrev(store)) != nil :for unused = unused - 1))
            (§ ass timestamps[unused] = storedBlock.getHeader().getTimeSeconds())

        (§ call Arrays.sort(timestamps, unused + 1, 11))
        (§ return timestamps[unused + (11 - unused) / 2])
    )

    ;;;
     ; Disconnect each transaction in the block (after reading it from the block store).
     ; Only called if shouldVerifyTransactions().
     ; @throws PrunedException if block does not exist as a {@link StoredUndoableBlock} in the block store.
     ; @throws BlockStoreException if the block store had an underlying error or block does not exist in the block store at all.
     ;;
    #_protected
    #_abstract
    (§ method void disconnectTransactions(StoredBlock block))
        (§ throws PrunedException, BlockStoreException)

    ;;;
     ; Called as part of connecting a block when the new block results in a different chain having higher total work.
     ;
     ; if (shouldVerifyTransactions)
     ;     either newChainHead needs to be in the block store as a FullStoredBlock, or (block != null && block.transactions != null)
     ;;
    #_private
    (§ method void handleNewBestChain(StoredBlock storedPrev, StoredBlock newChainHead, Block block, boolean expensiveChecks))
        (§ throws BlockStoreException, VerificationException, PrunedException)
    (ß
        (§ call Preconditions.checkState(lock.isHeldByCurrentThread()))

        ;; This chain has overtaken the one we currently believe is best.  Reorganize is required.
        ;;
        ;; Firstly, calculate the block at which the chain diverged.  We only need to examine the
        ;; chain from beyond this block to find differences.

        (§ var StoredBlock head = getChainHead())
        #_final
        (§ var StoredBlock splitPoint = findSplit(newChainHead, head, blockStore))
        (§ call log.info("Re-organize after split at height {}", splitPoint.getHeight()))
        (§ call log.info("Old chain head: {}", head.getHeader().getHashAsString()))
        (§ call log.info("New chain head: {}", newChainHead.getHeader().getHashAsString()))
        (§ call log.info("Split at block: {}", splitPoint.getHeader().getHashAsString()))

        ;; Then build a list of all blocks in the old part of the chain and the new part.
        #_final
        (§ var LinkedList<StoredBlock> oldBlocks = getPartialChain(head, splitPoint, blockStore))
        #_final
        (§ var LinkedList<StoredBlock> newBlocks = getPartialChain(newChainHead, splitPoint, blockStore))

        ;; Disconnect each transaction in the previous main chain that is no longer in the new main chain.
        (§ var StoredBlock storedNewHead = splitPoint)
        (§ if (shouldVerifyTransactions()))
        (ß
            (§ for (StoredBlock oldBlock :for oldBlocks))
            (ß
                (§ try)
                (ß
                    (§ call disconnectTransactions(oldBlock))
                )
                (§ catch (PrunedException e))
                (ß
                    ;; We threw away the data we need to re-org this deep!  We need to go back to a peer with full
                    ;; block contents and ask them for the relevant data then rebuild the indexs.  Or we could just
                    ;; give up and ask the human operator to help get us unstuck (e.g. rescan from the genesis block).
                    ;; TODO: retry adding this block when we get a block with hash e.getHash()
                    (§ throw e)
                )
            )

            (§ var StoredBlock cursor)
            ;; Walk in ascending chronological order.
            (§ for (Iterator<StoredBlock> it = newBlocks.descendingIterator() :for it.hasNext() :for ))
            (ß
                (§ ass cursor = it.next())
                (§ var Block cursorBlock = cursor.getHeader())
                (§ if (expensiveChecks && cursorBlock.getTimeSeconds() <= getMedianTimestampOfRecentBlocks(cursor.getPrev(blockStore), blockStore)))
                    (§ throw new VerificationException("Block's timestamp is too early during reorg"))
                (§ var TransactionOutputChanges txOutChanges)
                (§ if (cursor != newChainHead || block == nil))
                    (§ ass txOutChanges = connectTransactions(cursor))
                (§ else)
                    (§ ass txOutChanges = connectTransactions(newChainHead.getHeight(), block))
                (§ ass storedNewHead = addToBlockStore(storedNewHead, cursorBlock.cloneAsHeader(), txOutChanges))
            )
        )
        (§ else)
        (ß
            ;; (Finally) write block to block store.
            (§ ass storedNewHead = addToBlockStore(storedPrev, newChainHead.getHeader()))
        )

        ;; Now inform the listeners.  This is necessary so the set of currently active transactions (that we can spend)
        ;; can be updated to take into account the re-organize.  We might also have received new coins we didn't have
        ;; before and our previous spends might have been undone.
        (§ for (#_final ListenerRegistration<ReorganizeListener> registration :for reorganizeListeners))
        (ß
            (§ if (registration.executor == Threading.SAME_THREAD))
            (ß
                ;; Short circuit the executor so we can propagate any exceptions.
                ;; TODO: Do we really need to do this or should it be irrelevant?
                (§ call registration.listener.reorganize(splitPoint, oldBlocks, newBlocks))
            )
            (§ else)
            (ß
                (§ call registration.executor.execute(new Runnable()
                (ß
                    #_override
                    #_public
                    (§ method void run())
                    (ß
                        (§ try)
                        (ß
                            (§ call registration.listener.reorganize(splitPoint, oldBlocks, newBlocks))
                        )
                        (§ catch (VerificationException e))
                        (ß
                            (§ call log.error("Block chain listener threw exception during reorg", e))
                        )
                    )
                )))
            )
        )

        ;; Update the pointer to the best known block.
        (§ call setChainHead(storedNewHead))
    )

    ;;;
     ; Returns the set of contiguous blocks between 'higher' and 'lower'.  Higher is included, lower is not.
     ;;
    #_private
    #_static
    (§ method LinkedList<StoredBlock> getPartialChain(StoredBlock higher, StoredBlock lower, BlockStore store))
        (§ throws BlockStoreException)
    (ß
        (§ call Preconditions.checkArgument(lower.getHeight() < higher.getHeight(), "higher and lower are reversed"))
        (§ var LinkedList<StoredBlock> results = new LinkedList<>())
        (§ var StoredBlock cursor = higher)
        (§ while (true))
        (ß
            (§ call results.add(cursor))
            (§ ass cursor = Preconditions.checkNotNull(cursor.getPrev(store), "Ran off the end of the chain"))
            (§ if (cursor.equals(lower)))
                (§ break)
        )
        (§ return results)
    )

    ;;;
     ; Locates the point in the chain at which newStoredBlock and chainHead diverge.  Returns null if no split point was
     ; found (i.e. they are not part of the same chain).  Returns newChainHead or chainHead if they don't actually diverge
     ; but are part of the same chain.
     ;;
    #_private
    #_static
    (§ method StoredBlock findSplit(StoredBlock newChainHead, StoredBlock oldChainHead, BlockStore store))
        (§ throws BlockStoreException)
    (ß
        (§ var StoredBlock currentChainCursor = oldChainHead)
        (§ var StoredBlock newChainCursor = newChainHead)
        ;; Loop until we find the block both chains have in common.  Example:
        ;;
        ;;    A -> B -> C -> D
        ;;         \--> E -> F -> G
        ;;
        ;; findSplit will return block B.  oldChainHead = D and newChainHead = G.
        (§ while (!currentChainCursor.equals(newChainCursor)))
        (ß
            (§ if (newChainCursor.getHeight() < currentChainCursor.getHeight()))
            (ß
                (§ ass currentChainCursor = currentChainCursor.getPrev(store))
                (§ call Preconditions.checkNotNull(currentChainCursor, "Attempt to follow an orphan chain"))
            )
            (§ else)
            (ß
                (§ ass newChainCursor = newChainCursor.getPrev(store))
                (§ call Preconditions.checkNotNull(newChainCursor, "Attempt to follow an orphan chain"))
            )
        )
        (§ return currentChainCursor)
    )

    ;;;
     ; @return the height of the best known chain, convenience for <tt>getChainHead().getHeight()</tt>
     ;;
    #_public
    #_final
    (§ method int getBestChainHeight())
    (ß
        (§ return getChainHead().getHeight())
    )

    #_public
    (§ enum NewBlockType
        (§ item BEST_CHAIN)
        (§ item SIDE_CHAIN)
    )

    #_private
    #_static
    (§ method void sendTransactionsToListener(StoredBlock block, NewBlockType blockType, TransactionReceivedInBlockListener listener, int relativityOffset, List<Transaction> transactions, boolean clone, Set<Sha256Hash> falsePositives))
        (§ throws VerificationException)
    (ß
        (§ for (Transaction tx :for transactions))
        (ß
            (§ try)
            (ß
                (§ call falsePositives.remove(tx.getHash()))
                (§ if (clone))
                    (§ ass tx = tx.params.getDefaultSerializer().makeTransaction(tx.bitcoinSerialize()))
                (§ call listener.receiveFromBlock(tx, block, blockType, relativityOffset))
                (§ ass relativityOffset = relativityOffset + 1)
            )
            (§ catch (ScriptException e))
            (ß
                ;; We don't want scripts we don't understand to break the block chain so just note that this tx was
                ;; not scanned here and continue.
                (§ call log.warn("Failed to parse a script: " + e))
            )
            (§ catch (ProtocolException e))
            (ß
                ;; Failed to duplicate tx, should never happen.
                (§ throw new RuntimeException(e))
            )
        )
    )

    #_protected
    (§ method void setChainHead(StoredBlock chainHead))
        (§ throws BlockStoreException)
    (ß
        (§ call doSetChainHead(chainHead))
        (§ sync chainHeadLock)
        (ß
            (§ ass this.chainHead = chainHead)
        )
    )

    ;;;
     ; For each block in orphanBlocks, see if we can now fit it on top of the chain and if so, do so.
     ;;
    #_private
    (§ method void tryConnectingOrphans())
        (§ throws VerificationException, BlockStoreException, PrunedException)
    (ß
        (§ call Preconditions.checkState(lock.isHeldByCurrentThread()))

        ;; For each block in our orphan list, try and fit it onto the head of the chain.  If we succeed remove it
        ;; from the list and keep going.  If we changed the head of the list at the end of the round try again until
        ;; we can't fit anything else on the top.
        ;;
        ;; This algorithm is kind of crappy, we should do a topo-sort then just connect them in order, but for small
        ;; numbers of orphan blocks it does OK.

        (§ var int blocksConnectedThisRound)
        (§ do)
        (ß
            (§ ass blocksConnectedThisRound = 0)
            (§ var Iterator<OrphanBlock> iter = orphanBlocks.values().iterator())
            (§ while (iter.hasNext()))
            (ß
                (§ var OrphanBlock orphanBlock = iter.next())
                ;; Look up the blocks previous.
                (§ var StoredBlock prev = getStoredBlockInCurrentScope(orphanBlock.block.getPrevBlockHash()))
                (§ if (prev == nil))
                (ß
                    ;; This is still an unconnected/orphan block.
                    (§ call log.debug("Orphan block {} is not connectable right now", orphanBlock.block.getHash()))
                    (§ continue)
                )
                ;; Otherwise we can connect it now.
                ;; False here ensures we don't recurse infinitely downwards when connecting huge chains.
                (§ call log.info("Connected orphan {}", orphanBlock.block.getHash()))
                (§ call add(orphanBlock.block, false, orphanBlock.filteredTxHashes, orphanBlock.filteredTxn))
                (§ call iter.remove())
                (§ ass blocksConnectedThisRound = blocksConnectedThisRound + 1)
            )
            (§ if (0 < blocksConnectedThisRound))
                (§ call log.info("Connected {} orphan blocks.", blocksConnectedThisRound))
        )
        (§ again (0 < blocksConnectedThisRound))
    )

    ;;;
     ; Returns the block at the head of the current best chain.  This is the block which represents the greatest
     ; amount of cumulative work done.
     ;;
    #_public
    (§ method StoredBlock getChainHead())
    (ß
        (§ sync chainHeadLock)
        (ß
            (§ return chainHead)
        )
    )

    ;;;
     ; An orphan block is one that does not connect to the chain anywhere (i.e. we can't find its parent, therefore
     ; it's an orphan).  Typically this occurs when we are downloading the chain and didn't reach the head yet, and/or
     ; if a block is solved whilst we are downloading.  It's possible that we see a small amount of orphan blocks which
     ; chain together, this method tries walking backwards through the known orphan blocks to find the bottom-most.
     ;
     ; @return from or one of from's parents, or null if "from" does not identify an orphan block
     ;;
    #_nilable
    #_public
    (§ method Block getOrphanRoot(Sha256Hash from))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ var OrphanBlock cursor = orphanBlocks.get(from))
            (§ if (cursor == nil))
                (§ return nil)
            (§ var OrphanBlock tmp)
            (§ while ((tmp = orphanBlocks.get(cursor.block.getPrevBlockHash())) != nil))
            (ß
                (§ ass cursor = tmp)
            )
            (§ return cursor.block)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;; Returns true if the given block is currently in the orphan blocks list. ;;
    #_public
    (§ method boolean isOrphan(Sha256Hash block))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ return orphanBlocks.containsKey(block))
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Returns an estimate of when the given block will be reached, assuming a perfect 10 minute average for each
     ; block.  This is useful for turning transaction lock times into human readable times.  Note that a height in
     ; the past will still be estimated, even though the time of solving is actually known (we won't scan backwards
     ; through the chain to obtain the right answer).
     ;;
    #_public
    (§ method Date estimateBlockTime(int height))
    (ß
        (§ sync chainHeadLock)
        (ß
            (§ var long offset = height - chainHead.getHeight())
            (§ var long headTime = chainHead.getHeader().getTimeSeconds())
            (§ var long estimated = (headTime * 1000) + (1000 * 60 * 10 * offset))
            (§ return new Date(estimated))
        )
    )

    ;;;
     ; Returns a future that completes when the block chain has reached the given height.  Yields the
     ; {@link StoredBlock} of the block that reaches that height first.  The future completes on a peer thread.
     ;;
    #_public
    (§ method ListenableFuture<StoredBlock> getHeightFuture(#_final int height))
    (ß
        #_final
        (§ var SettableFuture<StoredBlock> result = SettableFuture.create())
        (§ call addNewBestBlockListener(Threading.SAME_THREAD, new NewBestBlockListener()
        (ß
            #_override
            #_public
            (§ method void notifyNewBestBlock(StoredBlock block))
                (§ throws VerificationException)
            (ß
                (§ if (height <= block.getHeight()))
                (ß
                    (§ call removeNewBestBlockListener(this))
                    (§ call result.set(block))
                )
            )
        )))
        (§ return result)
    )

    ;;;
     ; The false positive rate is the average over all blockchain transactions of:
     ;
     ; - 1.0 if the transaction was false-positive (was irrelevant to all listeners)
     ; - 0.0 if the transaction was relevant or filtered out
     ;;
    #_public
    (§ method double getFalsePositiveRate())
    (ß
        (§ return falsePositiveRate)
    )

    ;;
     ; We completed handling of a filtered block.  Update false-positive estimate based
     ; on the total number of transactions in the original block.
     ;
     ; count includes filtered transactions, transactions that were passed in and were relevant
     ; and transactions that were false positives (i.e. includes all transactions in the block).
     ;;
    #_protected
    (§ method void trackFilteredTransactions(int count))
    (ß
        ;; Track non-false-positives in batch.  Each non-false-positive counts as 0.0 towards the estimate.
        ;;
        ;; This is slightly off because we are applying false positive tracking before non-FP tracking,
        ;; which counts FP as if they came at the beginning of the block.  Assuming uniform FP
        ;; spread in a block, this will somewhat underestimate the FP rate (5% for 1000 tx block).
        (§ var double alphaDecay = Math.pow(1 - FP_ESTIMATOR_ALPHA, count))

        ;; new_rate = alpha_decay * new_rate
        (§ ass falsePositiveRate = alphaDecay * falsePositiveRate)

        (§ var double betaDecay = Math.pow(1 - FP_ESTIMATOR_BETA, count))

        ;; trend = beta * (new_rate - old_rate) + beta_decay * trend
        (§ ass falsePositiveTrend = FP_ESTIMATOR_BETA * count * (falsePositiveRate - previousFalsePositiveRate) + betaDecay * falsePositiveTrend)

        ;; new_rate += alpha_decay * trend
        (§ ass falsePositiveRate = falsePositiveRate + (alphaDecay * falsePositiveTrend))

        ;; stash new_rate in old_rate
        (§ ass previousFalsePositiveRate = falsePositiveRate)
    )

    ;;;Irrelevant transactions were received.  Update false-positive estimate. ;;
    (§ method void trackFalsePositives(int count))
    (ß
        ;; Track false positives in batch by adding alpha to the false positive estimate once per count.
        ;; Each false positive counts as 1.0 towards the estimate.
        (§ ass falsePositiveRate = falsePositiveRate + (FP_ESTIMATOR_ALPHA * count))
        (§ if (0 < count))
            (§ ass log.debug("{} false positives, current rate = {} trend = {}", count, falsePositiveRate, falsePositiveTrend))
    )

    ;;; Resets estimates of false positives.  Used when the filter is sent to the peer. ;;
    #_public
    (§ method void resetFalsePositiveEstimate())
    (ß
        (§ ass falsePositiveRate = 0)
        (§ ass falsePositiveTrend = 0)
        (§ ass previousFalsePositiveRate = 0)
    )

    #_protected
    (§ method VersionTally getVersionTally())
    (ß
        (§ return versionTally)
    )
)

#_(ns org.bitcoinj.core #_"Address"
    (:import [java.io IOException ObjectInputStream ObjectOutputStream])
    (:import [com.google.common.base Preconditions])
  #_(:require [org.bitcoinj.params Networks]
             [org.bitcoinj.script Script]))

;;;
 ; <p>A Bitcoin address looks like 1MsScoe2fTJoq4ZPdQgqyhgWeoNamYPevy and is derived from an elliptic curve public key
 ; plus a set of network parameters.  Not to be confused with a {@link PeerAddress} or {@link AddressMessage}
 ; which are about network (TCP) addresses.</p>
 ;
 ; <p>A standard address is built by taking the RIPE-MD160 hash of the public key bytes, with a version prefix and a
 ; checksum suffix, then encoding it textually as base58.  The version prefix is used to both denote the network for
 ; which the address is valid (see {@link NetworkParameters}, and also to indicate how the bytes inside the address
 ; should be interpreted.  Whilst almost all addresses today are hashes of public keys, another (currently unsupported
 ; type) can contain a hash of a script instead.</p>
 ;;
#_public
(§ class Address extends VersionedChecksummedBytes
    ;;;
     ; An address is a RIPEMD160 hash of a public key, therefore is always 160 bits or 20 bytes.
     ;;
    #_public
    #_static
    #_final
    (§ field int LENGTH = 20)

    #_private
    #_transient
    (§ field NetworkParameters params)

    ;;;
     ; Construct an address from parameters, the address version, and the hash160 form.  Example:
     ;
     ; <pre>new Address(MainNetParams.get(), NetworkParameters.getAddressHeader(), Hex.decode("4a22c3c4cbb31e4d03b15550636762bda0baf85a"));</pre>
     ;;
    #_public
    (§ constructor Address(NetworkParameters params, int version, byte[] hash160))
        (§ throws WrongNetworkException)
    (ß
        (§ super (version, hash160))

        (§ call Preconditions.checkNotNull(params))
        (§ call Preconditions.checkArgument(hash160.length == 20, "Addresses are 160-bit hashes, so you must provide 20 bytes"))
        (§ if (!isAcceptableVersion(params, version)))
            (§ throw new WrongNetworkException(version, params.getAcceptableAddressCodes()))
        (§ ass this.params = params)
    )

    ;;; Returns an Address that represents the given P2SH script hash. ;;
    #_public
    #_static
    (§ method Address fromP2SHHash(NetworkParameters params, byte[] hash160))
    (ß
        (§ try)
        (ß
            (§ return new Address(params, params.getP2SHHeader(), hash160))
        )
        (§ catch (WrongNetworkException e))
        (ß
            (§ throw new RuntimeException(e)) ;; Cannot happen.
        )
    )

    ;;; Returns an Address that represents the script hash extracted from the given scriptPubKey. ;;
    #_public
    #_static
    (§ method Address fromP2SHScript(NetworkParameters params, Script scriptPubKey))
    (ß
        (§ call Preconditions.checkArgument(scriptPubKey.isPayToScriptHash(), "Not a P2SH script"))
        (§ return fromP2SHHash(params, scriptPubKey.getPubKeyHash()))
    )

    ;;;
     ; Construct an address from its Base58 representation.
     ; @param params
     ;            The expected NetworkParameters or null if you don't want validation.
     ; @param base58
     ;            The textual form of the address, such as "17kzeh4N8g49GFvdDzSf8PjaPfyoD1MndL".
     ; @throws AddressFormatException
     ;             if the given base58 doesn't parse or the checksum is invalid
     ; @throws WrongNetworkException
     ;             if the given address is valid but for a different chain (e.g. testnet vs. mainnet)
     ;;
    #_public
    #_static
    (§ method Address fromBase58(#_nilable NetworkParameters params, String base58))
        (§ throws AddressFormatException)
    (ß
        (§ return new Address(params, base58))
    )

    ;;;
     ; Construct an address from parameters and the hash160 form.  Example:
     ;
     ; <pre>new Address(MainNetParams.get(), Hex.decode("4a22c3c4cbb31e4d03b15550636762bda0baf85a"));</pre>
     ;;
    #_public
    (§ constructor Address(NetworkParameters params, byte[] hash160))
    (ß
        (§ super (params.getAddressHeader(), hash160))

        (§ call Preconditions.checkArgument(hash160.length == 20, "Addresses are 160-bit hashes, so you must provide 20 bytes"))
        (§ ass this.params = params)
    )

    ;;; @deprecated Use {@link #fromBase58(NetworkParameters, String)} ;;
    #_deprecated
    #_public
    (§ constructor Address(#_nilable NetworkParameters params, String address))
        (§ throws AddressFormatException)
    (ß
        (§ super (address))

        (§ if (params != nil))
        (ß
            (§ if (!isAcceptableVersion(params, version)))
                (§ throw new WrongNetworkException(version, params.getAcceptableAddressCodes()))
            (§ ass this.params = params)
        )
        (§ else)
        (ß
            (§ var NetworkParameters paramsFound = nil)
            (§ for (NetworkParameters p :for Networks.get()))
            (ß
                (§ if (isAcceptableVersion(p, version)))
                (ß
                    (§ ass paramsFound = p)
                    (§ break)
                )
            )
            (§ if (paramsFound == nil))
                (§ throw new AddressFormatException("No network found for " + address))

            (§ ass this.params = paramsFound)
        )
    )

    ;;; The (big endian) 20 byte hash that is the core of a Bitcoin address. ;;
    #_public
    (§ method byte[] getHash160())
    (ß
        (§ return bytes)
    )

    ;;;
     ; Returns true if this address is a Pay-To-Script-Hash (P2SH) address.
     ; See also https://github.com/bitcoin/bips/blob/master/bip-0013.mediawiki: Address Format for pay-to-script-hash
     ;;
    #_public
    (§ method boolean isP2SHAddress())
    (ß
        #_final
        (§ var NetworkParameters parameters = getParameters())
        (§ return (parameters != nil && this.version == parameters.p2shHeader))
    )

    ;;;
     ; Examines the version byte of the address and attempts to find a matching NetworkParameters.  If you aren't sure
     ; which network the address is intended for (e.g. it was provided by a user), you can use this to decide if it is
     ; compatible with the current wallet.  You should be able to handle a null response from this method.  Note that
     ; the parameters returned is not necessarily the same as the one the Address was created with.
     ;
     ; @return a NetworkParameters representing the network the address is intended for
     ;;
    #_public
    (§ method NetworkParameters getParameters())
    (ß
        (§ return params)
    )

    ;;;
     ; Given an address, examines the version byte and attempts to find a matching NetworkParameters.  If you aren't sure
     ; which network the address is intended for (e.g. it was provided by a user), you can use this to decide if it is
     ; compatible with the current wallet.
     ; @return a NetworkParameters of the address
     ; @throws AddressFormatException if the string wasn't of a known version
     ;;
    #_public
    #_static
    (§ method NetworkParameters getParametersFromAddress(String address))
        (§ throws AddressFormatException)
    (ß
        (§ try)
        (ß
            (§ return Address.fromBase58(nil, address).getParameters())
        )
        (§ catch (WrongNetworkException e))
        (ß
            (§ throw new RuntimeException(e)) ;; Cannot happen.
        )
    )

    ;;;
     ; Check if a given address version is valid given the NetworkParameters.
     ;;
    #_private
    #_static
    (§ method boolean isAcceptableVersion(NetworkParameters params, int version))
    (ß
        (§ for (int v :for params.getAcceptableAddressCodes()))
        (ß
            (§ if (version == v))
                (§ return true)
        )
        (§ return false)
    )

    ;;;
     ; This implementation narrows the return type to <code>Address</code>.
     ;;
    #_override
    #_public
    (§ method Address clone())
        (§ throws CloneNotSupportedException)
    (ß
        (§ return (Address)super.clone())
    )

    ;; Java serialization

    #_private
    (§ method void writeObject(ObjectOutputStream out))
        (§ throws IOException)
    (ß
        (§ call out.defaultWriteObject())
        (§ call out.writeUTF(params.id))
    )

    #_private
    (§ method void readObject(ObjectInputStream in))
        (§ throws IOException, ClassNotFoundException)
    (ß
        (§ call in.defaultReadObject())
        (§ ass params = NetworkParameters.fromID(in.readUTF()))
    )
)

#_(ns org.bitcoinj.core #_"AddressFormatException")

#_public
(§ class AddressFormatException extends IllegalArgumentException
    #_public
    (§ constructor AddressFormatException())
    (ß
        (§ super ())
    )

    #_public
    (§ constructor AddressFormatException(String message))
    (ß
        (§ super (message))
    )
)

#_(ns org.bitcoinj.core #_"AddressMessage"
    (:import [java.io IOException OutputStream]
             [java.util ArrayList Collections List]))

;;;
 ; <p>Represents an "addr" message on the P2P network, which contains broadcast IP addresses of other peers.  This is
 ; one of the ways peers can find each other without using the DNS or IRC discovery mechanisms.  However storing and
 ; using addr messages is not presently implemented.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class AddressMessage extends Message
    #_private
    #_static
    #_final
    (§ field long MAX_ADDRESSES = 1024)

    #_private
    (§ field List<PeerAddress> addresses)

    ;;;
     ; Contruct a new 'addr' message.
     ; @param params NetworkParameters object.
     ; @param offset The location of the first payload byte within the array.
     ; @param parseRetain Whether to retain the backing byte array for quick reserialization.
     ; If true and the backing byte array is invalidated due to modification of a field, then
     ; the cached bytes may be repopulated and retained if the message is serialized again in the future.
     ; @param length The length of message if known.  Usually this is provided when deserializing of the wire
     ; as the length will be provided as part of the header.  Set to Message.UNKNOWN_LENGTH, if not known.
     ; @throws ProtocolException
     ;;
    (§ constructor AddressMessage(NetworkParameters params, byte[] payload, int offset, MessageSerializer setSerializer, int length))
        (§ throws ProtocolException)
    (ß
        (§ super (params, payload, offset, setSerializer, length))
    )

    ;;;
     ; Contruct a new 'addr' message.
     ; @param params NetworkParameters object.
     ; @param serializer The serializer to use for this block.
     ; @param length The length of message if known.  Usually this is provided when deserializing of the wire
     ; as the length will be provided as part of the header.  Set to Message.UNKNOWN_LENGTH, if not known.
     ; @throws ProtocolException
     ;;
    (§ constructor AddressMessage(NetworkParameters params, byte[] payload, MessageSerializer serializer, int length))
        (§ throws ProtocolException)
    (ß
        (§ super (params, payload, 0, serializer, length))
    )

    (§ constructor AddressMessage(NetworkParameters params, byte[] payload, int offset))
        (§ throws ProtocolException)
    (ß
        (§ super (params, payload, offset, params.getDefaultSerializer(), UNKNOWN_LENGTH))
    )

    (§ constructor AddressMessage(NetworkParameters params, byte[] payload))
        (§ throws ProtocolException)
    (ß
        (§ super (params, payload, 0, params.getDefaultSerializer(), UNKNOWN_LENGTH))
    )

    #_override
    #_protected
    (§ method void parse())
        (§ throws ProtocolException)
    (ß
        (§ var long numAddresses = readVarInt())
        ;; Guard against ultra large messages that will crash us.
        (§ if (MAX_ADDRESSES < numAddresses))
            (§ throw new ProtocolException("Address message too large."))
        (§ ass addresses = new ArrayList<>((int)numAddresses))
        (§ for (int i = 0 :for i < numAddresses :for i = i + 1))
        (ß
            (§ var PeerAddress addr = new PeerAddress(params, payload, cursor, protocolVersion, this, serializer))
            (§ call addresses.add(addr))
            (§ ass cursor = cursor + addr.getMessageSize())
        )
        (§ ass length = new VarInt(addresses.size()).getSizeInBytes())
        ;; The 4 byte difference is the uint32 timestamp that was introduced in version 31402.
        (§ ass length = length + (addresses.size() * (31402 < protocolVersion ? PeerAddress.MESSAGE_SIZE :else PeerAddress.MESSAGE_SIZE - 4)))
    )

    #_override
    #_protected
    (§ method void bitcoinSerializeToStream(OutputStream stream))
        (§ throws IOException)
    (ß
        (§ if (addresses != nil))
        (ß
            (§ call stream.write(new VarInt(addresses.size()).encode()))
            (§ for (PeerAddress addr :for addresses))
                (§ call addr.bitcoinSerialize(stream))
        )
    )

    ;;;
     ; @return An unmodifiableList view of the backing List of addresses.  Addresses contained within the list may be safely modified.
     ;;
    #_public
    (§ method List<PeerAddress> getAddresses())
    (ß
        (§ return Collections.unmodifiableList(addresses))
    )

    #_public
    (§ method void addAddress(PeerAddress address))
    (ß
        (§ call unCache())
        (§ call address.setParent(this))
        (§ call addresses.add(address))
        (§ if (length == UNKNOWN_LENGTH))
            (§ call getMessageSize())
        (§ else)
            (§ ass length = length + address.getMessageSize())
    )

    #_public
    (§ method void removeAddress(int index))
    (ß
        (§ call unCache())
        (§ var PeerAddress address = addresses.remove(index))
        (§ call address.setParent(nil))
        (§ if (length == UNKNOWN_LENGTH))
            (§ call getMessageSize())
        (§ else)
            (§ ass length = length - address.getMessageSize())
    )

    #_override
    #_public
    (§ method String toString())
    (ß
        (§ return "addr: " + Utils.SPACE_JOINER.join(addresses))
    )
)

#_(ns org.bitcoinj.core #_"AlertMessage"
    (:import [java.util Date HashSet Set]))

;;;
 ; Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 ; The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 ; an available upgrade or a serious network problem.  Alerts have an expiration time, data that specifies what
 ; set of software versions it matches and the ability to cancel them by broadcasting another type of alert.
 ;
 ; The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 ; log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 ; For example, you could treat it as an upgrade notification specific to your app.  Satoshi designed alerts to ensure
 ; that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 ; be purely peer-to-peer.  You don't have to use this of course, and indeed it often makes more sense not to.
 ;
 ; <p>Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class AlertMessage extends Message
    #_private
    (§ field byte[] content)
    #_private
    (§ field byte[] signature)

    ;; See the getters for documentation of what each field means.
    #_private
    (§ field long version = 1)
    #_private
    (§ field Date relayUntil)
    #_private
    (§ field Date expiration)
    #_private
    (§ field long id)
    #_private
    (§ field long cancel)
    #_private
    (§ field long minVer, maxVer)
    #_private
    (§ field long priority)
    #_private
    (§ field String comment, statusBar, reserved)

    ;; Chosen arbitrarily to avoid memory blowups.
    #_private
    #_static
    #_final
    (§ field long MAX_SET_SIZE = 100)

    #_public
    (§ constructor AlertMessage(NetworkParameters params, byte[] payloadBytes))
        (§ throws ProtocolException)
    (ß
        (§ super (params, payloadBytes, 0))
    )

    #_override
    #_public
    (§ method String toString())
    (ß
        (§ return "ALERT: " + getStatusBar())
    )

    #_override
    #_protected
    (§ method void parse())
        (§ throws ProtocolException)
    (ß
        ;; Alerts are formatted in two levels.  The top level contains two byte arrays: a signature, and a serialized
        ;; data structure containing the actual alert data.
        (§ var int startPos = cursor)
        (§ ass content = readByteArray())
        (§ ass signature = readByteArray())
        ;; Now we need to parse out the contents of the embedded structure.  Rewind back to the start of the message.
        (§ ass cursor = startPos)
        (§ call readVarInt()) ;; Skip the length field on the content array.
        ;; We're inside the embedded structure.
        (§ ass version = readUint32())
        ;; Read the timestamps.  Bitcoin uses seconds since the epoch.
        (§ ass relayUntil = new Date(readUint64().longValue() * 1000))
        (§ ass expiration = new Date(readUint64().longValue() * 1000))
        (§ ass id = readUint32())
        (§ ass cancel = readUint32())
        ;; Sets are serialized as <len><item><item><item>....
        (§ var long cancelSetSize = readVarInt())
        (§ if (cancelSetSize < 0 || MAX_SET_SIZE < cancelSetSize))
            (§ throw new ProtocolException("Bad cancel set size: " + cancelSetSize))
        ;; Using a hashset here is very inefficient given that this will normally be only one item.  But Java doesn't
        ;; make it easy to do better.  What we really want is just an array-backed set.
        (§ var Set<Long> cancelSet = new HashSet<>((int)cancelSetSize))
        (§ for (long i = 0 :for i < cancelSetSize :for i = i + 1))
            (§ call cancelSet.add(readUint32()))
        (§ ass minVer = readUint32())
        (§ ass maxVer = readUint32())
        ;; Read the subver matching set.
        (§ var long subverSetSize = readVarInt())
        (§ if (subverSetSize < 0 || MAX_SET_SIZE < subverSetSize))
            (§ throw new ProtocolException("Bad subver set size: " + subverSetSize))
        (§ var Set<String> matchingSubVers = new HashSet<>((int)subverSetSize))
        (§ for (long i = 0 :for i < subverSetSize :for i = i + 1))
            (§ call matchingSubVers.add(readStr()))
        (§ ass priority = readUint32())
        (§ ass comment = readStr())
        (§ ass statusBar = readStr())
        (§ ass reserved = readStr())

        (§ ass length = cursor - offset)
    )

    ;;;
     ; Returns true if the digital signature attached to the message verifies.  Don't do anything with the alert if it
     ; doesn't verify, because that would allow arbitrary attackers to spam your users.
     ;;
    #_public
    (§ method boolean isSignatureValid())
    (ß
        (§ return ECKey.verify(Sha256Hash.hashTwice(content), signature, params.getAlertSigningKey()))
    )

    ;;;
     ; The time at which the alert should stop being broadcast across the network.  Note that you can still receive
     ; the alert after this time from other nodes if the alert still applies to them or to you.
     ;;
    #_public
    (§ method Date getRelayUntil())
    (ß
        (§ return relayUntil)
    )

    #_public
    (§ method void setRelayUntil(Date relayUntil))
    (ß
        (§ ass this.relayUntil = relayUntil)
    )

    ;;;
     ; The time at which the alert ceases to be relevant.  It should not be presented to the user or app administrator
     ; after this time.
     ;;
    #_public
    (§ method Date getExpiration())
    (ß
        (§ return expiration)
    )

    #_public
    (§ method void setExpiration(Date expiration))
    (ß
        (§ ass this.expiration = expiration)
    )

    ;;;
     ; The numeric identifier of this alert.  Each alert should have a unique ID, but the signer can choose any number.
     ; If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     ; @return uint32
     ;;
    #_public
    (§ method long getId())
    (ß
        (§ return id)
    )

    #_public
    (§ method void setId(long id))
    (ß
        (§ ass this.id = id)
    )

    ;;;
     ; A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     ; @return uint32
     ;;
    #_public
    (§ method long getCancel())
    (ß
        (§ return cancel)
    )

    #_public
    (§ method void setCancel(long cancel))
    (ß
        (§ ass this.cancel = cancel)
    )

    ;;;
     ; The inclusive lower bound on software versions that are considered for the purposes of this alert.  Bitcoin Core
     ; compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     ; alerts could use any version numbers.
     ; @return uint32
     ;;
    #_public
    (§ method long getMinVer())
    (ß
        (§ return minVer)
    )

    #_public
    (§ method void setMinVer(long minVer))
    (ß
        (§ ass this.minVer = minVer)
    )

    ;;;
     ; The inclusive upper bound on software versions considered for the purposes of this alert.  Bitcoin Core
     ; compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     ; alerts could use any version numbers.
     ;;
    #_public
    (§ method long getMaxVer())
    (ß
        (§ return maxVer)
    )

    #_public
    (§ method void setMaxVer(long maxVer))
    (ß
        (§ ass this.maxVer = maxVer)
    )

    ;;;
     ; Provides an integer ordering amongst simultaneously active alerts.
     ; @return uint32
     ;;
    #_public
    (§ method long getPriority())
    (ß
        (§ return priority)
    )

    #_public
    (§ method void setPriority(long priority))
    (ß
        (§ ass this.priority = priority)
    )

    ;;;
     ; This field is unused.  It is presumably intended for the author of the alert to provide a justification for it
     ; visible to protocol developers but not users.
     ;;
    #_public
    (§ method String getComment())
    (ß
        (§ return comment)
    )

    #_public
    (§ method void setComment(String comment))
    (ß
        (§ ass this.comment = comment)
    )

    ;;;
     ; A string that is intended to display in the status bar of Bitcoin Core's GUI client.  It contains the user-visible
     ; message.  English only.
     ;;
    #_public
    (§ method String getStatusBar())
    (ß
        (§ return statusBar)
    )

    #_public
    (§ method void setStatusBar(String statusBar))
    (ß
        (§ ass this.statusBar = statusBar)
    )

    ;;;
     ; This field is never used.
     ;;
    #_public
    (§ method String getReserved())
    (ß
        (§ return reserved)
    )

    #_public
    (§ method void setReserved(String reserved))
    (ß
        (§ ass this.reserved = reserved)
    )

    #_public
    (§ method long getVersion())
    (ß
        (§ return version)
    )
)

#_(ns org.bitcoinj.core #_"Base58"
    (:import [java.math BigInteger]
             [java.util Arrays]))

;;;
 ; Base58 is a way to encode Bitcoin addresses (or arbitrary data) as alphanumeric strings.
 ;
 ; Note that this is not the same base58 as used by Flickr, which you may find referenced around the Internet.
 ;
 ; You may want to consider working with {@link VersionedChecksummedBytes} instead, which
 ; adds support for testing the prefix and suffix bytes commonly found in addresses.
 ;
 ; Satoshi explains: why base-58 instead of standard base-64 encoding?
 ; <ul>
 ; <li>Don't want 0OIl characters that look the same in some fonts and
 ;     could be used to create visually identical looking account numbers.</li>
 ; <li>A string with non-alphanumeric characters is not as easily accepted as an account number.</li>
 ; <li>E-mail usually won't line-break if there's no punctuation to break at.</li>
 ; <li>Doubleclicking selects the whole number as one word if it's all alphanumeric.</li>
 ; </ul>
 ;
 ; However, note that the encoding/decoding runs in O(n&sup2;) time, so it is not useful for large data.
 ;
 ; The basic idea of the encoding is to treat the data bytes as a large number represented using
 ; base-256 digits, convert the number to be represented using base-58 digits, preserve the exact
 ; number of leading zeros (which are otherwise lost during the mathematical operations on the
 ; numbers), and finally represent the resulting base-58 digits as alphanumeric ASCII characters.
 ;;
#_public
(§ class Base58
    #_public
    #_static
    #_final
    (§ field char[] ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz".toCharArray())
    #_private
    #_static
    #_final
    (§ field char ENCODED_ZERO = ALPHABET[0])
    #_private
    #_static
    #_final
    (§ field int[] INDEXES = new int[128])
    #_static
    (ß
        (§ call Arrays.fill(INDEXES, -1))
        (§ for (int i = 0 :for i < ALPHABET.length :for i = i + 1))
        (ß
            (§ ass INDEXES[ALPHABET[i]] = i)
        )
    )

    ;;;
     ; Encodes the given bytes as a base58 string (no checksum is appended).
     ;
     ; @param input the bytes to encode
     ; @return the base58-encoded string
     ;;
    #_public
    #_static
    (§ method String encode(byte[] input))
    (ß
        (§ if (input.length == 0))
            (§ return "")

        ;; Count leading zeros.
        (§ var int zeros = 0)
        (§ while (zeros < input.length && input[zeros] == 0))
            (§ ass zeros = zeros + 1)

        ;; Convert base-256 digits to base-58 digits (plus conversion to ASCII characters).
        (§ ass input = Arrays.copyOf(input, input.length)) ;; since we modify it in-place
        (§ var char[] encoded = new char[input.length * 2]) ;; upper bound
        (§ var int outputStart = encoded.length)
        (§ for (int inputStart = zeros :for inputStart < input.length :for ))
        (ß
            (§ ass outputStart = outputStart - 1)
            (§ ass encoded[outputStart] = ALPHABET[divmod(input, inputStart, 256, 58)])
            (§ if (input[inputStart] == 0))
                (§ ass inputStart = inputStart + 1) ;; optimization - skip leading zeros
        )
        ;; Preserve exactly as many leading encoded zeros in output as there were leading zeros in input.
        (§ while (outputStart < encoded.length && encoded[outputStart] == ENCODED_ZERO))
            (§ ass outputStart = outputStart + 1)
        (§ for ( :for 0 < zeros :for zeros = zeros - 1))
        (ß
            (§ ass outputStart = outputStart - 1)
            (§ ass encoded[outputStart] = ENCODED_ZERO)
        )

        ;; Return encoded string (including encoded leading zeros).
        (§ return new String(encoded, outputStart, encoded.length - outputStart))
    )

    ;;;
     ; Decodes the given base58 string into the original data bytes.
     ;
     ; @param input the base58-encoded string to decode
     ; @return the decoded data bytes
     ; @throws AddressFormatException if the given string is not a valid base58 string
     ;;
    #_public
    #_static
    (§ method byte[] decode(String input))
        (§ throws AddressFormatException)
    (ß
        (§ if (input.length() == 0))
            (§ return new byte[0])

        ;; Convert the base58-encoded ASCII chars to a base58 byte sequence (base58 digits).
        (§ var byte[] input58 = new byte[input.length()])
        (§ for (int i = 0 :for i < input.length() :for i = i + 1))
        (ß
            (§ var char c = input.charAt(i))
            (§ var int digit = (c < 128) ? INDEXES[c] :else -1)
            (§ if (digit < 0))
                (§ throw new AddressFormatException("Illegal character " + c + " at position " + i))
            (§ ass input58[i] = (byte)digit)
        )
        ;; Count leading zeros.
        (§ var int zeros = 0)
        (§ while (zeros < input58.length && input58[zeros] == 0))
            (§ ass zeros = zeros + 1)
        ;; Convert base-58 digits to base-256 digits.
        (§ var byte[] decoded = new byte[input.length()])
        (§ var int outputStart = decoded.length)
        (§ for (int inputStart = zeros :for inputStart < input58.length :for ))
        (ß
           (§ ass outputStart = outputStart - 1)
            (§ ass decoded[outputStart] = divmod(input58, inputStart, 58, 256))
            (§ if (input58[inputStart] == 0))
                (§ ass inputStart = inputStart + 1) ;; optimization - skip leading zeros
        )
        ;; Ignore extra leading zeroes that were added during the calculation.
        (§ while (outputStart < decoded.length && decoded[outputStart] == 0))
            (§ ass outputStart = outputStart + 1)

        ;; Return decoded data (including original number of leading zeros).
        (§ return Arrays.copyOfRange(decoded, outputStart - zeros, decoded.length))
    )

    #_public
    #_static
    (§ method BigInteger decodeToBigInteger(String input))
        (§ throws AddressFormatException)
    (ß
        (§ return new BigInteger(1, decode(input)))
    )

    ;;;
     ; Decodes the given base58 string into the original data bytes, using the checksum in the
     ; last 4 bytes of the decoded data to verify that the rest are correct.  The checksum is
     ; removed from the returned data.
     ;
     ; @param input the base58-encoded string to decode (which should include the checksum)
     ; @throws AddressFormatException if the input is not base 58 or the checksum does not validate
     ;;
    #_public
    #_static
    (§ method byte[] decodeChecked(String input))
        (§ throws AddressFormatException)
    (ß
        (§ var byte[] decoded = decode(input))
        (§ if (decoded.length < 4))
            (§ throw new AddressFormatException("Input too short"))
        (§ var byte[] data = Arrays.copyOfRange(decoded, 0, decoded.length - 4))
        (§ var byte[] checksum = Arrays.copyOfRange(decoded, decoded.length - 4, decoded.length))
        (§ var byte[] actualChecksum = Arrays.copyOfRange(Sha256Hash.hashTwice(data), 0, 4))
        (§ if (!Arrays.equals(checksum, actualChecksum)))
            (§ throw new AddressFormatException("Checksum does not validate"))
        (§ return data)
    )

    ;;;
     ; Divides a number, represented as an array of bytes each containing a single digit
     ; in the specified base, by the given divisor.  The given number is modified in-place
     ; to contain the quotient, and the return value is the remainder.
     ;
     ; @param number the number to divide
     ; @param firstDigit the index within the array of the first non-zero digit
     ;        (this is used for optimization by skipping the leading zeros)
     ; @param base the base in which the number's digits are represented (up to 256)
     ; @param divisor the number to divide by (up to 256)
     ; @return the remainder of the division operation
     ;;
    #_private
    #_static
    (§ method byte divmod(byte[] number, int firstDigit, int base, int divisor))
    (ß
        ;; This is just long division which accounts for the base of the input digits.
        (§ var int remainder = 0)
        (§ for (int i = firstDigit :for i < number.length :for i = i + 1))
        (ß
            (§ var int digit = (int)number[i] & 0xFF)
            (§ var int temp = remainder * base + digit)
            (§ ass number[i] = (byte)(temp / divisor))
            (§ ass remainder = temp % divisor)
        )
        (§ return (byte)remainder)
    )
)

#_(ns org.bitcoinj.core #_"BitcoinSerializer"
    (:import [java.io IOException OutputStream]
             [java.nio BufferUnderflowException ByteBuffer]
             [java.util HashMap Map])
    (:import [org.slf4j Logger LoggerFactory])
    (:import #_static #_[org.bitcoinj.core.Utils *]))

;;;
 ; <p>Methods to serialize and de-serialize messages to the Bitcoin network format as defined in
 ; <a href="https://en.bitcoin.it/wiki/Protocol_specification">the protocol specification</a>.</p>
 ;
 ; <p>To be able to serialize and deserialize new Message subclasses the following criteria needs to be met.</p>
 ;
 ; <ul>
 ; <li>The proper Class instance needs to be mapped to its message name in the names variable below.</li>
 ; <li>There needs to be a constructor matching: NetworkParameters params, byte[] payload.</li>
 ; <li>Message.bitcoinSerializeToStream() needs to be properly subclassed.</li>
 ; </ul>
 ;;
#_public
(§ class BitcoinSerializer extends MessageSerializer
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(BitcoinSerializer.class))
    #_private
    #_static
    #_final
    (§ field int COMMAND_LEN = 12)

    #_private
    #_static
    #_final
    (§ field Map<Class<? extends Message>, String> names = new HashMap<>())
    #_static
    (ß
        (§ call names.put(VersionMessage.class, "version"))
        (§ call names.put(InventoryMessage.class, "inv"))
        (§ call names.put(Block.class, "block"))
        (§ call names.put(GetDataMessage.class, "getdata"))
        (§ call names.put(Transaction.class, "tx"))
        (§ call names.put(AddressMessage.class, "addr"))
        (§ call names.put(Ping.class, "ping"))
        (§ call names.put(Pong.class, "pong"))
        (§ call names.put(VersionAck.class, "verack"))
        (§ call names.put(GetBlocksMessage.class, "getblocks"))
        (§ call names.put(GetHeadersMessage.class, "getheaders"))
        (§ call names.put(GetAddrMessage.class, "getaddr"))
        (§ call names.put(HeadersMessage.class, "headers"))
        (§ call names.put(BloomFilter.class, "filterload"))
        (§ call names.put(FilteredBlock.class, "merkleblock"))
        (§ call names.put(NotFoundMessage.class, "notfound"))
        (§ call names.put(MemoryPoolMessage.class, "mempool"))
        (§ call names.put(RejectMessage.class, "reject"))
    )

    #_private
    #_final
    (§ field NetworkParameters params)
    #_private
    #_final
    (§ field boolean parseRetain)

    ;;;
     ; Constructs a BitcoinSerializer with the given behavior.
     ;
     ; @param params           networkParams used to create Messages instances and termining packetMagic
     ; @param parseRetain      retain the backing byte array of a message for fast reserialization
     ;;
    #_public
    (§ constructor BitcoinSerializer(NetworkParameters params, boolean parseRetain))
    (ß
        (§ ass this.params = params)
        (§ ass this.parseRetain = parseRetain)
    )

    ;;;
     ; Writes message to to the output stream.
     ;;
    #_override
    #_public
    (§ method void serialize(String name, byte[] message, OutputStream out))
        (§ throws IOException)
    (ß
        (§ var byte[] header = new byte[4 + COMMAND_LEN + 4 + 4]) ;; checksum
        (§ call uint32ToByteArrayBE(params.getPacketMagic(), header, 0))

        ;; The header array is initialized to zero by Java so we don't have to worry
        ;; about NULL terminating the string here.
        (§ for (int i = 0 :for i < name.length() && i < COMMAND_LEN :for i = i + 1))
            (§ ass header[4 + i] = (byte)(name.codePointAt(i) & 0xFF))

        (§ call Utils.uint32ToByteArrayLE(message.length, header, 4 + COMMAND_LEN))

        (§ var byte[] hash = Sha256Hash.hashTwice(message))
        (§ call System.arraycopy(hash, 0, header, 4 + COMMAND_LEN + 4, 4))
        (§ call out.write(header))
        (§ call out.write(message))

        (§ if (log.isDebugEnabled()))
            (§ call log.debug("Sending {} message: {}", name, HEX.encode(header) + HEX.encode(message)))
    )

    ;;;
     ; Writes message to to the output stream.
     ;;
    #_override
    #_public
    (§ method void serialize(Message message, OutputStream out))
        (§ throws IOException)
    (ß
        (§ var String name = names.get(message.getClass()))
        (§ if (name == nil))
            (§ throw new Error("BitcoinSerializer doesn't currently know how to serialize " + message.getClass()))

        (§ call serialize(name, message.bitcoinSerialize(), out))
    )

    ;;;
     ; Reads a message from the given ByteBuffer and returns it.
     ;;
    #_override
    #_public
    (§ method Message deserialize(ByteBuffer in))
        (§ throws ProtocolException, IOException)
    (ß
        ;; A Bitcoin protocol message has the following format:
        ;;
        ;;   - 4 byte magic number: 0xfabfb5da for the testnet or
        ;;                          0xf9beb4d9 for production
        ;;   - 12 byte command in ASCII
        ;;   - 4 byte payload size
        ;;   - 4 byte checksum
        ;;   - Payload data
        ;;
        ;; The checksum is the first 4 bytes of a SHA256 hash of the message payload. It isn't
        ;; present for all messages, notably, the first one on a connection.
        ;;
        ;; Bitcoin Core ignores garbage before the magic header bytes. We have to do the same because
        ;; sometimes it sends us stuff that isn't part of any message.
        (§ call seekPastMagicBytes(in))
        (§ var BitcoinPacketHeader header = new BitcoinPacketHeader(in))
        ;; Now try to read the whole message.
        (§ return deserializePayload(header, in))
    )

    ;;;
     ; Deserializes only the header in case packet meta data is needed before decoding
     ; the payload.  This method assumes you have already called seekPastMagicBytes().
     ;;
    #_override
    #_public
    (§ method BitcoinPacketHeader deserializeHeader(ByteBuffer in))
        (§ throws ProtocolException, IOException)
    (ß
        (§ return new BitcoinPacketHeader(in))
    )

    ;;;
     ; Deserialize payload only.  You must provide a header, typically obtained by calling
     ; {@link BitcoinSerializer#deserializeHeader}.
     ;;
    #_override
    #_public
    (§ method Message deserializePayload(BitcoinPacketHeader header, ByteBuffer in))
        (§ throws ProtocolException, BufferUnderflowException)
    (ß
        (§ var byte[] payloadBytes = new byte[header.size])
        (§ call in.get(payloadBytes, 0, header.size))

        ;; Verify the checksum.
        (§ var byte[] hash)
        (§ ass hash = Sha256Hash.hashTwice(payloadBytes))
        (§ if (header.checksum[0] != hash[0] || header.checksum[1] != hash[1] || header.checksum[2] != hash[2] || header.checksum[3] != hash[3]))
            (§ throw new ProtocolException("Checksum failed to verify, actual " + HEX.encode(hash) + " vs " + HEX.encode(header.checksum)))

        (§ if (log.isDebugEnabled()))
            (§ call log.debug("Received {} byte '{}' message: {}", header.size, header.command, HEX.encode(payloadBytes)))

        (§ try)
        (ß
            (§ return makeMessage(header.command, header.size, payloadBytes, hash, header.checksum))
        )
        (§ catch (Exception e))
        (ß
            (§ throw new ProtocolException("Error deserializing message " + HEX.encode(payloadBytes) + "\n", e))
        )
    )

    #_private
    (§ method Message makeMessage(String command, int length, byte[] payloadBytes, byte[] hash, byte[] checksum))
        (§ throws ProtocolException)
    (ß
        ;; We use an if ladder rather than reflection because reflection is very slow on Android.
        (§ if (command.equals("version")))
            (§ return new VersionMessage(params, payloadBytes))
        (§ if (command.equals("inv")))
            (§ return makeInventoryMessage(payloadBytes, length))
        (§ if (command.equals("block")))
            (§ return makeBlock(payloadBytes, length))
        (§ if (command.equals("merkleblock")))
            (§ return makeFilteredBlock(payloadBytes))
        (§ if (command.equals("getdata")))
            (§ return new GetDataMessage(params, payloadBytes, this, length))
        (§ if (command.equals("getblocks")))
            (§ return new GetBlocksMessage(params, payloadBytes))
        (§ if (command.equals("getheaders")))
            (§ return new GetHeadersMessage(params, payloadBytes))
        (§ if (command.equals("tx")))
            (§ return makeTransaction(payloadBytes, 0, length, hash))
        (§ if (command.equals("addr")))
            (§ return makeAddressMessage(payloadBytes, length))
        (§ if (command.equals("ping")))
            (§ return new Ping(params, payloadBytes))
        (§ if (command.equals("pong")))
            (§ return new Pong(params, payloadBytes))
        (§ if (command.equals("verack")))
            (§ return new VersionAck(params, payloadBytes))
        (§ if (command.equals("headers")))
            (§ return new HeadersMessage(params, payloadBytes))
        (§ if (command.equals("alert")))
            (§ return makeAlertMessage(payloadBytes))
        (§ if (command.equals("filterload")))
            (§ return makeBloomFilter(payloadBytes))
        (§ if (command.equals("notfound")))
            (§ return new NotFoundMessage(params, payloadBytes))
        (§ if (command.equals("mempool")))
            (§ return new MemoryPoolMessage())
        (§ if (command.equals("reject")))
            (§ return new RejectMessage(params, payloadBytes))
        (§ call log.warn("No support for deserializing message with name {}", command))
        (§ return new UnknownMessage(params, command, payloadBytes))
    )

    ;;;
     ; Get the network parameters for this serializer.
     ;;
    #_public
    (§ method NetworkParameters getParameters())
    (ß
        (§ return params)
    )

    ;;;
     ; Make an address message from the payload.  Extension point for alternative serialization format support.
     ;;
    #_override
    #_public
    (§ method AddressMessage makeAddressMessage(byte[] payloadBytes, int length))
        (§ throws ProtocolException)
    (ß
        (§ return new AddressMessage(params, payloadBytes, this, length))
    )

    ;;;
     ; Make an alert message from the payload.  Extension point for alternative serialization format support.
     ;;
    #_override
    #_public
    (§ method Message makeAlertMessage(byte[] payloadBytes))
        (§ throws ProtocolException)
    (ß
        (§ return new AlertMessage(params, payloadBytes))
    )

    ;;;
     ; Make a block from the payload.  Extension point for alternative serialization format support.
     ;;
    #_override
    #_public
    (§ method Block makeBlock(#_final byte[] payloadBytes, #_final int offset, #_final int length))
        (§ throws ProtocolException)
    (ß
        (§ return new Block(params, payloadBytes, offset, this, length))
    )

    ;;;
     ; Make an filter message from the payload.  Extension point for alternative serialization format support.
     ;;
    #_override
    #_public
    (§ method Message makeBloomFilter(byte[] payloadBytes))
        (§ throws ProtocolException)
    (ß
        (§ return new BloomFilter(params, payloadBytes))
    )

    ;;;
     ; Make a filtered block from the payload.  Extension point for alternative serialization format support.
     ;;
    #_override
    #_public
    (§ method FilteredBlock makeFilteredBlock(byte[] payloadBytes))
        (§ throws ProtocolException)
    (ß
        (§ return new FilteredBlock(params, payloadBytes))
    )

    ;;;
     ; Make an inventory message from the payload.  Extension point for alternative serialization format support.
     ;;
    #_override
    #_public
    (§ method InventoryMessage makeInventoryMessage(byte[] payloadBytes, int length))
        (§ throws ProtocolException)
    (ß
        (§ return new InventoryMessage(params, payloadBytes, this, length))
    )

    ;;;
     ; Make a transaction from the payload.  Extension point for alternative serialization format support.
     ;;
    #_override
    #_public
    (§ method Transaction makeTransaction(byte[] payloadBytes, int offset, int length, byte[] hash))
        (§ throws ProtocolException)
    (ß
        (§ var Transaction tx = new Transaction(params, payloadBytes, offset, nil, this, length))
        (§ if (hash != nil))
            (§ call tx.setHash(Sha256Hash.wrapReversed(hash)))
        (§ return tx)
    )

    #_override
    #_public
    (§ method void seekPastMagicBytes(ByteBuffer in))
        (§ throws BufferUnderflowException)
    (ß
        (§ var int magicCursor = 3) ;; Which byte of the magic we're looking for currently.
        (§ while (true))
        (ß
            (§ var byte b = in.get())
            ;; We're looking for a run of bytes that is the same as the packet magic but we want to ignore partial
            ;; magics that aren't complete.  So we keep track of where we're up to with magicCursor.
            (§ var byte expectedByte = (byte)(0xff & params.getPacketMagic() >>> (magicCursor << 3)))
            (§ if (b == expectedByte))
            (ß
                (§ ass magicCursor = magicCursor - 1)
                (§ if (magicCursor < 0))
                    (§ return) ;; We found the magic sequence.
            )
            (§ else)
            (ß
                (§ ass magicCursor = 3)
            )
        )
    )

    ;;;
     ; Whether the serializer will produce cached mode Messages.
     ;;
    #_override
    #_public
    (§ method boolean isParseRetainMode())
    (ß
        (§ return parseRetain)
    )

    #_public
    #_static
    (§ class BitcoinPacketHeader
        ;;; The largest number of bytes that a header can represent. ;;
        #_public
        #_static
        #_final
        (§ field int HEADER_LENGTH = COMMAND_LEN + 4 + 4)

        #_public
        #_final
        (§ field byte[] header)
        #_public
        #_final
        (§ field String command)
        #_public
        #_final
        (§ field int size)
        #_public
        #_final
        (§ field byte[] checksum)

        #_public
        (§ constructor BitcoinPacketHeader(ByteBuffer in))
            (§ throws ProtocolException, BufferUnderflowException)
        (ß
            (§ ass header = new byte[HEADER_LENGTH])
            (§ call in.get(header, 0, header.length))

            (§ var int cursor = 0)

            ;; The command is a NULL terminated string, unless the command fills all twelve bytes
            ;; in which case the termination is implicit.
            (§ while (header[cursor] != 0 && cursor < COMMAND_LEN))
                (§ ass cursor = cursor + 1)
            (§ var byte[] commandBytes = new byte[cursor])
            (§ call System.arraycopy(header, 0, commandBytes, 0, cursor))
            (§ ass command = Utils.toString(commandBytes, "US-ASCII"))
            (§ ass cursor = COMMAND_LEN)

            (§ ass size = (int)readUint32(header, cursor))
            (§ ass cursor = cursor + 4)

            (§ if (Message.MAX_SIZE < size || size < 0))
                (§ throw new ProtocolException("Message size too large: " + size))

            ;; Old clients don't send the checksum.
            (§ ass checksum = new byte[4])
            ;; Note that the size read above includes the checksum bytes.
            (§ call System.arraycopy(header, cursor, checksum, 0, 4))
            (§ ass cursor = cursor + 4)
        )
    )
)

#_(ns org.bitcoinj.core #_"Block"
    (:import #_[java.io *]
             #_[java.math *]
             #_[java.util *])
    (:import #_[com.google.common.annotations *]
             #_[com.google.common.base *]
             #_[com.google.common.collect *]
             #_[org.slf4j *])
  #_(:require #_[org.bitcoinj.script *]
             #_static #_[org.bitcoinj.core.Coin *]
             #_static #_[org.bitcoinj.core.Sha256Hash *]))

;;;
 ; <p>A block is a group of transactions, and is one of the fundamental data structures of the Bitcoin system.
 ; It records a set of {@link Transaction}s together with some data that links it into a place in the global block chain,
 ; and proves that a difficult calculation was done over its contents.
 ; See <a href="http://www.bitcoin.org/bitcoin.pdf">the Bitcoin technical paper</a> for more detail on blocks.
 ;
 ; <p>To get a block, you can either build one from the raw bytes you can get from another implementation, or request one
 ; specifically using {@link Peer#getBlock(Sha256Hash)}, or grab one from a downloaded {@link BlockChain}.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class Block extends Message
    ;;;
     ; Flags used to control which elements of block validation are done on received blocks.
     ;;
    #_public
    (§ enum VerifyFlag
        ;;; Check that block height is in coinbase transaction (BIP 34). ;;
        (§ item HEIGHT_IN_COINBASE)
    )

    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(Block.class))

    ;;; How many bytes are required to represent a block header WITHOUT the trailing 00 length byte. ;;
    #_public
    #_static
    #_final
    (§ field int HEADER_SIZE = 80)

    #_static
    #_final
    (§ field long ALLOWED_TIME_DRIFT = 2 * 60 * 60) ;; Same value as Bitcoin Core.

    ;;;
     ; A constant shared by the entire network: how large in bytes a block is allowed to be.  One day we may have to
     ; upgrade everyone to change this, so Bitcoin can continue to grow.  For now it exists as an anti-DoS measure to
     ; avoid somebody creating a titanically huge but valid block and forcing everyone to download/store it forever.
     ;;
    #_public
    #_static
    #_final
    (§ field int MAX_BLOCK_SIZE = 1 * 1000 * 1000)
    ;;;
     ; A "sigop" is a signature verification operation.  Because they're expensive, we also impose a separate limit on
     ; the number in a block to prevent somebody mining a huge block that has way more sigops than normal, so is very
     ; expensive/slow to verify.
     ;;
    #_public
    #_static
    #_final
    (§ field int MAX_BLOCK_SIGOPS = MAX_BLOCK_SIZE / 50)

    ;;; A value for difficultyTarget (nBits) that allows half of all possible hash solutions.  Used in unit testing. ;;
    #_public
    #_static
    #_final
    (§ field long EASIEST_DIFFICULTY_TARGET = 0x207fffff)

    ;;; Value to use if the block height is unknown. ;;
    #_public
    #_static
    #_final
    (§ field int BLOCK_HEIGHT_UNKNOWN = -1)
    ;;; Height of the first block. ;;
    #_public
    #_static
    #_final
    (§ field int BLOCK_HEIGHT_GENESIS = 0)

    #_public
    #_static
    #_final
    (§ field long BLOCK_VERSION_GENESIS = 1)
    ;;; Block version introduced in BIP 34: Height in coinbase. ;;
    #_public
    #_static
    #_final
    (§ field long BLOCK_VERSION_BIP34 = 2)
    ;;; Block version introduced in BIP 66: Strict DER signatures. ;;
    #_public
    #_static
    #_final
    (§ field long BLOCK_VERSION_BIP66 = 3)
    ;;; Block version introduced in BIP 65: OP_CHECKLOCKTIMEVERIFY ;;
    #_public
    #_static
    #_final
    (§ field long BLOCK_VERSION_BIP65 = 4)

    ;; Fields defined as part of the protocol format.
    #_private
    (§ field long version)
    #_private
    (§ field Sha256Hash prevBlockHash)
    #_private
    (§ field Sha256Hash merkleRoot)
    #_private
    (§ field long time)
    #_private
    (§ field long difficultyTarget) ;; "nBits"
    #_private
    (§ field long nonce)

    ;; TODO: Get rid of all the direct accesses to this field.  It's a long-since unnecessary holdover from the Dalvik days.
    ;;; If null, it means this object holds only the headers. ;;
    #_nilable
    (§ field List<Transaction> transactions)

    ;;; Stores the hash of the block.  If null, getHash() will recalculate it. ;;
    #_private
    (§ field Sha256Hash hash)

    #_protected
    (§ field boolean headerBytesValid)
    #_protected
    (§ field boolean transactionBytesValid)

    ;; Blocks can be encoded in a way that will use more bytes than is optimal (due to VarInts having multiple encodings).
    ;; MAX_BLOCK_SIZE must be compared to the optimal encoding, not the actual encoding, so when parsing, we keep track
    ;; of the size of the ideal encoding in addition to the actual message size (which Message needs).
    #_protected
    (§ field int optimalEncodingMessageSize)

    ;;; Special case constructor, used for the genesis node, cloneAsHeader and unit tests. ;;
    (§ constructor Block(NetworkParameters params, long setVersion))
    (ß
        (§ super (params))

        ;; Set up a few basic things.  We are not complete after this though.
        (§ ass version = setVersion)
        (§ ass difficultyTarget = 0x1d07fff8)
        (§ ass time = System.currentTimeMillis() / 1000)
        (§ ass prevBlockHash = Sha256Hash.ZERO_HASH)

        (§ ass length = HEADER_SIZE)
    )

    ;;;
     ; Constructs a block object from the Bitcoin wire format.
     ; @deprecated Use {@link BitcoinSerializer#makeBlock(byte[])} instead.
     ;;
    #_deprecated
    #_public
    (§ constructor Block(NetworkParameters params, byte[] payloadBytes))
        (§ throws ProtocolException)
    (ß
        (§ super (params, payloadBytes, 0, params.getDefaultSerializer(), payloadBytes.length))
    )

    ;;;
     ; Construct a block object from the Bitcoin wire format.
     ; @param params NetworkParameters object.
     ; @param payloadBytes The payload to extract the block from.
     ; @param serializer The serializer to use for this message.
     ; @param length The length of message if known.  Usually this is provided when deserializing of the wire
     ; as the length will be provided as part of the header.  Set to Message.UNKNOWN_LENGTH, if not known.
     ; @throws ProtocolException
     ;;
    #_public
    (§ constructor Block(NetworkParameters params, byte[] payloadBytes, MessageSerializer serializer, int length))
        (§ throws ProtocolException)
    (ß
        (§ super (params, payloadBytes, 0, serializer, length))
    )

    ;;;
     ; Construct a block object from the Bitcoin wire format.
     ; @param params NetworkParameters object.
     ; @param payloadBytes The payload to extract the block from.
     ; @param offset The location of the first payload byte within the array.
     ; @param serializer The serializer to use for this message.
     ; @param length The length of message if known.  Usually this is provided when deserializing of the wire
     ; as the length will be provided as part of the header.  Set to Message.UNKNOWN_LENGTH, if not known.
     ; @throws ProtocolException
     ;;
    #_public
    (§ constructor Block(NetworkParameters params, byte[] payloadBytes, int offset, MessageSerializer serializer, int length))
        (§ throws ProtocolException)
    (ß
        (§ super (params, payloadBytes, offset, serializer, length))
    )

    ;;;
     ; Construct a block object from the Bitcoin wire format.  Used in the case of a block
     ; contained within another message (i.e. for AuxPoW header).
     ;
     ; @param params NetworkParameters object.
     ; @param payloadBytes Bitcoin protocol formatted byte array containing message content.
     ; @param offset The location of the first payload byte within the array.
     ; @param parent The message element which contains this block, maybe null for no parent.
     ; @param serializer The serializer to use for this block.
     ; @param length The length of message if known.  Usually this is provided when deserializing of the wire
     ; as the length will be provided as part of the header.  Set to Message.UNKNOWN_LENGTH, if not known.
     ; @throws ProtocolException
     ;;
    #_public
    (§ constructor Block(NetworkParameters params, byte[] payloadBytes, int offset, #_nilable Message parent, MessageSerializer serializer, int length))
        (§ throws ProtocolException)
    (ß
        ;; TODO: Keep the parent.
        (§ super (params, payloadBytes, offset, serializer, length))
    )

    ;;;
     ; Construct a block initialized with all the given fields.
     ; @param params Which network the block is for.
     ; @param version This should usually be set to 1 or 2, depending on if the height is in the coinbase input.
     ; @param prevBlockHash Reference to previous block in the chain or {@link Sha256Hash#ZERO_HASH} if genesis.
     ; @param merkleRoot The root of the merkle tree formed by the transactions.
     ; @param time UNIX time when the block was mined.
     ; @param difficultyTarget Number which this block hashes lower than.
     ; @param nonce Arbitrary number to make the block hash lower than the target.
     ; @param transactions List of transactions including the coinbase.
     ;;
    #_public
    (§ constructor Block(NetworkParameters params, long version, Sha256Hash prevBlockHash, Sha256Hash merkleRoot, long time, long difficultyTarget, long nonce, List<Transaction> transactions))
    (ß
        (§ super (params))

        (§ ass this.version = version)
        (§ ass this.prevBlockHash = prevBlockHash)
        (§ ass this.merkleRoot = merkleRoot)
        (§ ass this.time = time)
        (§ ass this.difficultyTarget = difficultyTarget)
        (§ ass this.nonce = nonce)
        (§ ass this.transactions = new LinkedList<>())
        (§ call this.transactions.addAll(transactions))
    )

    ;;;
     ; <p>A utility method that calculates how much new Bitcoin would be created by the block at the given height.
     ; The inflation of Bitcoin is predictable and drops roughly every 4 years (210,000 blocks).  At the dawn of
     ; the system it was 50 coins per block, in late 2012 it went to 25 coins per block, and so on.  The size of
     ; a coinbase transaction is inflation plus fees.</p>
     ;
     ; The half-life is controlled by {@link org.bitcoinj.core.NetworkParameters#getSubsidyDecreaseBlockCount()}.
     ;;
    #_public
    (§ method Coin getBlockInflation(int height))
    (ß
        (§ return FIFTY_COINS.shiftRight(height / params.getSubsidyDecreaseBlockCount()))
    )

    ;;;
     ; Parse transactions from the block.
     ;
     ; @param transactionsOffset Offset of the transactions within the block.
     ; Useful for non-Bitcoin chains where the block header may not be a fixed size.
     ;;
    #_protected
    (§ method void parseTransactions(#_final int transactionsOffset))
        (§ throws ProtocolException)
    (ß
        (§ ass cursor = transactionsOffset)
        (§ ass optimalEncodingMessageSize = HEADER_SIZE)
        (§ if (payload.length == cursor))
        (ß
            ;; This message is just a header, it has no transactions.
            (§ ass transactionBytesValid = false)
            (§ return)
        )

        (§ var int numTransactions = (int)readVarInt())
        (§ ass optimalEncodingMessageSize = optimalEncodingMessageSize + VarInt.sizeOf(numTransactions))
        (§ ass transactions = new ArrayList<>(numTransactions))
        (§ for (int i = 0 :for i < numTransactions :for i = i + 1))
        (ß
            (§ var Transaction tx = new Transaction(params, payload, cursor, this, serializer, UNKNOWN_LENGTH))
            ;; Label the transaction as coming from the P2P network, so code that cares where we first saw it knows.
            (§ call tx.getConfidence().setSource(TransactionConfidence.Source.NETWORK))
            (§ call transactions.add(tx))
            (§ ass cursor = cursor + tx.getMessageSize())
            (§ ass optimalEncodingMessageSize = optimalEncodingMessageSize + tx.getOptimalEncodingMessageSize())
        )
        (§ ass transactionBytesValid = serializer.isParseRetainMode())
    )

    #_override
    #_protected
    (§ method void parse())
        (§ throws ProtocolException)
    (ß
        ;; header
        (§ ass cursor = offset)
        (§ ass version = readUint32())
        (§ ass prevBlockHash = readHash())
        (§ ass merkleRoot = readHash())
        (§ ass time = readUint32())
        (§ ass difficultyTarget = readUint32())
        (§ ass nonce = readUint32())
        (§ ass hash = Sha256Hash.wrapReversed(Sha256Hash.hashTwice(payload, offset, cursor - offset)))
        (§ ass headerBytesValid = serializer.isParseRetainMode())

        ;; transactions
        (§ call parseTransactions(offset + HEADER_SIZE))
        (§ ass length = cursor - offset)
    )

    #_public
    (§ method int getOptimalEncodingMessageSize())
    (ß
        (§ if (optimalEncodingMessageSize != 0))
            (§ return optimalEncodingMessageSize)
        (§ ass optimalEncodingMessageSize = bitcoinSerialize().length)
        (§ return optimalEncodingMessageSize)
    )

    ;; default for testing
    (§ method void writeHeader(OutputStream stream))
        (§ throws IOException)
    (ß
        ;; try for cached write first
        (§ if (headerBytesValid && payload != nil && offset + HEADER_SIZE <= payload.length))
        (ß
            (§ call stream.write(payload, offset, HEADER_SIZE))
            (§ return)
        )

        ;; fall back to manual write
        (§ call Utils.uint32ToByteStreamLE(version, stream))
        (§ call stream.write(prevBlockHash.getReversedBytes()))
        (§ call stream.write(getMerkleRoot().getReversedBytes()))
        (§ call Utils.uint32ToByteStreamLE(time, stream))
        (§ call Utils.uint32ToByteStreamLE(difficultyTarget, stream))
        (§ call Utils.uint32ToByteStreamLE(nonce, stream))
    )

    #_private
    (§ method void writeTransactions(OutputStream stream))
        (§ throws IOException)
    (ß
        ;; check for no transaction conditions first
        (§ if (transactions == nil))
            (§ return)

        ;; confirmed we must have transactions either cached or as objects
        (§ if (transactionBytesValid && payload != nil && offset + length <= payload.length))
        (ß
            (§ call stream.write(payload, offset + HEADER_SIZE, length - HEADER_SIZE))
            (§ return)
        )

        (§ if (transactions != nil))
        (ß
            (§ call stream.write(new VarInt(transactions.size()).encode()))
            (§ for (Transaction tx :for transactions))
                (§ call tx.bitcoinSerialize(stream))
        )
    )

    ;;;
     ; Special handling to check if we have a valid byte array for both header and transactions.
     ;
     ; @throws IOException
     ;;
    #_override
    #_public
    (§ method byte[] bitcoinSerialize())
    (ß
        ;; we have completely cached byte array
        (§ if (headerBytesValid && transactionBytesValid))
        (ß
            (§ call Preconditions.checkNotNull(payload, "Bytes should never be nil if headerBytesValid && transactionBytesValid"))
            (§ if (length == payload.length))
                (§ return payload)

            ;; byte array is offset, so copy out the correct range
            (§ var byte[] buf = new byte[length])
            (§ call System.arraycopy(payload, offset, buf, 0, length))
            (§ return buf)
        )

        ;; At least one of the two cacheable components is invalid, so fall back to stream write since we can't be sure of the length.
        (§ var ByteArrayOutputStream stream = new UnsafeByteArrayOutputStream((length == UNKNOWN_LENGTH) ? HEADER_SIZE + guessTransactionsLength() :else length))
        (§ try)
        (ß
            (§ call writeHeader(stream))
            (§ call writeTransactions(stream))
        )
        (§ catch (IOException e))
        (ß
            ;; Cannot happen, we are serializing to a memory stream.
        )
        (§ return stream.toByteArray())
    )

    #_override
    #_protected
    (§ method void bitcoinSerializeToStream(OutputStream stream))
        (§ throws IOException)
    (ß
        (§ call writeHeader(stream))
        ;; We may only have enough data to write the header.
        (§ call writeTransactions(stream))
    )

    ;;;
     ; Provides a reasonable guess at the byte length of the transactions part of the block.
     ; The returned value will be accurate in 99% of cases and in those cases where not will probably slightly oversize.
     ;
     ; This is used to preallocate the underlying byte array for a ByteArrayOutputStream.  If the size is under the
     ; real value the only penalty is resizing of the underlying byte array.
     ;;
    #_private
    (§ method int guessTransactionsLength())
    (ß
        (§ if (transactionBytesValid))
            (§ return payload.length - HEADER_SIZE)
        (§ if (transactions == nil))
            (§ return 0)
        (§ var int len = VarInt.sizeOf(transactions.size()))
        (§ for (Transaction tx :for transactions))
        (ß
            ;; 255 is just a guess at an average tx length
            (§ ass len = len + (tx.length == UNKNOWN_LENGTH ? 255 :else tx.length))
        )
        (§ return len)
    )

    #_override
    #_protected
    (§ method void unCache())
    (ß
        ;; Since we have alternate uncache methods to use internally, this will only ever be called by a child
        ;; transaction, so we only need to invalidate that part of the cache.
        (§ call unCacheTransactions())
    )

    #_private
    (§ method void unCacheHeader())
    (ß
        (§ ass headerBytesValid = false)
        (§ if (!transactionBytesValid))
            (§ ass payload = nil)
        (§ ass hash = nil)
    )

    #_private
    (§ method void unCacheTransactions())
    (ß
        (§ ass transactionBytesValid = false)
        (§ if (!headerBytesValid))
            (§ ass payload = nil)
        ;; Current implementation has to uncache headers as well as any change to a tx will alter the merkle root.
        ;; In future, we can go more granular and cache merkle root separately so rest of the header does not need to be rewritten.
        (§ call unCacheHeader())
        ;; Clear merkleRoot last as it may end up being parsed during unCacheHeader().
        (§ ass merkleRoot = nil)
    )

    ;;;
     ; Calculates the block hash by serializing the block and hashing the resulting bytes.
     ;;
    #_private
    (§ method Sha256Hash calculateHash())
    (ß
        (§ try)
        (ß
            (§ var ByteArrayOutputStream bos = new UnsafeByteArrayOutputStream(HEADER_SIZE))
            (§ call writeHeader(bos))
            (§ return Sha256Hash.wrapReversed(Sha256Hash.hashTwice(bos.toByteArray())))
        )
        (§ catch (IOException e))
        (ß
            (§ throw new RuntimeException(e)) ;; Cannot happen.
        )
    )

    ;;;
     ; Returns the hash of the block (which for a valid, solved block should be below the target) in the form seen on
     ; the block explorer.  If you call this on block 1 in the mainnet chain,
     ; you will get "00000000839a8e6886ab5951d76f411475428afc90947ee320161bbf18eb6048".
     ;;
    #_public
    (§ method String getHashAsString())
    (ß
        (§ return getHash().toString())
    )

    ;;;
     ; Returns the hash of the block (which for a valid, solved block should be
     ; below the target).  Big endian.
     ;;
    #_override
    #_public
    (§ method Sha256Hash getHash())
    (ß
        (§ if (hash == nil))
            (§ ass hash = calculateHash())
        (§ return hash)
    )

    ;;;
     ; The number that is one greater than the largest representable SHA-256 hash.
     ;;
    #_private
    #_static
    (§ field BigInteger LARGEST_HASH = BigInteger.ONE.shiftLeft(256))

    ;;;
     ; Returns the work represented by this block.
     ;
     ; Work is defined as the number of tries needed to solve a block in the
     ; average case.  Consider a difficulty target that covers 5% of all possible
     ; hash values.  Then the work of the block will be 20.  As the target gets
     ; lower, the amount of work goes up.
     ;;
    #_public
    (§ method BigInteger getWork())
        (§ throws VerificationException)
    (ß
        (§ var BigInteger target = getDifficultyTargetAsInteger())
        (§ return LARGEST_HASH.divide(target.add(BigInteger.ONE)))
    )

    ;;; Returns a copy of the block, but without any transactions. ;;
    #_public
    (§ method Block cloneAsHeader())
    (ß
        (§ var Block block = new Block(params, BLOCK_VERSION_GENESIS))
        (§ call copyBitcoinHeaderTo(block))
        (§ return block)
    )

    ;;; Copy the block without transactions into the provided empty block. ;;
    #_protected
    #_final
    (§ method void copyBitcoinHeaderTo(#_final Block block))
    (ß
        (§ ass block.nonce = nonce)
        (§ ass block.prevBlockHash = prevBlockHash)
        (§ ass block.merkleRoot = getMerkleRoot())
        (§ ass block.version = version)
        (§ ass block.time = time)
        (§ ass block.difficultyTarget = difficultyTarget)
        (§ ass block.transactions = nil)
        (§ ass block.hash = getHash())
    )

    ;;;
     ; Returns a multi-line string containing a description of the contents of the block.
     ; Use for debugging purposes only.
     ;;
    #_override
    #_public
    (§ method String toString())
    (ß
        (§ var StringBuilder sb = new StringBuilder())
        (§ call sb.append(" block: \n"))
        (§ call sb.append("   hash: ").append(getHashAsString()).append("\n"))
        (§ call sb.append("   version: ").append(version))
        (§ var String bips = Joiner.on(", ").skipNulls().join(isBIP34() ? "BIP34" :else nil, isBIP66() ? "BIP66" :else nil, isBIP65() ? "BIP65" :else nil))
        (§ if (!bips.isEmpty()))
            (§ call sb.append(" (").append(bips).append(")"))
        (§ call sb.append("\n"))
        (§ call sb.append("   previous block: ").append(getPrevBlockHash()).append("\n"))
        (§ call sb.append("   merkle root: ").append(getMerkleRoot()).append("\n"))
        (§ call sb.append("   time: ").append(time).append(" (").append(Utils.dateTimeFormat(time * 1000)).append(")\n"))
        (§ call sb.append("   difficulty target (nBits): ").append(difficultyTarget).append("\n"))
        (§ call sb.append("   nonce: ").append(nonce).append("\n"))
        (§ if (transactions != nil && 0 < transactions.size()))
        (ß
            (§ call sb.append("   with ").append(transactions.size()).append(" transaction(s):\n"))
            (§ for (Transaction tx :for transactions))
                (§ call sb.append(tx))
        )
        (§ return sb.toString())
    )

    ;;;
     ; <p>Finds a value of nonce that makes the blocks hash lower than the difficulty target.  This is called mining,
     ; but solve() is far too slow to do real mining with.  It exists only for unit testing purposes.
     ;
     ; <p>This can loop forever if a solution cannot be found solely by incrementing nonce.  It doesn't change
     ; extraNonce.</p>
     ;;
    #_public
    (§ method void solve())
    (ß
        (§ while (true))
        (ß
            (§ try)
            (ß
                ;; Is our proof of work valid yet?
                (§ if (checkProofOfWork(false)))
                    (§ return)
                ;; No, so increment the nonce and try again.
                (§ call setNonce(getNonce() + 1))
            )
            (§ catch (VerificationException e))
            (ß
                (§ throw new RuntimeException(e)) ;; Cannot happen.
            )
        )
    )

    ;;;
     ; Returns the difficulty target as a 256 bit value that can be compared to a SHA-256 hash.  Inside a block the
     ; target is represented using a compact form.  If this form decodes to a value that is out of bounds, an exception
     ; is thrown.
     ;;
    #_public
    (§ method BigInteger getDifficultyTargetAsInteger())
        (§ throws VerificationException)
    (ß
        (§ var BigInteger target = Utils.decodeCompactBits(difficultyTarget))
        (§ if (target.signum() <= 0 || 0 < target.compareTo(params.maxTarget)))
            (§ throw new VerificationException("Difficulty target is bad: " + target))
        (§ return target)
    )

    ;;; Returns true if the hash of the block is OK (lower than difficulty target). ;;
    #_protected
    (§ method boolean checkProofOfWork(boolean throwException))
        (§ throws VerificationException)
    (ß
        ;; This part is key - it is what proves the block was as difficult to make as it claims
        ;; to be.  Note however that in the context of this function, the block can claim to be
        ;; as difficult as it wants to be .... if somebody was able to take control of our network
        ;; connection and fork us onto a different chain, they could send us valid blocks with
        ;; ridiculously easy difficulty and this function would accept them.
        ;;
        ;; To prevent this attack from being possible, elsewhere we check that the difficultyTarget
        ;; field is of the right value.  This requires us to have the preceeding blocks.
        (§ var BigInteger target = getDifficultyTargetAsInteger())

        (§ var BigInteger h = getHash().toBigInteger())
        (§ if (0 < h.compareTo(target)))
        (ß
            ;; Proof of work check failed!
            (§ if (throwException))
                (§ throw new VerificationException("Hash is higher than target: " + getHashAsString() + " vs " + target.toString(16)))
            (§ else)
                (§ return false)
        )
        (§ return true)
    )

    #_private
    (§ method void checkTimestamp())
        (§ throws VerificationException)
    (ß
        #_final
        (§ var long allowedTime = Utils.currentTimeSeconds() + ALLOWED_TIME_DRIFT)
        (§ if (allowedTime < time))
            (§ throw new VerificationException(String.format(Locale.US, "Block too far in future: %s (%d) vs allowed %s (%d)", Utils.dateTimeFormat(time * 1000), time, Utils.dateTimeFormat(allowedTime * 1000), allowedTime)))
    )

    #_private
    (§ method void checkSigOps())
        (§ throws VerificationException)
    (ß
        ;; Check there aren't too many signature verifications in the block.  This is an anti-DoS measure, see the
        ;; comments for MAX_BLOCK_SIGOPS.
        (§ var int sigOps = 0)
        (§ for (Transaction tx :for transactions))
            (§ ass sigOps = sigOps + tx.getSigOpCount())

        (§ if (MAX_BLOCK_SIGOPS < sigOps))
            (§ throw new VerificationException("Block had too many Signature Operations"))
    )

    #_private
    (§ method void checkMerkleRoot())
        (§ throws VerificationException)
    (ß
        (§ var Sha256Hash calculatedRoot = calculateMerkleRoot())
        (§ if (!calculatedRoot.equals(merkleRoot)))
        (ß
            (§ call log.error("Merkle tree did not verify"))
            (§ throw new VerificationException("Merkle hashes do not match: " + calculatedRoot + " vs " + merkleRoot))
        )
    )

    #_private
    (§ method Sha256Hash calculateMerkleRoot())
    (ß
        (§ var List<byte[]> tree = buildMerkleTree())
        (§ return Sha256Hash.wrap(tree.get(tree.size() - 1)))
    )

    #_private
    (§ method List<byte[]> buildMerkleTree())
    (ß
        ;; The Merkle root is based on a tree of hashes calculated from the transactions:
        ;;
        ;;     root
        ;;     /  \
        ;;   A      B
        ;;  / \    / \
        ;; t1 t2  t3 t4
        ;;
        ;; The tree is represented as a list: (t1 t2 t3 t4 A B root), where each entry is a hash.
        ;;
        ;; The hashing algorithm is double SHA-256.  The leaves are a hash of the serialized contents of the transaction.
        ;; The interior nodes are hashes of the concenation of the two child hashes.
        ;;
        ;; This structure allows the creation of proof that a transaction was included into a block without having to
        ;; provide the full block contents.  Instead, you can provide only a Merkle branch.  For example to prove tx2 was
        ;; in a block you can just provide tx2, the hash(tx1) and B.  Now the other party has everything they need to
        ;; derive the root, which can be checked against the block header.  These proofs aren't used right now but
        ;; will be helpful later when we want to download partial block contents.
        ;;
        ;; Note that if the number of transactions is not even, the last tx is repeated to make it so (see tx3 above).
        ;; A tree with 5 transactions would look like this:
        ;;
        ;;          root
        ;;        /      \
        ;;      1          5
        ;;    /   \       / \
        ;;   2     3     4   4
        ;;  / \   / \   / \
        ;; t1 t2 t3 t4 t5 t5
        (§ var ArrayList<byte[]> tree = new ArrayList<>())
        ;; Start by adding all the hashes of the transactions as leaves of the tree.
        (§ for (Transaction t :for transactions))
            (§ call tree.add(t.getHash().getBytes()))

        ;; Offset in the list where the currently processed level starts.
        (§ var int levelOffset = 0)
        ;; Step through each level, stopping when we reach the root (levelSize == 1).
        (§ for (int levelSize = transactions.size() :for 1 < levelSize :for levelSize = (levelSize + 1) / 2))
        (ß
            ;; For each pair of nodes on that level:
            (§ for (int left = 0 :for left < levelSize :for left = left + 2))
            (ß
                ;; The right hand node can be the same as the left hand, in the case where we don't have enough transactions.
                (§ var int right = Math.min(left + 1, levelSize - 1))
                (§ var byte[] leftBytes = Utils.reverseBytes(tree.get(levelOffset + left)))
                (§ var byte[] rightBytes = Utils.reverseBytes(tree.get(levelOffset + right)))
                (§ call tree.add(Utils.reverseBytes(hashTwice(leftBytes, 0, 32, rightBytes, 0, 32))))
            )
            ;; Move to the next level.
            (§ ass levelOffset = levelOffset + levelSize)
        )
        (§ return tree)
    )

    ;;;
     ; Verify the transactions on a block.
     ;
     ; @param height Block height, if known, or -1 otherwise.
     ;               If provided, used to validate the coinbase input script of v2 and above blocks.
     ; @throws VerificationException if there was an error verifying the block.
     ;;
    #_private
    (§ method void checkTransactions(#_final int height, #_final EnumSet<VerifyFlag> flags))
        (§ throws VerificationException)
    (ß
        ;; The first transaction in a block must always be a coinbase transaction.
        (§ if (!transactions.get(0).isCoinBase()))
            (§ throw new VerificationException("First tx is not coinbase"))

        (§ if (flags.contains(Block.VerifyFlag.HEIGHT_IN_COINBASE) && BLOCK_HEIGHT_GENESIS <= height))
            (§ call transactions.get(0).checkCoinBaseHeight(height))

        ;; The rest must not be.
        (§ for (int i = 1 :for i < transactions.size() :for i = i + 1))
            (§ if (transactions.get(i).isCoinBase()))
                (§ throw new VerificationException("TX " + i + " is coinbase when it should not be."))
    )

    ;;;
     ; Checks the block data to ensure it follows the rules laid out in the network parameters.  Specifically,
     ; throws an exception if the proof of work is invalid, or if the timestamp is too far from what it should be.
     ; This is <b>not</b> everything that is required for a block to be valid, only what is checkable independent
     ; of the chain and without a transaction index.
     ;
     ; @throws VerificationException
     ;;
    #_public
    (§ method void verifyHeader())
        (§ throws VerificationException)
    (ß
        ;; Prove that this block is OK.  It might seem that we can just ignore most of these checks given that the
        ;; network is also verifying the blocks, but we cannot as it'd open us to a variety of obscure attacks.
        ;;
        ;; Firstly we need to ensure this block does in fact represent real work done.  If the difficulty is high
        ;; enough, it's probably been done by the network.
        (§ call checkProofOfWork(true))
        (§ call checkTimestamp())
    )

    ;;;
     ; Checks the block contents.
     ;
     ; @param height Block height, if known, or -1 otherwise.
     ;               If valid, used to validate the coinbase input script of v2 and above blocks.
     ; @param flags Flags to indicate which tests should be applied (i.e. whether to test for height in the coinbase transaction).
     ; @throws VerificationException if there was an error verifying the block.
     ;;
    #_public
    (§ method void verifyTransactions(#_final int height, #_final EnumSet<VerifyFlag> flags))
        (§ throws VerificationException)
    (ß
        ;; Now we need to check that the body of the block actually matches the headers.  The network won't generate
        ;; an invalid block, but if we didn't validate this then an untrusted man-in-the-middle could obtain the next
        ;; valid block from the network and simply replace the transactions in it with their own fictional
        ;; transactions that reference spent or non-existant inputs.
        (§ if (transactions.isEmpty()))
            (§ throw new VerificationException("Block had no transactions"))
        (§ if (MAX_BLOCK_SIZE < this.getOptimalEncodingMessageSize()))
            (§ throw new VerificationException("Block larger than MAX_BLOCK_SIZE"))
        (§ call checkTransactions(height, flags))
        (§ call checkMerkleRoot())
        (§ call checkSigOps())
        (§ for (Transaction transaction :for transactions))
            (§ call transaction.verify())
    )

    ;;;
     ; Verifies both the header and that the transactions hash to the merkle root.
     ;
     ; @param height Block height, if known, or -1 otherwise.
     ; @param flags Flags to indicate which tests should be applied (i.e. whether to test for height in the coinbase transaction).
     ; @throws VerificationException if there was an error verifying the block.
     ;;
    #_public
    (§ method void verify(#_final int height, #_final EnumSet<VerifyFlag> flags))
        (§ throws VerificationException)
    (ß
        (§ call verifyHeader())
        (§ call verifyTransactions(height, flags))
    )

    #_override
    #_public
    (§ method boolean equals(Object o))
    (ß
        (§ if (this == o))
            (§ return true)
        (§ if (o == nil || getClass() != o.getClass()))
            (§ return false)
        (§ return getHash().equals(((Block)o).getHash()))
    )

    #_override
    #_public
    (§ method int hashCode())
    (ß
        (§ return getHash().hashCode())
    )

    ;;;
     ; Returns the merkle root in big endian form, calculating it from transactions if necessary.
     ;;
    #_public
    (§ method Sha256Hash getMerkleRoot())
    (ß
        (§ if (merkleRoot == nil))
        (ß
            ;; TODO: Check if this is really necessary.
            (§ call unCacheHeader())
            (§ ass merkleRoot = calculateMerkleRoot())
        )
        (§ return merkleRoot)
    )

    ;;; Exists only for unit testing. ;;
    (§ method void setMerkleRoot(Sha256Hash value))
    (ß
        (§ call unCacheHeader())
        (§ ass merkleRoot = value)
        (§ ass hash = nil)
    )

    ;;; Adds a transaction to this block.  The nonce and merkle root are invalid after this. ;;
    #_public
    (§ method void addTransaction(Transaction t))
    (ß
        (§ call addTransaction(t, true))
    )

    ;;; Adds a transaction to this block, with or without checking the sanity of doing so. ;;
    (§ method void addTransaction(Transaction t, boolean runSanityChecks))
    (ß
        (§ call unCacheTransactions())
        (§ if (transactions == nil))
            (§ ass transactions = new ArrayList<>())
        (§ call t.setParent(this))
        (§ if (runSanityChecks && transactions.size() == 0 && !t.isCoinBase()))
            (§ throw new RuntimeException("Attempted to add a non-coinbase transaction as the first transaction: " + t))
        (§ if (runSanityChecks && 0 < transactions.size() && t.isCoinBase()))
            (§ throw new RuntimeException("Attempted to add a coinbase transaction when there already is one: " + t))
        (§ call transactions.add(t))
        (§ call adjustLength(transactions.size(), t.length))
        ;; Force a recalculation next time the values are needed.
        (§ ass merkleRoot = nil)
        (§ ass hash = nil)
    )

    ;;;
     ; Returns the version of the block data structure as defined by the Bitcoin protocol.
     ;;
    #_public
    (§ method long getVersion())
    (ß
        (§ return version)
    )

    ;;;
     ; Returns the hash of the previous block in the chain, as defined by the block header.
     ;;
    #_public
    (§ method Sha256Hash getPrevBlockHash())
    (ß
        (§ return prevBlockHash)
    )

    (§ method void setPrevBlockHash(Sha256Hash prevBlockHash))
    (ß
        (§ call unCacheHeader())
        (§ ass this.prevBlockHash = prevBlockHash)
        (§ ass this.hash = nil)
    )

    ;;;
     ; Returns the time at which the block was solved and broadcast, according to the clock of the solving node.
     ; This is measured in seconds since the UNIX epoch (midnight Jan 1st 1970).
     ;;
    #_public
    (§ method long getTimeSeconds())
    (ß
        (§ return time)
    )

    ;;;
     ; Returns the time at which the block was solved and broadcast, according to the clock of the solving node.
     ;;
    #_public
    (§ method Date getTime())
    (ß
        (§ return new Date(getTimeSeconds() * 1000))
    )

    #_public
    (§ method void setTime(long time))
    (ß
        (§ call unCacheHeader())
        (§ ass this.time = time)
        (§ ass this.hash = nil)
    )

    ;;;
     ; Returns the difficulty of the proof of work that this block should meet encoded <b>in compact form</b>.
     ; The {@link BlockChain} verifies that this is not too easy by looking at the length of the chain when the block is added.
     ; To find the actual value the hash should be compared against, use {@link org.bitcoinj.core.Block#getDifficultyTargetAsInteger()}.
     ; Note that this is <b>not</b> the same as the difficulty value reported by the Bitcoin "getdifficulty" RPC that you may see on various block explorers.
     ; That number is the result of applying a formula to the underlying difficulty to normalize the minimum to 1.
     ; Calculating the difficulty that way is currently unsupported.
     ;;
    #_public
    (§ method long getDifficultyTarget())
    (ß
        (§ return difficultyTarget)
    )

    ;;; Sets the difficulty target in compact form. ;;
    #_public
    (§ method void setDifficultyTarget(long compactForm))
    (ß
        (§ call unCacheHeader())
        (§ ass this.difficultyTarget = compactForm)
        (§ ass this.hash = nil)
    )

    ;;;
     ; Returns the nonce, an arbitrary value that exists only to make the hash of the block header fall below the difficulty target.
     ;;
    #_public
    (§ method long getNonce())
    (ß
        (§ return nonce)
    )

    ;;;
     ; Sets the nonce and clears any cached data.
     ;;
    #_public
    (§ method void setNonce(long nonce))
    (ß
        (§ call unCacheHeader())
        (§ ass this.nonce = nonce)
        (§ ass this.hash = nil)
    )

    ;;; Returns an immutable list of transactions held in this block, or null if this object represents just a header. ;;
    #_nilable
    #_public
    (§ method List<Transaction> getTransactions())
    (ß
        (§ return (transactions == nil) ? nil :else ImmutableList.copyOf(transactions))
    )

    ;; Used to make transactions unique.
    #_private
    #_static
    (§ field int txCounter)

    ;;; Adds a coinbase transaction to the block.  This exists for unit tests.
     ;
     ; @param height Block height, if known, or -1 otherwise.
     ;;
    #_testing
    (§ method void addCoinbaseTransaction(byte[] pubKeyTo, Coin value, #_final int height))
    (ß
        (§ call unCacheTransactions())
        (§ ass transactions = new ArrayList<>())
        (§ var Transaction coinbase = new Transaction(params))
        #_final
        (§ var ScriptBuilder inputBuilder = new ScriptBuilder())

        (§ if (Block.BLOCK_HEIGHT_GENESIS <= height))
            (§ call inputBuilder.number(height))
        (§ call inputBuilder.data(new byte[] (ß (byte)txCounter, (byte)(txCounter >> 8) )))
        (§ ass txCounter = txCounter + 1)

        ;; A real coinbase transaction has some stuff in the scriptSig like the extraNonce and difficulty.
        ;; The transactions are distinguished by every TX output going to a different key.
        ;;
        ;; Here we will do things a bit differently so a new address isn't needed every time.
        ;; We'll put a simple counter in the scriptSig, so every transaction has a different hash.
        (§ call coinbase.addInput(new TransactionInput(params, coinbase, inputBuilder.build().getProgram())))
        (§ call coinbase.addOutput(new TransactionOutput(params, coinbase, value, ScriptBuilder.createOutputScript(ECKey.fromPublicOnly(pubKeyTo)).getProgram())))
        (§ call transactions.add(coinbase))
        (§ call coinbase.setParent(this))
        (§ ass coinbase.length = coinbase.unsafeBitcoinSerialize().length)
        (§ call adjustLength(transactions.size(), coinbase.length))
    )

    #_static
    #_final
    (§ field byte[] EMPTY_BYTES = new byte[32])

    ;; It's pretty weak to have this around at runtime: fix later.
    #_private
    #_static
    #_final
    (§ field byte[] pubkeyForTesting = new ECKey().getPubKey())

    ;;;
     ; Returns a solved block that builds on top of this one.  This exists for unit tests.
     ;;
    #_testing
    #_public
    (§ method Block createNextBlock(Address to, long version, long time, int blockHeight))
    (ß
        (§ return createNextBlock(to, version, nil, time, pubkeyForTesting, FIFTY_COINS, blockHeight))
    )

    ;;;
     ; Returns a solved block that builds on top of this one.  This exists for unit tests.
     ; In this variant you can specify a public key (pubkey) for use in generating coinbase blocks.
     ;
     ; @param height Block height, if known, or -1 otherwise.
     ;;
    (§ method Block createNextBlock(#_nilable #_final Address to, #_final long version, #_nilable TransactionOutPoint prevOut, #_final long time, #_final byte[] pubKey, #_final Coin coinbaseValue, #_final int height))
    (ß
        (§ var Block b = new Block(params, version))
        (§ call b.setDifficultyTarget(difficultyTarget))
        (§ call b.addCoinbaseTransaction(pubKey, coinbaseValue, height))

        (§ if (to != nil))
        (ß
            ;; Add a transaction paying 50 coins to the "to" address.
            (§ var Transaction t = new Transaction(params))
            (§ call t.addOutput(new TransactionOutput(params, t, FIFTY_COINS, to)))
            ;; The input does not really need to be a valid signature, as long as it has the right general form.
            (§ var TransactionInput input)
            (§ if (prevOut == nil))
            (ß
                (§ ass input = new TransactionInput(params, t, Script.createInputScript(EMPTY_BYTES, EMPTY_BYTES)))
                ;; Importantly, the outpoint hash cannot be zero as that's how we detect a coinbase transaction in isolation,
                ;; but it must be unique to avoid 'different' transactions looking the same.
                (§ var byte[] counter = new byte[32])
                (§ ass counter[0] = (byte)txCounter)
                (§ ass counter[1] = (byte)(txCounter >> 8))
                (§ ass txCounter = txCounter + 1)
                (§ call input.getOutpoint().setHash(Sha256Hash.wrap(counter)))
            )
            (§ else)
            (ß
                (§ ass input = new TransactionInput(params, t, Script.createInputScript(EMPTY_BYTES, EMPTY_BYTES), prevOut))
            )
            (§ call t.addInput(input))
            (§ call b.addTransaction(t))
        )

        (§ call b.setPrevBlockHash(getHash()))
        ;; Don't let timestamp go backwards.
        (§ if (time <= getTimeSeconds()))
            (§ call b.setTime(getTimeSeconds() + 1))
        (§ else)
            (§ call b.setTime(time))
        (§ call b.solve())
        (§ try)
        (ß
            (§ call b.verifyHeader())
        )
        (§ catch (VerificationException e))
        (ß
            (§ throw new RuntimeException(e)) ;; Cannot happen.
        )
        (§ if (b.getVersion() != version))
        (ß
            (§ throw new RuntimeException())
        )
        (§ return b)
    )

    #_testing
    #_public
    (§ method Block createNextBlock(#_nilable Address to, TransactionOutPoint prevOut))
    (ß
        (§ return createNextBlock(to, BLOCK_VERSION_GENESIS, prevOut, getTimeSeconds() + 5, pubkeyForTesting, FIFTY_COINS, BLOCK_HEIGHT_UNKNOWN))
    )

    #_testing
    #_public
    (§ method Block createNextBlock(#_nilable Address to, Coin value))
    (ß
        (§ return createNextBlock(to, BLOCK_VERSION_GENESIS, nil, getTimeSeconds() + 5, pubkeyForTesting, value, BLOCK_HEIGHT_UNKNOWN))
    )

    #_testing
    #_public
    (§ method Block createNextBlock(#_nilable Address to))
    (ß
        (§ return createNextBlock(to, FIFTY_COINS))
    )

    #_testing
    #_public
    (§ method Block createNextBlockWithCoinbase(long version, byte[] pubKey, Coin coinbaseValue, #_final int height))
    (ß
        (§ return createNextBlock(nil, version, (TransactionOutPoint)nil, Utils.currentTimeSeconds(), pubKey, coinbaseValue, height))
    )

    ;;;
     ; Create a block sending 50BTC as a coinbase transaction to the public key specified.
     ; This method is intended for test use only.
     ;;
    #_testing
    (§ method Block createNextBlockWithCoinbase(long version, byte[] pubKey, #_final int height))
    (ß
        (§ return createNextBlock(nil, version, (TransactionOutPoint)nil, Utils.currentTimeSeconds(), pubKey, FIFTY_COINS, height))
    )

    #_testing
    (§ method boolean isHeaderBytesValid())
    (ß
        (§ return headerBytesValid)
    )

    #_testing
    (§ method boolean isTransactionBytesValid())
    (ß
        (§ return transactionBytesValid)
    )

    ;;;
     ; Return whether this block contains any transactions.
     ;
     ; @return true if the block contains transactions, false otherwise (is purely a header).
     ;;
    #_public
    (§ method boolean hasTransactions())
    (ß
        (§ return !this.transactions.isEmpty())
    )

    ;;;
     ; Returns whether this block conforms to
     ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0034.mediawiki">BIP34: Height in Coinbase</a>.
     ;;
    #_public
    (§ method boolean isBIP34())
    (ß
        (§ return (BLOCK_VERSION_BIP34 <= version))
    )

    ;;;
     ; Returns whether this block conforms to
     ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki">BIP66: Strict DER signatures</a>.
     ;;
    #_public
    (§ method boolean isBIP66())
    (ß
        (§ return (BLOCK_VERSION_BIP66 <= version))
    )

    ;;;
     ; Returns whether this block conforms to
     ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki">BIP65: OP_CHECKLOCKTIMEVERIFY</a>.
     ;;
    #_public
    (§ method boolean isBIP65())
    (ß
        (§ return (BLOCK_VERSION_BIP65 <= version))
    )
)

#_(ns org.bitcoinj.core #_"BlockChain"
    (:import [java.util ArrayList List])
    (:import [com.google.common.base Preconditions])
  #_(:require [org.bitcoinj.store BlockStore BlockStoreException]
             [org.bitcoinj.wallet Wallet]))

;; TODO: Rename this class to SPVBlockChain at some point.

;;;
 ; A BlockChain implements the <i>simplified payment verification</i> mode of the Bitcoin protocol.  It is the right
 ; choice to use for programs that have limited resources as it won't verify transactions signatures or attempt to store
 ; all of the block chain.  Really, this class should be called SPVBlockChain but for backwards compatibility it is not.
 ;;
#_public
(§ class BlockChain extends AbstractBlockChain
    ;;; Keeps a map of block hashes to StoredBlocks. ;;
    #_protected
    #_final
    (§ field BlockStore blockStore)

    ;;;
     ; <p>Constructs a BlockChain connected to the given wallet and store.  To obtain a {@link Wallet} you can construct
     ; one from scratch, or you can deserialize a saved wallet from disk using {@link Wallet#loadFromFile(java.io.File)}.</p>
     ;
     ; <p>For the store, you should use {@link org.bitcoinj.store.SPVBlockStore} or you could also try a
     ; {@link org.bitcoinj.store.MemoryBlockStore} if you want to hold all headers in RAM and don't care about
     ; disk serialization (this is rare).</p>
     ;;
    #_public
    (§ constructor BlockChain(Context context, Wallet wallet, BlockStore blockStore))
        (§ throws BlockStoreException)
    (ß
        (§ this (context, new ArrayList<Wallet>(), blockStore))
        (§ call addWallet(wallet))
    )

    ;;; See {@link #BlockChain(Context, Wallet, BlockStore)}}. ;;
    #_public
    (§ constructor BlockChain(NetworkParameters params, Wallet wallet, BlockStore blockStore))
        (§ throws BlockStoreException)
    (ß
        (§ this (Context.getOrCreate(params), wallet, blockStore))
    )

    ;;;
     ; Constructs a BlockChain that has no wallet at all.  This is helpful when you don't actually care about sending
     ; and receiving coins but rather, just want to explore the network data structures.
     ;;
    #_public
    (§ constructor BlockChain(Context context, BlockStore blockStore))
        (§ throws BlockStoreException)
    (ß
        (§ this (context, new ArrayList<Wallet>(), blockStore))
    )

    ;;; See {@link #BlockChain(Context, BlockStore)}. ;;
    #_public
    (§ constructor BlockChain(NetworkParameters params, BlockStore blockStore))
        (§ throws BlockStoreException)
    (ß
        (§ this (params, new ArrayList<Wallet>(), blockStore))
    )

    ;;;
     ; Constructs a BlockChain connected to the given list of listeners and a store.
     ;;
    #_public
    (§ constructor BlockChain(Context params, List<? extends Wallet> wallets, BlockStore blockStore))
        (§ throws BlockStoreException)
    (ß
        (§ super (params, wallets, blockStore))
        (§ ass this.blockStore = blockStore)
    )

    ;;; See {@link #BlockChain(Context, List, BlockStore)}. ;;
    #_public
    (§ constructor BlockChain(NetworkParameters params, List<? extends Wallet> wallets, BlockStore blockStore))
        (§ throws BlockStoreException)
    (ß
        (§ this (Context.getOrCreate(params), wallets, blockStore))
    )

    #_override
    #_protected
    (§ method StoredBlock addToBlockStore(StoredBlock storedPrev, Block blockHeader, TransactionOutputChanges txOutChanges))
        (§ throws BlockStoreException, VerificationException)
    (ß
        (§ var StoredBlock newBlock = storedPrev.build(blockHeader))
        (§ call blockStore.put(newBlock))
        (§ return newBlock)
    )

    #_override
    #_protected
    (§ method StoredBlock addToBlockStore(StoredBlock storedPrev, Block blockHeader))
        (§ throws BlockStoreException, VerificationException)
    (ß
        (§ var StoredBlock newBlock = storedPrev.build(blockHeader))
        (§ call blockStore.put(newBlock))
        (§ return newBlock)
    )

    #_override
    #_protected
    (§ method void rollbackBlockStore(int height))
        (§ throws BlockStoreException)
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ var int currentHeight = getBestChainHeight())
            (§ call Preconditions.checkArgument(0 <= height && height <= currentHeight, "Bad height: %s", height))
            (§ if (height == currentHeight))
                (§ return) ;; nothing to do

            ;; Look for the block we want to be the new chain head.
            (§ var StoredBlock newChainHead = blockStore.getChainHead())
            (§ while (height < newChainHead.getHeight()))
            (ß
                (§ ass newChainHead = newChainHead.getPrev(blockStore))
                (§ if (newChainHead == nil))
                    (§ throw new BlockStoreException("Unreachable height"))
            )

            ;; Modify store directly.
            (§ call blockStore.put(newChainHead))
            (§ call this.setChainHead(newChainHead))
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    #_override
    #_protected
    (§ method boolean shouldVerifyTransactions())
    (ß
        (§ return false)
    )

    #_override
    #_protected
    (§ method TransactionOutputChanges connectTransactions(int height, Block block))
    (ß
        ;; Don't have to do anything as this is only called if shouldVerifyTransactions().
        (§ throw new UnsupportedOperationException())
    )

    #_override
    #_protected
    (§ method TransactionOutputChanges connectTransactions(StoredBlock newBlock))
    (ß
        ;; Don't have to do anything as this is only called if shouldVerifyTransactions().
        (§ throw new UnsupportedOperationException())
    )

    #_override
    #_protected
    (§ method void disconnectTransactions(StoredBlock block))
    (ß
        ;; Don't have to do anything as this is only called if shouldVerifyTransactions().
        (§ throw new UnsupportedOperationException())
    )

    #_override
    #_protected
    (§ method void doSetChainHead(StoredBlock chainHead))
        (§ throws BlockStoreException)
    (ß
        (§ call blockStore.setChainHead(chainHead))
    )

    #_override
    #_protected
    (§ method void notSettingChainHead())
        (§ throws BlockStoreException)
    (ß
        ;; We don't use DB transactions here, so we don't need to do anything.
    )

    #_override
    #_protected
    (§ method StoredBlock getStoredBlockInCurrentScope(Sha256Hash hash))
        (§ throws BlockStoreException)
    (ß
        (§ return blockStore.get(hash))
    )

    #_override
    #_public
    (§ method boolean add(FilteredBlock block))
        (§ throws VerificationException, PrunedException)
    (ß
        (§ var boolean success = super.add(block))
        (§ if (success))
            (§ call trackFilteredTransactions(block.getTransactionCount()))
        (§ return success)
    )
)

#_(ns org.bitcoinj.core #_"BloomFilter"
    (:import [java.io IOException OutputStream]
             #_static #_[java.lang.Math *]
             [java.util ArrayList Arrays List])
    (:import [com.google.common.base Objects Preconditions]
             [com.google.common.collect Lists])
  #_(:require [org.bitcoinj.script Script ScriptChunk]))

;;;
 ; <p>A Bloom filter is a probabilistic data structure which can be sent to another client so that it can avoid
 ; sending us transactions that aren't relevant to our set of keys.  This allows for significantly more efficient
 ; use of available network bandwidth and CPU time.</p>
 ;
 ; <p>Because a Bloom filter is probabilistic, it has a configurable false positive rate.  So the filter will sometimes
 ; match transactions that weren't inserted into it, but it will never fail to match transactions that were.  This is
 ; a useful privacy feature - if you have spare bandwidth the false positive rate can be increased so the remote peer
 ; gets a noisy picture of what transactions are relevant to your wallet.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class BloomFilter extends Message
    ;;;
     ; The BLOOM_UPDATE_* constants control when the bloom filter is auto-updated by the peer using
     ; it as a filter, either never, for all outputs or only for pay-2-pubkey outputs (default).
     ;;
    #_public
    (§ enum BloomUpdate
        (§ item UPDATE_NONE) ;; 0
        (§ item UPDATE_ALL) ;; 1
        ;;; Only adds outpoints to the filter if the output is a pay-to-pubkey/pay-to-multisig script. ;;
        (§ item UPDATE_P2PUBKEY_ONLY) ;; 2
    )

    #_private
    (§ field byte[] data)
    #_private
    (§ field long hashFuncs)
    #_private
    (§ field long nTweak)
    #_private
    (§ field byte nFlags)

    ;; Same value as of Bitcoin Core.
    ;; A filter of 20,000 items and a false positive rate of 0.1% or one of 10,000 items and 0.0001% is just under 36,000 bytes.
    #_private
    #_static
    #_final
    (§ field long MAX_FILTER_SIZE = 36000)
    ;; There is little reason to ever have more hash functions than 50 given a limit of 36,000 bytes.
    #_private
    #_static
    #_final
    (§ field int MAX_HASH_FUNCS = 50)

    ;;;
     ; Construct a BloomFilter by deserializing payloadBytes.
     ;;
    #_public
    (§ constructor BloomFilter(NetworkParameters params, byte[] payloadBytes))
        (§ throws ProtocolException)
    (ß
        (§ super (params, payloadBytes, 0))
    )

    ;;;
     ; Constructs a filter with the given parameters which is updated on pay2pubkey outputs only.
     ;;
    #_public
    (§ constructor BloomFilter(int elements, double falsePositiveRate, long randomNonce))
    (ß
        (§ this (elements, falsePositiveRate, randomNonce, BloomUpdate.UPDATE_P2PUBKEY_ONLY))
    )

    ;;;
     ; <p>Constructs a new Bloom Filter which will provide approximately the given false positive rate when the given
     ; number of elements have been inserted.  If the filter would otherwise be larger than the maximum allowed size,
     ; it will be automatically downsized to the maximum size.</p>
     ;
     ; <p>To check the theoretical false positive rate of a given filter, use {@link BloomFilter#getFalsePositiveRate(int)}.</p>
     ;
     ; <p>The anonymity of which coins are yours to any peer which you send a BloomFilter to is controlled by the
     ; false positive rate.  For reference, as of block 187,000, the total number of addresses used in the chain was
     ; roughly 4.5 million.  Thus, if you use a false positive rate of 0.001 (0.1%), there will be, on average, 4,500
     ; distinct public keys/addresses which will be thought to be yours by nodes which have your bloom filter, but
     ; which are not actually yours.  Keep in mind that a remote node can do a pretty good job estimating the order of
     ; magnitude of the false positive rate of a given filter you provide it when considering the anonymity of a given
     ; filter.</p>
     ;
     ; <p>In order for filtered block download to function efficiently, the number of matched transactions in any given
     ; block should be less than (with some headroom) the maximum size of the MemoryPool used by the Peer
     ; doing the downloading (default is {@link TxConfidenceTable#MAX_SIZE}).  See the comment in processBlock(FilteredBlock)
     ; for more information on this restriction.</p>
     ;
     ; <p>randomNonce is a tweak for the hash function used to prevent some theoretical DoS attacks.
     ; It should be a random value, however secureness of the random value is of no great consequence.</p>
     ;
     ; <p>updateFlag is used to control filter behaviour on the server (remote node) side when it encounters a hit.
     ; See {@link org.bitcoinj.core.BloomFilter.BloomUpdate} for a brief description of each mode.  The purpose
     ; of this flag is to reduce network round-tripping and avoid over-dirtying the filter for the most common
     ; wallet configurations.</p>
     ;;
    #_public
    (§ constructor BloomFilter(int elements, double falsePositiveRate, long randomNonce, BloomUpdate updateFlag))
    (ß
        ;; The following formulas were stolen from Wikipedia's page on Bloom Filters (with the addition of min(..., MAX_...)).
        ;; Size required for a given number of elements and false-positive rate.
        (§ var int size = (int)(-1 / pow(log(2), 2) * elements * log(falsePositiveRate)))
        (§ ass size = max(1, min(size, (int)MAX_FILTER_SIZE * 8) / 8))
        (§ ass data = new byte[size])
        ;; Optimal number of hash functions for a given filter size and element count.
        (§ ass hashFuncs = (int)(data.length * 8 / (double)elements * log(2)))
        (§ ass hashFuncs = max(1, min(hashFuncs, MAX_HASH_FUNCS)))
        (§ ass this.nTweak = randomNonce)
        (§ ass this.nFlags = (byte)(0xff & updateFlag.ordinal()))
    )

    ;;;
     ; Returns the theoretical false positive rate of this filter if were to contain the given number of elements.
     ;;
    #_public
    (§ method double getFalsePositiveRate(int elements))
    (ß
        (§ return pow(1 - pow(E, -1.0 * (hashFuncs * elements) / (data.length * 8)), hashFuncs))
    )

    #_override
    #_public
    (§ method String toString())
    (ß
        (§ return "Bloom Filter of size " + data.length + " with " + hashFuncs + " hash functions.")
    )

    #_override
    #_protected
    (§ method void parse())
        (§ throws ProtocolException)
    (ß
        (§ ass data = readByteArray())
        (§ if (MAX_FILTER_SIZE < data.length))
            (§ throw new ProtocolException ("Bloom filter out of size range."))
        (§ ass hashFuncs = readUint32())
        (§ if (MAX_HASH_FUNCS < hashFuncs))
            (§ throw new ProtocolException("Bloom filter hash function count out of range"))
        (§ ass nTweak = readUint32())
        (§ ass nFlags = readBytes(1)[0])
        (§ ass length = cursor - offset)
    )

    ;;;
     ; Serializes this message to the provided stream.  If you just want the raw bytes use bitcoinSerialize().
     ;;
    #_override
    #_protected
    (§ method void bitcoinSerializeToStream(OutputStream stream))
        (§ throws IOException)
    (ß
        (§ call stream.write(new VarInt(data.length).encode()))
        (§ call stream.write(data))
        (§ call Utils.uint32ToByteStreamLE(hashFuncs, stream))
        (§ call Utils.uint32ToByteStreamLE(nTweak, stream))
        (§ call stream.write(nFlags))
    )

    #_private
    #_static
    (§ method int rotateLeft32(int x, int r))
    (ß
        (§ return (x << r) | (x >>> (32 - r)))
    )

    ;;;
     ; Applies the MurmurHash3 (x86_32) algorithm to the given data.
     ; See <a href="https://github.com/aappleby/smhasher/blob/master/src/MurmurHash3.cpp">this C++ code</a> for the original.
     ;;
    #_public
    #_static
    (§ method int murmurHash3(byte[] data, long nTweak, int hashNum, byte[] object))
    (ß
        (§ var int h1 = (int)(hashNum * 0xfba4c795 + nTweak))
        #_final
        (§ var int c1 = 0xcc9e2d51)
        #_final
        (§ var int c2 = 0x1b873593)

        (§ var int numBlocks = (object.length / 4) * 4)

        ;; body
        (§ for (int i = 0 :for i < numBlocks :for i = i + 4))
        (ß
            (§ var int k1 = (object[i] & 0xff) | ((object[i + 1] & 0xff) << 8) | ((object[i + 2] & 0xff) << 16) | ((object[i + 3] & 0xff) << 24))

            (§ ass k1 = k1 * c1)
            (§ ass k1 = rotateLeft32(k1, 15))
            (§ ass k1 = k1 * c2)

            (§ ass h1 = h1 :xor k1)
            (§ ass h1 = rotateLeft32(h1, 13))
            (§ ass h1 = h1 * 5 + 0xe6546b64)
        )

        (§ var int k1 = 0)
        (§ switch (object.length & 3))
        (ß
            (§ case 3)
                (§ ass k1 = k1 :xor ((object[numBlocks + 2] & 0xff) << 16))
                ;; Fall through.
            (§ case 2)
                (§ ass k1 = k1 :xor ((object[numBlocks + 1] & 0xff) << 8))
                ;; Fall through.
            (§ case 1)
                (§ ass k1 = k1 :xor (object[numBlocks] & 0xff))
                (§ ass k1 = k1 * c1)
                (§ ass k1 = rotateLeft32(k1, 15))
                (§ ass k1 = k1 * c2)
                (§ ass h1 = h1 :xor k1)
                ;; Fall through.
            (§ default)
                ;; Do nothing.
                (§ break)
        )

        ;; finalization
        (§ ass h1 = h1 :xor object.length)
        (§ ass h1 = h1 :xor (h1 >>> 16))
        (§ ass h1 = h1 * 0x85ebca6b)
        (§ ass h1 = h1 :xor (h1 >>> 13))
        (§ ass h1 = h1 * 0xc2b2ae35)
        (§ ass h1 = h1 :xor (h1 >>> 16))

        (§ return (int)((h1 & 0xffffffff) % (data.length * 8)))
    )

    ;;;
     ; Returns true if the given object matches the filter either because it was inserted, or because we have a false-positive.
     ;;
    #_public
    #_synchronized
    (§ method boolean contains(byte[] object))
    (ß
        (§ for (int i = 0 :for i < hashFuncs :for i = i + 1))
            (§ if (!Utils.checkBitLE(data, murmurHash3(data, nTweak, i, object))))
                (§ return false)

        (§ return true)
    )

    ;;; Insert the given arbitrary data into the filter. ;;
    #_public
    #_synchronized
    (§ method void insert(byte[] object))
    (ß
        (§ for (int i = 0 :for i < hashFuncs :for i = i + 1))
            (§ call Utils.setBitLE(data, murmurHash3(data, nTweak, i, object)))
    )

    ;;; Inserts the given key and equivalent hashed form (for the address). ;;
    #_public
    #_synchronized
    (§ method void insert(ECKey key))
    (ß
        (§ call insert(key.getPubKey()))
        (§ call insert(key.getPubKeyHash()))
    )

    ;;;
     ; Sets this filter to match all objects.  A Bloom filter which matches everything may seem pointless, however,
     ; it is useful in order to reduce steady state bandwidth usage when you want full blocks.  Instead of receiving
     ; all transaction data twice, you will receive the vast majority of all transactions just once, at broadcast time.
     ; Solved blocks will then be send just as Merkle trees of tx hashes, meaning a constant 32 bytes of data for each
     ; transaction instead of 100-300 bytes as per usual.
     ;;
    #_public
    #_synchronized
    (§ method void setMatchAll())
    (ß
        (§ ass data = new byte[] (ß (byte)0xff ))
    )

    ;;;
     ; Copies filter into this.  Filter must have the same size, hash function count and nTweak or an
     ; IllegalArgumentException will be thrown.
     ;;
    #_public
    #_synchronized
    (§ method void merge(BloomFilter filter))
    (ß
        (§ if (!this.matchesAll() && !filter.matchesAll()))
        (ß
            (§ call Preconditions.checkArgument(filter.data.length == this.data.length && filter.hashFuncs == this.hashFuncs && filter.nTweak == this.nTweak))

            (§ for (int i = 0 :for i < data.length :for i = i + 1))
                (§ ass this.data[i] = this.data[i] | filter.data[i])
        )
        (§ else)
        (ß
            (§ ass this.data = new byte[] (ß (byte)0xff ))
        )
    )

    ;;;
     ; Returns true if this filter will match anything.  See {@link org.bitcoinj.core.BloomFilter#setMatchAll()}
     ; for when this can be a useful thing to do.
     ;;
    #_public
    #_synchronized
    (§ method boolean matchesAll())
    (ß
        (§ for (byte b :for data))
            (§ if (b != (byte)0xff))
                (§ return false)
        (§ return true)
    )

    ;;;
     ; The update flag controls how application of the filter to a block modifies the filter.  See the enum javadocs
     ; for information on what occurs and when.
     ;;
    #_public
    #_synchronized
    (§ method BloomUpdate getUpdateFlag())
    (ß
        (§ if (nFlags == 0))
            (§ return BloomUpdate.UPDATE_NONE)
        (§ if (nFlags == 1))
            (§ return BloomUpdate.UPDATE_ALL)
        (§ if (nFlags == 2))
            (§ return BloomUpdate.UPDATE_P2PUBKEY_ONLY)

        (§ throw new IllegalStateException("Unknown flag combination"))
    )

    ;;;
     ; Creates a new FilteredBlock from the given Block, using this filter to select transactions.  Matches can cause the
     ; filter to be updated with the matched element, this ensures that when a filter is applied to a block, spends of
     ; matched transactions are also matched.  However it means this filter can be mutated by the operation.  The returned
     ; filtered block already has the matched transactions associated with it.
     ;;
    #_public
    #_synchronized
    (§ method FilteredBlock applyAndUpdate(Block block))
    (ß
        (§ var List<Transaction> txns = block.getTransactions())
        (§ var List<Sha256Hash> txHashes = new ArrayList<>(txns.size()))
        (§ var List<Transaction> matched = Lists.newArrayList())
        (§ var byte[] bits = new byte[(int)Math.ceil(txns.size() / 8.0)])
        (§ for (int i = 0 :for i < txns.size() :for i = i + 1))
        (ß
            (§ var Transaction tx = txns.get(i))
            (§ call txHashes.add(tx.getHash()))
            (§ if (applyAndUpdate(tx)))
            (ß
                (§ call Utils.setBitLE(bits, i))
                (§ call matched.add(tx))
            )
        )
        (§ var PartialMerkleTree pmt = PartialMerkleTree.buildFromLeaves(block.getParams(), bits, txHashes))
        (§ var FilteredBlock filteredBlock = new FilteredBlock(block.getParams(), block.cloneAsHeader(), pmt))
        (§ for (Transaction transaction :for matched))
            (§ call filteredBlock.provideTransaction(transaction))
        (§ return filteredBlock)
    )

    #_public
    #_synchronized
    (§ method boolean applyAndUpdate(Transaction tx))
    (ß
        (§ if (contains(tx.getHash().getBytes())))
            (§ return true)
        (§ var boolean found = false)
        (§ var BloomUpdate flag = getUpdateFlag())
        (§ for (TransactionOutput output :for tx.getOutputs()))
        (ß
            (§ var Script script = output.getScriptPubKey())
            (§ for (ScriptChunk chunk :for script.getChunks()))
            (ß
                (§ if (chunk.isPushData() && contains(chunk.data)))
                (ß
                    (§ var boolean isSendingToPubKeys = script.isSentToRawPubKey() || script.isSentToMultiSig())
                    (§ if (flag == BloomUpdate.UPDATE_ALL || (flag == BloomUpdate.UPDATE_P2PUBKEY_ONLY && isSendingToPubKeys)))
                        (§ call insert(output.getOutPointFor().unsafeBitcoinSerialize()))
                    (§ ass found = true)
                )
            )
        )
        (§ if (found))
            (§ return true)
        (§ for (TransactionInput input :for tx.getInputs()))
        (ß
            (§ if (contains(input.getOutpoint().unsafeBitcoinSerialize())))
                (§ return true)

            (§ for (ScriptChunk chunk :for input.getScriptSig().getChunks()))
                (§ if (chunk.isPushData() && contains(chunk.data)))
                    (§ return true)
        )
        (§ return false)
    )

    #_override
    #_public
    #_synchronized
    (§ method boolean equals(Object o))
    (ß
        (§ if (this == o))
            (§ return true)
        (§ if (o == nil || getClass() != o.getClass()))
            (§ return false)
        (§ var BloomFilter other = (BloomFilter)o)
        (§ return (hashFuncs == other.hashFuncs && nTweak == other.nTweak && Arrays.equals(data, other.data)))
    )

    #_override
    #_public
    #_synchronized
    (§ method int hashCode())
    (ß
        (§ return Objects.hashCode(hashFuncs, nTweak, Arrays.hashCode(data)))
    )
)

#_(ns org.bitcoinj.core #_"CheckpointManager"
    (:import [java.io BufferedInputStream BufferedReader DataInputStream IOException InputStream InputStreamReader]
             [java.nio ByteBuffer ByteOrder]
             [java.security DigestInputStream MessageDigest]
             [java.util Arrays Map TreeMap])
    (:import [com.google.common.base Charsets Preconditions]
             [com.google.common.hash HashCode Hasher Hashing]
             [com.google.common.io BaseEncoding]
             [org.slf4j Logger LoggerFactory])
  #_(:require [org.bitcoinj.store BlockStore BlockStoreException FullPrunedBlockStore]))

;;;
 ; <p>Vends hard-coded {@link StoredBlock}s for blocks throughout the chain.  Checkpoints serve two purposes:</p>
 ; <ol>
 ;    <li>They act as a safety mechanism against huge re-orgs that could rewrite large chunks of history, thus
 ;    constraining the block chain to be a consensus mechanism only for recent parts of the timeline.</li>
 ;    <li>They allow synchronization to the head of the chain for new wallets/users much faster than syncing all
 ;    headers from the genesis block.</li>
 ; </ol>
 ;
 ; <p>Checkpoints are used by the SPV {@link BlockChain} to initialize fresh {@link org.bitcoinj.store.SPVBlockStore}s.
 ; They are not used by fully validating mode, which instead has a different concept of checkpoints that are used
 ; to hard-code the validity of blocks that violate BIP30 (duplicate coinbase transactions).
 ; Those "checkpoints" can be found in NetworkParameters.</p>
 ;
 ; <p>The file format consists of the string "CHECKPOINTS 1", followed by a uint32 containing the number of signatures
 ; to read.  The value may not be larger than 256 (so it could have been a byte but isn't for historical reasons).
 ; If the number of signatures is larger than zero, each 65 byte ECDSA secp256k1 signature then follows.  The signatures
 ; sign the hash of all bytes that follow the last signature.</p>
 ;
 ; <p>After the signatures come an int32 containing the number of checkpoints in the file.  Then each checkpoint follows
 ; one after the other.  A checkpoint is 12 bytes for the total work done field, 4 bytes for the height, 80 bytes
 ; for the block header and then 1 zero byte at the end (i.e. number of transactions in the block: always zero).</p>
 ;;
#_public
(§ class CheckpointManager
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(CheckpointManager.class))

    #_private
    #_static
    #_final
    (§ field String BINARY_MAGIC = "CHECKPOINTS 1")
    #_private
    #_static
    #_final
    (§ field String TEXTUAL_MAGIC = "TXT CHECKPOINTS 1")
    #_private
    #_static
    #_final
    (§ field int MAX_SIGNATURES = 256)

    ;; Map of block header time to data.
    #_protected
    #_final
    (§ field TreeMap<Long, StoredBlock> checkpoints = new TreeMap<>())

    #_protected
    #_final
    (§ field NetworkParameters params)
    #_protected
    #_final
    (§ field Sha256Hash dataHash)

    #_public
    #_static
    #_final
    (§ field BaseEncoding BASE64 = BaseEncoding.base64().omitPadding())

    ;;; Loads the default checkpoints bundled with bitcoinj. ;;
    #_public
    (§ constructor CheckpointManager(Context context))
        (§ throws IOException)
    (ß
        (§ this (context.getParams(), nil))
    )

    ;;; Loads the checkpoints from the given stream. ;;
    #_public
    (§ constructor CheckpointManager(NetworkParameters params, #_nilable InputStream inputStream))
        (§ throws IOException)
    (ß
        (§ ass this.params = Preconditions.checkNotNull(params))
        (§ if (inputStream == nil))
            (§ ass inputStream = openStream(params))
        (§ call Preconditions.checkNotNull(inputStream))
        (§ ass inputStream = new BufferedInputStream(inputStream))
        (§ call inputStream.mark(1))
        (§ var int first = inputStream.read())
        (§ call inputStream.reset())
        (§ if (first == BINARY_MAGIC.charAt(0)))
            (§ ass dataHash = readBinary(inputStream))
        (§ elseif (first == TEXTUAL_MAGIC.charAt(0)))
            (§ ass dataHash = readTextual(inputStream))
        (§ else)
            (§ throw new IOException("Unsupported format."))
    )

    ;;; Returns a checkpoints stream pointing to inside the bitcoinj JAR. ;;
    #_public
    #_static
    (§ method InputStream openStream(NetworkParameters params))
    (ß
        (§ return CheckpointManager.class.getResourceAsStream("/" + params.getId() + ".checkpoints.txt"))
    )

    #_private
    (§ method Sha256Hash readBinary(InputStream inputStream))
        (§ throws IOException)
    (ß
        (§ var DataInputStream dis = nil)
        (§ try)
        (ß
            (§ var MessageDigest digest = Sha256Hash.newDigest())
            (§ var DigestInputStream digestInputStream = new DigestInputStream(inputStream, digest))
            (§ ass dis = new DataInputStream(digestInputStream))
            (§ call digestInputStream.on(false))
            (§ var byte[] header = new byte[BINARY_MAGIC.length()])
            (§ call dis.readFully(header))
            (§ if (!Arrays.equals(header, BINARY_MAGIC.getBytes("US-ASCII"))))
                (§ throw new IOException("Header bytes did not match expected version"))
            (§ var int numSignatures = checkPositionIndex(dis.readInt(), MAX_SIGNATURES, "Num signatures out of range"))
            (§ for (int i = 0 :for i < numSignatures :for i = i + 1))
            (ß
                (§ var byte[] sig = new byte[65])
                (§ call dis.readFully(sig))
                ;; TODO: Do something with the signature here.
            )
            (§ call digestInputStream.on(true))
            (§ var int numCheckpoints = dis.readInt())
            (§ call Preconditions.checkState(0 < numCheckpoints))
            #_final
            (§ var int size = StoredBlock.COMPACT_SERIALIZED_SIZE)
            (§ var ByteBuffer buffer = ByteBuffer.allocate(size))
            (§ for (int i = 0 :for i < numCheckpoints :for i = i + 1))
            (ß
                (§ if (dis.read(buffer.array(), 0, size) < size))
                    (§ throw new IOException("Incomplete read whilst loading checkpoints."))
                (§ var StoredBlock block = StoredBlock.deserializeCompact(params, buffer))
                (§ call buffer.position(0))
                (§ call checkpoints.put(block.getHeader().getTimeSeconds(), block))
            )
            (§ var Sha256Hash dataHash = Sha256Hash.wrap(digest.digest()))
            (§ call log.info("Read {} checkpoints, hash is {}", checkpoints.size(), dataHash))
            (§ return dataHash)
        )
        (§ catch (ProtocolException e))
        (ß
            (§ throw new IOException(e))
        )
        (§ finally)
        (ß
            (§ if (dis != nil))
                (§ call dis.close())
            (§ call inputStream.close())
        )
    )

    #_private
    (§ method Sha256Hash readTextual(InputStream inputStream))
        (§ throws IOException)
    (ß
        (§ var Hasher hasher = Hashing.sha256().newHasher())
        (§ var BufferedReader reader = nil)
        (§ try)
        (ß
            (§ ass reader = new BufferedReader(new InputStreamReader(inputStream, Charsets.US_ASCII)))
            (§ var String magic = reader.readLine())
            (§ if (!TEXTUAL_MAGIC.equals(magic)))
                (§ throw new IOException("unexpected magic: " + magic))
            (§ var int numSigs = Integer.parseInt(reader.readLine()))
            (§ for (int i = 0 :for i < numSigs :for i = i + 1))
                (§ call reader.readLine()) ;; Skip sigs for now.
            (§ var int numCheckpoints = Integer.parseInt(reader.readLine()))
            (§ call Preconditions.checkState(0 < numCheckpoints))
            ;; Hash numCheckpoints in a way compatible to the binary format.
            (§ call hasher.putBytes(ByteBuffer.allocate(4).order(ByteOrder.BIG_ENDIAN).putInt(numCheckpoints).array()))
            #_final
            (§ var int size = StoredBlock.COMPACT_SERIALIZED_SIZE)
            (§ var ByteBuffer buffer = ByteBuffer.allocate(size))
            (§ for (int i = 0 :for i < numCheckpoints :for i = i + 1))
            (ß
                (§ var byte[] bytes = BASE64.decode(reader.readLine()))
                (§ call hasher.putBytes(bytes))
                (§ call buffer.position(0))
                (§ call buffer.put(bytes))
                (§ call buffer.position(0))
                (§ var StoredBlock block = StoredBlock.deserializeCompact(params, buffer))
                (§ call checkpoints.put(block.getHeader().getTimeSeconds(), block))
            )
            (§ var HashCode hash = hasher.hash())
            (§ call log.info("Read {} checkpoints, hash is {}", checkpoints.size(), hash))
            (§ return Sha256Hash.wrap(hash.asBytes()))
        )
        (§ finally)
        (ß
            (§ if (reader != nil))
                (§ call reader.close())
        )
    )

    ;;;
     ; Returns a {@link StoredBlock} representing the last checkpoint before the given time, for example, normally
     ; you would want to know the checkpoint before the earliest wallet birthday.
     ;;
    #_public
    (§ method StoredBlock getCheckpointBefore(long time))
    (ß
        (§ try)
        (ß
            (§ call Preconditions.checkArgument(params.getGenesisBlock().getTimeSeconds() < time))
            ;; This is thread safe because the map never changes after creation.
            (§ var Map.Entry<Long, StoredBlock> entry = checkpoints.floorEntry(time))
            (§ if (entry != nil))
                (§ return entry.getValue())
            (§ var Block genesis = params.getGenesisBlock().cloneAsHeader())
            (§ return new StoredBlock(genesis, genesis.getWork(), 0))
        )
        (§ catch (VerificationException e))
        (ß
            (§ throw new RuntimeException(e)) ;; Cannot happen.
        )
    )

    ;;; Returns the number of checkpoints that were loaded. ;;
    #_public
    (§ method int numCheckpoints())
    (ß
        (§ return checkpoints.size())
    )

    ;;; Returns a hash of the concatenated checkpoint data. ;;
    #_public
    (§ method Sha256Hash getDataHash())
    (ß
        (§ return dataHash)
    )

    ;;;
     ; <p>Convenience method that creates a CheckpointManager, loads the given data, gets the checkpoint for the given
     ; time, then inserts it into the store and sets that to be the chain head.  Useful when you have just created
     ; a new store from scratch and want to use configure it all in one go.</p>
     ;
     ; <p>Note that time is adjusted backwards by a week to account for possible clock drift in the block headers.</p>
     ;;
    #_public
    #_static
    (§ method void checkpoint(NetworkParameters params, InputStream checkpoints, BlockStore store, long time))
        (§ throws IOException, BlockStoreException)
    (ß
        (§ call Preconditions.checkNotNull(params))
        (§ call Preconditions.checkNotNull(store))
        (§ call Preconditions.checkArgument(!(store instanceof FullPrunedBlockStore), "You cannot use checkpointing with a full store."))

        (§ ass time = time - (86400 * 7))

        (§ call Preconditions.checkArgument(0 < time))
        (§ call log.info("Attempting to initialize a new block store with a checkpoint for time {} ({})", time, Utils.dateTimeFormat(time * 1000)))

        (§ var BufferedInputStream stream = new BufferedInputStream(checkpoints))
        (§ var CheckpointManager manager = new CheckpointManager(params, stream))
        (§ var StoredBlock checkpoint = manager.getCheckpointBefore(time))
        (§ call store.put(checkpoint))
        (§ call store.setChainHead(checkpoint))
    )
)

#_(ns org.bitcoinj.core #_"ChildMessage")

;;;
 ; <p>Represents a Message type that can be contained within another Message.  ChildMessages that have a cached
 ; backing byte array need to invalidate their parent's caches as well as their own if they are modified.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
#_abstract
(§ class ChildMessage extends Message
    #_nilable
    #_protected
    (§ field Message parent)

    #_public
    (§ constructor ChildMessage(NetworkParameters params))
    (ß
        (§ super (params))
    )

    #_public
    (§ constructor ChildMessage(NetworkParameters params, byte[] payload, int offset, int protocolVersion))
        (§ throws ProtocolException)
    (ß
        (§ super (params, payload, offset, protocolVersion))
    )

    #_public
    (§ constructor ChildMessage(NetworkParameters params, byte[] payload, int offset, int protocolVersion, Message parent, MessageSerializer setSerializer, int length))
        (§ throws ProtocolException)
    (ß
        (§ super (params, payload, offset, protocolVersion, setSerializer, length))
        (§ ass this.parent = parent)
    )

    #_public
    (§ constructor ChildMessage(NetworkParameters params, byte[] payload, int offset))
        (§ throws ProtocolException)
    (ß
        (§ super (params, payload, offset))
    )

    #_public
    (§ constructor ChildMessage(NetworkParameters params, byte[] payload, int offset, #_nilable Message parent, MessageSerializer setSerializer, int length))
        (§ throws ProtocolException)
    (ß
        (§ super (params, payload, offset, setSerializer, length))
        (§ ass this.parent = parent)
    )

    #_public
    #_final
    (§ method void setParent(#_nilable Message parent))
    (ß
        (§ if (this.parent != nil && this.parent != parent && parent != nil))
        (ß
            ;; After old parent is unlinked it won't be able to receive notice if this ChildMessage changes internally.
            ;; To be safe we invalidate the parent cache to ensure it rebuilds manually on serialization.
            (§ call this.parent.unCache())
        )
        (§ ass this.parent = parent)
    )

    #_override
    #_protected
    (§ method void unCache())
    (ß
        (§ call super.unCache())
        (§ if (parent != nil))
            (§ call parent.unCache())
    )

    #_protected
    (§ method void adjustLength(int adjustment))
    (ß
        (§ call adjustLength(0, adjustment))
    )

    #_override
    #_protected
    (§ method void adjustLength(int newArraySize, int adjustment))
    (ß
        (§ call super.adjustLength(newArraySize, adjustment))
        (§ if (parent != nil))
            (§ call parent.adjustLength(newArraySize, adjustment))
    )
)

#_(ns org.bitcoinj.core #_"Coin"
    (:import [java.io Serializable]
             [java.math BigDecimal])
    (:import [com.google.common.base Preconditions]
             [com.google.common.math LongMath]
             [com.google.common.primitives Longs])
  #_(:require [org.bitcoinj.utils MonetaryFormat]))

;;;
 ; Represents a monetary Bitcoin value.  This class is immutable.
 ;;
#_public
#_final
(§ class Coin implements Monetary, Comparable<Coin>, Serializable
    ;;;
     ; Number of decimals for one Bitcoin.  This constant is useful for quick adapting to other coins because a lot of
     ; constants derive from it.
     ;;
    #_public
    #_static
    #_final
    (§ field int SMALLEST_UNIT_EXPONENT = 8)

    ;;;
     ; The number of satoshis equal to one bitcoin.
     ;;
    #_private
    #_static
    #_final
    (§ field long COIN_VALUE = LongMath.pow(10, SMALLEST_UNIT_EXPONENT))

    ;;;
     ; Zero Bitcoins.
     ;;
    #_public
    #_static
    #_final
    (§ field Coin ZERO = Coin.valueOf(0))

    ;;;
     ; One Bitcoin.
     ;;
    #_public
    #_static
    #_final
    (§ field Coin COIN = Coin.valueOf(COIN_VALUE))

    ;;;
     ; 0.01 Bitcoins.  This unit is not really used much.
     ;;
    #_public
    #_static
    #_final
    (§ field Coin CENT = COIN.divide(100))

    ;;;
     ; 0.001 Bitcoins, also known as 1 mBTC.
     ;;
    #_public
    #_static
    #_final
    (§ field Coin MILLICOIN = COIN.divide(1000))

    ;;;
     ; 0.000001 Bitcoins, also known as 1 µBTC or 1 uBTC.
     ;;
    #_public
    #_static
    #_final
    (§ field Coin MICROCOIN = MILLICOIN.divide(1000))

    ;;;
     ; A satoshi is the smallest unit that can be transferred.  100 million of them fit into a Bitcoin.
     ;;
    #_public
    #_static
    #_final
    (§ field Coin SATOSHI = Coin.valueOf(1))

    #_public
    #_static
    #_final
    (§ field Coin FIFTY_COINS = COIN.multiply(50))

    ;;;
     ; Represents a monetary value of minus one satoshi.
     ;;
    #_public
    #_static
    #_final
    (§ field Coin NEGATIVE_SATOSHI = Coin.valueOf(-1))

    ;;;
     ; The number of satoshis of this monetary value.
     ;;
    #_public
    #_final
    (§ field long value)

    #_private
    (§ constructor Coin(#_final long satoshis))
    (ß
        (§ ass this.value = satoshis)
    )

    #_public
    #_static
    (§ method Coin valueOf(#_final long satoshis))
    (ß
        (§ return new Coin(satoshis))
    )

    #_override
    #_public
    (§ method int smallestUnitExponent())
    (ß
        (§ return SMALLEST_UNIT_EXPONENT)
    )

    ;;;
     ; Returns the number of satoshis of this monetary value.
     ;;
    #_override
    #_public
    (§ method long getValue())
    (ß
        (§ return value)
    )

    ;;;
     ; Convert an amount expressed in the way humans are used to into satoshis.
     ;;
    #_public
    #_static
    (§ method Coin valueOf(#_final int coins, #_final int cents))
    (ß
        (§ call Preconditions.checkArgument(0 <= coins && 0 <= cents && cents < 100))

        (§ return COIN.multiply(coins).add(CENT.multiply(cents)))
    )

    ;;;
     ; Parses an amount expressed in the way humans are used to.
     ;
     ; This takes string in a format understood by {@link BigDecimal#BigDecimal(String)},
     ; for example "0", "1", "0.10", "1.23E3", "1234.5E-5".
     ;
     ; @throws IllegalArgumentException if you try to specify fractional satoshis, or a value out of range.
     ;;
    #_public
    #_static
    (§ method Coin parseCoin(#_final String str))
    (ß
        (§ try)
        (ß
            (§ var long satoshis = new BigDecimal(str).movePointRight(SMALLEST_UNIT_EXPONENT).longValueExact())
            (§ return Coin.valueOf(satoshis))
        )
        (§ catch (ArithmeticException e))
        (ß
            (§ throw new IllegalArgumentException(e)) ;; Repackage exception to honor method contract.
        )
    )

    ;;;
     ; Parses an amount expressed in the way humans are used to.  The amount is cut to satoshi precision.
     ;
     ; This takes string in a format understood by {@link BigDecimal#BigDecimal(String)},
     ; for example "0", "1", "0.10", "1.23E3", "1234.5E-5".
     ;
     ; @throws IllegalArgumentException if you try to specify a value out of range.
     ;;
    #_public
    #_static
    (§ method Coin parseCoinInexact(#_final String str))
    (ß
        (§ try)
        (ß
            (§ var long satoshis = new BigDecimal(str).movePointRight(SMALLEST_UNIT_EXPONENT).longValue())
            (§ return Coin.valueOf(satoshis))
        )
        (§ catch (ArithmeticException e))
        (ß
            (§ throw new IllegalArgumentException(e)) ;; Repackage exception to honor method contract.
        )
    )

    #_public
    (§ method Coin add(#_final Coin value))
    (ß
        (§ return new Coin(LongMath.checkedAdd(this.value, value.value)))
    )

    ;;; Alias for add. ;;
    #_public
    (§ method Coin plus(#_final Coin value))
    (ß
        (§ return add(value))
    )

    #_public
    (§ method Coin subtract(#_final Coin value))
    (ß
        (§ return new Coin(LongMath.checkedSubtract(this.value, value.value)))
    )

    ;;; Alias for subtract. ;;
    #_public
    (§ method Coin minus(#_final Coin value))
    (ß
        (§ return subtract(value))
    )

    #_public
    (§ method Coin multiply(#_final long factor))
    (ß
        (§ return new Coin(LongMath.checkedMultiply(this.value, factor)))
    )

    ;;; Alias for multiply. ;;
    #_public
    (§ method Coin times(#_final long factor))
    (ß
        (§ return multiply(factor))
    )

    ;;; Alias for multiply. ;;
    #_public
    (§ method Coin times(#_final int factor))
    (ß
        (§ return multiply(factor))
    )

    #_public
    (§ method Coin divide(#_final long divisor))
    (ß
        (§ return new Coin(this.value / divisor))
    )

    ;;; Alias for divide. ;;
    #_public
    (§ method Coin div(#_final long divisor))
    (ß
        (§ return divide(divisor))
    )

    ;;; Alias for divide. ;;
    #_public
    (§ method Coin div(#_final int divisor))
    (ß
        (§ return divide(divisor))
    )

    #_public
    (§ method Coin[] divideAndRemainder(#_final long divisor))
    (ß
        (§ return new Coin[] (ß new Coin(this.value / divisor), new Coin(this.value % divisor) ))
    )

    #_public
    (§ method long divide(#_final Coin divisor))
    (ß
        (§ return this.value / divisor.value)
    )

    ;;;
     ; Returns true if and only if this instance represents a monetary value greater than zero,
     ; otherwise false.
     ;;
    #_public
    (§ method boolean isPositive())
    (ß
        (§ return (signum() == 1))
    )

    ;;;
     ; Returns true if and only if this instance represents a monetary value less than zero,
     ; otherwise false.
     ;;
    #_public
    (§ method boolean isNegative())
    (ß
        (§ return (signum() == -1))
    )

    ;;;
     ; Returns true if and only if this instance represents zero monetary value,
     ; otherwise false.
     ;;
    #_public
    (§ method boolean isZero())
    (ß
        (§ return (signum() == 0))
    )

    ;;;
     ; Returns true if the monetary value represented by this instance is greater than that
     ; of the given other Coin, otherwise false.
     ;;
    #_public
    (§ method boolean isGreaterThan(Coin other))
    (ß
        (§ return (0 < compareTo(other)))
    )

    ;;;
     ; Returns true if the monetary value represented by this instance is less than that
     ; of the given other Coin, otherwise false.
     ;;
    #_public
    (§ method boolean isLessThan(Coin other))
    (ß
        (§ return (compareTo(other) < 0))
    )

    #_public
    (§ method Coin shiftLeft(#_final int n))
    (ß
        (§ return new Coin(this.value << n))
    )

    #_public
    (§ method Coin shiftRight(#_final int n))
    (ß
        (§ return new Coin(this.value >> n))
    )

    #_override
    #_public
    (§ method int signum())
    (ß
        (§ if (this.value == 0))
            (§ return 0)
        (§ return (this.value < 0) ? -1 :else 1)
    )

    #_public
    (§ method Coin negate())
    (ß
        (§ return new Coin(-this.value))
    )

    ;;;
     ; Returns the number of satoshis of this monetary value.  It's deprecated in favour of accessing {@link #value} directly.
     ;;
    #_public
    (§ method long longValue())
    (ß
        (§ return this.value)
    )

    #_private
    #_static
    #_final
    (§ field MonetaryFormat FRIENDLY_FORMAT = MonetaryFormat.BTC.minDecimals(2).repeatOptionalDecimals(1, 6).postfixCode())

    ;;;
     ; Returns the value as a 0.12 type string.  More digits after the decimal place will be used
     ; if necessary, but two will always be present.
     ;;
    #_public
    (§ method String toFriendlyString())
    (ß
        (§ return FRIENDLY_FORMAT.format(this).toString())
    )

    #_private
    #_static
    #_final
    (§ field MonetaryFormat PLAIN_FORMAT = MonetaryFormat.BTC.minDecimals(0).repeatOptionalDecimals(1, 8).noCode())

    ;;;
     ; Returns the value as a plain string denominated in BTC.
     ; The result is unformatted with no trailing zeroes.
     ; For instance, a value of 150000 satoshis gives an output string of "0.0015" BTC.
     ;;
    #_public
    (§ method String toPlainString())
    (ß
        (§ return PLAIN_FORMAT.format(this).toString())
    )

    #_override
    #_public
    (§ method String toString())
    (ß
        (§ return Long.toString(value))
    )

    #_override
    #_public
    (§ method boolean equals(#_final Object o))
    (ß
        (§ if (this == o))
            (§ return true)
        (§ if (o == nil || getClass() != o.getClass()))
            (§ return false)
        (§ return (this.value == ((Coin)o).value))
    )

    #_override
    #_public
    (§ method int hashCode())
    (ß
        (§ return (int)this.value)
    )

    #_override
    #_public
    (§ method int compareTo(#_final Coin other))
    (ß
        (§ return Longs.compare(this.value, other.value))
    )
)

#_(ns org.bitcoinj.core #_"Context"
    (:import [com.google.common.base Preconditions]
             #_[org.slf4j *]))

;; TODO: Finish adding Context c'tors to all the different objects so we can start deprecating the versions that take NetworkParameters.
;; TODO: Add a working directory notion to Context and make various subsystems that want to use files default to that directory (e.g. Orchid, block stores, wallet, etc).
;; TODO: Auto-register the block chain object here, and then use it in the (newly deprecated) TransactionConfidence.getDepthInBlocks() method:
;;       the new version should take an AbstractBlockChain specifically.
;;       Also use the block chain object reference from the context in PeerGroup and remove the other constructors, as it's easy to forget to wire things up.
;; TODO: Move Threading.USER_THREAD to here and leave behind just a source code stub.  Allow different instantiations of the library to use different user threads.
;; TODO: Keep a URI to where library internal data files can be found, to abstract over the lack of JAR files on Android.
;; TODO: Stash anything else that resembles global library configuration in here and use it to clean up the rest of the API without breaking people.
;; TODO: Move the TorClient into Context, so different parts of the library can read data over Tor without having to request it directly. (or maybe a general socket factory??)

;;;
 ; <p>The Context object holds various objects and pieces of configuration that are scoped to a specific instantiation of
 ; bitcoinj for a specific network.  You can get an instance of this class through calling {@link #get()}.</p>
 ;
 ; <p>Context is new in 0.13 and the library is currently in a transitional period: you should create a Context that
 ; wraps your chosen network parameters before using the rest of the library.  However if you don't, things will still
 ; work as a Context will be created for you and stashed in thread local storage.  The context is then propagated between
 ; library created threads as needed.  This automagical propagation and creation is a temporary mechanism: one day it
 ; will be removed to avoid confusing edge cases that could occur if the developer does not fully understand it e.g.
 ; in the case where multiple instances of the library are in use simultaneously.</p>
 ;;
#_public
(§ class Context
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(Context.class))

    #_public
    #_static
    #_final
    (§ field int DEFAULT_EVENT_HORIZON = 100)

    #_final
    #_private
    (§ field TxConfidenceTable confidenceTable)
    #_final
    #_private
    (§ field NetworkParameters params)
    #_final
    #_private
    (§ field int eventHorizon)
    #_final
    #_private
    (§ field boolean ensureMinRequiredFee)
    #_final
    #_private
    (§ field Coin feePerKb)

    ;;;
     ; Creates a new context object.  For now, this will be done for you by the framework.  Eventually you will be
     ; expected to do this yourself in the same manner as fetching a NetworkParameters object (at the start of your app).
     ;
     ; @param params The network parameters that will be associated with this context.
     ;;
    #_public
    (§ constructor Context(NetworkParameters params))
    (ß
        (§ this (params, DEFAULT_EVENT_HORIZON, Transaction.DEFAULT_TX_FEE, true))
    )

    ;;;
     ; Creates a new custom context object.  This is mainly meant for unit tests for now.
     ;
     ; @param params The network parameters that will be associated with this context.
     ; @param eventHorizon Number of blocks after which the library will delete data and be unable to always process reorgs (see {@link #getEventHorizon()}).
     ; @param feePerKb The default fee per 1000 bytes of transaction data to pay when completing transactions.  For details, see {@link SendRequest#feePerKb}.
     ; @param ensureMinRequiredFee Whether to ensure the minimum required fee by default when completing transactions.  For details, see {@link SendRequest#ensureMinRequiredFee}.
     ;;
    #_public
    (§ constructor Context(NetworkParameters params, int eventHorizon, Coin feePerKb, boolean ensureMinRequiredFee))
    (ß
        (§ call log.info("Creating bitcoinj {} context.", VersionMessage.BITCOINJ_VERSION))
        (§ ass this.confidenceTable = new TxConfidenceTable())
        (§ ass this.params = params)
        (§ ass this.eventHorizon = eventHorizon)
        (§ ass this.ensureMinRequiredFee = ensureMinRequiredFee)
        (§ ass this.feePerKb = feePerKb)
        (§ ass lastConstructed = this)
        (§ call slot.set(this))
    )

    #_private
    #_static
    #_volatile
    (§ field Context lastConstructed)
    #_private
    #_static
    (§ field boolean isStrictMode)
    #_private
    #_static
    #_final
    (§ field ThreadLocal<Context> slot = new ThreadLocal<>())

    ;;;
     ; Returns the current context that is associated with the <b>calling thread</b>.  BitcoinJ is an API that has thread
     ; affinity: much like OpenGL it expects each thread that accesses it to have been configured with a global Context
     ; object.  This method returns that.  Note that to help you develop, this method will <i>also</i> propagate whichever
     ; context was created last onto the current thread, if it's missing.  However it will print an error when doing so
     ; because propagation of contexts is meant to be done manually: this is so two libraries or subsystems that
     ; independently use bitcoinj (or possibly alt coin forks of it) can operate correctly.
     ;
     ; @throws java.lang.IllegalStateException if no context exists at all or if we are in strict mode and there is no context.
     ;;
    #_public
    #_static
    (§ method Context get())
    (ß
        (§ var Context tls = slot.get())
        (§ if (tls == nil))
        (ß
            (§ if (isStrictMode))
            (ß
                (§ call log.error("Thread is missing a bitcoinj context."))
                (§ call log.error("You should use Context.propagate() or a ContextPropagatingThreadFactory."))
                (§ throw new IllegalStateException("missing context"))
            )
            (§ if (lastConstructed == nil))
                (§ throw new IllegalStateException("You must construct a Context object before using bitcoinj!"))
            (§ call slot.set(lastConstructed))
            (§ call log.error("Performing thread fixup: you are accessing bitcoinj via a thread that has not had any context set on it."))
            (§ call log.error("This error has been corrected for, but doing this makes your app less robust."))
            (§ call log.error("You should use Context.propagate() or a ContextPropagatingThreadFactory."))
            (§ call log.error("Please refer to the user guide for more information about this."))
            (§ call log.error("Thread name is {}.", Thread.currentThread().getName()))
            ;; TODO: Actually write the user guide section about this.
            (§ return lastConstructed)
        )

        (§ return tls)
    )

    ;;;
     ; Require that new threads use {@link #propagate(Context)} or {@link org.bitcoinj.utils.ContextPropagatingThreadFactory},
     ; rather than using a heuristic for the desired context.
     ;;
    #_public
    #_static
    (§ method void enableStrictMode())
    (ß
        (§ ass isStrictMode = true)
    )

    ;; A temporary internal shim designed to help us migrate internally in a way that doesn't wreck source compatibility.
    #_public
    #_static
    (§ method Context getOrCreate(NetworkParameters params))
    (ß
        (§ var Context context)
        (§ try)
        (ß
            (§ ass context = get())
        )
        (§ catch (IllegalStateException e))
        (ß
            (§ call log.warn("Implicitly creating context. This is a migration step and this message will eventually go away."))
            (§ ass context = new Context(params))
            (§ return context)
        )
        (§ if (context.getParams() != params))
            (§ throw new IllegalStateException("Context does not match implicit network params: " + context.getParams() + " vs " + params))
        (§ return context)
    )

    ;;;
     ; Sets the given context as the current thread context.  You should use this if you create your own threads that
     ; want to create core BitcoinJ objects.  Generally, if a class can accept a Context in its constructor and might
     ; be used (even indirectly) by a thread, you will want to call this first.  Your task may be simplified by using
     ; a {@link org.bitcoinj.utils.ContextPropagatingThreadFactory}.
     ;;
    #_public
    #_static
    (§ method void propagate(Context context))
    (ß
        (§ call slot.set(Preconditions.checkNotNull(context)))
    )

    ;;;
     ; Returns the {@link TxConfidenceTable} created by this context.  The pool tracks advertised
     ; and downloaded transactions so their confidence can be measured as a proportion of how many peers announced it.
     ; With an un-tampered with internet connection, the more peers announce a transaction the more confidence you can
     ; have that it's really valid.
     ;;
    #_public
    (§ method TxConfidenceTable getConfidenceTable())
    (ß
        (§ return confidenceTable)
    )

    ;;;
     ; Returns the {@link org.bitcoinj.core.NetworkParameters} specified when this context was (auto) created.  The
     ; network parameters defines various hard coded constants for a specific instance of a Bitcoin network, such as
     ; main net, testnet, etc.
     ;;
    #_public
    (§ method NetworkParameters getParams())
    (ß
        (§ return params)
    )

    ;;;
     ; The event horizon is the number of blocks after which various bits of the library consider a transaction to be
     ; so confirmed that it's safe to delete data.  Re-orgs larger than the event horizon will not be correctly
     ; processed, so the default value is high (100).
     ;;
    #_public
    (§ method int getEventHorizon())
    (ß
        (§ return eventHorizon)
    )

    ;;;
     ; The default fee per 1000 bytes of transaction data to pay when completing transactions.  For details, see {@link SendRequest#feePerKb}.
     ;;
    #_public
    (§ method Coin getFeePerKb())
    (ß
        (§ return feePerKb)
    )

    ;;;
     ; Whether to ensure the minimum required fee by default when completing transactions.  For details, see {@link SendRequest#ensureMinRequiredFee}.
     ;;
    #_public
    (§ method boolean isEnsureMinRequiredFee())
    (ß
        (§ return ensureMinRequiredFee)
    )
)

#_(ns org.bitcoinj.core #_"DummySerializer"
    (:import [java.io IOException OutputStream]
             [java.nio BufferUnderflowException ByteBuffer]))

;;;
 ; Dummy serializer used ONLY for objects which do not have network parameters set.
 ;;
(§ class DummySerializer extends MessageSerializer
    #_public
    #_static
    #_final
    (§ field DummySerializer DEFAULT = new DummySerializer())

    #_private
    #_static
    #_final
    (§ field String DEFAULT_EXCEPTION_MESSAGE = "Dummy serializer cannot serialize/deserialize objects as it does not know which network they belong to.")

    #_public
    (§ constructor DummySerializer())
    (ß
    )

    #_override
    #_public
    (§ method Message deserialize(ByteBuffer in))
        (§ throws UnsupportedOperationException)
    (ß
        (§ throw new UnsupportedOperationException(DEFAULT_EXCEPTION_MESSAGE))
    )

    #_override
    #_public
    (§ method BitcoinSerializer.BitcoinPacketHeader deserializeHeader(ByteBuffer in))
        (§ throws UnsupportedOperationException)
    (ß
        (§ throw new UnsupportedOperationException(DEFAULT_EXCEPTION_MESSAGE))
    )

    #_override
    #_public
    (§ method Message deserializePayload(BitcoinSerializer.BitcoinPacketHeader header, ByteBuffer in))
        (§ throws UnsupportedOperationException)
    (ß
        (§ throw new UnsupportedOperationException(DEFAULT_EXCEPTION_MESSAGE))
    )

    #_override
    #_public
    (§ method boolean isParseRetainMode())
    (ß
        (§ return false)
    )

    #_override
    #_public
    (§ method AddressMessage makeAddressMessage(byte[] payloadBytes, int length))
        (§ throws UnsupportedOperationException)
    (ß
        (§ throw new UnsupportedOperationException(DEFAULT_EXCEPTION_MESSAGE))
    )

    #_override
    #_public
    (§ method Message makeAlertMessage(byte[] payloadBytes))
        (§ throws UnsupportedOperationException)
    (ß
        (§ throw new UnsupportedOperationException(DEFAULT_EXCEPTION_MESSAGE))
    )

    #_override
    #_public
    (§ method Block makeBlock(byte[] payloadBytes, int offset, int length))
        (§ throws UnsupportedOperationException)
    (ß
        (§ throw new UnsupportedOperationException(DEFAULT_EXCEPTION_MESSAGE))
    )

    #_override
    #_public
    (§ method Message makeBloomFilter(byte[] payloadBytes))
        (§ throws UnsupportedOperationException)
    (ß
        (§ throw new UnsupportedOperationException(DEFAULT_EXCEPTION_MESSAGE))
    )

    #_override
    #_public
    (§ method FilteredBlock makeFilteredBlock(byte[] payloadBytes))
        (§ throws UnsupportedOperationException)
    (ß
        (§ throw new UnsupportedOperationException(DEFAULT_EXCEPTION_MESSAGE))
    )

    #_override
    #_public
    (§ method InventoryMessage makeInventoryMessage(byte[] payloadBytes, int length))
        (§ throws UnsupportedOperationException)
    (ß
        (§ throw new UnsupportedOperationException(DEFAULT_EXCEPTION_MESSAGE))
    )

    #_override
    #_public
    (§ method Transaction makeTransaction(byte[] payloadBytes, int offset, int length, byte[] hash))
        (§ throws UnsupportedOperationException)
    (ß
        (§ throw new UnsupportedOperationException(DEFAULT_EXCEPTION_MESSAGE))
    )

    #_override
    #_public
    (§ method void seekPastMagicBytes(ByteBuffer in))
        (§ throws BufferUnderflowException)
    (ß
        (§ throw new UnsupportedOperationException(DEFAULT_EXCEPTION_MESSAGE))
    )

    #_override
    #_public
    (§ method void serialize(String name, byte[] message, OutputStream out))
        (§ throws IOException)
    (ß
        (§ throw new UnsupportedOperationException(DEFAULT_EXCEPTION_MESSAGE))
    )

    #_override
    #_public
    (§ method void serialize(Message message, OutputStream out))
        (§ throws IOException)
    (ß
        (§ throw new UnsupportedOperationException(DEFAULT_EXCEPTION_MESSAGE))
    )
)

#_(ns org.bitcoinj.core #_"ECKey"
    (:import [java.io ByteArrayOutputStream IOException]
             [java.math BigInteger]
             [java.nio.charset Charset]
             [java.security SecureRandom SignatureException]
             [java.util Arrays Comparator])
    (:import [com.google.common.annotations VisibleForTesting]
             [com.google.common.base MoreObjects Objects Preconditions]
             [com.google.common.primitives Ints UnsignedBytes]
             [org.slf4j Logger LoggerFactory]
             #_[org.spongycastle.asn1 *]
             [org.spongycastle.asn1.x9 X9ECParameters X9IntegerConverter]
             [org.spongycastle.crypto AsymmetricCipherKeyPair]
             [org.spongycastle.crypto.digests SHA256Digest]
             [org.spongycastle.crypto.ec CustomNamedCurves]
             [org.spongycastle.crypto.generators ECKeyPairGenerator]
             #_[org.spongycastle.crypto.params *]
             [org.spongycastle.crypto.signers ECDSASigner HMacDSAKCalculator]
             [org.spongycastle.math.ec ECAlgorithms ECPoint FixedPointCombMultiplier FixedPointUtil]
             [org.spongycastle.math.ec.custom.sec SecP256K1Curve]
             [org.spongycastle.util.encoders Base64])
  #_(:require #_[org.bitcoinj.crypto *]
             [org.bitcoinj.wallet Protos Wallet]))

;; TODO: Move this class to tracking compression state itself.
;; The Bouncy Castle guys are deprecating their own tracking of the compression state.

;;;
 ; <p>Represents an elliptic curve public and (optionally) private key, usable for digital signatures but not encryption.
 ; Creating a new ECKey with the empty constructor will generate a new random keypair.  Other static methods can be used
 ; when you already have the public or private parts.  If you create a key with only the public part, you can check
 ; signatures but not create them.</p>
 ;
 ; <p>ECKey also provides access to Bitcoin Core compatible text message signing, as accessible via the UI or JSON-RPC.
 ; This is slightly different to signing raw bytes - if you want to sign your own data and it won't be exposed as
 ; text to people, you don't want to use this.  If in doubt, ask on the mailing list.</p>
 ;
 ; <p>The ECDSA algorithm supports <i>key recovery</i> in which a signature plus a couple of discriminator bits can
 ; be reversed to find the public key used to calculate it.  This can be convenient when you have a message and a
 ; signature and want to find out who signed it, rather than requiring the user to provide the expected identity.</p>
 ;
 ; <p>This class supports a variety of serialization forms.  The methods that accept/return byte arrays serialize
 ; private keys as raw byte arrays and public keys using the SEC standard byte encoding for public keys.  Signatures
 ; are encoded using ASN.1/DER inside the Bitcoin protocol.</p>
 ;
 ; <p>A key can be <i>compressed</i> or <i>uncompressed</i>.  This refers to whether the public key is represented
 ; when encoded into bytes as an (x, y) coordinate on the elliptic curve, or whether it's represented as just an X
 ; co-ordinate and an extra byte that carries a sign bit.  With the latter form the Y coordinate can be calculated
 ; dynamically, however, <b>because the binary serialization is different the address of a key changes if its
 ; compression status is changed</b>.  If you deviate from the defaults it's important to understand this: money sent
 ; to a compressed version of the key will have a different address to the same key in uncompressed form.  Whether
 ; a public key is compressed or not is recorded in the SEC binary serialisation format, and preserved in a flag in
 ; this class so round-tripping preserves state.  Unless you're working with old software or doing unusual things, you
 ; can usually ignore the compressed/uncompressed distinction.</p>
 ;;
#_public
(§ class ECKey implements EncryptableItem
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(ECKey.class))

    ;;; Sorts oldest keys first, newest last. ;;
    #_public
    #_static
    #_final
    (§ field Comparator<ECKey> AGE_COMPARATOR = new Comparator<ECKey>()
        (ß
            #_override
            #_public
            (§ method int compare(ECKey k1, ECKey k2))
            (ß
                (§ if (k1.creationTimeSeconds == k2.creationTimeSeconds))
                    (§ return 0)

                (§ return (k1.creationTimeSeconds < k2.creationTimeSeconds) ? -1 :else 1)
            )
        ))

    ;;; Compares pub key bytes using {@link com.google.common.primitives.UnsignedBytes#lexicographicalComparator()}. ;;
    #_public
    #_static
    #_final
    (§ field Comparator<ECKey> PUBKEY_COMPARATOR = new Comparator<ECKey>()
        (ß
            #_private
            (§ field Comparator<byte[]> comparator = UnsignedBytes.lexicographicalComparator())

            #_override
            #_public
            (§ method int compare(ECKey k1, ECKey k2))
            (ß
                (§ return comparator.compare(k1.getPubKey(), k2.getPubKey()))
            )
        ))

    ;; The parameters of the secp256k1 curve that Bitcoin uses.
    #_private
    #_static
    #_final
    (§ field X9ECParameters CURVE_PARAMS = CustomNamedCurves.getByName("secp256k1"))

    ;;; The parameters of the secp256k1 curve that Bitcoin uses. ;;
    #_public
    #_static
    #_final
    (§ field ECDomainParameters CURVE)

    ;;;
     ; Equal to CURVE.getN().shiftRight(1), used for canonicalising the S value of a signature.
     ; If you aren't sure what this is about, you can ignore it.
     ;;
    #_public
    #_static
    #_final
    (§ field BigInteger HALF_CURVE_ORDER)

    #_private
    #_static
    #_final
    (§ field SecureRandom secureRandom)

    #_static
    (ß
        ;; Init proper random number generator, as some old Android installations have bugs that make it unsecure.
        (§ if (Utils.isAndroidRuntime()))
            (§ call new LinuxSecureRandom())

        ;; Tell Bouncy Castle to precompute data that's needed during secp256k1 calculations.  Increasing the width
        ;; number makes calculations faster, but at a cost of extra memory usage and with decreasing returns.  12 was
        ;; picked after consulting with the BC team.
        (§ call FixedPointUtil.precompute(CURVE_PARAMS.getG(), 12))
        (§ ass CURVE = new ECDomainParameters(CURVE_PARAMS.getCurve(), CURVE_PARAMS.getG(), CURVE_PARAMS.getN(), CURVE_PARAMS.getH()))
        (§ ass HALF_CURVE_ORDER = CURVE_PARAMS.getN().shiftRight(1))
        (§ ass secureRandom = new SecureRandom())
    )

    ;; The two parts of the key.  If "priv" is set, "pub" can always be calculated.  If "pub" is set but not "priv", we
    ;; can only verify signatures not make them.
    #_protected
    #_final
    (§ field BigInteger priv) ;; A field element.
    #_protected
    #_final
    (§ field LazyECPoint pub)

    ;; Creation time of the key in seconds since the epoch, or zero if the key was deserialized from a version that did
    ;; not have this field.
    #_protected
    (§ field long creationTimeSeconds)

    #_protected
    (§ field KeyCrypter keyCrypter)
    #_protected
    (§ field EncryptedData encryptedPrivateKey)

    #_private
    (§ field byte[] pubKeyHash)

    ;;;
     ; Generates an entirely new keypair.  Point compression is used so the resulting public key will be 33 bytes
     ; (32 for the co-ordinate and 1 byte to represent the y bit).
     ;;
    #_public
    (§ constructor ECKey())
    (ß
        (§ this (secureRandom))
    )

    ;;;
     ; Generates an entirely new keypair with the given {@link SecureRandom} object.  Point compression is used so the
     ; resulting public key will be 33 bytes (32 for the co-ordinate and 1 byte to represent the y bit).
     ;;
    #_public
    (§ constructor ECKey(SecureRandom secureRandom))
    (ß
        (§ var ECKeyPairGenerator generator = new ECKeyPairGenerator())
        (§ var ECKeyGenerationParameters keygenParams = new ECKeyGenerationParameters(CURVE, secureRandom))
        (§ call generator.init(keygenParams))
        (§ var AsymmetricCipherKeyPair keypair = generator.generateKeyPair())
        (§ var ECPrivateKeyParameters privParams = (ECPrivateKeyParameters)keypair.getPrivate())
        (§ var ECPublicKeyParameters pubParams = (ECPublicKeyParameters)keypair.getPublic())
        (§ ass priv = privParams.getD())
        (§ ass pub = new LazyECPoint(CURVE.getCurve(), pubParams.getQ().getEncoded(true)))
        (§ ass creationTimeSeconds = Utils.currentTimeSeconds())
    )

    #_protected
    (§ constructor ECKey(#_nilable BigInteger priv, ECPoint pub))
    (ß
        (§ this (priv, new LazyECPoint(Preconditions.checkNotNull(pub))))
    )

    #_protected
    (§ constructor ECKey(#_nilable BigInteger priv, LazyECPoint pub))
    (ß
        (§ if (priv != nil))
        (ß
            (§ call Preconditions.checkArgument(priv.bitLength() <= (32 << 3), "private key exceeds 32 bytes: {} bits", priv.bitLength()))
            ;; Try and catch buggy callers or bad key imports, etc.  Zero and one are special because these are often
            ;; used as sentinel values and because scripting languages have a habit of auto-casting true and false to
            ;; 1 and 0 or vice-versa.  Type confusion bugs could therefore result in private keys with these values.
            (§ call Preconditions.checkArgument(!priv.equals(BigInteger.ZERO)))
            (§ call Preconditions.checkArgument(!priv.equals(BigInteger.ONE)))
        )
        (§ ass this.priv = priv)
        (§ ass this.pub = Preconditions.checkNotNull(pub))
    )

    ;;;
     ; Utility for compressing an elliptic curve point.  Returns the same point if it's already compressed.
     ; See the ECKey class docs for a discussion of point compression.
     ;;
    #_public
    #_static
    (§ method ECPoint compressPoint(ECPoint point))
    (ß
        (§ return getPointWithCompression(point, true))
    )

    #_public
    #_static
    (§ method LazyECPoint compressPoint(LazyECPoint point))
    (ß
        (§ return point.isCompressed() ? point :else new LazyECPoint(compressPoint(point.get())))
    )

    ;;;
     ; Utility for decompressing an elliptic curve point.  Returns the same point if it's already compressed.
     ; See the ECKey class docs for a discussion of point compression.
     ;;
    #_public
    #_static
    (§ method ECPoint decompressPoint(ECPoint point))
    (ß
        (§ return getPointWithCompression(point, false))
    )

    #_public
    #_static
    (§ method LazyECPoint decompressPoint(LazyECPoint point))
    (ß
        (§ return !point.isCompressed() ? point :else new LazyECPoint(decompressPoint(point.get())))
    )

    #_private
    #_static
    (§ method ECPoint getPointWithCompression(ECPoint point, boolean compressed))
    (ß
        (§ if (point.isCompressed() == compressed))
            (§ return point)

        (§ ass point = point.normalize())
        (§ var BigInteger x = point.getAffineXCoord().toBigInteger())
        (§ var BigInteger y = point.getAffineYCoord().toBigInteger())
        (§ return CURVE.getCurve().createPoint(x, y, compressed))
    )

    ;;;
     ; Construct an ECKey from an ASN.1 encoded private key.  These are produced by OpenSSL and stored by Bitcoin
     ; Core in its wallet.  Note that this is slow because it requires an EC point multiply.
     ;;
    #_public
    #_static
    (§ method ECKey fromASN1(byte[] asn1privkey))
    (ß
        (§ return extractKeyFromASN1(asn1privkey))
    )

    ;;;
     ; Creates an ECKey given the private key only.  The public key is calculated from it (this is slow).  The resulting
     ; public key is compressed.
     ;;
    #_public
    #_static
    (§ method ECKey fromPrivate(BigInteger privKey))
    (ß
        (§ return fromPrivate(privKey, true))
    )

    ;;;
     ; Creates an ECKey given the private key only.  The public key is calculated from it (this is slow), either
     ; compressed or not.
     ;;
    #_public
    #_static
    (§ method ECKey fromPrivate(BigInteger privKey, boolean compressed))
    (ß
        (§ var ECPoint point = publicPointFromPrivate(privKey))
        (§ return new ECKey(privKey, getPointWithCompression(point, compressed)))
    )

    ;;;
     ; Creates an ECKey given the private key only.  The public key is calculated from it (this is slow).  The resulting
     ; public key is compressed.
     ;;
    #_public
    #_static
    (§ method ECKey fromPrivate(byte[] privKeyBytes))
    (ß
        (§ return fromPrivate(new BigInteger(1, privKeyBytes)))
    )

    ;;;
     ; Creates an ECKey given the private key only.  The public key is calculated from it (this is slow), either
     ; compressed or not.
     ;;
    #_public
    #_static
    (§ method ECKey fromPrivate(byte[] privKeyBytes, boolean compressed))
    (ß
        (§ return fromPrivate(new BigInteger(1, privKeyBytes), compressed))
    )

    ;;;
     ; Creates an ECKey that simply trusts the caller to ensure that point is really the result of multiplying the
     ; generator point by the private key.  This is used to speed things up when you know you have the right values
     ; already.  The compression state of pub will be preserved.
     ;;
    #_public
    #_static
    (§ method ECKey fromPrivateAndPrecalculatedPublic(BigInteger priv, ECPoint pub))
    (ß
        (§ return new ECKey(priv, pub))
    )

    ;;;
     ; Creates an ECKey that simply trusts the caller to ensure that point is really the result of multiplying the
     ; generator point by the private key.  This is used to speed things up when you know you have the right values
     ; already.  The compression state of the point will be preserved.
     ;;
    #_public
    #_static
    (§ method ECKey fromPrivateAndPrecalculatedPublic(byte[] priv, byte[] pub))
    (ß
        (§ call Preconditions.checkNotNull(priv))
        (§ call Preconditions.checkNotNull(pub))
        (§ return new ECKey(new BigInteger(1, priv), CURVE.getCurve().decodePoint(pub)))
    )

    ;;;
     ; Creates an ECKey that cannot be used for signing, only verifying signatures, from the given point.
     ; The compression state of pub will be preserved.
     ;;
    #_public
    #_static
    (§ method ECKey fromPublicOnly(ECPoint pub))
    (ß
        (§ return new ECKey(nil, pub))
    )

    ;;;
     ; Creates an ECKey that cannot be used for signing, only verifying signatures, from the given encoded point.
     ; The compression state of pub will be preserved.
     ;;
    #_public
    #_static
    (§ method ECKey fromPublicOnly(byte[] pub))
    (ß
        (§ return new ECKey(nil, CURVE.getCurve().decodePoint(pub)))
    )

    ;;;
     ; Returns a copy of this key, but with the public point represented in uncompressed form.  Normally you would
     ; never need this: it's for specialised scenarios or when backwards compatibility in encoded form is necessary.
     ;;
    #_public
    (§ method ECKey decompress())
    (ß
        (§ return pub.isCompressed() ? new ECKey(priv, decompressPoint(pub.get())) :else this)
    )

    ;;;
     ; Creates an ECKey given only the private key bytes.  This is the same as using the BigInteger constructor, but
     ; is more convenient if you are importing a key from elsewhere.  The public key will be automatically derived
     ; from the private key.
     ;;
    #_deprecated
    #_public
    (§ constructor ECKey(#_nilable byte[] privKeyBytes, #_nilable byte[] pubKey))
    (ß
        (§ this ((privKeyBytes != nil) ? new BigInteger(1, privKeyBytes) :else nil, pubKey))
    )

    ;;;
     ; Create a new ECKey with an encrypted private key, a public key and a KeyCrypter.
     ;
     ; @param encryptedPrivateKey The encrypted private key.
     ; @param pubKey The public key.
     ; @param keyCrypter The KeyCrypter that will be used, with an AES key, to encrypt and decrypt the private key.
     ;;
    #_deprecated
    #_public
    (§ constructor ECKey(EncryptedData encryptedPrivateKey, byte[] pubKey, KeyCrypter keyCrypter))
    (ß
        (§ this ((byte[])nil, pubKey))

        (§ ass this.keyCrypter = Preconditions.checkNotNull(keyCrypter))
        (§ ass this.encryptedPrivateKey = encryptedPrivateKey)
    )

    ;;;
     ; Constructs a key that has an encrypted private component.  The given object wraps encrypted bytes and an
     ; initialization vector.  Note that the key will not be decrypted during this call: the returned ECKey is
     ; unusable for signing unless a decryption key is supplied.
     ;;
    #_public
    #_static
    (§ method ECKey fromEncrypted(EncryptedData encryptedPrivateKey, KeyCrypter crypter, byte[] pubKey))
    (ß
        (§ var ECKey key = fromPublicOnly(pubKey))
        (§ ass key.encryptedPrivateKey = Preconditions.checkNotNull(encryptedPrivateKey))
        (§ ass key.keyCrypter = Preconditions.checkNotNull(crypter))
        (§ return key)
    )

    ;;;
     ; Creates an ECKey given either the private key only, the public key only, or both.  If only the private key
     ; is supplied, the public key will be calculated from it (this is slow).  If both are supplied, it's assumed
     ; the public key already correctly matches the private key.  If only the public key is supplied, this ECKey
     ; cannot be used for signing.
     ; @param compressed If set to true and pubKey is null, the derived public key will be in compressed form.
     ;;
    #_deprecated
    #_public
    (§ constructor ECKey(#_nilable BigInteger privKey, #_nilable byte[] pubKey, boolean compressed))
    (ß
        (§ if (privKey == nil && pubKey == nil))
            (§ throw new IllegalArgumentException("ECKey requires at least private or public key"))
        (§ ass this.priv = privKey)
        (§ if (pubKey == nil))
        (ß
            ;; Derive public from private.
            (§ var ECPoint point = publicPointFromPrivate(privKey))
            (§ ass point = getPointWithCompression(point, compressed))
            (§ ass this.pub = new LazyECPoint(point))
        )
        (§ else)
        (ß
            ;; We expect the pubkey to be in regular encoded form, just as a BigInteger.
            ;; Therefore the first byte is a special marker byte.
            ;; TODO: This is probably not a useful API and may be confusing.
            (§ ass this.pub = new LazyECPoint(CURVE.getCurve(), pubKey))
        )
    )

    ;;;
     ; Creates an ECKey given either the private key only, the public key only, or both.  If only the private key
     ; is supplied, the public key will be calculated from it (this is slow).  If both are supplied, it's assumed
     ; the public key already correctly matches the public key.  If only the public key is supplied, this ECKey cannot
     ; be used for signing.
     ;;
    #_deprecated
    #_private
    (§ constructor ECKey(#_nilable BigInteger privKey, #_nilable byte[] pubKey))
    (ß
        (§ this (privKey, pubKey, false))
    )

    ;;;
     ; Returns true if this key doesn't have unencrypted access to private key bytes.  This may be because
     ; it was never given any private key bytes to begin with (a watching key), or because the key is encrypted.
     ; You can use {@link #isEncrypted()} to tell the cases apart.
     ;;
    #_public
    (§ method boolean isPubKeyOnly())
    (ß
        (§ return (priv == nil))
    )

    ;;;
     ; Returns true if this key has unencrypted access to private key bytes.
     ; Does the opposite of {@link #isPubKeyOnly()}.
     ;;
    #_public
    (§ method boolean hasPrivKey())
    (ß
        (§ return (priv != nil))
    )

    ;;; Returns true if this key is watch only, meaning it has a public key but no private key. ;;
    #_public
    (§ method boolean isWatching())
    (ß
        (§ return (isPubKeyOnly() && !isEncrypted()))
    )

    ;;;
     ; Output this ECKey as an ASN.1 encoded private key, as understood by OpenSSL or used by Bitcoin Core
     ; in its wallet storage format.
     ; @throws org.bitcoinj.core.ECKey.MissingPrivateKeyException if the private key is missing or encrypted.
     ;;
    #_public
    (§ method byte[] toASN1())
    (ß
        (§ try)
        (ß
            (§ var byte[] privKeyBytes = getPrivKeyBytes())
            (§ var ByteArrayOutputStream baos = new ByteArrayOutputStream(400))

            ;; ASN1_SEQUENCE(EC_PRIVATEKEY) = {
            ;;   ASN1_SIMPLE(EC_PRIVATEKEY, version, LONG),
            ;;   ASN1_SIMPLE(EC_PRIVATEKEY, privateKey, ASN1_OCTET_STRING),
            ;;   ASN1_EXP_OPT(EC_PRIVATEKEY, parameters, ECPKPARAMETERS, 0),
            ;;   ASN1_EXP_OPT(EC_PRIVATEKEY, publicKey, ASN1_BIT_STRING, 1)
            ;; } ASN1_SEQUENCE_END(EC_PRIVATEKEY)
            (§ var DERSequenceGenerator seq = new DERSequenceGenerator(baos))
            (§ call seq.addObject(new ASN1Integer(1))) ;; version
            (§ call seq.addObject(new DEROctetString(privKeyBytes)))
            (§ call seq.addObject(new DERTaggedObject(0, CURVE_PARAMS.toASN1Primitive())))
            (§ call seq.addObject(new DERTaggedObject(1, new DERBitString(getPubKey()))))
            (§ call seq.close())
            (§ return baos.toByteArray())
        )
        (§ catch (IOException e))
        (ß
            (§ throw new RuntimeException(e)) ;; Cannot happen, writing to memory stream.
        )
    )

    ;;;
     ; Returns public key bytes from the given private key.  To convert a byte array into a BigInteger, use <tt>new BigInteger(1, bytes)</tt>.
     ;;
    #_public
    #_static
    (§ method byte[] publicKeyFromPrivate(BigInteger privKey, boolean compressed))
    (ß
        (§ return publicPointFromPrivate(privKey).getEncoded(compressed))
    )

    ;;;
     ; Returns public key point from the given private key.  To convert a byte array into a BigInteger, use <tt>new BigInteger(1, bytes)</tt>.
     ;;
    #_public
    #_static
    (§ method ECPoint publicPointFromPrivate(BigInteger privKey))
    (ß
        ;;
         ; TODO: FixedPointCombMultiplier currently doesn't support scalars longer than the group order,
         ; but that could change in future versions.
         ;;
        (§ if (CURVE.getN().bitLength() < privKey.bitLength()))
            (§ ass privKey = privKey.mod(CURVE.getN()))

        (§ return new FixedPointCombMultiplier().multiply(CURVE.getG(), privKey))
    )

    ;;; Gets the hash160 form of the public key (as seen in addresses). ;;
    #_public
    (§ method byte[] getPubKeyHash())
    (ß
        (§ if (pubKeyHash == nil))
            (§ ass pubKeyHash = Utils.sha256hash160(this.pub.getEncoded()))

        (§ return pubKeyHash)
    )

    ;;;
     ; Gets the raw public key value.  This appears in transaction scriptSigs.  Note that this is <b>not</b> the same
     ; as the pubKeyHash/address.
     ;;
    #_public
    (§ method byte[] getPubKey())
    (ß
        (§ return pub.getEncoded())
    )

    ;;; Gets the public key in the form of an elliptic curve point object from Bouncy Castle. ;;
    #_public
    (§ method ECPoint getPubKeyPoint())
    (ß
        (§ return pub.get())
    )

    ;;;
     ; Gets the private key in the form of an integer field element.  The public key is derived by performing EC
     ; point addition this number of times (i.e. point multiplying).
     ;
     ; @throws java.lang.IllegalStateException if the private key bytes are not available.
     ;;
    #_public
    (§ method BigInteger getPrivKey())
    (ß
        (§ if (priv == nil))
            (§ throw new MissingPrivateKeyException())

        (§ return priv)
    )

    ;;;
     ; Returns whether this key is using the compressed form or not.  Compressed pubkeys are only 33 bytes, not 64.
     ;;
    #_public
    (§ method boolean isCompressed())
    (ß
        (§ return pub.isCompressed())
    )

    ;;;
     ; Returns the address that corresponds to the public part of this ECKey.  Note that an address is derived from
     ; the RIPEMD-160 hash of the public key and is not the public key itself (which is too large to be convenient).
     ;;
    #_public
    (§ method Address toAddress(NetworkParameters params))
    (ß
        (§ return new Address(params, getPubKeyHash()))
    )

    ;;;
     ; Groups the two components that make up a signature, and provides a way to encode to DER form, which is
     ; how ECDSA signatures are represented when embedded in other data structures in the Bitcoin protocol.
     ; The raw components can be useful for doing further EC maths on them.
     ;;
    #_public
    #_static
    (§ class ECDSASignature
        ;;; The two components of the signature. ;;
        #_public
        #_final
        (§ field BigInteger r, s)

        ;;;
         ; Constructs a signature with the given components.  Does NOT automatically canonicalise the signature.
         ;;
        #_public
        (§ constructor ECDSASignature(BigInteger r, BigInteger s))
        (ß
            (§ ass this.r = r)
            (§ ass this.s = s)
        )

        ;;;
         ; Returns true if the S component is "low", that means it is below {@link ECKey#HALF_CURVE_ORDER}.  See
         ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0062.mediawiki#Low_S_values_in_signatures">BIP62</a>.
         ;;
        #_public
        (§ method boolean isCanonical())
        (ß
            (§ return (s.compareTo(HALF_CURVE_ORDER) <= 0))
        )

        ;;;
         ; Will automatically adjust the S component to be less than or equal to half the curve order, if necessary.
         ; This is required because for every signature (r,s) the signature (r, -s (mod N)) is a valid signature of
         ; the same message.  However, we dislike the ability to modify the bits of a Bitcoin transaction after it's
         ; been signed, as that violates various assumed invariants.  Thus in future only one of those forms will be
         ; considered legal and the other will be banned.
         ;;
        #_public
        (§ method ECDSASignature toCanonicalised())
        (ß
            (§ if (!isCanonical()))
            (ß
                ;; The order of the curve is the number of valid points that exist on that curve.  If S is in the upper
                ;; half of the number of valid points, then bring it back to the lower half.  Otherwise, imagine that
                ;;    N = 10
                ;;    s = 8, so (-8 % 10 == 2) thus both (r, 8) and (r, 2) are valid solutions.
                ;;    10 - 8 == 2, giving us always the latter solution, which is canonical.
                (§ return new ECDSASignature(r, CURVE.getN().subtract(s)))
            )

            (§ return this)
        )

        ;;;
         ; DER is an international standard for serializing data structures which is widely used in cryptography.
         ; It's somewhat like protocol buffers but less convenient.  This method returns a standard DER encoding
         ; of the signature, as recognized by OpenSSL and other libraries.
         ;;
        #_public
        (§ method byte[] encodeToDER())
        (ß
            (§ try)
            (ß
                (§ return derByteStream().toByteArray())
            )
            (§ catch (IOException e))
            (ß
                (§ throw new RuntimeException(e)) ;; Cannot happen.
            )
        )

        #_public
        #_static
        (§ method ECDSASignature decodeFromDER(byte[] bytes))
            (§ throws IllegalArgumentException)
        (ß
            (§ var ASN1InputStream decoder = nil)
            (§ try)
            (ß
                (§ ass decoder = new ASN1InputStream(bytes))
                (§ var DLSequence seq = (DLSequence)decoder.readObject())
                (§ if (seq == nil))
                    (§ throw new IllegalArgumentException("Reached past end of ASN.1 stream."))

                (§ var ASN1Integer r, s)
                (§ try)
                (ß
                    (§ ass r = (ASN1Integer)seq.getObjectAt(0))
                    (§ ass s = (ASN1Integer)seq.getObjectAt(1))
                )
                (§ catch (ClassCastException e))
                (ß
                    (§ throw new IllegalArgumentException(e))
                )
                ;; OpenSSL deviates from the DER spec by interpreting these values as unsigned, though they should not be.
                ;; Thus, we always use the positive versions.  See http://r6.ca/blog/20111119T211504Z.html
                (§ return new ECDSASignature(r.getPositiveValue(), s.getPositiveValue()))
            )
            (§ catch (IOException e))
            (ß
                (§ throw new IllegalArgumentException(e))
            )
            (§ finally)
            (ß
                (§ if (decoder != nil))
                    (§ try)
                    (ß
                        (§ call decoder.close())
                    )
                    (§ catch (IOException _))
                    (ß
                    )
            )
        )

        #_protected
        (§ method ByteArrayOutputStream derByteStream())
            (§ throws IOException)
        (ß
            ;; Usually 70-72 bytes.
            (§ var ByteArrayOutputStream bos = new ByteArrayOutputStream(72))
            (§ var DERSequenceGenerator seq = new DERSequenceGenerator(bos))
            (§ call seq.addObject(new ASN1Integer(r)))
            (§ call seq.addObject(new ASN1Integer(s)))
            (§ call seq.close())
            (§ return bos)
        )

        #_override
        #_public
        (§ method boolean equals(Object o))
        (ß
            (§ if (this == o))
                (§ return true)
            (§ if (o == nil || getClass() != o.getClass()))
                (§ return false)
            (§ var ECDSASignature other = (ECDSASignature)o)
            (§ return (r.equals(other.r) && s.equals(other.s)))
        )

        #_override
        #_public
        (§ method int hashCode())
        (ß
            (§ return Objects.hashCode(r, s))
        )
    )

    ;;;
     ; Signs the given hash and returns the R and S components as BigIntegers.  In the Bitcoin protocol, they are
     ; usually encoded using ASN.1 format, so you want {@link org.bitcoinj.core.ECKey.ECDSASignature#toASN1()}
     ; instead.  However sometimes the independent components can be useful, for instance, if you're going to do
     ; further EC maths on them.
     ; @throws KeyCrypterException if this ECKey doesn't have a private part.
     ;;
    #_public
    (§ method ECDSASignature sign(Sha256Hash input))
        (§ throws KeyCrypterException)
    (ß
        (§ return sign(input, nil))
    )

    ;;;
     ; If this global variable is set to true, sign() creates a dummy signature and verify() always returns true.
     ; This is intended to help accelerate unit tests that do a lot of signing/verifying, which in the debugger
     ; can be painfully slow.
     ;;
    #_testing
    #_public
    #_static
    (§ field boolean FAKE_SIGNATURES = false)

    ;;;
     ; Signs the given hash and returns the R and S components as BigIntegers.  In the Bitcoin protocol, they are
     ; usually encoded using DER format, so you want {@link org.bitcoinj.core.ECKey.ECDSASignature#encodeToDER()}
     ; instead.  However sometimes the independent components can be useful, for instance, if you're doing to do further
     ; EC maths on them.
     ;
     ; @param aesKey The AES key to use for decryption of the private key.  If null, then no decryption is required.
     ; @throws KeyCrypterException if there's something wrong with aesKey.
     ; @throws ECKey.MissingPrivateKeyException if this key cannot sign because it's pubkey only.
     ;;
    #_public
    (§ method ECDSASignature sign(Sha256Hash input, #_nilable KeyParameter aesKey))
        (§ throws KeyCrypterException)
    (ß
        (§ var KeyCrypter crypter = getKeyCrypter())
        (§ if (crypter != nil))
        (ß
            (§ if (aesKey == nil))
                (§ throw new KeyIsEncryptedException())
            (§ return decrypt(aesKey).sign(input))
        )
        (§ else)
        (ß
            ;; No decryption of private key required.
            (§ if (priv == nil))
                (§ throw new MissingPrivateKeyException())
        )
        (§ return doSign(input, priv))
    )

    #_protected
    (§ method ECDSASignature doSign(Sha256Hash input, BigInteger privateKeyForSigning))
    (ß
        (§ if (FAKE_SIGNATURES))
            (§ return TransactionSignature.dummy())

        (§ call Preconditions.checkNotNull(privateKeyForSigning))

        (§ var ECDSASigner signer = new ECDSASigner(new HMacDSAKCalculator(new SHA256Digest())))
        (§ var ECPrivateKeyParameters privKey = new ECPrivateKeyParameters(privateKeyForSigning, CURVE))
        (§ call signer.init(true, privKey))
        (§ var BigInteger[] components = signer.generateSignature(input.getBytes()))
        (§ return new ECDSASignature(components[0], components[1]).toCanonicalised())
    )

    ;;;
     ; <p>Verifies the given ECDSA signature against the message bytes using the public key bytes.</p>
     ;
     ; <p>When using native ECDSA verification, data must be 32 bytes, and no element may be
     ; larger than 520 bytes.</p>
     ;
     ; @param data      Hash of the data to verify.
     ; @param signature ASN.1 encoded signature.
     ; @param pub       The public key bytes to use.
     ;;
    #_public
    #_static
    (§ method boolean verify(byte[] data, ECDSASignature signature, byte[] pub))
    (ß
        (§ if (FAKE_SIGNATURES))
            (§ return true)

        (§ var ECDSASigner signer = new ECDSASigner())
        (§ var ECPublicKeyParameters params = new ECPublicKeyParameters(CURVE.getCurve().decodePoint(pub), CURVE))
        (§ call signer.init(false, params))
        (§ try)
        (ß
            (§ return signer.verifySignature(data, signature.r, signature.s))
        )
        (§ catch (NullPointerException e))
        (ß
            ;; Bouncy Castle contains a bug that can cause NPEs given specially crafted signatures.  Those signatures
            ;; are inherently invalid/attack sigs so we just fail them here rather than crash the thread.
            (§ call log.error("Caught NPE inside bouncy castle", e))
            (§ return false)
        )
    )

    ;;;
     ; Verifies the given ASN.1 encoded ECDSA signature against a hash using the public key.
     ;
     ; @param data      Hash of the data to verify.
     ; @param signature ASN.1 encoded signature.
     ; @param pub       The public key bytes to use.
     ;;
    #_public
    #_static
    (§ method boolean verify(byte[] data, byte[] signature, byte[] pub))
    (ß
        (§ return verify(data, ECDSASignature.decodeFromDER(signature), pub))
    )

    ;;;
     ; Verifies the given ASN.1 encoded ECDSA signature against a hash using the public key.
     ;
     ; @param hash      Hash of the data to verify.
     ; @param signature ASN.1 encoded signature.
     ;;
    #_public
    (§ method boolean verify(byte[] hash, byte[] signature))
    (ß
        (§ return ECKey.verify(hash, signature, getPubKey()))
    )

    ;;;
     ; Verifies the given R/S pair (signature) against a hash using the public key.
     ;;
    #_public
    (§ method boolean verify(Sha256Hash sigHash, ECDSASignature signature))
    (ß
        (§ return ECKey.verify(sigHash.getBytes(), signature, getPubKey()))
    )

    ;;;
     ; Verifies the given ASN.1 encoded ECDSA signature against a hash using the public key, and throws an exception
     ; if the signature doesn't match.
     ; @throws java.security.SignatureException if the signature does not match.
     ;;
    #_public
    (§ method void verifyOrThrow(byte[] hash, byte[] signature))
        (§ throws SignatureException)
    (ß
        (§ if (!verify(hash, signature)))
            (§ throw new SignatureException())
    )

    ;;;
     ; Verifies the given R/S pair (signature) against a hash using the public key, and throws an exception
     ; if the signature doesn't match.
     ; @throws java.security.SignatureException if the signature does not match.
     ;;
    #_public
    (§ method void verifyOrThrow(Sha256Hash sigHash, ECDSASignature signature))
        (§ throws SignatureException)
    (ß
        (§ if (!ECKey.verify(sigHash.getBytes(), signature, getPubKey())))
            (§ throw new SignatureException())
    )

    ;;;
     ; Returns true if the given pubkey is canonical, i.e. the correct length taking into account compression.
     ;;
    #_public
    #_static
    (§ method boolean isPubKeyCanonical(byte[] pubkey))
    (ß
        (§ if (pubkey.length < 33))
            (§ return false)
        ;; Uncompressed pubkey.
        (§ if (pubkey[0] == 0x04))
            (§ return (pubkey.length == 65))
        ;; Compressed pubkey.
        (§ if (pubkey[0] == 0x02 || pubkey[0] == 0x03))
            (§ return (pubkey.length == 33))
        (§ return false)
    )

    #_private
    #_static
    (§ method ECKey extractKeyFromASN1(byte[] asn1privkey))
    (ß
        ;; To understand this code, see the definition of the ASN.1 format for EC private keys in the OpenSSL source
        ;; code in ec_asn1.c:
        ;;
        ;; ASN1_SEQUENCE(EC_PRIVATEKEY) = {
        ;;   ASN1_SIMPLE(EC_PRIVATEKEY, version, LONG),
        ;;   ASN1_SIMPLE(EC_PRIVATEKEY, privateKey, ASN1_OCTET_STRING),
        ;;   ASN1_EXP_OPT(EC_PRIVATEKEY, parameters, ECPKPARAMETERS, 0),
        ;;   ASN1_EXP_OPT(EC_PRIVATEKEY, publicKey, ASN1_BIT_STRING, 1)
        ;; } ASN1_SEQUENCE_END(EC_PRIVATEKEY)
        (§ try)
        (ß
            (§ var ASN1InputStream decoder = new ASN1InputStream(asn1privkey))
            (§ var DLSequence seq = (DLSequence)decoder.readObject())
            (§ call Preconditions.checkArgument(decoder.readObject() == nil, "Input contains extra bytes"))
            (§ call decoder.close())

            (§ call Preconditions.checkArgument(seq.size() == 4, "Input does not appear to be an ASN.1 OpenSSL EC private key"))

            (§ call Preconditions.checkArgument(((ASN1Integer)seq.getObjectAt(0)).getValue().equals(BigInteger.ONE), "Input is of wrong version"))

            (§ var byte[] privbits = ((ASN1OctetString)seq.getObjectAt(1)).getOctets())
            (§ var BigInteger privkey = new BigInteger(1, privbits))

            (§ var ASN1TaggedObject pubkey = (ASN1TaggedObject)seq.getObjectAt(3))
            (§ call Preconditions.checkArgument(pubkey.getTagNo() == 1, "Input has 'publicKey' with bad tag number"))
            (§ var byte[] pubbits = ((DERBitString)pubkey.getObject()).getBytes())
            (§ call Preconditions.checkArgument(pubbits.length == 33 || pubbits.length == 65, "Input has 'publicKey' with invalid length"))
            (§ var int encoding = pubbits[0] & 0xff)
            ;; Only allow compressed(2,3) and uncompressed(4), not infinity(0) or hybrid(6,7).
            (§ call Preconditions.checkArgument(2 <= encoding && encoding <= 4, "Input has 'publicKey' with invalid encoding"))

            ;; Now sanity check to ensure the pubkey bytes match the privkey.
            (§ var boolean compressed = (pubbits.length == 33))
            (§ var ECKey key = new ECKey(privkey, nil, compressed))
            (§ if (!Arrays.equals(key.getPubKey(), pubbits)))
                (§ throw new IllegalArgumentException("Public key in ASN.1 structure does not match private key."))
            (§ return key)
        )
        (§ catch (IOException e))
        (ß
            (§ throw new RuntimeException(e)) ;; Cannot happen, reading from memory stream.
        )
    )

    ;;;
     ; Signs a text message using the standard Bitcoin messaging signing format and returns the signature as a base64
     ; encoded string.
     ;
     ; @throws IllegalStateException if this ECKey does not have the private part.
     ; @throws KeyCrypterException if this ECKey is encrypted and no AESKey is provided or it does not decrypt the ECKey.
     ;;
    #_public
    (§ method String signMessage(String message))
        (§ throws KeyCrypterException)
    (ß
        (§ return signMessage(message, nil))
    )

    ;;;
     ; Signs a text message using the standard Bitcoin messaging signing format and returns the signature as a base64
     ; encoded string.
     ;
     ; @throws IllegalStateException if this ECKey does not have the private part.
     ; @throws KeyCrypterException if this ECKey is encrypted and no AESKey is provided or it does not decrypt the ECKey.
     ;;
    #_public
    (§ method String signMessage(String message, #_nilable KeyParameter aesKey))
        (§ throws KeyCrypterException)
    (ß
        (§ var byte[] data = Utils.formatMessageForSigning(message))
        (§ var Sha256Hash hash = Sha256Hash.twiceOf(data))
        (§ var ECDSASignature sig = sign(hash, aesKey))
        ;; Now we have to work backwards to figure out the recId needed to recover the signature.
        (§ var int recId = -1)
        (§ for (int i = 0 :for i < 4 :for i = i + 1))
        (ß
            (§ var ECKey k = ECKey.recoverFromSignature(i, sig, hash, isCompressed()))
            (§ if (k != nil && k.pub.equals(pub)))
            (ß
                (§ ass recId = i)
                (§ break)
            )
        )
        (§ if (recId == -1))
            (§ throw new RuntimeException("Could not construct a recoverable key. This should never happen."))
        (§ var int headerByte = recId + 27 + (isCompressed() ? 4 :else 0))
        (§ var byte[] sigData = new byte[65]) ;; 1 header + 32 bytes for R + 32 bytes for S
        (§ ass sigData[0] = (byte)headerByte)
        (§ call System.arraycopy(Utils.bigIntegerToBytes(sig.r, 32), 0, sigData, 1, 32))
        (§ call System.arraycopy(Utils.bigIntegerToBytes(sig.s, 32), 0, sigData, 33, 32))
        (§ return new String(Base64.encode(sigData), Charset.forName("UTF-8")))
    )

    ;;;
     ; Given an arbitrary piece of text and a Bitcoin-format message signature encoded in base64, returns an ECKey
     ; containing the public key that was used to sign it.  This can then be compared to the expected public key to
     ; determine if the signature was correct.  These sorts of signatures are compatible with the Bitcoin-Qt/bitcoind
     ; format generated by signmessage/verifymessage RPCs and GUI menu options.  They are intended for humans to verify
     ; their communications with each other, hence the base64 format and the fact that the input is text.
     ;
     ; @param message Some piece of human readable text.
     ; @param signatureBase64 The Bitcoin-format message signature in base64.
     ; @throws SignatureException if the public key could not be recovered or if there was a signature format error.
     ;;
    #_public
    #_static
    (§ method ECKey signedMessageToKey(String message, String signatureBase64))
        (§ throws SignatureException)
    (ß
        (§ var byte[] signatureEncoded)
        (§ try)
        (ß
            (§ ass signatureEncoded = Base64.decode(signatureBase64))
        )
        (§ catch (RuntimeException e))
        (ß
            ;; This is what you get back from Bouncy Castle if base64 doesn't decode :( ;; )
            (§ throw new SignatureException("Could not decode base64", e))
        )
        ;; Parse the signature bytes into r/s and the selector value.
        (§ if (signatureEncoded.length < 65))
            (§ throw new SignatureException("Signature truncated, expected 65 bytes and got " + signatureEncoded.length))

        (§ var int header = signatureEncoded[0] & 0xff)
        ;; The header byte: 0x1B = first key with even y, 0x1C = first key with odd y,
        ;;                  0x1D = second key with even y, 0x1E = second key with odd y.
        (§ if (header < 27 || 34 < header))
            (§ throw new SignatureException("Header byte out of range: " + header))
        (§ var BigInteger r = new BigInteger(1, Arrays.copyOfRange(signatureEncoded, 1, 33)))
        (§ var BigInteger s = new BigInteger(1, Arrays.copyOfRange(signatureEncoded, 33, 65)))
        (§ var ECDSASignature sig = new ECDSASignature(r, s))
        (§ var byte[] messageBytes = Utils.formatMessageForSigning(message))
        ;; Note that the C++ code doesn't actually seem to specify any character encoding.
        ;; Presumably it's whatever JSON-SPIRIT hands back.  Assume UTF-8 for now.
        (§ var Sha256Hash messageHash = Sha256Hash.twiceOf(messageBytes))
        (§ var boolean compressed = false)
        (§ if (31 <= header))
        (ß
            (§ ass compressed = true)
            (§ ass header = header - 4)
        )
        (§ var int recId = header - 27)
        (§ var ECKey key = ECKey.recoverFromSignature(recId, sig, messageHash, compressed))
        (§ if (key == nil))
            (§ throw new SignatureException("Could not recover public key from signature"))
        (§ return key)
    )

    ;;;
     ; Convenience wrapper around {@link ECKey#signedMessageToKey(String, String)}.
     ; If the key derived from the signature is not the same as this one, throws a SignatureException.
     ;;
    #_public
    (§ method void verifyMessage(String message, String signatureBase64))
        (§ throws SignatureException)
    (ß
        (§ var ECKey key = ECKey.signedMessageToKey(message, signatureBase64))
        (§ if (!key.pub.equals(pub)))
            (§ throw new SignatureException("Signature did not match for message"))
    )

    ;;;
     ; <p>Given the components of a signature and a selector value, recover and return the public key
     ; that generated the signature according to the algorithm in SEC1v2 section 4.1.6.</p>
     ;
     ; <p>The recId is an index from 0 to 3 which indicates which of the 4 possible keys is the correct one.  Because
     ; the key recovery operation yields multiple potential keys, the correct key must either be stored alongside the
     ; signature, or you must be willing to try each recId in turn until you find one that outputs the key you are
     ; expecting.</p>
     ;
     ; <p>If this method returns null it means recovery was not possible and recId should be iterated.</p>
     ;
     ; <p>Given the above two points, a correct usage of this method is inside a for loop from 0 to 3, and if the
     ; output is null OR a key that is not the one you expect, you try again with the next recId.</p>
     ;
     ; @param recId Which possible key to recover.
     ; @param sig The R and S components of the signature, wrapped.
     ; @param message Hash of the data that was signed.
     ; @param compressed Whether or not the original pubkey was compressed.
     ; @return An ECKey containing only the public part, or null if recovery wasn't possible.
     ;;
    #_nilable
    #_public
    #_static
    (§ method ECKey recoverFromSignature(int recId, ECDSASignature sig, Sha256Hash message, boolean compressed))
    (ß
        (§ call Preconditions.checkArgument(0 <= recId, "recId must be positive"))
        (§ call Preconditions.checkArgument(0 <= sig.r.signum(), "r must be positive"))
        (§ call Preconditions.checkArgument(0 <= sig.s.signum(), "s must be positive"))
        (§ call Preconditions.checkNotNull(message))

        ;; 1.0 For j from 0 to h   (h == recId here and the loop is outside this function)
        ;;   1.1 Let x = r + jn
        (§ var BigInteger n = CURVE.getN()) ;; Curve order.
        (§ var BigInteger i = BigInteger.valueOf((long)recId / 2))
        (§ var BigInteger x = sig.r.add(i.multiply(n)))
        ;;   1.2. Convert the integer x to an octet string X of length mlen using the conversion routine
        ;;        specified in Section 2.3.7, where mlen = ⌈(log2 p)/8⌉ or mlen = ⌈m/8⌉.
        ;;   1.3. Convert the octet string (16 set binary digits)||X to an elliptic curve point R using the
        ;;        conversion routine specified in Section 2.3.4. If this conversion routine outputs “invalid”,
        ;;        then do another iteration of Step 1.
        ;;
        ;; More concisely, what these points mean is to use X as a compressed public key.
        (§ var BigInteger prime = SecP256K1Curve.q)
        ;; Cannot have point co-ordinates larger than this as everything takes place modulo Q.
        (§ if (0 <= x.compareTo(prime)))
            (§ return nil)

        ;; Compressed keys require you to know an extra bit of data about the y-coord as there are two possibilities.
        ;; So it's encoded in the recId.
        (§ var ECPoint R = decompressKey(x, (recId & 1) == 1))
        ;;   1.4. If nR != point at infinity, then do another iteration of Step 1 (callers responsibility).
        (§ if (!R.multiply(n).isInfinity()))
            (§ return nil)

        ;;   1.5. Compute e from M using Steps 2 and 3 of ECDSA signature verification.
        (§ var BigInteger e = message.toBigInteger())
        ;;   1.6. For k from 1 to 2 do the following.   (loop is outside this function via iterating recId)
        ;;   1.6.1. Compute a candidate public key as:
        ;;               Q = mi(r) * (sR - eG)
        ;;
        ;; Where mi(x) is the modular multiplicative inverse. We transform this into the following:
        ;;               Q = (mi(r) * s ** R) + (mi(r) * -e ** G)
        ;; Where -e is the modular additive inverse of e, that is z such that z + e = 0 (mod n). In the above equation
        ;; ** is point multiplication and + is point addition (the EC group operator).
        ;;
        ;; We can find the additive inverse by subtracting e from zero then taking the mod. For example the additive
        ;; inverse of 3 modulo 11 is 8 because 3 + 8 mod 11 = 0, and -3 mod 11 = 8.
        (§ var BigInteger eInv = BigInteger.ZERO.subtract(e).mod(n))
        (§ var BigInteger rInv = sig.r.modInverse(n))
        (§ var BigInteger srInv = rInv.multiply(sig.s).mod(n))
        (§ var BigInteger eInvrInv = rInv.multiply(eInv).mod(n))
        (§ var ECPoint q = ECAlgorithms.sumOfTwoMultiplies(CURVE.getG(), eInvrInv, R, srInv))
        (§ return ECKey.fromPublicOnly(q.getEncoded(compressed)))
    )

    ;;; Decompress a compressed public key (x co-ord and low-bit of y-coord). ;;
    #_private
    #_static
    (§ method ECPoint decompressKey(BigInteger xBN, boolean yBit))
    (ß
        (§ var X9IntegerConverter x9 = new X9IntegerConverter())
        (§ var byte[] compEnc = x9.integerToBytes(xBN, 1 + x9.getByteLength(CURVE.getCurve())))
        (§ ass compEnc[0] = (byte)(yBit ? 0x03 :else 0x02))
        (§ return CURVE.getCurve().decodePoint(compEnc))
    )

    ;;;
     ; Returns a 32 byte array containing the private key.
     ; @throws org.bitcoinj.core.ECKey.MissingPrivateKeyException if the private key bytes are missing/encrypted.
     ;;
    #_public
    (§ method byte[] getPrivKeyBytes())
    (ß
        (§ return Utils.bigIntegerToBytes(getPrivKey(), 32))
    )

    ;;;
     ; Returns the creation time of this key or zero if the key was deserialized from a version that did not store
     ; that data.
     ;;
    #_override
    #_public
    (§ method long getCreationTimeSeconds())
    (ß
        (§ return creationTimeSeconds)
    )

    ;;;
     ; Sets the creation time of this key.  Zero is a convention to mean "unavailable".  This method can be useful when
     ; you have a raw key you are importing from somewhere else.
     ;;
    #_public
    (§ method void setCreationTimeSeconds(long newCreationTimeSeconds))
    (ß
        (§ if (newCreationTimeSeconds < 0))
            (§ throw new IllegalArgumentException("Cannot set creation time to negative value: " + newCreationTimeSeconds))
        (§ ass creationTimeSeconds = newCreationTimeSeconds)
    )

    ;;;
     ; Create an encrypted private key with the keyCrypter and the AES key supplied.
     ; This method returns a new encrypted key and leaves the original unchanged.
     ;
     ; @param keyCrypter The keyCrypter that specifies exactly how the encrypted bytes are created.
     ; @param aesKey The KeyParameter with the AES encryption key (usually constructed with keyCrypter#deriveKey and cached as it is slow to create).
     ; @return encryptedKey
     ;;
    #_public
    (§ method ECKey encrypt(KeyCrypter keyCrypter, KeyParameter aesKey))
        (§ throws KeyCrypterException)
    (ß
        (§ call Preconditions.checkNotNull(keyCrypter))

        #_final
        (§ var byte[] privKeyBytes = getPrivKeyBytes())
        (§ var EncryptedData encryptedPrivateKey = keyCrypter.encrypt(privKeyBytes, aesKey))
        (§ var ECKey result = ECKey.fromEncrypted(encryptedPrivateKey, keyCrypter, getPubKey()))
        (§ call result.setCreationTimeSeconds(creationTimeSeconds))
        (§ return result)
    )

    ;;;
     ; Create a decrypted private key with the keyCrypter and AES key supplied.  Note that if the aesKey is wrong, this
     ; has some chance of throwing KeyCrypterException due to the corrupted padding that will result, but it can also
     ; just yield a garbage key.
     ;
     ; @param keyCrypter The keyCrypter that specifies exactly how the decrypted bytes are created.
     ; @param aesKey The KeyParameter with the AES encryption key (usually constructed with keyCrypter#deriveKey and cached).
     ;;
    #_public
    (§ method ECKey decrypt(KeyCrypter keyCrypter, KeyParameter aesKey))
        (§ throws KeyCrypterException)
    (ß
        (§ call Preconditions.checkNotNull(keyCrypter))

        ;; Check that the keyCrypter matches the one used to encrypt the keys, if set.
        (§ if (this.keyCrypter != nil && !this.keyCrypter.equals(keyCrypter)))
            (§ throw new KeyCrypterException("The keyCrypter being used to decrypt the key is different to the one that was used to encrypt it"))

        (§ call Preconditions.checkState(encryptedPrivateKey != nil, "This key is not encrypted"))

        (§ var byte[] unencryptedPrivateKey = keyCrypter.decrypt(encryptedPrivateKey, aesKey))
        (§ var ECKey key = ECKey.fromPrivate(unencryptedPrivateKey))
        (§ if (!isCompressed()))
            (§ ass key = key.decompress())
        (§ if (!Arrays.equals(key.getPubKey(), getPubKey())))
            (§ throw new KeyCrypterException("Provided AES key is wrong"))

        (§ call key.setCreationTimeSeconds(creationTimeSeconds))
        (§ return key)
    )

    ;;;
     ; Create a decrypted private key with AES key.  Note that if the AES key is wrong, this
     ; has some chance of throwing KeyCrypterException due to the corrupted padding that will result, but it can also
     ; just yield a garbage key.
     ;
     ; @param aesKey The KeyParameter with the AES encryption key (usually constructed with keyCrypter#deriveKey and cached).
     ;;
    #_public
    (§ method ECKey decrypt(KeyParameter aesKey))
        (§ throws KeyCrypterException)
    (ß
        #_final
        (§ var KeyCrypter crypter = getKeyCrypter())
        (§ if (crypter == nil))
            (§ throw new KeyCrypterException("No key crypter available"))

        (§ return decrypt(crypter, aesKey))
    )

    ;;;
     ; Creates decrypted private key if needed.
     ;;
    #_public
    (§ method ECKey maybeDecrypt(#_nilable KeyParameter aesKey))
        (§ throws KeyCrypterException)
    (ß
        (§ return (isEncrypted() && aesKey != nil) ? decrypt(aesKey) :else this)
    )

    ;;;
     ; <p>Check that it is possible to decrypt the key with the keyCrypter and that the original key is returned.</p>
     ;
     ; <p>Because it is a critical failure if the private keys cannot be decrypted successfully (resulting of loss of
     ; all bitcoins controlled by the private key) you can use this method to check when you *encrypt* a wallet that
     ; it can definitely be decrypted successfully.</p>
     ;
     ; <p>See {@link Wallet#encrypt(KeyCrypter keyCrypter, KeyParameter aesKey)} for example usage.</p>
     ;
     ; @return true if the encrypted key can be decrypted back to the original key successfully.
     ;;
    #_public
    #_static
    (§ method boolean encryptionIsReversible(ECKey originalKey, ECKey encryptedKey, KeyCrypter keyCrypter, KeyParameter aesKey))
    (ß
        (§ try)
        (ß
            (§ var ECKey rebornUnencryptedKey = encryptedKey.decrypt(keyCrypter, aesKey))
            (§ var byte[] originalPrivateKeyBytes = originalKey.getPrivKeyBytes())
            (§ var byte[] rebornKeyBytes = rebornUnencryptedKey.getPrivKeyBytes())
            (§ if (!Arrays.equals(originalPrivateKeyBytes, rebornKeyBytes)))
            (ß
                (§ call log.error("The check that encryption could be reversed failed for {}", originalKey))
                (§ return false)
            )
            (§ return true)
        )
        (§ catch (KeyCrypterException kce))
        (ß
            (§ call log.error(kce.getMessage()))
            (§ return false)
        )
    )

    ;;;
     ; Indicates whether the private key is encrypted (true) or not (false).
     ; A private key is deemed to be encrypted when there is both a KeyCrypter and the encryptedPrivateKey is non-zero.
     ;;
    #_override
    #_public
    (§ method boolean isEncrypted())
    (ß
        (§ return (keyCrypter != nil && encryptedPrivateKey != nil && 0 < encryptedPrivateKey.encryptedBytes.length))
    )

    #_nilable
    #_override
    #_public
    (§ method Protos.Wallet.EncryptionType getEncryptionType())
    (ß
        (§ return (keyCrypter != nil) ? keyCrypter.getUnderstoodEncryptionType() :else Protos.Wallet.EncryptionType.UNENCRYPTED)
    )

    ;;;
     ; A wrapper for {@link #getPrivKeyBytes()} that returns null if the private key bytes are missing or would have
     ; to be derived (for the HD key case).
     ;;
    #_override
    #_nilable
    #_public
    (§ method byte[] getSecretBytes())
    (ß
        (§ if (hasPrivKey()))
            (§ return getPrivKeyBytes())

        (§ return nil)
    )

    ;;; An alias for {@link #getEncryptedPrivateKey()}. ;;
    #_nilable
    #_override
    #_public
    (§ method EncryptedData getEncryptedData())
    (ß
        (§ return getEncryptedPrivateKey())
    )

    ;;;
     ; Returns the the encrypted private key bytes and initialisation vector for this ECKey, or null if the ECKey
     ; is not encrypted.
     ;;
    #_nilable
    #_public
    (§ method EncryptedData getEncryptedPrivateKey())
    (ß
        (§ return encryptedPrivateKey)
    )

    ;;;
     ; Returns the KeyCrypter that was used to encrypt to encrypt this ECKey.  You need this to decrypt the ECKey.
     ;;
    #_nilable
    #_public
    (§ method KeyCrypter getKeyCrypter())
    (ß
        (§ return keyCrypter)
    )

    #_public
    #_static
    (§ class MissingPrivateKeyException extends RuntimeException
    )

    #_public
    #_static
    (§ class KeyIsEncryptedException extends MissingPrivateKeyException
    )

    #_override
    #_public
    (§ method boolean equals(Object o))
    (ß
        (§ if (this == o))
            (§ return true)
        (§ if (o == nil || !(o instanceof ECKey)))
            (§ return false)
        (§ var ECKey other = (ECKey)o)
        (§ return Objects.equal(this.priv, other.priv) && Objects.equal(this.pub, other.pub) && Objects.equal(this.creationTimeSeconds, other.creationTimeSeconds) && Objects.equal(this.keyCrypter, other.keyCrypter) && Objects.equal(this.encryptedPrivateKey, other.encryptedPrivateKey))
    )

    #_override
    #_public
    (§ method int hashCode())
    (ß
        (§ return pub.hashCode())
    )

    #_override
    #_public
    (§ method String toString())
    (ß
        (§ return toString(false, nil))
    )

    ;;;
     ; Produce a string rendering of the ECKey INCLUDING the private key.
     ; Unless you absolutely need the private key it is better for security reasons to just use {@link #toString()}.
     ;;
    #_public
    (§ method String toStringWithPrivate(NetworkParameters params))
    (ß
        (§ return toString(true, params))
    )

    #_public
    (§ method String getPrivateKeyAsHex())
    (ß
        (§ return Utils.HEX.encode(getPrivKeyBytes()))
    )

    #_public
    (§ method String getPublicKeyAsHex())
    (ß
        (§ return Utils.HEX.encode(pub.getEncoded()))
    )

    #_private
    (§ method String toString(boolean includePrivate, NetworkParameters params))
    (ß
        #_final
        (§ var MoreObjects.ToStringHelper helper = MoreObjects.toStringHelper(this).omitNullValues())
        (§ call helper.add("pub HEX", getPublicKeyAsHex()))
        (§ if (includePrivate))
        (ß
            (§ try)
            (ß
                (§ call helper.add("priv HEX", getPrivateKeyAsHex()))
            )
            (§ catch (IllegalStateException _))
            (ß
                ;; TODO: Make hasPrivKey() work for deterministic keys and fix this.
            )
            (§ catch (Exception e))
            (ß
                #_final
                (§ var String message = e.getMessage())
                (§ call helper.add("priv EXCEPTION", e.getClass().getName() + (message != nil ? ": " + message :else "")))
            )
        )
        (§ if (0 < creationTimeSeconds))
            (§ call helper.add("creationTimeSeconds", creationTimeSeconds))
        (§ call helper.add("keyCrypter", keyCrypter))
        (§ if (includePrivate))
            (§ call helper.add("encryptedPrivateKey", encryptedPrivateKey))
        (§ call helper.add("isEncrypted", isEncrypted()))
        (§ call helper.add("isPubKeyOnly", isPubKeyOnly()))
        (§ return helper.toString())
    )

    #_public
    (§ method void formatKeyWithAddress(boolean includePrivateKeys, StringBuilder sb, NetworkParameters params))
    (ß
        #_final
        (§ var Address address = toAddress(params))
        (§ call sb.append("  addr:"))
        (§ call sb.append(address.toString()))
        (§ call sb.append("  hash160:"))
        (§ call sb.append(Utils.HEX.encode(getPubKeyHash())))
        (§ if (0 < creationTimeSeconds))
            (§ call sb.append("  creationTimeSeconds:").append(creationTimeSeconds))
        (§ call sb.append("\n"))
        (§ if (includePrivateKeys))
        (ß
            (§ call sb.append("  "))
            (§ call sb.append(toStringWithPrivate(params)))
            (§ call sb.append("\n"))
        )
    )
)

#_(ns org.bitcoinj.core #_"EmptyMessage"
    (:import [java.io IOException OutputStream]))

;;;
 ; <p>Parent class for header only messages that don't have a payload.
 ; Currently this includes getaddr, verack and special bitcoinj class UnknownMessage.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
#_abstract
(§ class EmptyMessage extends Message
    #_public
    (§ constructor EmptyMessage())
    (ß
        (§ ass length = 0)
    )

    #_public
    (§ constructor EmptyMessage(NetworkParameters params))
    (ß
        (§ super (params))
        (§ ass length = 0)
    )

    #_public
    (§ constructor EmptyMessage(NetworkParameters params, byte[] payload, int offset))
        (§ throws ProtocolException)
    (ß
        (§ super (params, payload, offset))
        (§ ass length = 0)
    )

    #_override
    #_protected
    #_final
    (§ method void bitcoinSerializeToStream(OutputStream stream))
        (§ throws IOException)
    (ß
    )

    #_override
    #_protected
    (§ method void parse())
        (§ throws ProtocolException)
    (ß
    )

    #_override
    #_public
    (§ method byte[] bitcoinSerialize())
    (ß
        (§ return new byte[0])
    )
)

#_(ns org.bitcoinj.core #_"FilteredBlock"
    (:import [java.io IOException OutputStream]
             #_[java.util *])
    (:import [com.google.common.base Objects]))

;;;
 ; <p>A FilteredBlock is used to relay a block with its transactions filtered using a {@link BloomFilter}.  It consists
 ; of the block header and a {@link PartialMerkleTree} which contains the transactions which matched the filter.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class FilteredBlock extends Message
    #_private
    (§ field Block header)

    #_private
    (§ field PartialMerkleTree merkleTree)
    #_private
    (§ field List<Sha256Hash> cachedTransactionHashes)

    ;; A set of transactions whose hashes are a subset of getTransactionHashes().
    ;; These were relayed as a part of the filteredblock getdata, i.e. likely weren't previously received as loose transactions.
    #_private
    (§ field Map<Sha256Hash, Transaction> associatedTransactions = new HashMap<>())

    #_public
    (§ constructor FilteredBlock(NetworkParameters params, byte[] payloadBytes))
        (§ throws ProtocolException)
    (ß
        (§ super (params, payloadBytes, 0))
    )

    #_public
    (§ constructor FilteredBlock(NetworkParameters params, Block header, PartialMerkleTree pmt))
    (ß
        (§ super (params))
        (§ ass this.header = header)
        (§ ass this.merkleTree = pmt)
    )

    #_override
    #_public
    (§ method void bitcoinSerializeToStream(OutputStream stream))
        (§ throws IOException)
    (ß
        (§ if (header.transactions == nil))
            (§ call header.bitcoinSerializeToStream(stream))
        (§ else)
            (§ call header.cloneAsHeader().bitcoinSerializeToStream(stream))
        (§ call merkleTree.bitcoinSerializeToStream(stream))
    )

    #_override
    #_protected
    (§ method void parse())
        (§ throws ProtocolException)
    (ß
        (§ var byte[] headerBytes = new byte[Block.HEADER_SIZE])
        (§ call System.arraycopy(payload, 0, headerBytes, 0, Block.HEADER_SIZE))
        (§ ass header = params.getDefaultSerializer().makeBlock(headerBytes))

        (§ ass merkleTree = new PartialMerkleTree(params, payload, Block.HEADER_SIZE))

        (§ ass length = Block.HEADER_SIZE + merkleTree.getMessageSize())
    )

    ;;;
     ; Gets a list of leaf hashes which are contained in the partial merkle tree in this filtered block.
     ;
     ; @throws ProtocolException if the partial merkle block is invalid or the merkle root of the partial merkle block doesnt match the block header.
     ;;
    #_public
    (§ method List<Sha256Hash> getTransactionHashes())
        (§ throws VerificationException)
    (ß
        (§ if (cachedTransactionHashes != nil))
            (§ return Collections.unmodifiableList(cachedTransactionHashes))

        (§ var List<Sha256Hash> hashesMatched = new LinkedList<>())
        (§ if (header.getMerkleRoot().equals(merkleTree.getTxnHashAndMerkleRoot(hashesMatched))))
        (ß
            (§ ass cachedTransactionHashes = hashesMatched)
            (§ return Collections.unmodifiableList(cachedTransactionHashes))
        )

        (§ throw new VerificationException("Merkle root of block header does not match merkle root of partial merkle tree."))
    )

    ;;;
     ; Gets a copy of the block header.
     ;;
    #_public
    (§ method Block getBlockHeader())
    (ß
        (§ return header.cloneAsHeader())
    )

    ;;; Gets the hash of the block represented in this FilteredBlock. ;;
    #_override
    #_public
    (§ method Sha256Hash getHash())
    (ß
        (§ return header.getHash())
    )

    ;;;
     ; Provide this FilteredBlock with a transaction which is in its Merkle tree.
     ; @return false if the tx is not relevant to this FilteredBlock.
     ;;
    #_public
    (§ method boolean provideTransaction(Transaction tx))
        (§ throws VerificationException)
    (ß
        (§ var Sha256Hash hash = tx.getHash())
        (§ if (getTransactionHashes().contains(hash)))
        (ß
            (§ call associatedTransactions.put(hash, tx))
            (§ return true)
        )
        (§ return false)
    )

    ;;; Returns the {@link PartialMerkleTree} object that provides the mathematical proof of transaction inclusion in the block. ;;
    #_public
    (§ method PartialMerkleTree getPartialMerkleTree())
    (ß
        (§ return merkleTree)
    )

    ;;; Gets the set of transactions which were provided using provideTransaction() which match in getTransactionHashes(). ;;
    #_public
    (§ method Map<Sha256Hash, Transaction> getAssociatedTransactions())
    (ß
        (§ return Collections.unmodifiableMap(associatedTransactions))
    )

    ;;; Number of transactions in this block, before it was filtered. ;;
    #_public
    (§ method int getTransactionCount())
    (ß
        (§ return merkleTree.getTransactionCount())
    )

    #_override
    #_public
    (§ method boolean equals(Object o))
    (ß
        (§ if (this == o))
            (§ return true)
        (§ if (o == nil || getClass() != o.getClass()))
            (§ return false)
        (§ var FilteredBlock other = (FilteredBlock)o)
        (§ return (associatedTransactions.equals(other.associatedTransactions) && header.equals(other.header) && merkleTree.equals(other.merkleTree)))
    )

    #_override
    #_public
    (§ method int hashCode())
    (ß
        (§ return Objects.hashCode(associatedTransactions, header, merkleTree))
    )

    #_override
    #_public
    (§ method String toString())
    (ß
        (§ return "FilteredBlock{merkleTree=" + merkleTree + ", header=" + header + "}")
    )
)

#_(ns org.bitcoinj.core #_"FullPrunedBlockChain"
    (:import [java.util ArrayList LinkedList List ListIterator Set]
             #_[java.util.concurrent *])
    (:import [com.google.common.base Preconditions]
             [org.slf4j Logger LoggerFactory])
  #_(:require [org.bitcoinj.script Script]
             [org.bitcoinj.script.Script VerifyFlag]
             [org.bitcoinj.store BlockStoreException FullPrunedBlockStore]
             #_[org.bitcoinj.utils *]
             [org.bitcoinj.wallet Wallet]))

;;;
 ; <p>A FullPrunedBlockChain works in conjunction with a {@link FullPrunedBlockStore} to verify all the rules of the
 ; Bitcoin system, with the downside being a large cost in system resources.  Fully verifying means all unspent
 ; transaction outputs are stored.  Once a transaction output is spent and that spend is buried deep enough, the data
 ; related to it is deleted to ensure disk space usage doesn't grow forever.  For this reason a pruning node cannot
 ; serve the full block chain to other clients, but it nevertheless provides the same security guarantees as Bitcoin
 ; Core does.</p>
 ;;
#_public
(§ class FullPrunedBlockChain extends AbstractBlockChain
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(FullPrunedBlockChain.class))

    ;;;
     ; Keeps a map of block hashes to StoredBlocks.
     ;;
    #_protected
    #_final
    (§ field FullPrunedBlockStore blockStore)

    ;; Whether or not to execute scriptPubKeys before accepting a transaction (i.e. check signatures).
    #_private
    (§ field boolean runScripts = true)

    ;;;
     ; Constructs a block chain connected to the given wallet and store.  To obtain a {@link Wallet} you can construct
     ; one from scratch, or you can deserialize a saved wallet from disk using {@link Wallet#loadFromFile(java.io.File)}.
     ;;
    #_public
    (§ constructor FullPrunedBlockChain(Context context, Wallet wallet, FullPrunedBlockStore blockStore))
        (§ throws BlockStoreException)
    (ß
        (§ this (context, new ArrayList<Wallet>(), blockStore))
        (§ call addWallet(wallet))
    )

    ;;;
     ; Constructs a block chain connected to the given wallet and store.  To obtain a {@link Wallet} you can construct
     ; one from scratch, or you can deserialize a saved wallet from disk using {@link Wallet#loadFromFile(java.io.File)}.
     ;;
    #_public
    (§ constructor FullPrunedBlockChain(NetworkParameters params, Wallet wallet, FullPrunedBlockStore blockStore))
        (§ throws BlockStoreException)
    (ß
        (§ this (Context.getOrCreate(params), wallet, blockStore))
    )

    ;;;
     ; Constructs a block chain connected to the given store.
     ;;
    #_public
    (§ constructor FullPrunedBlockChain(Context context, FullPrunedBlockStore blockStore))
        (§ throws BlockStoreException)
    (ß
        (§ this (context, new ArrayList<Wallet>(), blockStore))
    )

    ;;;
     ; See {@link #FullPrunedBlockChain(Context, Wallet, FullPrunedBlockStore)}.
     ;;
    #_public
    (§ constructor FullPrunedBlockChain(NetworkParameters params, FullPrunedBlockStore blockStore))
        (§ throws BlockStoreException)
    (ß
        (§ this (Context.getOrCreate(params), blockStore))
    )

    ;;;
     ; Constructs a block chain connected to the given list of wallets and a store.
     ;;
    #_public
    (§ constructor FullPrunedBlockChain(Context context, List<Wallet> listeners, FullPrunedBlockStore blockStore))
        (§ throws BlockStoreException)
    (ß
        (§ super (context, listeners, blockStore))
        (§ ass this.blockStore = blockStore)
        ;; Ignore upgrading for now.
        (§ ass this.chainHead = blockStore.getVerifiedChainHead())
    )

    ;;;
     ; See {@link #FullPrunedBlockChain(Context, List, FullPrunedBlockStore)}.
     ;;
    #_public
    (§ constructor FullPrunedBlockChain(NetworkParameters params, List<Wallet> listeners, FullPrunedBlockStore blockStore))
        (§ throws BlockStoreException)
    (ß
        (§ this (Context.getOrCreate(params), listeners, blockStore))
    )

    #_override
    #_protected
    (§ method StoredBlock addToBlockStore(StoredBlock storedPrev, Block header, TransactionOutputChanges txOutChanges))
        (§ throws BlockStoreException, VerificationException)
    (ß
        (§ var StoredBlock newBlock = storedPrev.build(header))
        (§ call blockStore.put(newBlock, new StoredUndoableBlock(newBlock.getHeader().getHash(), txOutChanges)))
        (§ return newBlock)
    )

    #_override
    #_protected
    (§ method StoredBlock addToBlockStore(StoredBlock storedPrev, Block block))
        (§ throws BlockStoreException, VerificationException)
    (ß
        (§ var StoredBlock newBlock = storedPrev.build(block))
        (§ call blockStore.put(newBlock, new StoredUndoableBlock(newBlock.getHeader().getHash(), block.transactions)))
        (§ return newBlock)
    )

    #_override
    #_protected
    (§ method void rollbackBlockStore(int height))
        (§ throws BlockStoreException)
    (ß
        (§ throw new BlockStoreException("Unsupported"))
    )

    #_override
    #_protected
    (§ method boolean shouldVerifyTransactions())
    (ß
        (§ return true)
    )

    ;;;
     ; Whether or not to run scripts whilst accepting blocks (i.e. checking signatures, for most transactions).
     ; If you're accepting data from an untrusted node, such as one found via the P2P network, this should be set
     ; to true (which is the default).  If you're downloading a chain from a node you control, script execution
     ; is redundant because you know the connected node won't relay bad data to you.  In that case it's safe to set
     ; this to false and obtain a significant speedup.
     ;;
    #_public
    (§ method void setRunScripts(boolean value))
    (ß
        (§ ass this.runScripts = value)
    )

    ;; TODO: Remove lots of duplicated code in the two connectTransactions.

    ;; TODO: Execute in order of largest transaction (by input count) first.
    (§ field ExecutorService scriptVerificationExecutor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors(), new ContextPropagatingThreadFactory("Script verification")))

    ;;;
     ; A job submitted to the executor which verifies signatures.
     ;;
    #_private
    #_static
    (§ class Verifier implements Callable<VerificationException>
        #_final
        (§ field Transaction tx)
        #_final
        (§ field List<Script> prevOutScripts)
        #_final
        (§ field Set<VerifyFlag> verifyFlags)

        #_public
        (§ constructor Verifier(#_final Transaction tx, #_final List<Script> prevOutScripts, #_final Set<VerifyFlag> verifyFlags))
        (ß
            (§ ass this.tx = tx)
            (§ ass this.prevOutScripts = prevOutScripts)
            (§ ass this.verifyFlags = verifyFlags)
        )

        #_nilable
        #_override
        #_public
        (§ method VerificationException call())
            (§ throws Exception)
        (ß
            (§ try)
            (ß
                (§ var ListIterator<Script> prevOutIt = prevOutScripts.listIterator())
                (§ for (int index = 0 :for index < tx.getInputs().size() :for index = index + 1))
                    (§ call tx.getInputs().get(index).getScriptSig().correctlySpends(tx, index, prevOutIt.next(), verifyFlags))
                (§ return nil)
            )
            (§ catch (VerificationException e))
            (ß
                (§ return e)
            )
        )
    )

    ;;;
     ; Get the {@link Script} from the script bytes or return Script of empty byte array.
     ;;
    #_private
    (§ method Script getScript(byte[] scriptBytes))
    (ß
        (§ try)
        (ß
            (§ return new Script(scriptBytes))
        )
        (§ catch (Exception _))
        (ß
            (§ return new Script(new byte[0]))
        )
    )

    ;;;
     ; Get the address from the {@link Script} if it exists, otherwise return empty string "".
     ;
     ; @param script The script.
     ; @return The address.
     ;;
    #_private
    (§ method String getScriptAddress(#_nilable Script script))
    (ß
        (§ var String address = "")
        (§ try)
        (ß
            (§ if (script != nil))
                (§ ass address = script.getToAddress(params, true).toString())
        )
        (§ catch (Exception _))
        (ß
        )
        (§ return address)
    )

    #_override
    #_protected
    (§ method TransactionOutputChanges connectTransactions(int height, Block block))
        (§ throws VerificationException, BlockStoreException)
    (ß
        (§ call Preconditions.checkState(lock.isHeldByCurrentThread()))

        (§ if (block.transactions == nil))
            (§ throw new RuntimeException("connectTransactions called with Block that didn't have transactions!"))
        (§ if (!params.passesCheckpoint(height, block.getHash())))
            (§ throw new VerificationException("Block failed checkpoint lockin at " + height))

        (§ call blockStore.beginDatabaseBatchWrite())

        (§ var LinkedList<UTXO> txOutsSpent = new LinkedList<>())
        (§ var LinkedList<UTXO> txOutsCreated = new LinkedList<>())
        (§ var long sigOps = 0)

        (§ if (scriptVerificationExecutor.isShutdown()))
            (§ ass scriptVerificationExecutor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()))

        (§ var List<Future<VerificationException>> listScriptVerificationResults = new ArrayList<>(block.transactions.size()))
        (§ try)
        (ß
            (§ if (!params.isCheckpoint(height)))
            (ß
                ;; BIP30 violator blocks are ones that contain a duplicated transaction.  They are all in the checkpoints list
                ;; and we therefore only check non-checkpoints for duplicated transactions here.  See the BIP30 document
                ;; for more details on this: https://github.com/bitcoin/bips/blob/master/bip-0030.mediawiki
                (§ for (Transaction tx :for block.transactions))
                (ß
                    #_final
                    (§ var Set<VerifyFlag> verifyFlags = params.getTransactionVerificationFlags(block, tx, getVersionTally(), height))
                    (§ var Sha256Hash hash = tx.getHash())
                    ;; If we already have unspent outputs for this hash, we saw the tx already.
                    ;; Either the block is being added twice (bug) or the block is a BIP30 violator.
                    (§ if (blockStore.hasUnspentOutputs(hash, tx.getOutputs().size())))
                        (§ throw new VerificationException("Block failed BIP30 test!"))
                    ;; We already check non-BIP16 sigops in Block.verifyTransactions(true).
                    (§ if (verifyFlags.contains(VerifyFlag.P2SH)))
                        (§ ass sigOps = sigOps + tx.getSigOpCount())
                )
            )
            (§ var Coin totalFees = Coin.ZERO)
            (§ var Coin coinbaseValue = nil)
            (§ for (#_final Transaction tx :for block.transactions))
            (ß
                (§ var boolean isCoinBase = tx.isCoinBase())
                (§ var Coin valueIn = Coin.ZERO)
                (§ var Coin valueOut = Coin.ZERO)
                #_final
                (§ var List<Script> prevOutScripts = new LinkedList<>())
                #_final
                (§ var Set<VerifyFlag> verifyFlags = params.getTransactionVerificationFlags(block, tx, getVersionTally(), height))
                (§ if (!isCoinBase))
                (ß
                    ;; For each input of the transaction remove the corresponding output from the set of unspent outputs.
                    (§ for (int index = 0 :for index < tx.getInputs().size() :for index = index + 1))
                    (ß
                        (§ var TransactionInput in = tx.getInputs().get(index))
                        (§ var UTXO prevOut = blockStore.getTransactionOutput(in.getOutpoint().getHash(), in.getOutpoint().getIndex()))
                        (§ if (prevOut == nil))
                            (§ throw new VerificationException("Attempted to spend a non-existent or already spent output!"))
                        ;; Coinbases can't be spent until they mature, to avoid re-orgs destroying entire transaction chains.
                        ;; The assumption is there will ~never be re-orgs deeper than the spendable coinbase chain depth.
                        (§ if (prevOut.isCoinbase()))
                        (ß
                            (§ if (height - prevOut.getHeight() < params.getSpendableCoinbaseDepth()))
                                (§ throw new VerificationException("Tried to spend coinbase at depth " + (height - prevOut.getHeight())))
                        )
                        ;; TODO: Check we're not spending the genesis transaction here. Bitcoin Core won't allow it.
                        (§ ass valueIn = valueIn.add(prevOut.getValue()))
                        (§ if (verifyFlags.contains(VerifyFlag.P2SH)))
                        (ß
                            (§ if (prevOut.getScript().isPayToScriptHash()))
                                (§ ass sigOps = sigOps + Script.getP2SHSigOpCount(in.getScriptBytes()))
                            (§ if (Block.MAX_BLOCK_SIGOPS < sigOps))
                                (§ throw new VerificationException("Too many P2SH SigOps in block"))
                        )

                        (§ call prevOutScripts.add(prevOut.getScript()))
                        (§ call blockStore.removeUnspentTransactionOutput(prevOut))
                        (§ call txOutsSpent.add(prevOut))
                    )
                )
                (§ var Sha256Hash hash = tx.getHash())
                (§ for (TransactionOutput out :for tx.getOutputs()))
                (ß
                    (§ ass valueOut = valueOut.add(out.getValue()))
                    ;; For each output, add it to the set of unspent outputs so it can be consumed in future.
                    (§ var Script script = getScript(out.getScriptBytes()))
                    (§ var UTXO newOut = new UTXO(hash, out.getIndex(), out.getValue(), height, isCoinBase, script, getScriptAddress(script)))
                    (§ call blockStore.addUnspentTransactionOutput(newOut))
                    (§ call txOutsCreated.add(newOut))
                )
                ;; All values were already checked for being non-negative (as it is verified in Transaction.verify()),
                ;; but we check again here just for defence in depth.  Transactions with zero output value are OK.
                (§ if (valueOut.signum() < 0 || 0 < valueOut.compareTo(params.getMaxMoney())))
                    (§ throw new VerificationException("Transaction output value out of range"))

                (§ if (isCoinBase))
                (ß
                    (§ ass coinbaseValue = valueOut)
                )
                (§ else)
                (ß
                    (§ if (valueIn.compareTo(valueOut) < 0 || 0 < valueIn.compareTo(params.getMaxMoney())))
                        (§ throw new VerificationException("Transaction input value out of range"))
                    (§ ass totalFees = totalFees.add(valueIn.subtract(valueOut)))
                )

                (§ if (!isCoinBase && runScripts))
                (ß
                    ;; Because correctlySpends modifies transactions, this must come after we are done with tx.
                    (§ var FutureTask<VerificationException> future = new FutureTask<>(new Verifier(tx, prevOutScripts, verifyFlags)))
                    (§ call scriptVerificationExecutor.execute(future))
                    (§ call listScriptVerificationResults.add(future))
                )
            )
            (§ if (0 < totalFees.compareTo(params.getMaxMoney()) || block.getBlockInflation(height).add(totalFees).compareTo(coinbaseValue) < 0))
                (§ throw new VerificationException("Transaction fees out of range"))

            (§ for (Future<VerificationException> future :for listScriptVerificationResults))
            (ß
                (§ var VerificationException e)
                (§ try)
                (ß
                    (§ ass e = future.get())
                )
                (§ catch (InterruptedException ie))
                (ß
                    (§ throw new RuntimeException(ie)) ;; Shouldn't happen.
                )
                (§ catch (ExecutionException ee))
                (ß
                    (§ call log.error("Script.correctlySpends threw a non-normal exception: " + ee.getCause()))
                    (§ throw new VerificationException("Bug in Script.correctlySpends, likely script malformed in some new and interesting way.", ee))
                )
                (§ if (e != nil))
                    (§ throw e)
            )
        )
        (§ catch (VerificationException e))
        (ß
            (§ call scriptVerificationExecutor.shutdownNow())
            (§ call blockStore.abortDatabaseBatchWrite())
            (§ throw e)
        )
        (§ catch (BlockStoreException e))
        (ß
            (§ call scriptVerificationExecutor.shutdownNow())
            (§ call blockStore.abortDatabaseBatchWrite())
            (§ throw e)
        )

        (§ return new TransactionOutputChanges(txOutsCreated, txOutsSpent))
    )

    #_override
    ;;;
     ; Used during reorgs to connect a block previously on a fork.
     ;;
    #_protected
    #_synchronized
    (§ method TransactionOutputChanges connectTransactions(StoredBlock newBlock))
        (§ throws VerificationException, BlockStoreException, PrunedException)
    (ß
        (§ call Preconditions.checkState(lock.isHeldByCurrentThread()))
        (§ if (!params.passesCheckpoint(newBlock.getHeight(), newBlock.getHeader().getHash())))
            (§ throw new VerificationException("Block failed checkpoint lockin at " + newBlock.getHeight()))

        (§ call blockStore.beginDatabaseBatchWrite())
        (§ var StoredUndoableBlock block = blockStore.getUndoBlock(newBlock.getHeader().getHash()))
        (§ if (block == nil))
        (ß
            ;; We're trying to re-org too deep and the data needed has been deleted.
            (§ call blockStore.abortDatabaseBatchWrite())
            (§ throw new PrunedException(newBlock.getHeader().getHash()))
        )

        (§ var TransactionOutputChanges txOutChanges)
        (§ try)
        (ß
            (§ var List<Transaction> transactions = block.getTransactions())
            (§ if (transactions != nil))
            (ß
                (§ var LinkedList<UTXO> txOutsSpent = new LinkedList<>())
                (§ var LinkedList<UTXO> txOutsCreated = new LinkedList<>())
                (§ var long sigOps = 0)

                (§ if (!params.isCheckpoint(newBlock.getHeight())))
                (ß
                    (§ for (Transaction tx :for transactions))
                    (ß
                        (§ var Sha256Hash hash = tx.getHash())
                        (§ if (blockStore.hasUnspentOutputs(hash, tx.getOutputs().size())))
                            (§ throw new VerificationException("Block failed BIP30 test!"))
                    )
                )

                (§ var Coin totalFees = Coin.ZERO)
                (§ var Coin coinbaseValue = nil)

                (§ if (scriptVerificationExecutor.isShutdown()))
                    (§ ass scriptVerificationExecutor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()))

                (§ var List<Future<VerificationException>> listScriptVerificationResults = new ArrayList<>(transactions.size()))
                (§ for (#_final Transaction tx :for transactions))
                (ß
                    #_final
                    (§ var Set<VerifyFlag> verifyFlags = params.getTransactionVerificationFlags(newBlock.getHeader(), tx, getVersionTally(), Integer.SIZE))
                    (§ var boolean isCoinBase = tx.isCoinBase())
                    (§ var Coin valueIn = Coin.ZERO)
                    (§ var Coin valueOut = Coin.ZERO)
                    #_final
                    (§ var List<Script> prevOutScripts = new LinkedList<>())

                    (§ if (!isCoinBase))
                    (ß
                        (§ for (int index = 0 :for index < tx.getInputs().size() :for index = index + 1))
                        (ß
                            #_final
                            (§ var TransactionInput in = tx.getInputs().get(index))
                            #_final
                            (§ var UTXO prevOut = blockStore.getTransactionOutput(in.getOutpoint().getHash(), in.getOutpoint().getIndex()))
                            (§ if (prevOut == nil))
                                (§ throw new VerificationException("Attempted spend of a non-existent or already spent output!"))
                            (§ if (prevOut.isCoinbase() && newBlock.getHeight() - prevOut.getHeight() < params.getSpendableCoinbaseDepth()))
                                (§ throw new VerificationException("Tried to spend coinbase at depth " + (newBlock.getHeight() - prevOut.getHeight())))
                            (§ ass valueIn = valueIn.add(prevOut.getValue()))
                            (§ if (verifyFlags.contains(VerifyFlag.P2SH)))
                            (ß
                                (§ if (prevOut.getScript().isPayToScriptHash()))
                                    (§ ass sigOps = sigOps + Script.getP2SHSigOpCount(in.getScriptBytes()))
                                (§ if (sigOps > Block.MAX_BLOCK_SIGOPS))
                                    (§ throw new VerificationException("Too many P2SH SigOps in block"))
                            )

                            ;; TODO: Enforce DER signature format.

                            (§ call prevOutScripts.add(prevOut.getScript()))

                            (§ call blockStore.removeUnspentTransactionOutput(prevOut))
                            (§ call txOutsSpent.add(prevOut))
                        )
                    )
                    (§ var Sha256Hash hash = tx.getHash())
                    (§ for (TransactionOutput out :for tx.getOutputs()))
                    (ß
                        (§ ass valueOut = valueOut.add(out.getValue()))
                        (§ var Script script = getScript(out.getScriptBytes()))
                        (§ var UTXO newOut = new UTXO(hash, out.getIndex(), out.getValue(), newBlock.getHeight(), isCoinBase, script, getScriptAddress(script)))
                        (§ call blockStore.addUnspentTransactionOutput(newOut))
                        (§ call txOutsCreated.add(newOut))
                    )
                    ;; All values were already checked for being non-negative (as it is verified in Transaction.verify())
                    ;; but we check again here just for defence in depth.  Transactions with zero output value are OK.
                    (§ if (valueOut.signum() < 0 || 0 < valueOut.compareTo(params.getMaxMoney())))
                        (§ throw new VerificationException("Transaction output value out of range"))

                    (§ if (isCoinBase))
                    (ß
                        (§ ass coinbaseValue = valueOut)
                    )
                    (§ else)
                    (ß
                        (§ if (valueIn.compareTo(valueOut) < 0 || 0 < valueIn.compareTo(params.getMaxMoney())))
                            (§ throw new VerificationException("Transaction input value out of range"))
                        (§ ass totalFees = totalFees.add(valueIn.subtract(valueOut)))
                    )

                    (§ if (!isCoinBase))
                    (ß
                        ;; Because correctlySpends modifies transactions, this must come after we are done with tx.
                        (§ var FutureTask<VerificationException> future = new FutureTask<>(new Verifier(tx, prevOutScripts, verifyFlags)))
                        (§ call scriptVerificationExecutor.execute(future))
                        (§ call listScriptVerificationResults.add(future))
                    )
                )
                (§ if (0 < totalFees.compareTo(params.getMaxMoney()) || newBlock.getHeader().getBlockInflation(newBlock.getHeight()).add(totalFees).compareTo(coinbaseValue) < 0))
                    (§ throw new VerificationException("Transaction fees out of range"))

                (§ ass txOutChanges = new TransactionOutputChanges(txOutsCreated, txOutsSpent))
                (§ for (Future<VerificationException> future :for listScriptVerificationResults))
                (ß
                    (§ var VerificationException e)
                    (§ try)
                    (ß
                        (§ ass e = future.get())
                    )
                    (§ catch (InterruptedException ie))
                    (ß
                        (§ throw new RuntimeException(ie)) ;; Shouldn't happen.
                    )
                    (§ catch (ExecutionException ee))
                    (ß
                        (§ call log.error("Script.correctlySpends threw a non-normal exception: " + ee.getCause()))
                        (§ throw new VerificationException("Bug in Script.correctlySpends, likely script malformed in some new and interesting way.", ee))
                    )
                    (§ if (e != nil))
                        (§ throw e)
                )
            )
            (§ else)
            (ß
                (§ ass txOutChanges = block.getTxOutChanges())
                (§ if (!params.isCheckpoint(newBlock.getHeight())))
                    (§ for (UTXO out :for txOutChanges.txOutsCreated))
                    (ß
                        (§ var Sha256Hash hash = out.getHash())
                        (§ if (blockStore.getTransactionOutput(hash, out.getIndex()) != nil))
                            (§ throw new VerificationException("Block failed BIP30 test!"))
                    )
                (§ for (UTXO out :for txOutChanges.txOutsCreated))
                    (§ call blockStore.addUnspentTransactionOutput(out))
                (§ for (UTXO out :for txOutChanges.txOutsSpent))
                    (§ call blockStore.removeUnspentTransactionOutput(out))
            )
        )
        (§ catch (VerificationException e))
        (ß
            (§ call scriptVerificationExecutor.shutdownNow())
            (§ call blockStore.abortDatabaseBatchWrite())
            (§ throw e)
        )
        (§ catch (BlockStoreException e))
        (ß
            (§ call scriptVerificationExecutor.shutdownNow())
            (§ call blockStore.abortDatabaseBatchWrite())
            (§ throw e)
        )
        (§ return txOutChanges)
    )

    ;;;
     ; This is broken for blocks that do not pass BIP30, so all BIP30-failing blocks which are allowed to fail BIP30
     ; must be checkpointed.
     ;;
    #_override
    #_protected
    (§ method void disconnectTransactions(StoredBlock oldBlock))
        (§ throws PrunedException, BlockStoreException)
    (ß
        (§ call Preconditions.checkState(lock.isHeldByCurrentThread()))
        (§ call blockStore.beginDatabaseBatchWrite())
        (§ try)
        (ß
            (§ var StoredUndoableBlock undoBlock = blockStore.getUndoBlock(oldBlock.getHeader().getHash()))
            (§ if (undoBlock == nil))
                (§ throw new PrunedException(oldBlock.getHeader().getHash()))

            (§ var TransactionOutputChanges txOutChanges = undoBlock.getTxOutChanges())
            (§ for (UTXO out :for txOutChanges.txOutsSpent))
                (§ call blockStore.addUnspentTransactionOutput(out))
            (§ for (UTXO out :for txOutChanges.txOutsCreated))
                (§ call blockStore.removeUnspentTransactionOutput(out))
        )
        (§ catch (PrunedException e))
        (ß
            (§ call blockStore.abortDatabaseBatchWrite())
            (§ throw e)
        )
        (§ catch (BlockStoreException e))
        (ß
            (§ call blockStore.abortDatabaseBatchWrite())
            (§ throw e)
        )
    )

    #_override
    #_protected
    (§ method void doSetChainHead(StoredBlock chainHead))
        (§ throws BlockStoreException)
    (ß
        (§ call Preconditions.checkState(lock.isHeldByCurrentThread()))
        (§ call blockStore.setVerifiedChainHead(chainHead))
        (§ call blockStore.commitDatabaseBatchWrite())
    )

    #_override
    #_protected
    (§ method void notSettingChainHead())
        (§ throws BlockStoreException)
    (ß
        (§ call blockStore.abortDatabaseBatchWrite())
    )

    #_override
    #_protected
    (§ method StoredBlock getStoredBlockInCurrentScope(Sha256Hash hash))
        (§ throws BlockStoreException)
    (ß
        (§ call Preconditions.checkState(lock.isHeldByCurrentThread()))
        (§ return blockStore.getOnceUndoableStoredBlock(hash))
    )
)

#_(ns org.bitcoinj.core #_"GetAddrMessage")

;;;
 ; <p>Represents the "getaddr" P2P protocol message, which requests network {@link AddressMessage}s from a peer.
 ; Not to be confused with {@link Address} which is sort of like an account number.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class GetAddrMessage extends EmptyMessage
    #_public
    (§ constructor GetAddrMessage(NetworkParameters params))
    (ß
        (§ super (params))
    )
)

#_(ns org.bitcoinj.core #_"GetBlocksMessage"
    (:import [java.io IOException OutputStream]
             [java.util ArrayList List]))

;;;
 ; <p>Represents the "getblocks" P2P network message, which requests the hashes of the parts of the block chain we're missing.
 ; Those blocks can then be downloaded with a {@link GetDataMessage}.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class GetBlocksMessage extends Message
    #_protected
    (§ field long version)
    #_protected
    (§ field List<Sha256Hash> locator)
    #_protected
    (§ field Sha256Hash stopHash)

    #_public
    (§ constructor GetBlocksMessage(NetworkParameters params, List<Sha256Hash> locator, Sha256Hash stopHash))
    (ß
        (§ super (params))

        (§ ass this.version = protocolVersion)
        (§ ass this.locator = locator)
        (§ ass this.stopHash = stopHash)
    )

    #_public
    (§ constructor GetBlocksMessage(NetworkParameters params, byte[] payload))
        (§ throws ProtocolException)
    (ß
        (§ super (params, payload, 0))
    )

    #_override
    #_protected
    (§ method void parse())
        (§ throws ProtocolException)
    (ß
        (§ ass cursor = offset)
        (§ ass version = readUint32())
        (§ var int startCount = (int)readVarInt())
        (§ if (500 < startCount))
            (§ throw new ProtocolException("Number of locators cannot be > 500, received: " + startCount))

        (§ ass length = cursor - offset + ((startCount + 1) * 32))
        (§ ass locator = new ArrayList<>(startCount))
        (§ for (int i = 0 :for i < startCount :for i = i + 1))
            (§ call locator.add(readHash()))
        (§ ass stopHash = readHash())
    )

    #_public
    (§ method List<Sha256Hash> getLocator())
    (ß
        (§ return locator)
    )

    #_public
    (§ method Sha256Hash getStopHash())
    (ß
        (§ return stopHash)
    )

    #_override
    #_public
    (§ method String toString())
    (ß
        (§ return "getblocks: " + Utils.SPACE_JOINER.join(locator))
    )

    #_override
    #_protected
    (§ method void bitcoinSerializeToStream(OutputStream stream))
        (§ throws IOException)
    (ß
        ;; Version, for some reason.
        (§ call Utils.uint32ToByteStreamLE(params.getProtocolVersionNum(NetworkParameters.ProtocolVersion.CURRENT), stream))
        ;; Then a vector of block hashes.  This is actually a "block locator", a set of block
        ;; identifiers that spans the entire chain with exponentially increasing gaps between
        ;; them, until we end up at the genesis block.  See CBlockLocator::Set().
        (§ call stream.write(new VarInt(locator.size()).encode()))
        (§ for (Sha256Hash hash :for locator))
        (ß
            ;; Have to reverse as wire format is little endian.
            (§ call stream.write(hash.getReversedBytes()))
        )
        ;; Next, a block ID to stop at.
        (§ call stream.write(stopHash.getReversedBytes()))
    )

    #_override
    #_public
    (§ method boolean equals(Object o))
    (ß
        (§ if (this == o))
            (§ return true)
        (§ if (o == nil || getClass() != o.getClass()))
            (§ return false)
        (§ var GetBlocksMessage other = (GetBlocksMessage)o)
        (§ return (version == other.version && stopHash.equals(other.stopHash) && locator.size() == other.locator.size() && locator.containsAll(other.locator))) ;; ignores locator ordering
    )

    #_override
    #_public
    (§ method int hashCode())
    (ß
        (§ var int hashCode = (int)version :xor "getblocks".hashCode() :xor stopHash.hashCode())
        (§ for (Sha256Hash l :for locator))
            (§ ass hashCode = hashCode :xor l.hashCode()) ;; ignores locator ordering
        (§ return hashCode)
    )
)

#_(ns org.bitcoinj.core #_"GetDataMessage")

;;;
 ; <p>Represents the "getdata" P2P network message, which requests the contents of blocks or transactions given their hashes.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class GetDataMessage extends ListMessage
    #_public
    (§ constructor GetDataMessage(NetworkParameters params, byte[] payloadBytes))
        (§ throws ProtocolException)
    (ß
        (§ super (params, payloadBytes))
    )

    ;;;
     ; Deserializes a 'getdata' message.
     ; @param params NetworkParameters object.
     ; @param payload Bitcoin protocol formatted byte array containing message content.
     ; @param serializer The serializer to use for this message.
     ; @param length The length of message if known.  Usually this is provided when deserializing of the wire
     ; as the length will be provided as part of the header.  Set to Message.UNKNOWN_LENGTH, if not known.
     ; @throws ProtocolException
     ;;
    #_public
    (§ constructor GetDataMessage(NetworkParameters params, byte[] payload, MessageSerializer serializer, int length))
        (§ throws ProtocolException)
    (ß
        (§ super (params, payload, serializer, length))
    )

    #_public
    (§ constructor GetDataMessage(NetworkParameters params))
    (ß
        (§ super (params))
    )

    #_public
    (§ method void addTransaction(Sha256Hash hash))
    (ß
        (§ call addItem(new InventoryItem(InventoryItem.Type.Transaction, hash)))
    )

    #_public
    (§ method void addBlock(Sha256Hash hash))
    (ß
        (§ call addItem(new InventoryItem(InventoryItem.Type.Block, hash)))
    )

    #_public
    (§ method void addFilteredBlock(Sha256Hash hash))
    (ß
        (§ call addItem(new InventoryItem(InventoryItem.Type.FilteredBlock, hash)))
    )

    #_public
    (§ method Sha256Hash getHashOf(int i))
    (ß
        (§ return getItems().get(i).hash)
    )
)

#_(ns org.bitcoinj.core #_"GetHeadersMessage"
    (:import [java.util List]))

;;;
 ; <p>The "getheaders" command is structurally identical to "getblocks", but has different meaning.  On receiving this
 ; message a Bitcoin node returns matching blocks up to the limit, but without the bodies.  It is useful as an
 ; optimization: when your wallet does not contain any keys created before a particular time, you don't have to download
 ; the bodies for those blocks because you know there are no relevant transactions.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class GetHeadersMessage extends GetBlocksMessage
    #_public
    (§ constructor GetHeadersMessage(NetworkParameters params, List<Sha256Hash> locator, Sha256Hash stopHash))
    (ß
        (§ super (params, locator, stopHash))
    )

    #_public
    (§ constructor GetHeadersMessage(NetworkParameters params, byte[] payload))
        (§ throws ProtocolException)
    (ß
        (§ super (params, payload))
    )

    #_override
    #_public
    (§ method String toString())
    (ß
        (§ return "getheaders: " + Utils.SPACE_JOINER.join(locator))
    )

    ;;;
     ; Compares two getheaders messages.  Note that even though they are structurally identical a GetHeadersMessage
     ; will not compare equal to a GetBlocksMessage containing the same data.
     ;;
    #_override
    #_public
    (§ method boolean equals(Object o))
    (ß
        (§ if (this == o))
            (§ return true)
        (§ if (o == nil || getClass() != o.getClass()))
            (§ return false)
        (§ var GetHeadersMessage other = (GetHeadersMessage)o)
        (§ return (version == other.version && stopHash.equals(other.stopHash) && locator.size() == other.locator.size() && locator.containsAll(other.locator))) ;; ignores locator ordering
    )

    #_override
    #_public
    (§ method int hashCode())
    (ß
        (§ var int hashCode = (int)version :xor "getheaders".hashCode() :xor stopHash.hashCode())
        (§ for (Sha256Hash l :for locator))
            (§ ass hashCode = hashCode :xor l.hashCode()) ;; ignores locator ordering
        (§ return hashCode)
    )
)

#_(ns org.bitcoinj.core #_"HeadersMessage"
    (:import [java.io IOException OutputStream]
             [java.util ArrayList Arrays List])
    (:import [org.slf4j Logger LoggerFactory]))

;;;
 ; <p>A protocol message that contains a repeated series of block headers, sent in response to the "getheaders" command.
 ; This is useful when you want to traverse the chain but know you don't care about the block contents, for example,
 ; because you have a freshly created wallet with no keys.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class HeadersMessage extends Message
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(HeadersMessage.class))

    ;; The main client will never send us more than this number of headers.
    #_public
    #_static
    #_final
    (§ field int MAX_HEADERS = 2000)

    #_private
    (§ field List<Block> blockHeaders)

    #_public
    (§ constructor HeadersMessage(NetworkParameters params, byte[] payload))
        (§ throws ProtocolException)
    (ß
        (§ super (params, payload, 0))
    )

    #_public
    (§ constructor HeadersMessage(NetworkParameters params, Block... headers))
        (§ throws ProtocolException)
    (ß
        (§ super (params))
        (§ ass blockHeaders = Arrays.asList(headers))
    )

    #_public
    (§ constructor HeadersMessage(NetworkParameters params, List<Block> headers))
        (§ throws ProtocolException)
    (ß
        (§ super (params))
        (§ ass blockHeaders = headers)
    )

    #_override
    #_public
    (§ method void bitcoinSerializeToStream(OutputStream stream))
        (§ throws IOException)
    (ß
        (§ call stream.write(new VarInt(blockHeaders.size()).encode()))
        (§ for (Block header :for blockHeaders))
        (ß
            (§ call header.cloneAsHeader().bitcoinSerializeToStream(stream))
            (§ call stream.write(0))
        )
    )

    #_override
    #_protected
    (§ method void parse())
        (§ throws ProtocolException)
    (ß
        (§ var long numHeaders = readVarInt())
        (§ if (MAX_HEADERS < numHeaders))
            (§ throw new ProtocolException("Too many headers: got " + numHeaders + " which is larger than " + MAX_HEADERS))

        (§ ass blockHeaders = new ArrayList<>())
        #_final
        (§ var BitcoinSerializer serializer = this.params.getSerializer(true))

        (§ for (int i = 0 :for i < numHeaders :for i = i + 1))
        (ß
            #_final
            (§ var Block newBlockHeader = serializer.makeBlock(payload, cursor, UNKNOWN_LENGTH))
            (§ if (newBlockHeader.hasTransactions()))
                (§ throw new ProtocolException("Block header does not end with a nil byte"))

            (§ ass cursor = cursor + newBlockHeader.optimalEncodingMessageSize)
            (§ call blockHeaders.add(newBlockHeader))
        )

        (§ if (length == UNKNOWN_LENGTH))
            (§ ass length = cursor - offset)

        (§ if (log.isDebugEnabled()))
            (§ for (int i = 0 :for i < numHeaders :for i = i + 1))
                (§ call log.debug(this.blockHeaders.get(i).toString()))
    )

    #_public
    (§ method List<Block> getBlockHeaders())
    (ß
        (§ return blockHeaders)
    )
)

#_(ns org.bitcoinj.core #_"InsufficientMoneyException"
    (:import [com.google.common.base Preconditions]))

;;;
 ; Thrown to indicate that you don't have enough money available to perform the requested operation.
 ;;
#_public
(§ class InsufficientMoneyException extends Exception
    ;;; Contains the number of satoshis that would have been required to complete the operation. ;;
    #_nilable
    #_public
    #_final
    (§ field Coin missing)

    #_protected
    (§ constructor InsufficientMoneyException())
    (ß
        (§ ass this.missing = nil)
    )

    #_public
    (§ constructor InsufficientMoneyException(Coin missing))
    (ß
        (§ this (missing, "Insufficient money,  missing " + missing.toFriendlyString()))
    )

    #_public
    (§ constructor InsufficientMoneyException(Coin missing, String message))
    (ß
        (§ super (message))
        (§ ass this.missing = Preconditions.checkNotNull(missing))
    )
)

#_(ns org.bitcoinj.core #_"InventoryItem"
    (:import [com.google.common.base Objects]))

#_public
(§ class InventoryItem
    ;;;
     ; 4 byte uint32 type field + 32 byte hash
     ;;
    #_static
    #_final
    (§ field int MESSAGE_LENGTH = 36)

    #_public
    (§ enum Type
        (§ item Error)
        (§ item Transaction)
        (§ item Block)
        (§ item FilteredBlock)
    )

    #_public
    #_final
    (§ field Type type)
    #_public
    #_final
    (§ field Sha256Hash hash)

    #_public
    (§ constructor InventoryItem(Type type, Sha256Hash hash))
    (ß
        (§ ass this.type = type)
        (§ ass this.hash = hash)
    )

    #_override
    #_public
    (§ method String toString())
    (ß
        (§ return type + ": " + hash)
    )

    #_override
    #_public
    (§ method boolean equals(Object o))
    (ß
        (§ if (this == o))
            (§ return true)
        (§ if (o == nil || getClass() != o.getClass()))
            (§ return false)
        (§ var InventoryItem other = (InventoryItem)o)
        (§ return (type == other.type && hash.equals(other.hash)))
    )

    #_override
    #_public
    (§ method int hashCode())
    (ß
        (§ return Objects.hashCode(type, hash))
    )
)

#_(ns org.bitcoinj.core #_"InventoryMessage"
    (:import [com.google.common.base Preconditions]))

;;;
 ; <p>Represents the "inv" P2P network message.  An inv contains a list of hashes of either blocks or transactions.
 ; It's a bandwidth optimization - on receiving some data, a (fully validating) peer sends every connected peer an inv
 ; containing the hash of what it saw.  It'll only transmit the full thing if a peer asks for it with a
 ; {@link GetDataMessage}.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class InventoryMessage extends ListMessage
    ;;; A hard coded constant in the protocol. ;;
    #_public
    #_static
    #_final
    (§ field int MAX_INV_SIZE = 50000)

    #_public
    (§ constructor InventoryMessage(NetworkParameters params, byte[] bytes))
        (§ throws ProtocolException)
    (ß
        (§ super (params, bytes))
    )

    ;;;
     ; Deserializes an 'inv' message.
     ; @param params NetworkParameters object.
     ; @param payload Bitcoin protocol formatted byte array containing message content.
     ; @param serializer The serializer to use for this message.
     ; @param length The length of message if known.  Usually this is provided when deserializing of the wire
     ; as the length will be provided as part of the header.  Set to Message.UNKNOWN_LENGTH, if not known.
     ; @throws ProtocolException
     ;;
    #_public
    (§ constructor InventoryMessage(NetworkParameters params, byte[] payload, MessageSerializer serializer, int length))
        (§ throws ProtocolException)
    (ß
        (§ super (params, payload, serializer, length))
    )

    #_public
    (§ constructor InventoryMessage(NetworkParameters params))
    (ß
        (§ super (params))
    )

    #_public
    (§ method void addBlock(Block block))
    (ß
        (§ call addItem(new InventoryItem(InventoryItem.Type.Block, block.getHash())))
    )

    #_public
    (§ method void addTransaction(Transaction tx))
    (ß
        (§ call addItem(new InventoryItem(InventoryItem.Type.Transaction, tx.getHash())))
    )

    ;;; Creates a new inv message for the given transactions. ;;
    #_public
    #_static
    (§ method InventoryMessage with(Transaction... txs))
    (ß
        (§ call Preconditions.checkArgument(0 < txs.length))
        (§ var InventoryMessage result = new InventoryMessage(txs[0].getParams()))
        (§ for (Transaction tx :for txs))
            (§ call result.addTransaction(tx))
        (§ return result)
    )
)

#_(ns org.bitcoinj.core #_"ListMessage"
    (:import [java.io IOException OutputStream]
             [java.util ArrayList Collections List]))

;;;
 ; <p>Abstract superclass of classes with list based payload, i.e. InventoryMessage and GetDataMessage.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
#_abstract
(§ class ListMessage extends Message
    #_public
    #_static
    #_final
    (§ field long MAX_INVENTORY_ITEMS = 50000)

    #_private
    (§ field long arrayLen)
    ;; For some reason the compiler complains if this is inside InventoryItem.
    #_protected
    (§ field List<InventoryItem> items)

    #_public
    (§ constructor ListMessage(NetworkParameters params, byte[] bytes))
        (§ throws ProtocolException)
    (ß
        (§ super (params, bytes, 0))
    )

    #_public
    (§ constructor ListMessage(NetworkParameters params, byte[] payload, MessageSerializer serializer, int length))
        (§ throws ProtocolException)
    (ß
        (§ super (params, payload, 0, serializer, length))
    )

    #_public
    (§ constructor ListMessage(NetworkParameters params))
    (ß
        (§ super (params))

        (§ ass items = new ArrayList<>())
        (§ ass length = 1) ;; length of 0 varint
    )

    #_public
    (§ method List<InventoryItem> getItems())
    (ß
        (§ return Collections.unmodifiableList(items))
    )

    #_public
    (§ method void addItem(InventoryItem item))
    (ß
        (§ call unCache())
        (§ ass length = length - VarInt.sizeOf(items.size()))
        (§ call items.add(item))
        (§ ass length = length + VarInt.sizeOf(items.size()) + InventoryItem.MESSAGE_LENGTH)
    )

    #_public
    (§ method void removeItem(int index))
    (ß
        (§ call unCache())
        (§ ass length = length - VarInt.sizeOf(items.size()))
        (§ call items.remove(index))
        (§ ass length = length + VarInt.sizeOf(items.size()) - InventoryItem.MESSAGE_LENGTH)
    )

    #_override
    #_protected
    (§ method void parse())
        (§ throws ProtocolException)
    (ß
        (§ ass arrayLen = readVarInt())
        (§ if (MAX_INVENTORY_ITEMS < arrayLen))
            (§ throw new ProtocolException("Too many items in INV message: " + arrayLen))
        (§ ass length = (int)(cursor - offset + (arrayLen * InventoryItem.MESSAGE_LENGTH)))

        ;; An inv is vector<CInv> where CInv is int+hash.  The int is either 1 or 2 for tx or block.
        (§ ass items = new ArrayList<>((int)arrayLen))
        (§ for (int i = 0 :for i < arrayLen :for i = i + 1))
        (ß
            (§ if (payload.length < cursor + InventoryItem.MESSAGE_LENGTH))
                (§ throw new ProtocolException("Ran off the end of the INV"))

            (§ var int typeCode = (int)readUint32())
            (§ var InventoryItem.Type type)
            ;; see ppszTypeName in net.h
            (§ switch (typeCode))
            (ß
                (§ case 0)
                    (§ ass type = InventoryItem.Type.Error)
                    (§ break)
                (§ case 1)
                    (§ ass type = InventoryItem.Type.Transaction)
                    (§ break)
                (§ case 2)
                    (§ ass type = InventoryItem.Type.Block)
                    (§ break)
                (§ case 3)
                    (§ ass type = InventoryItem.Type.FilteredBlock)
                    (§ break)
                (§ default)
                    (§ throw new ProtocolException("Unknown CInv type: " + typeCode))
            )
            (§ call items.add(new InventoryItem(type, readHash())))
        )
        (§ ass payload = nil)
    )

    #_override
    #_public
    (§ method void bitcoinSerializeToStream(OutputStream stream))
        (§ throws IOException)
    (ß
        (§ call stream.write(new VarInt(items.size()).encode()))
        (§ for (InventoryItem i :for items))
        (ß
            ;; Write out the type code.
            (§ call Utils.uint32ToByteStreamLE(i.type.ordinal(), stream))
            ;; And now the hash.
            (§ call stream.write(i.hash.getReversedBytes()))
        )
    )

    #_override
    #_public
    (§ method boolean equals(Object o))
    (ß
        (§ if (this == o))
            (§ return true)
        (§ if (o == nil || getClass() != o.getClass()))
            (§ return false)
        (§ return items.equals(((ListMessage)o).items))
    )

    #_override
    #_public
    (§ method int hashCode())
    (ß
        (§ return items.hashCode())
    )
)

#_(ns org.bitcoinj.core #_"MemoryPoolMessage"
    (:import [java.io IOException OutputStream]))

;;;
 ; <p>The "mempool" message asks a remote peer to announce all transactions in its memory pool, possibly restricted by
 ; any Bloom filter set on the connection.  The list of transaction hashes comes back in an inv message.  Note that
 ; this is different to the {@link TxConfidenceTable} object which doesn't try to keep track of all pending transactions,
 ; it's just a holding area for transactions that a part of the app may find interesting.  The mempool message has
 ; no fields.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class MemoryPoolMessage extends Message
    #_override
    #_protected
    (§ method void parse())
        (§ throws ProtocolException)
    (ß
    )

    #_override
    #_protected
    (§ method void bitcoinSerializeToStream(OutputStream stream))
        (§ throws IOException)
    (ß
    )
)

#_(ns org.bitcoinj.core #_"Message"
    (:import #_[java.io *]
             [java.math BigInteger]
             [java.util Arrays])
    (:import [com.google.common.base Preconditions]
             [org.slf4j Logger LoggerFactory]))

;;;
 ; <p>A Message is a data structure that can be serialized/deserialized using the Bitcoin serialization format.
 ; Specific types of messages that are used both in the block chain, and on the wire, are derived from this class.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
#_abstract
(§ class Message
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(Message.class))

    #_public
    #_static
    #_final
    (§ field int MAX_SIZE = 0x02000000) ;; 32MB

    #_public
    #_static
    #_final
    (§ field int UNKNOWN_LENGTH = Integer.MIN_VALUE)

    ;; Useful to ensure serialize/deserialize are consistent with each other.
    #_private
    #_static
    #_final
    (§ field boolean SELF_CHECK = false)

    ;; The offset is how many bytes into the provided byte array this message payload starts at.
    #_protected
    (§ field int offset)
    ;; The cursor keeps track of where we are in the byte array as we parse it.
    ;; Note that it's relative to the start of the array NOT the start of the message payload.
    #_protected
    (§ field int cursor)

    #_protected
    (§ field int length = UNKNOWN_LENGTH)

    ;; The raw message payload bytes themselves.
    #_protected
    (§ field byte[] payload)

    #_protected
    (§ field boolean recached = false)
    #_protected
    (§ field MessageSerializer serializer)

    #_protected
    (§ field int protocolVersion)

    #_protected
    (§ field NetworkParameters params)

    #_protected
    (§ constructor Message())
    (ß
        (§ ass serializer = DummySerializer.DEFAULT)
    )

    #_protected
    (§ constructor Message(NetworkParameters params))
    (ß
        (§ ass this.params = params)
        (§ ass serializer = params.getDefaultSerializer())
    )

    #_protected
    (§ constructor Message(NetworkParameters params, byte[] payload, int offset, int protocolVersion))
        (§ throws ProtocolException)
    (ß
        (§ this (params, payload, offset, protocolVersion, params.getDefaultSerializer(), UNKNOWN_LENGTH))
    )

    ;;;
     ; @param params NetworkParameters object.
     ; @param payload Bitcoin protocol formatted byte array containing message content.
     ; @param offset The location of the first payload byte within the array.
     ; @param protocolVersion Bitcoin protocol version.
     ; @param serializer The serializer to use for this message.
     ; @param length The length of message payload if known.  Usually this is provided when deserializing of the wire
     ; as the length will be provided as part of the header.  Set to Message.UNKNOWN_LENGTH, if not known.
     ; @throws ProtocolException
     ;;
    #_protected
    (§ constructor Message(NetworkParameters params, byte[] payload, int offset, int protocolVersion, MessageSerializer serializer, int length))
        (§ throws ProtocolException)
    (ß
        (§ ass this.serializer = serializer)
        (§ ass this.protocolVersion = protocolVersion)
        (§ ass this.params = params)
        (§ ass this.payload = payload)
        (§ ass this.cursor = this.offset = offset)
        (§ ass this.length = length)

        (§ call parse())

        (§ if (this.length == UNKNOWN_LENGTH))
            (§ call Preconditions.checkState(false, "Length field has not been set in constructor for %s after parse.", getClass().getSimpleName()))

        (§ if (SELF_CHECK))
            (§ call selfCheck(payload, offset))

        (§ if (!serializer.isParseRetainMode()))
            (§ ass this.payload = nil)
    )

    #_private
    (§ method void selfCheck(byte[] payload, int offset))
    (ß
        (§ if (!(this instanceof VersionMessage)))
        (ß
            (§ var byte[] payloadBytes = new byte[cursor - offset])
            (§ call System.arraycopy(payload, offset, payloadBytes, 0, cursor - offset))
            (§ var byte[] reserialized = bitcoinSerialize())
            (§ if (!Arrays.equals(reserialized, payloadBytes)))
                (§ throw new RuntimeException("Serialization is wrong: \n" + Utils.HEX.encode(reserialized) + " vs \n" + Utils.HEX.encode(payloadBytes)))
        )
    )

    #_protected
    (§ constructor Message(NetworkParameters params, byte[] payload, int offset))
        (§ throws ProtocolException)
    (ß
        (§ this (params, payload, offset, params.getProtocolVersionNum(NetworkParameters.ProtocolVersion.CURRENT), params.getDefaultSerializer(), UNKNOWN_LENGTH))
    )

    #_protected
    (§ constructor Message(NetworkParameters params, byte[] payload, int offset, MessageSerializer serializer, int length))
        (§ throws ProtocolException)
    (ß
        (§ this (params, payload, offset, params.getProtocolVersionNum(NetworkParameters.ProtocolVersion.CURRENT), serializer, length))
    )

    ;; These methods handle the serialization/deserialization using the custom Bitcoin protocol.

    #_protected
    #_abstract
    (§ method void parse())
        (§ throws ProtocolException)

    ;;;
     ; <p>To be called before any change of internal values including any setters.  This ensures any cached byte array is
     ; removed.<p/>
     ; <p>Child messages of this object (e.g. Transactions belonging to a Block) will not have their internal byte caches
     ; invalidated unless they are also modified internally.</p>
     ;;
    #_protected
    (§ method void unCache())
    (ß
        (§ ass payload = nil)
        (§ ass recached = false)
    )

    #_protected
    (§ method void adjustLength(int newArraySize, int adjustment))
    (ß
        (§ if (length == UNKNOWN_LENGTH))
            (§ return)
        ;; Our own length is now unknown if we have an unknown length adjustment.
        (§ if (adjustment == UNKNOWN_LENGTH))
        (ß
            (§ ass length = UNKNOWN_LENGTH)
            (§ return)
        )
        (§ ass length = length + adjustment)
        ;; Check if we will need more bytes to encode the length prefix.
        (§ if (newArraySize == 1))
            (§ ass length = length + 1) ;; The assumption here is we never call adjustLength with the same arraySize as before.
        (§ elseif (newArraySize != 0))
            (§ ass length = length + VarInt.sizeOf(newArraySize) - VarInt.sizeOf(newArraySize - 1))
    )

    ;;;
     ; used for unit testing
     ;;
    #_public
    (§ method boolean isCached())
    (ß
        (§ return (payload != nil))
    )

    #_public
    (§ method boolean isRecached())
    (ß
        (§ return recached)
    )

    ;;;
     ; Returns a copy of the array returned by {@link Message#unsafeBitcoinSerialize()}, which is safe to mutate.
     ; If you need extra performance and can guarantee you won't write to the array, you can use the unsafe version.
     ;
     ; @return a freshly allocated serialized byte array.
     ;;
    #_public
    (§ method byte[] bitcoinSerialize())
    (ß
        (§ var byte[] bytes = unsafeBitcoinSerialize())
        (§ var byte[] copy = new byte[bytes.length])
        (§ call System.arraycopy(bytes, 0, copy, 0, bytes.length))
        (§ return copy)
    )

    ;;;
     ; Serialize this message to a byte array that conforms to the bitcoin wire protocol.
     ; <br/>
     ; This method may return the original byte array used to construct this message if the
     ; following conditions are met:
     ; <ol>
     ; <li>1. The message was parsed from a byte array with parseRetain = true.</li>
     ; <li>2. The message has not been modified.</li>
     ; <li>3. The array had an offset of 0 and no surplus bytes.</li>
     ; </ol>
     ;
     ; If condition 3 is not met then an copy of the relevant portion of the array will be returned.
     ; Otherwise a full serialize will occur.  For this reason you should only use this API
     ; if you can guarantee you will treat the resulting array as read only.
     ;
     ; @return a byte array owned by this object, do NOT mutate it.
     ;;
    #_public
    (§ method byte[] unsafeBitcoinSerialize())
    (ß
        ;; 1st attempt to use a cached array.
        (§ if (payload != nil))
        (ß
            ;; Cached byte array is the entire message with no extras so we can return as is and avoid an array copy.
            (§ if (offset == 0 && length == payload.length))
                (§ return payload)

            (§ var byte[] buf = new byte[length])
            (§ call System.arraycopy(payload, offset, buf, 0, length))
            (§ return buf)
        )

        ;; No cached array available so serialize parts by stream.
        (§ var ByteArrayOutputStream stream = new UnsafeByteArrayOutputStream(length < 32 ? 32 :else length + 32))
        (§ try)
        (ß
            (§ call bitcoinSerializeToStream(stream))
        )
        (§ catch (IOException _))
        (ß
            ;; Cannot happen, we are serializing to a memory stream.
        )

        (§ if (serializer.isParseRetainMode()))
        (ß
            ;; A free set of steak knives!
            ;; If there happens to be a call to this method we gain an opportunity to recache
            ;; the byte array and in this case it contains no bytes from parent messages.
            ;; This give a dual benefit.  Releasing references to the larger byte array so that it
            ;; it is more likely to be GC'd.  And preventing double serializations.  E.g. calculating
            ;; merkle root calls this method.  It is will frequently happen prior to serializing the block
            ;; which means another call to bitcoinSerialize is coming.  If we didn't recache then internal
            ;; serialization would occur a 2nd time and every subsequent time the message is serialized.
            (§ ass payload = stream.toByteArray())
            (§ ass cursor = cursor - offset)
            (§ ass offset = 0)
            (§ ass recached = true)
            (§ ass length = payload.length)
            (§ return payload)
        )
        ;; Record length.  If this Message wasn't parsed from a byte stream it won't have length field
        ;; set (except for static length message types).  Setting it makes future streaming more efficient
        ;; because we can preallocate the ByteArrayOutputStream buffer and avoid resizing.
        (§ var byte[] buf = stream.toByteArray())
        (§ ass length = buf.length)
        (§ return buf)
    )

    ;;;
     ; Serialize this message to the provided OutputStream using the bitcoin wire format.
     ;
     ; @param stream
     ; @throws IOException
     ;;
    #_public
    #_final
    (§ method void bitcoinSerialize(OutputStream stream))
        (§ throws IOException)
    (ß
        ;; 1st check for cached bytes.
        (§ if (payload != nil && length != UNKNOWN_LENGTH))
        (ß
            (§ call stream.write(payload, offset, length))
            (§ return)
        )

        (§ call bitcoinSerializeToStream(stream))
    )

    ;;;
     ; Serializes this message to the provided stream.  If you just want the raw bytes use bitcoinSerialize().
     ;;
    #_protected
    (§ method void bitcoinSerializeToStream(OutputStream stream))
        (§ throws IOException)
    (ß
        (§ call log.error("Error: {} class has not implemented bitcoinSerializeToStream method.  Generating message with no payload", getClass()))
    )

    ;;;
     ; This method is a NOP for all classes except Block and Transaction.  It is only declared in Message
     ; so BitcoinSerializer can avoid 2 instanceof checks + a casting.
     ;;
    #_public
    (§ method Sha256Hash getHash())
    (ß
        (§ throw new UnsupportedOperationException())
    )

    ;;;
     ; This returns a correct value by parsing the message.
     ;;
    #_public
    #_final
    (§ method int getMessageSize())
    (ß
        (§ if (length == UNKNOWN_LENGTH))
            (§ call Preconditions.checkState(false, "Length field has not been set in %s.", getClass().getSimpleName()))
        (§ return length)
    )

    #_protected
    (§ method long readUint32())
        (§ throws ProtocolException)
    (ß
        (§ try)
        (ß
            (§ var long u = Utils.readUint32(payload, cursor))
            (§ ass cursor = cursor + 4)
            (§ return u)
        )
        (§ catch (ArrayIndexOutOfBoundsException e))
        (ß
            (§ throw new ProtocolException(e))
        )
    )

    #_protected
    (§ method long readInt64())
        (§ throws ProtocolException)
    (ß
        (§ try)
        (ß
            (§ var long u = Utils.readInt64(payload, cursor))
            (§ ass cursor = cursor + 8)
            (§ return u)
        )
        (§ catch (ArrayIndexOutOfBoundsException e))
        (ß
            (§ throw new ProtocolException(e))
        )
    )

    #_protected
    (§ method BigInteger readUint64())
        (§ throws ProtocolException)
    (ß
        ;; Java does not have an unsigned 64 bit type. So scrape it off the wire then flip.
        (§ return new BigInteger(Utils.reverseBytes(readBytes(8))))
    )

    #_protected
    (§ method long readVarInt())
        (§ throws ProtocolException)
    (ß
        (§ return readVarInt(0))
    )

    #_protected
    (§ method long readVarInt(int offset))
        (§ throws ProtocolException)
    (ß
        (§ try)
        (ß
            (§ var VarInt varint = new VarInt(payload, cursor + offset))
            (§ ass cursor = cursor + offset + varint.getOriginalSizeInBytes())
            (§ return varint.value)
        )
        (§ catch (ArrayIndexOutOfBoundsException e))
        (ß
            (§ throw new ProtocolException(e))
        )
    )

    #_protected
    (§ method byte[] readBytes(int length))
        (§ throws ProtocolException)
    (ß
        (§ if (MAX_SIZE < length))
            (§ throw new ProtocolException("Claimed value length too large: " + length))

        (§ try)
        (ß
            (§ var byte[] b = new byte[length])
            (§ call System.arraycopy(payload, cursor, b, 0, length))
            (§ ass cursor = cursor + length)
            (§ return b)
        )
        (§ catch (IndexOutOfBoundsException e))
        (ß
            (§ throw new ProtocolException(e))
        )
    )

    #_protected
    (§ method byte[] readByteArray())
        (§ throws ProtocolException)
    (ß
        (§ var long len = readVarInt())
        (§ return readBytes((int)len))
    )

    #_protected
    (§ method String readStr())
        (§ throws ProtocolException)
    (ß
        (§ var long length = readVarInt())
        (§ return (length == 0) ? "" :else Utils.toString(readBytes((int)length), "UTF-8")) ;; optimization for empty strings
    )

    #_protected
    (§ method Sha256Hash readHash())
        (§ throws ProtocolException)
    (ß
        ;; We have to flip it around, as it's been read off the wire in little endian.
        ;; Not the most efficient way to do this but the clearest.
        (§ return Sha256Hash.wrapReversed(readBytes(32)))
    )

    #_protected
    (§ method boolean hasMoreBytes())
    (ß
        (§ return (cursor < payload.length))
    )

    ;;; Network parameters this message was created with. ;;
    #_public
    (§ method NetworkParameters getParams())
    (ß
        (§ return params)
    )

    ;;;
     ; Set the serializer for this message when deserialized by Java.
     ;;
    #_private
    (§ method void readObject(java.io.ObjectInputStream in))
        (§ throws IOException, ClassNotFoundException)
    (ß
        (§ call in.defaultReadObject())
        (§ if (params != nil))
            (§ ass this.serializer = params.getDefaultSerializer())
    )
)

#_(ns org.bitcoinj.core #_"MessageSerializer"
    (:import [java.io IOException OutputStream]
             [java.nio BufferUnderflowException ByteBuffer]))

;;;
 ; Generic interface for classes which serialize/deserialize messages.
 ; Implementing classes should be immutable.
 ;;
#_public
#_abstract
(§ class MessageSerializer
    ;;;
     ; Reads a message from the given ByteBuffer and returns it.
     ;;
    #_public
    #_abstract
    (§ method Message deserialize(ByteBuffer in))
        (§ throws ProtocolException, IOException, UnsupportedOperationException)

    ;;;
     ; Deserializes only the header in case packet meta data is needed before decoding
     ; the payload.  This method assumes you have already called seekPastMagicBytes().
     ;;
    #_public
    #_abstract
    (§ method BitcoinSerializer.BitcoinPacketHeader deserializeHeader(ByteBuffer in))
        (§ throws ProtocolException, IOException, UnsupportedOperationException)

    ;;;
     ; Deserialize payload only.  You must provide a header, typically obtained by calling
     ; {@link BitcoinSerializer#deserializeHeader}.
     ;;
    #_public
    #_abstract
    (§ method Message deserializePayload(BitcoinSerializer.BitcoinPacketHeader header, ByteBuffer in))
        (§ throws ProtocolException, BufferUnderflowException, UnsupportedOperationException)

    ;;;
     ; Whether the serializer will produce cached mode Messages.
     ;;
    #_public
    #_abstract
    (§ method boolean isParseRetainMode())

    ;;;
     ; Make an address message from the payload.  Extension point for alternative
     ; serialization format support.
     ;;
    #_public
    #_abstract
    (§ method AddressMessage makeAddressMessage(byte[] payloadBytes, int length))
        (§ throws ProtocolException, UnsupportedOperationException)

    ;;;
     ; Make an alert message from the payload.  Extension point for alternative
     ; serialization format support.
     ;;
    #_public
    #_abstract
    (§ method Message makeAlertMessage(byte[] payloadBytes))
        (§ throws ProtocolException, UnsupportedOperationException)

    ;;;
     ; Make a block from the payload, using an offset of zero and the payload
     ; length as block length.
     ;;
    #_public
    #_final
    (§ method Block makeBlock(byte[] payloadBytes))
        (§ throws ProtocolException)
    (ß
        (§ return makeBlock(payloadBytes, 0, payloadBytes.length))
    )

    ;;;
     ; Make a block from the payload, using an offset of zero and the provided
     ; length as block length.
     ;;
    #_public
    #_final
    (§ method Block makeBlock(byte[] payloadBytes, int length))
        (§ throws ProtocolException)
    (ß
        (§ return makeBlock(payloadBytes, 0, length))
    )

    ;;;
     ; Make a block from the payload, using an offset of zero and the provided
     ; length as block length.  Extension point for alternative
     ; serialization format support.
     ;;
    #_public
    #_abstract
    (§ method Block makeBlock(#_final byte[] payloadBytes, #_final int offset, #_final int length))
        (§ throws ProtocolException, UnsupportedOperationException)

    ;;;
     ; Make an filter message from the payload.  Extension point for alternative
     ; serialization format support.
     ;;
    #_public
    #_abstract
    (§ method Message makeBloomFilter(byte[] payloadBytes))
        (§ throws ProtocolException, UnsupportedOperationException)

    ;;;
     ; Make a filtered block from the payload.  Extension point for alternative
     ; serialization format support.
     ;;
    #_public
    #_abstract
    (§ method FilteredBlock makeFilteredBlock(byte[] payloadBytes))
        (§ throws ProtocolException, UnsupportedOperationException)

    ;;;
     ; Make an inventory message from the payload.  Extension point for alternative
     ; serialization format support.
     ;;
    #_public
    #_abstract
    (§ method InventoryMessage makeInventoryMessage(byte[] payloadBytes, int length))
        (§ throws ProtocolException, UnsupportedOperationException)

    ;;;
     ; Make a transaction from the payload.  Extension point for alternative
     ; serialization format support.
     ;
     ; @throws UnsupportedOperationException if this serializer/deserializer
     ; does not support deserialization.  This can occur either because it's a dummy
     ; serializer (i.e. for messages with no network parameters), or because
     ; it does not support deserializing transactions.
     ;;
    #_public
    #_abstract
    (§ method Transaction makeTransaction(byte[] payloadBytes, int offset, int length, byte[] hash))
        (§ throws ProtocolException, UnsupportedOperationException)

    ;;;
     ; Make a transaction from the payload.  Extension point for alternative
     ; serialization format support.
     ;
     ; @throws UnsupportedOperationException if this serializer/deserializer
     ; does not support deserialization.  This can occur either because it's a dummy
     ; serializer (i.e. for messages with no network parameters), or because
     ; it does not support deserializing transactions.
     ;;
    #_public
    #_final
    (§ method Transaction makeTransaction(byte[] payloadBytes))
        (§ throws ProtocolException, UnsupportedOperationException)
    (ß
        (§ return makeTransaction(payloadBytes, 0))
    )

    ;;;
     ; Make a transaction from the payload.  Extension point for alternative
     ; serialization format support.
     ;
     ; @throws UnsupportedOperationException if this serializer/deserializer
     ; does not support deserialization.  This can occur either because it's a dummy
     ; serializer (i.e. for messages with no network parameters), or because
     ; it does not support deserializing transactions.
     ;;
    #_public
    #_final
    (§ method Transaction makeTransaction(byte[] payloadBytes, int offset))
        (§ throws ProtocolException)
    (ß
        (§ return makeTransaction(payloadBytes, offset, payloadBytes.length, nil))
    )

    #_public
    #_abstract
    (§ method void seekPastMagicBytes(ByteBuffer in))
        (§ throws BufferUnderflowException)

    ;;;
     ; Writes message to to the output stream.
     ;
     ; @throws UnsupportedOperationException if this serializer/deserializer
     ; does not support serialization.  This can occur either because it's a dummy
     ; serializer (i.e. for messages with no network parameters), or because
     ; it does not support serializing the given message.
     ;;
    #_public
    #_abstract
    (§ method void serialize(String name, byte[] message, OutputStream out))
        (§ throws IOException, UnsupportedOperationException)

    ;;;
     ; Writes message to to the output stream.
     ;
     ; @throws UnsupportedOperationException if this serializer/deserializer
     ; does not support serialization.  This can occur either because it's a dummy
     ; serializer (i.e. for messages with no network parameters), or because
     ; it does not support serializing the given message.
     ;;
    #_public
    #_abstract
    (§ method void serialize(Message message, OutputStream out))
        (§ throws IOException, UnsupportedOperationException)
)

#_(ns org.bitcoinj.core #_"Monetary"
    (:import [java.io Serializable]))

;;;
 ; Classes implementing this interface represent a monetary value, such as a Bitcoin or fiat amount.
 ;;
#_public
(§ interface Monetary extends Serializable
    ;;;
     ; Returns the absolute value of exponent of the value of a "smallest unit" in scientific notation.
     ; For Bitcoin, a satoshi is worth 1E-8 so this would be 8.
     ;;
    (§ method int smallestUnitExponent())

    ;;;
     ; Returns the number of "smallest units" of this monetary value.
     ; For Bitcoin, this would be the number of satoshis.
     ;;
    (§ method long getValue())

    (§ method int signum())
)

#_(ns org.bitcoinj.core #_"NetworkParameters"
    (:import #_[java.io *]
             #_[java.math *]
             #_[java.util *])
    (:import [com.google.common.base Objects])
  #_(:require [org.bitcoinj.core Block]
             #_static #_[org.bitcoinj.core.Coin *]
             [org.bitcoinj.core StoredBlock VerificationException]
             #_[org.bitcoinj.net.discovery *]
             #_[org.bitcoinj.params *]
             #_[org.bitcoinj.script *]
             [org.bitcoinj.store BlockStore BlockStoreException]
             [org.bitcoinj.utils MonetaryFormat VersionTally]))

;;;
 ; <p>NetworkParameters contains the data needed for working with an instantiation of a Bitcoin chain.</p>
 ;
 ; <p>This is an abstract class, concrete instantiations can be found in the params package.  There are four:
 ; one for the main network ({@link MainNetParams}), one for the public test network, and two others that are
 ; intended for unit testing and local app development purposes.  Although this class contains some aliases for
 ; them, you are encouraged to call the static get() methods on each specific params class directly.</p>
 ;;
#_public
#_abstract
(§ class NetworkParameters
    ;;;
     ; The alert signing key originally owned by Satoshi, and now passed on to Gavin along with a few others.
     ;;
    #_public
    #_static
    #_final
    (§ field byte[] SATOSHI_KEY = Utils.HEX.decode("04fc9702847840aaf195de8442ebecedf5b095cdbb9bc716bda9110971b28a49e0ead8564ff0db22209e0374782c093bb899692d524e9d6a6956e7c5ecbcd68284"))

    ;;; The string returned by getId() for the main, production network where people trade things. ;;
    #_public
    #_static
    #_final
    (§ field String ID_MAINNET = "org.bitcoin.production")
    ;;; The string returned by getId() for the testnet. ;;
    #_public
    #_static
    #_final
    (§ field String ID_TESTNET = "org.bitcoin.test")
    ;;; Unit test network. ;;
    #_public
    #_static
    #_final
    (§ field String ID_UNITTESTNET = "org.bitcoinj.unittest")

    ;;; The string used by the payment protocol to represent the main net. ;;
    #_public
    #_static
    #_final
    (§ field String PAYMENT_PROTOCOL_ID_MAINNET = "main")
    ;;; The string used by the payment protocol to represent the test net. ;;
    #_public
    #_static
    #_final
    (§ field String PAYMENT_PROTOCOL_ID_TESTNET = "test")
    ;;; The string used by the payment protocol to represent unit testing (note that this is non-standard). ;;
    #_public
    #_static
    #_final
    (§ field String PAYMENT_PROTOCOL_ID_UNIT_TESTS = "unittest")

    ;; TODO: Seed nodes should be here as well.

    #_protected
    (§ field Block genesisBlock)
    #_protected
    (§ field BigInteger maxTarget)
    #_protected
    (§ field int port)
    #_protected
    (§ field long packetMagic) ;; Indicates message origin network and is used to seek to the next message when stream state is unknown.
    #_protected
    (§ field int addressHeader)
    #_protected
    (§ field int p2shHeader)
    #_protected
    (§ field int interval)
    #_protected
    (§ field int targetTimespan)
    #_protected
    (§ field byte[] alertSigningKey)
    #_protected
    (§ field int bip32HeaderPub)
    #_protected
    (§ field int bip32HeaderPriv)

    ;;; Used to check majorities for block version upgrade. ;;
    #_protected
    (§ field int majorityEnforceBlockUpgrade)
    #_protected
    (§ field int majorityRejectBlockOutdated)
    #_protected
    (§ field int majorityWindow)

    ;;;
     ; See getId().  This may be null for old deserialized wallets.  In that case we derive it heuristically
     ; by looking at the port number.
     ;;
    #_protected
    (§ field String id)

    ;;;
     ; The depth of blocks required for a coinbase transaction to be spendable.
     ;;
    #_protected
    (§ field int spendableCoinbaseDepth)
    #_protected
    (§ field int subsidyDecreaseBlockCount)

    #_protected
    (§ field int[] acceptableAddressCodes)
    #_protected
    (§ field String[] dnsSeeds)
    #_protected
    (§ field int[] addrSeeds)
    #_protected
    (§ field Map<Integer, Sha256Hash> checkpoints = new HashMap<>())
    #_protected
    #_transient
    (§ field MessageSerializer defaultSerializer)

    #_protected
    (§ constructor NetworkParameters())
    (ß
        (§ ass alertSigningKey = SATOSHI_KEY)
        (§ ass genesisBlock = createGenesis(this))
    )

    #_private
    #_static
    (§ method Block createGenesis(NetworkParameters n))
    (ß
        (§ var Block genesisBlock = new Block(n, Block.BLOCK_VERSION_GENESIS))
        (§ var Transaction t = new Transaction(n))
        (§ try)
        (ß
            ;; A script containing the difficulty bits and the following message: "The Times 03/Jan/2009 Chancellor on brink of second bailout for banks".
            (§ var byte[] bytes = Utils.HEX.decode("04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73"))
            (§ call t.addInput(new TransactionInput(n, t, bytes)))
            (§ var ByteArrayOutputStream scriptPubKeyBytes = new ByteArrayOutputStream())
            (§ call Script.writeBytes(scriptPubKeyBytes, Utils.HEX.decode("04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f")))
            (§ call scriptPubKeyBytes.write(ScriptOpCodes.OP_CHECKSIG))
            (§ call t.addOutput(new TransactionOutput(n, t, FIFTY_COINS, scriptPubKeyBytes.toByteArray())))
        )
        (§ catch (Exception e))
        (ß
            (§ throw new RuntimeException(e)) ;; Cannot happen.
        )
        (§ call genesisBlock.addTransaction(t))
        (§ return genesisBlock)
    )

    #_public
    #_static
    #_final
    (§ field int TARGET_TIMESPAN = 14 * 24 * 60 * 60) ;; 2 weeks per difficulty cycle, on average.
    #_public
    #_static
    #_final
    (§ field int TARGET_SPACING = 10 * 60) ;; 10 minutes per block.
    #_public
    #_static
    #_final
    (§ field int INTERVAL = TARGET_TIMESPAN / TARGET_SPACING)

    ;;;
     ; Blocks with a timestamp after this should enforce BIP 16, aka "Pay to script hash".  This BIP changed
     ; the network rules in a soft-forking manner, that is, blocks that don't follow the rules are accepted
     ; but not mined upon and thus will be quickly re-orged out as long as the majority are enforcing the rule.
     ;;
    #_public
    #_static
    #_final
    (§ field int BIP16_ENFORCE_TIME = 1333238400)

    ;;;
     ; The maximum number of coins to be generated.
     ;;
    #_public
    #_static
    #_final
    (§ field long MAX_COINS = 21000000)

    ;;;
     ; The maximum money to be generated.
     ;;
    #_public
    #_static
    #_final
    (§ field Coin MAX_MONEY = COIN.multiply(MAX_COINS))

    ;;;
     ; A Java package style string acting as unique ID for these parameters.
     ;;
    #_public
    (§ method String getId())
    (ß
        (§ return id)
    )

    #_public
    #_abstract
    (§ method String getPaymentProtocolId())

    #_override
    #_public
    (§ method boolean equals(Object o))
    (ß
        (§ if (this == o))
            (§ return true)
        (§ if (o == nil || getClass() != o.getClass()))
            (§ return false)
        (§ return getId().equals(((NetworkParameters)o).getId()))
    )

    #_override
    #_public
    (§ method int hashCode())
    (ß
        (§ return Objects.hashCode(getId()))
    )

    ;;; Returns the network parameters for the given string ID or NULL if not recognized. ;;
    #_nilable
    #_public
    #_static
    (§ method NetworkParameters fromID(String id))
    (ß
        (§ if (id.equals(ID_MAINNET)))
            (§ return MainNetParams.get())
        (§ if (id.equals(ID_TESTNET)))
            (§ return TestNet3Params.get())
        (§ if (id.equals(ID_UNITTESTNET)))
            (§ return UnitTestParams.get())
        (§ return nil)
    )

    ;;; Returns the network parameters for the given string paymentProtocolID or NULL if not recognized. ;;
    #_nilable
    #_public
    #_static
    (§ method NetworkParameters fromPmtProtocolID(String pmtProtocolId))
    (ß
        (§ if (pmtProtocolId.equals(PAYMENT_PROTOCOL_ID_MAINNET)))
            (§ return MainNetParams.get())
        (§ if (pmtProtocolId.equals(PAYMENT_PROTOCOL_ID_TESTNET)))
            (§ return TestNet3Params.get())
        (§ if (pmtProtocolId.equals(PAYMENT_PROTOCOL_ID_UNIT_TESTS)))
            (§ return UnitTestParams.get())
        (§ return nil)
    )

    #_public
    (§ method int getSpendableCoinbaseDepth())
    (ß
        (§ return spendableCoinbaseDepth)
    )

    ;;;
     ; Throws an exception if the block's difficulty is not correct.
     ;
     ; @throws VerificationException if the block's difficulty is not correct.
     ;;
    #_public
    #_abstract
    (§ method void checkDifficultyTransitions(StoredBlock storedPrev, Block next, #_final BlockStore blockStore))
        (§ throws VerificationException, BlockStoreException)

    ;;;
     ; Returns true if the block height is either not a checkpoint, or is a checkpoint and the hash matches.
     ;;
    #_public
    (§ method boolean passesCheckpoint(int height, Sha256Hash hash))
    (ß
        (§ var Sha256Hash checkpointHash = checkpoints.get(height))
        (§ return (checkpointHash == nil || checkpointHash.equals(hash)))
    )

    ;;;
     ; Returns true if the given height has a recorded checkpoint.
     ;;
    #_public
    (§ method boolean isCheckpoint(int height))
    (ß
        (§ var Sha256Hash checkpointHash = checkpoints.get(height))
        (§ return (checkpointHash != nil))
    )

    #_public
    (§ method int getSubsidyDecreaseBlockCount())
    (ß
        (§ return subsidyDecreaseBlockCount)
    )

    ;;; Returns DNS names that when resolved, give IP addresses of active peers. ;;
    #_public
    (§ method String[] getDnsSeeds())
    (ß
        (§ return dnsSeeds)
    )

    ;;; Returns IP address of active peers. ;;
    #_public
    (§ method int[] getAddrSeeds())
    (ß
        (§ return addrSeeds)
    )

    ;;;
     ; <p>Genesis block for this chain.</p>
     ;
     ; <p>The first block in every chain is a well known constant shared between all Bitcoin implemenetations.
     ; For a block to be valid, it must be eventually possible to work backwards to the genesis block by following
     ; the prevBlockHash pointers in the block headers.</p>
     ;
     ; <p>The genesis blocks for both test and main networks contain the timestamp of when they were created,
     ; and a message in the coinbase transaction.  It says,
     ; <i>"The Times 03/Jan/2009 Chancellor on brink of second bailout for banks"</i>.</p>
     ;;
    #_public
    (§ method Block getGenesisBlock())
    (ß
        (§ return genesisBlock)
    )

    ;;; Default TCP port on which to connect to nodes. ;;
    #_public
    (§ method int getPort())
    (ß
        (§ return port)
    )

    ;;; The header bytes that identify the start of a packet on this network. ;;
    #_public
    (§ method long getPacketMagic())
    (ß
        (§ return packetMagic)
    )

    ;;;
     ; First byte of a base58 encoded address.  See {@link org.bitcoinj.core.Address}.
     ; This is the same as acceptableAddressCodes[0] and is the one used for "normal" addresses.
     ; Other types of address may be encountered with version codes found in the acceptableAddressCodes array.
     ;;
    #_public
    (§ method int getAddressHeader())
    (ß
        (§ return addressHeader)
    )

    ;;;
     ; First byte of a base58 encoded P2SH address.  P2SH addresses are defined as part of BIP0013.
     ;;
    #_public
    (§ method int getP2SHHeader())
    (ß
        (§ return p2shHeader)
    )

    ;;;
     ; How much time in seconds is supposed to pass between "interval" blocks.  If the actual elapsed time is
     ; significantly different from this value, the network difficulty formula will produce a different value.
     ; Both test and main Bitcoin networks use 2 weeks (1209600 seconds).
     ;;
    #_public
    (§ method int getTargetTimespan())
    (ß
        (§ return targetTimespan)
    )

    ;;;
     ; The version codes that prefix addresses which are acceptable on this network.  Although Satoshi intended these
     ; to be used for "versioning", in fact they are today used to discriminate what kind of data is contained in the
     ; address and to prevent accidentally sending coins across chains which would destroy them.
     ;;
    #_public
    (§ method int[] getAcceptableAddressCodes())
    (ß
        (§ return acceptableAddressCodes)
    )

    ;;;
     ; If we are running in testnet-in-a-box mode, we allow connections to nodes with 0 non-genesis blocks.
     ;;
    #_public
    (§ method boolean allowEmptyPeerChain())
    (ß
        (§ return true)
    )

    ;;; How many blocks pass between difficulty adjustment periods.  Bitcoin standardises this to be 2016. ;;
    #_public
    (§ method int getInterval())
    (ß
        (§ return interval)
    )

    ;;; Maximum target represents the easiest allowable proof of work. ;;
    #_public
    (§ method BigInteger getMaxTarget())
    (ß
        (§ return maxTarget)
    )

    ;;;
     ; The key used to sign {@link org.bitcoinj.core.AlertMessage}s.
     ; You can use {@link org.bitcoinj.core.ECKey#verify(byte[], byte[], byte[])} to verify signatures using it.
     ;;
    #_public
    (§ method byte[] getAlertSigningKey())
    (ß
        (§ return alertSigningKey)
    )

    ;;; Returns the 4 byte header for BIP32 (HD) wallet - public key part. ;;
    #_public
    (§ method int getBip32HeaderPub())
    (ß
        (§ return bip32HeaderPub)
    )

    ;;; Returns the 4 byte header for BIP32 (HD) wallet - private key part. ;;
    #_public
    (§ method int getBip32HeaderPriv())
    (ß
        (§ return bip32HeaderPriv)
    )

    ;;;
     ; Returns the number of coins that will be produced in total, on this network.
     ; Where not applicable, a very large number of coins is returned
     ; instead (i.e. the main coin issue for Dogecoin).
     ;;
    #_public
    #_abstract
    (§ method Coin getMaxMoney())

    ;;;
     ; Any standard (i.e. pay-to-address) output smaller than this value will
     ; most likely be rejected by the network.
     ;;
    #_public
    #_abstract
    (§ method Coin getMinNonDustOutput())

    ;;;
     ; The monetary object for this currency.
     ;;
    #_public
    #_abstract
    (§ method MonetaryFormat getMonetaryFormat())

    ;;;
     ; Scheme part for URIs, for example "bitcoin".
     ;;
    #_public
    #_abstract
    (§ method String getUriScheme())

    ;;;
     ; Returns whether this network has a maximum number of coins (finite supply) or not.
     ; Always returns true for Bitcoin, but exists to be overriden for other networks.
     ;;
    #_public
    #_abstract
    (§ method boolean hasMaxMoney())

    ;;;
     ; Return the default serializer for this network.  This is a shared serializer.
     ;;
    #_public
    #_final
    (§ method MessageSerializer getDefaultSerializer())
    (ß
        ;; Construct a default serializer if we don't have one.
        (§ if (this.defaultSerializer == nil))
        (ß
            ;; Don't grab a lock unless we absolutely need it.
            (§ sync this)
            (ß
                ;; Now we have a lock, double check there's still no serializer and create one if so.
                (§ if (this.defaultSerializer == nil))
                (ß
                    ;; As the serializers are intended to be immutable, creating
                    ;; two due to a race condition should not be a problem, however
                    ;; to be safe we ensure only one exists for each network.
                    (§ ass this.defaultSerializer = getSerializer(false))
                )
            )
        )
        (§ return defaultSerializer)
    )

    ;;;
     ; Construct and return a custom serializer.
     ;;
    #_public
    #_abstract
    (§ method BitcoinSerializer getSerializer(boolean parseRetain))

    ;;;
     ; The number of blocks in the last {@link getMajorityWindow()} blocks
     ; at which to trigger a notice to the user to upgrade their client, where
     ; the client does not understand those blocks.
     ;;
    #_public
    (§ method int getMajorityEnforceBlockUpgrade())
    (ß
        (§ return majorityEnforceBlockUpgrade)
    )

    ;;;
     ; The number of blocks in the last {@link getMajorityWindow()} blocks
     ; at which to enforce the requirement that all new blocks are of the
     ; newer type (i.e. outdated blocks are rejected).
     ;;
    #_public
    (§ method int getMajorityRejectBlockOutdated())
    (ß
        (§ return majorityRejectBlockOutdated)
    )

    ;;;
     ; The sampling window from which the version numbers of blocks are taken
     ; in order to determine if a new block version is now the majority.
     ;;
    #_public
    (§ method int getMajorityWindow())
    (ß
        (§ return majorityWindow)
    )

    ;;;
     ; The flags indicating which block validation tests should be applied to
     ; the given block.  Enables support for alternative blockchains which enable
     ; tests based on different criteria.
     ;
     ; @param block Block to determine flags for.
     ; @param height Height of the block, if known, null otherwise.  Returned
     ; tests should be a safe subset if block height is unknown.
     ;;
    #_public
    (§ method EnumSet<Block.VerifyFlag> getBlockVerificationFlags(#_final Block block, #_final VersionTally tally, #_final Integer height))
    (ß
        #_final
        (§ var EnumSet<Block.VerifyFlag> flags = EnumSet.noneOf(Block.VerifyFlag.class))

        (§ if (block.isBIP34()))
        (ß
            #_final
            (§ var Integer count = tally.getCountAtOrAbove(Block.BLOCK_VERSION_BIP34))
            (§ if (count != nil && getMajorityEnforceBlockUpgrade() <= count))
                (§ call flags.add(Block.VerifyFlag.HEIGHT_IN_COINBASE))
        )

        (§ return flags)
    )

    ;;;
     ; The flags indicating which script validation tests should be applied to
     ; the given transaction.  Enables support for alternative blockchains which enable
     ; tests based on different criteria.
     ;
     ; @param block Block the transaction belongs to.
     ; @param transaction to determine flags for.
     ; @param height Height of the block, if known, null otherwise.  Returned
     ; tests should be a safe subset if block height is unknown.
     ;;
    #_public
    (§ method EnumSet<Script.VerifyFlag> getTransactionVerificationFlags(#_final Block block, #_final Transaction transaction, #_final VersionTally tally, #_final Integer height))
    (ß
        #_final
        (§ var EnumSet<Script.VerifyFlag> verifyFlags = EnumSet.noneOf(Script.VerifyFlag.class))
        (§ if (NetworkParameters.BIP16_ENFORCE_TIME <= block.getTimeSeconds()))
            (§ call verifyFlags.add(Script.VerifyFlag.P2SH))

        ;; Start enforcing CHECKLOCKTIMEVERIFY (BIP65) for block.nVersion=4 blocks,
        ;; when 75% of the network has been upgraded:
        (§ if (Block.BLOCK_VERSION_BIP65 <= block.getVersion() && this.getMajorityEnforceBlockUpgrade() < tally.getCountAtOrAbove(Block.BLOCK_VERSION_BIP65)))
            (§ call verifyFlags.add(Script.VerifyFlag.CHECKLOCKTIMEVERIFY))

        (§ return verifyFlags)
    )

    #_public
    #_abstract
    (§ method int getProtocolVersionNum(#_final ProtocolVersion version))

    #_public
    #_static
    (§ enum ProtocolVersion
        (§ item MINIMUM(70000))
        (§ item PONG(60001))
        (§ item BLOOM_FILTER(70000))
        (§ item CURRENT(70001))

        #_private
        #_final
        (§ field int bitcoinProtocol)

        (§ constructor ProtocolVersion(#_final int bitcoinProtocol))
        (ß
            (§ ass this.bitcoinProtocol = bitcoinProtocol)
        )

        #_public
        (§ method int getBitcoinProtocolVersion())
        (ß
            (§ return bitcoinProtocol)
        )
    )
)

#_(ns org.bitcoinj.core #_"NotFoundMessage"
    (:import [java.util ArrayList List]))

;;;
 ; <p>Sent by a peer when a getdata request doesn't find the requested data in the mempool.  It has the same format
 ; as an inventory message and lists the hashes of the missing items.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class NotFoundMessage extends InventoryMessage
    #_public
    #_static
    (§ field int MIN_PROTOCOL_VERSION = 70001)

    #_public
    (§ constructor NotFoundMessage(NetworkParameters params))
    (ß
        (§ super (params))
    )

    #_public
    (§ constructor NotFoundMessage(NetworkParameters params, byte[] payloadBytes))
        (§ throws ProtocolException)
    (ß
        (§ super (params, payloadBytes))
    )

    #_public
    (§ constructor NotFoundMessage(NetworkParameters params, List<InventoryItem> items))
    (ß
        (§ super (params))
        (§ ass this.items = new ArrayList<>(items))
    )
)

#_(ns org.bitcoinj.core #_"PartialMerkleTree"
    (:import [java.io IOException OutputStream]
             [java.util ArrayList Arrays List])
    (:import [com.google.common.base Objects])
    (:import #_static #_[org.bitcoinj.core.Utils *]))

;;;
 ; <p>A data structure that contains proofs of block inclusion for one or more transactions, in an efficient manner.</p>
 ;
 ; <p>The encoding works as follows: we traverse the tree in depth-first order, storing a bit for each traversed node,
 ; signifying whether the node is the parent of at least one matched leaf txid (or a matched txid itself).  In case we
 ; are at the leaf level, or this bit is 0, its merkle node hash is stored, and its children are not explored further.
 ; Otherwise, no hash is stored, but we recurse into both (or the only) child branch.  During decoding, the same
 ; depth-first traversal is performed, consuming bits and hashes as they were written during encoding.</p>
 ;
 ; <p>The serialization is fixed and provides a hard guarantee about the encoded size,
 ; <tt>SIZE &lt;= 10 + ceil(32.25 * N)</tt> where N represents the number of leaf nodes of the partial tree.
 ; N itself is bounded by:</p>
 ;
 ; N &lt;= total_transactions<br>
 ; N &lt;= 1 + matched_transactions * tree_height
 ;
 ; <p><pre>The serialization format:
 ;  - uint32     total_transactions (4 bytes)
 ;  - varint     number of hashes (1-3 bytes)
 ;  - uint256[]  hashes in depth-first order (&lt;= 32*N bytes)
 ;  - varint     number of bytes of flag bits (1-3 bytes)
 ;  - byte[]     flag bits, packed per 8 in a byte, least significant bit first (&lt;= 2*N-1 bits)
 ; The size constraints follow from this.</pre></p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class PartialMerkleTree extends Message
    ;; the total number of transactions in the block
    #_private
    (§ field int transactionCount)

    ;; node-is-parent-of-matched-txid bits
    #_private
    (§ field byte[] matchedChildBits)

    ;; txids and internal hashes
    #_private
    (§ field List<Sha256Hash> hashes)

    #_public
    (§ constructor PartialMerkleTree(NetworkParameters params, byte[] payloadBytes, int offset))
        (§ throws ProtocolException)
    (ß
        (§ super (params, payloadBytes, offset))
    )

    ;;;
     ; Constructs a new PMT with the given bit set (little endian) and the raw list of hashes including internal hashes,
     ; taking ownership of the list.
     ;;
    #_public
    (§ constructor PartialMerkleTree(NetworkParameters params, byte[] bits, List<Sha256Hash> hashes, int origTxCount))
    (ß
        (§ super (params))

        (§ ass this.matchedChildBits = bits)
        (§ ass this.hashes = hashes)
        (§ ass this.transactionCount = origTxCount)
    )

    ;;;
     ; Calculates a PMT given the list of leaf hashes and which leaves need to be included.  The relevant interior hashes
     ; are calculated and a new PMT returned.
     ;;
    #_public
    #_static
    (§ method PartialMerkleTree buildFromLeaves(NetworkParameters params, byte[] includeBits, List<Sha256Hash> allLeafHashes))
    (ß
        ;; Calculate height of the tree.
        (§ var int height = 0)
        (§ while (1 < getTreeWidth(allLeafHashes.size(), height)))
            (§ ass height = height + 1)
        (§ var List<Boolean> bitList = new ArrayList<>())
        (§ var List<Sha256Hash> hashes = new ArrayList<>())
        (§ call traverseAndBuild(height, 0, allLeafHashes, includeBits, bitList, hashes))
        (§ var byte[] bits = new byte[(int)Math.ceil(bitList.size() / 8.0)])
        (§ for (int i = 0 :for i < bitList.size() :for i = i + 1))
            (§ if (bitList.get(i)))
                (§ call Utils.setBitLE(bits, i))
        (§ return new PartialMerkleTree(params, bits, hashes, allLeafHashes.size()))
    )

    #_override
    #_public
    (§ method void bitcoinSerializeToStream(OutputStream stream))
        (§ throws IOException)
    (ß
        (§ call uint32ToByteStreamLE(transactionCount, stream))

        (§ call stream.write(new VarInt(hashes.size()).encode()))
        (§ for (Sha256Hash hash :for hashes))
            (§ call stream.write(hash.getReversedBytes()))

        (§ call stream.write(new VarInt(matchedChildBits.length).encode()))
        (§ call stream.write(matchedChildBits))
    )

    #_override
    #_protected
    (§ method void parse())
        (§ throws ProtocolException)
    (ß
        (§ ass transactionCount = (int)readUint32())

        (§ var int nHashes = (int)readVarInt())
        (§ ass hashes = new ArrayList<>(nHashes))
        (§ for (int i = 0 :for i < nHashes :for i = i + 1))
            (§ call hashes.add(readHash()))

        (§ var int nFlagBytes = (int)readVarInt())
        (§ ass matchedChildBits = readBytes(nFlagBytes))

        (§ ass length = cursor - offset)
    )

    ;; Based on CPartialMerkleTree::TraverseAndBuild in Bitcoin Core.
    #_private
    #_static
    (§ method void traverseAndBuild(int height, int pos, List<Sha256Hash> allLeafHashes, byte[] includeBits, List<Boolean> matchedChildBits, List<Sha256Hash> resultHashes))
    (ß
        (§ var boolean parentOfMatch = false)
        ;; Is this node a parent of at least one matched hash?
        (§ for (int p = pos << height :for p < (pos + 1) << height && p < allLeafHashes.size() :for p = p + 1))
        (ß
            (§ if (Utils.checkBitLE(includeBits, p)))
            (ß
                (§ ass parentOfMatch = true)
                (§ break)
            )
        )
        ;; Store as a flag bit.
        (§ call matchedChildBits.add(parentOfMatch))
        (§ if (height == 0 || !parentOfMatch))
        (ß
            ;; If at height 0, or nothing interesting below, store hash and stop.
            (§ call resultHashes.add(calcHash(height, pos, allLeafHashes)))
        )
        (§ else)
        (ß
            ;; Otherwise descend into the subtrees.
            (§ var int h = height - 1)
            (§ var int p = pos * 2)
            (§ call traverseAndBuild(h, p, allLeafHashes, includeBits, matchedChildBits, resultHashes))
            (§ if (p + 1 < getTreeWidth(allLeafHashes.size(), h)))
                (§ call traverseAndBuild(h, p + 1, allLeafHashes, includeBits, matchedChildBits, resultHashes))
        )
    )

    #_private
    #_static
    (§ method Sha256Hash calcHash(int height, int pos, List<Sha256Hash> hashes))
    (ß
        ;; Hash at height 0 is just the regular tx hash itself.
        (§ if (height == 0))
            (§ return hashes.get(pos))

        (§ var int h = height - 1)
        (§ var int p = pos * 2)
        (§ var Sha256Hash left = calcHash(h, p, hashes))
        ;; Calculate right hash if not beyond the end of the array - copy left hash otherwise.
        (§ var Sha256Hash right = (p + 1 < getTreeWidth(hashes.size(), h)) ? calcHash(h, p + 1, hashes) :else left)

        (§ return combineLeftRight(left.getBytes(), right.getBytes()))
    )

    ;; Helper function to efficiently calculate the number of nodes at given height in the merkle tree.
    #_private
    #_static
    (§ method int getTreeWidth(int transactionCount, int height))
    (ß
        (§ return (transactionCount + (1 << height) - 1) >> height)
    )

    #_private
    #_static
    (§ class ValuesUsed
        #_public
        (§ field int bitsUsed = 0, hashesUsed = 0)
    )

    ;; Recursive function that traverses tree nodes, consuming the bits and hashes produced by TraverseAndBuild.
    ;; It returns the hash of the respective node.
    #_private
    (§ method Sha256Hash recursiveExtractHashes(int height, int pos, ValuesUsed used, List<Sha256Hash> matchedHashes))
        (§ throws VerificationException)
    (ß
        ;; overflowed bits array - failure
        (§ if (matchedChildBits.length * 8 <= used.bitsUsed))
            (§ throw new VerificationException("PartialMerkleTree overflowed its bits array"))

        (§ var boolean parentOfMatch = checkBitLE(matchedChildBits, used.bitsUsed))
        (§ ass used.bitsUsed = used.bitsUsed + 1)

        ;; if at height 0, or nothing interesting below, use stored hash and do not descend
        (§ if (height == 0 || !parentOfMatch))
        (ß
            ;; overflowed hash array - failure
            (§ if (hashes.size() <= used.hashesUsed))
                (§ throw new VerificationException("PartialMerkleTree overflowed its hash array"))

            (§ var Sha256Hash hash = hashes.get(used.hashesUsed))
            (§ ass used.hashesUsed = used.hashesUsed + 1)
            ;; in case of height 0, we have a matched txid
            (§ if (height == 0 && parentOfMatch))
                (§ call matchedHashes.add(hash))

            (§ return hash)
        )
        (§ else)
        (ß
            ;; otherwise, descend into the subtrees to extract matched txids and hashes
            (§ var byte[] left = recursiveExtractHashes(height - 1, pos * 2, used, matchedHashes).getBytes(), right)
            (§ if (pos * 2 + 1 < getTreeWidth(transactionCount, height - 1)))
            (ß
                (§ ass right = recursiveExtractHashes(height - 1, pos * 2 + 1, used, matchedHashes).getBytes())
                (§ if (Arrays.equals(right, left)))
                    (§ throw new VerificationException("Invalid merkle tree with duplicated left/right branches"))
            )
            (§ else)
            (ß
                (§ ass right = left)
            )
            ;; and combine them before returning
            (§ return combineLeftRight(left, right))
        )
    )

    #_private
    #_static
    (§ method Sha256Hash combineLeftRight(byte[] left, byte[] right))
    (ß
        (§ return Sha256Hash.wrapReversed(Sha256Hash.hashTwice(reverseBytes(left), 0, 32, reverseBytes(right), 0, 32)))
    )

    ;;;
     ; Extracts tx hashes that are in this merkle tree and returns the merkle root of this tree.
     ;
     ; The returned root should be checked against the merkle root contained in the block header for security.
     ;
     ; @param matchedHashesOut A list which will contain the matched txn (will be cleared).
     ; @return the merkle root of this merkle tree.
     ; @throws ProtocolException if this partial merkle tree is invalid.
     ;;
    #_public
    (§ method Sha256Hash getTxnHashAndMerkleRoot(List<Sha256Hash> matchedHashesOut))
        (§ throws VerificationException)
    (ß
        (§ call matchedHashesOut.clear())

        ;; an empty set will not work
        (§ if (transactionCount == 0))
            (§ throw new VerificationException("Got a CPartialMerkleTree with 0 transactions"))
        ;; check for excessively high numbers of transactions
        (§ if (Block.MAX_BLOCK_SIZE / 60 < transactionCount)) ;; 60 is the lower bound for the size of a serialized CTransaction
            (§ throw new VerificationException("Got a CPartialMerkleTree with more transactions than is possible"))
        ;; there can never be more hashes provided than one for every txid
        (§ if (transactionCount < hashes.size()))
            (§ throw new VerificationException("Got a CPartialMerkleTree with more hashes than transactions"))
        ;; there must be at least one bit per node in the partial tree, and at least one node per hash
        (§ if (matchedChildBits.length * 8 < hashes.size()))
            (§ throw new VerificationException("Got a CPartialMerkleTree with fewer matched bits than hashes"))

        ;; calculate height of tree
        (§ var int height = 0)
        (§ while (1 < getTreeWidth(transactionCount, height)))
            (§ ass height = height + 1)
        ;; traverse the partial tree
        (§ var ValuesUsed used = new ValuesUsed())
        (§ var Sha256Hash merkleRoot = recursiveExtractHashes(height, 0, used, matchedHashesOut))
        ;; verify that all bits were consumed (except for the padding caused by serializing it as a byte sequence)
        ;; verify that all hashes were consumed
        (§ if ((used.bitsUsed + 7) / 8 != matchedChildBits.length || used.hashesUsed != hashes.size()))
            (§ throw new VerificationException("Got a CPartialMerkleTree that didn't need all the data it provided"))

        (§ return merkleRoot)
    )

    #_public
    (§ method int getTransactionCount())
    (ß
        (§ return transactionCount)
    )

    #_override
    #_public
    (§ method boolean equals(Object o))
    (ß
        (§ if (this == o))
            (§ return true)
        (§ if (o == nil || getClass() != o.getClass()))
            (§ return false)
        (§ var PartialMerkleTree other = (PartialMerkleTree)o)
        (§ return (transactionCount == other.transactionCount && hashes.equals(other.hashes) && Arrays.equals(matchedChildBits, other.matchedChildBits)))
    )

    #_override
    #_public
    (§ method int hashCode())
    (ß
        (§ return Objects.hashCode(transactionCount, hashes, Arrays.hashCode(matchedChildBits)))
    )

    #_override
    #_public
    (§ method String toString())
    (ß
        (§ return "PartialMerkleTree{" + "transactionCount=" + transactionCount + ", matchedChildBits=" + Arrays.toString(matchedChildBits) + ", hashes=" + hashes + "}")
    )
)

#_(ns org.bitcoinj.core #_"Peer"
    (:import #_[java.util *]
             [java.util.concurrent CopyOnWriteArrayList CopyOnWriteArraySet Executor]
             [java.util.concurrent.atomic AtomicInteger]
             [java.util.concurrent.locks ReentrantLock])
    (:import [com.google.common.base * Objects]
             [com.google.common.collect Lists]
             [com.google.common.util.concurrent FutureCallback Futures ListenableFuture SettableFuture]
             [net.jcip.annotations GuardedBy]
             [org.slf4j Logger LoggerFactory])
  #_(:require #_[org.bitcoinj.core.listeners *]
             [org.bitcoinj.net StreamConnection]
             [org.bitcoinj.store BlockStore BlockStoreException]
             [org.bitcoinj.utils ListenerRegistration Threading]
             [org.bitcoinj.wallet Wallet]))

;;;
 ; <p>A Peer handles the high level communication with a Bitcoin node, extending a {@link PeerSocketHandler} which
 ; handles low-level message (de)serialization.</p>
 ;
 ; <p>Note that timeouts are handled by the extended
 ; {@link org.bitcoinj.net.AbstractTimeoutHandler} and timeout is automatically disabled (using
 ; {@link org.bitcoinj.net.AbstractTimeoutHandler#setTimeoutEnabled(boolean)}) once the version
 ; handshake completes.</p>
 ;;
#_public
(§ class Peer extends PeerSocketHandler
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(Peer.class))

    #_protected
    #_final
    (§ field ReentrantLock lock = Threading.lock("peer"))

    #_private
    #_final
    (§ field NetworkParameters params)
    #_private
    #_final
    (§ field AbstractBlockChain blockChain)
    #_private
    #_final
    (§ field Context context)

    #_private
    #_final
    (§ field CopyOnWriteArrayList<ListenerRegistration<BlocksDownloadedEventListener>> blocksDownloadedEventListeners = new CopyOnWriteArrayList<>())
    #_private
    #_final
    (§ field CopyOnWriteArrayList<ListenerRegistration<ChainDownloadStartedEventListener>> chainDownloadStartedEventListeners = new CopyOnWriteArrayList<>())
    #_private
    #_final
    (§ field CopyOnWriteArrayList<ListenerRegistration<PeerConnectedEventListener>> connectedEventListeners = new CopyOnWriteArrayList<>())
    #_private
    #_final
    (§ field CopyOnWriteArrayList<ListenerRegistration<PeerDisconnectedEventListener>> disconnectedEventListeners = new CopyOnWriteArrayList<>())
    #_private
    #_final
    (§ field CopyOnWriteArrayList<ListenerRegistration<GetDataEventListener>> getDataEventListeners = new CopyOnWriteArrayList<>())
    #_private
    #_final
    (§ field CopyOnWriteArrayList<ListenerRegistration<PreMessageReceivedEventListener>> preMessageReceivedEventListeners = new CopyOnWriteArrayList<>())
    #_private
    #_final
    (§ field CopyOnWriteArrayList<ListenerRegistration<OnTransactionBroadcastListener>> onTransactionEventListeners = new CopyOnWriteArrayList<>())

    ;; Whether to try and download blocks and transactions from this peer.  Set to false by PeerGroup if not the
    ;; primary peer.  This is to avoid redundant work and concurrency problems with downloading the same chain
    ;; in parallel.
    #_private
    #_volatile
    (§ field boolean vDownloadData)
    ;; The version data to announce to the other side of the connections we make: useful for setting our "user agent"
    ;; equivalent and other things.
    #_private
    #_final
    (§ field VersionMessage versionMessage)
    ;; Maximum depth up to which pending transaction dependencies are downloaded, or 0 for disabled.
    #_private
    #_volatile
    (§ field int vDownloadTxDependencyDepth)
    ;; How many block messages the peer has announced to us.  Peers only announce blocks that attach to their best chain
    ;; so we can use this to calculate the height of the peers chain, by adding it to the initial height in the version
    ;; message.  This method can go wrong if the peer re-orgs onto a shorter (but harder) chain, however, this is rare.
    #_private
    #_final
    (§ field AtomicInteger blocksAnnounced = new AtomicInteger())
    ;; Each wallet added to the peer will be notified of downloaded transaction data.
    #_private
    #_final
    (§ field CopyOnWriteArrayList<Wallet> wallets)
    ;; A time before which we only download block headers, after that point we download block bodies.
    #_guarded-by(ß "lock")
    #_private
    (§ field long fastCatchupTimeSecs)
    ;; Whether we are currently downloading headers only or block bodies.  Starts at true.  If the fast catchup time is
    ;; set AND our best block is before that date, switch to false until block headers beyond that point have been
    ;; received at which point it gets set to true again.  This isn't relevant unless vDownloadData is true.
    #_guarded-by(ß "lock")
    #_private
    (§ field boolean downloadBlockBodies = true)
    ;; Whether to request filtered blocks instead of full blocks if the protocol version allows for them.
    #_guarded-by(ß "lock")
    #_private
    (§ field boolean useFilteredBlocks = false)
    ;; The current Bloom filter set on the connection, used to tell the remote peer what transactions to send us.
    #_private
    #_volatile
    (§ field BloomFilter vBloomFilter)
    ;; The last filtered block we received, we're waiting to fill it out with transactions.
    #_private
    (§ field FilteredBlock currentFilteredBlock = nil)
    ;; How many filtered blocks have been received during the lifetime of this connection.  Used to decide when to
    ;; refresh the server-side side filter by sending a new one (it degrades over time as false positives are added
    ;; on the remote side, see BIP 37 for a discussion of this).
    ;; TODO: Is this still needed?  It should not be since the auto FP tracking logic was added.
    #_private
    (§ field int filteredBlocksReceived)
    ;; If non-null, we should discard incoming filtered blocks because we ran out of keys and are awaiting a new filter
    ;; to be calculated by the PeerGroup.  The discarded block hashes should be added here so we can re-request them
    ;; once we've recalculated and resent a new filter.
    #_guarded-by(ß "lock")
    #_nilable
    #_private
    (§ field List<Sha256Hash> awaitingFreshFilter)
    ;; How frequently to refresh the filter.  This should become dynamic in future and calculated depending on the
    ;; actual false positive rate.  For now a good value was determined empirically around January 2013.
    #_private
    #_static
    #_final
    (§ field int RESEND_BLOOM_FILTER_BLOCK_COUNT = 25000)
    ;; Keeps track of things we requested internally with getdata but didn't receive yet, so we can avoid re-requests.
    ;; It's not quite the same as getDataFutures, as this is used only for getdatas done as part of downloading
    ;; the chain and so is lighter weight (we just keep a bunch of hashes not futures).
    ;;
    ;; It is important to avoid a nasty edge case where we can end up with parallel chain downloads proceeding
    ;; simultaneously if we were to receive a newly solved block whilst parts of the chain are streaming to us.
    #_private
    #_final
    (§ field HashSet<Sha256Hash> pendingBlockDownloads = new HashSet<>())
    ;; Keep references to TransactionConfidence objects for transactions that were announced by a remote peer, but
    ;; which we haven't downloaded yet.  These objects are de-duplicated by the TxConfidenceTable class.
    ;; Once the tx is downloaded (by some peer), the Transaction object that is created will have a reference to
    ;; the confidence object held inside it, and it's then up to the event listeners that receive the Transaction
    ;; to keep it pinned to the root set if they care about this data.
    #_suppress(ß "MismatchedQueryAndUpdateOfCollection")
    #_private
    #_final
    (§ field HashSet<TransactionConfidence> pendingTxDownloads = new HashSet<>())
    ;; The lowest version number we're willing to accept.  Lower than this will result in an immediate disconnect.
    #_private
    #_volatile
    (§ field int vMinProtocolVersion)
    ;; When an API user explicitly requests a block or transaction from a peer, the InventoryItem is put here
    ;; whilst waiting for the response.  Is not used for downloads Peer generates itself.
    #_private
    #_static
    (§ class GetDataRequest
        #_final
        (§ field Sha256Hash hash)
        #_final
        (§ field SettableFuture future)

        #_public
        (§ constructor GetDataRequest(Sha256Hash hash, SettableFuture future))
        (ß
            (§ ass this.hash = hash)
            (§ ass this.future = future)
        )
    )
    ;; TODO: The types/locking should be rationalised a bit.
    #_private
    #_final
    (§ field CopyOnWriteArrayList<GetDataRequest> getDataFutures)
    #_guarded-by(ß "getAddrFutures")
    #_private
    #_final
    (§ field LinkedList<SettableFuture<AddressMessage>> getAddrFutures)

    #_private
    #_static
    #_final
    (§ field int PING_MOVING_AVERAGE_WINDOW = 20)

    ;; Outstanding pings against this peer and how long the last one took to complete.
    #_private
    #_final
    (§ field ReentrantLock lastPingTimesLock = new ReentrantLock())
    #_guarded-by(ß "lastPingTimesLock")
    #_private
    (§ field long[] lastPingTimes)
    #_private
    #_final
    (§ field CopyOnWriteArrayList<PendingPing> pendingPings)

    #_private
    #_volatile
    (§ field VersionMessage vPeerVersionMessage)

    ;; A settable future which completes (with this) when the connection is open.
    #_private
    #_final
    (§ field SettableFuture<Peer> connectionOpenFuture = SettableFuture.create())
    #_private
    #_final
    (§ field SettableFuture<Peer> outgoingVersionHandshakeFuture = SettableFuture.create())
    #_private
    #_final
    (§ field SettableFuture<Peer> incomingVersionHandshakeFuture = SettableFuture.create())
    #_private
    #_final
    (§ field ListenableFuture<Peer> versionHandshakeFuture = Futures.transform(Futures.allAsList(outgoingVersionHandshakeFuture, incomingVersionHandshakeFuture), new Function<List<Peer>, Peer>()
        (ß
            #_override
            #_nilable
            #_public
            (§ method Peer apply(#_nilable List<Peer> peers))
            (ß
                (§ call Preconditions.checkNotNull(peers))
                (§ call Preconditions.checkState(peers.size() == 2 && peers.get(0) == peers.get(1)))
                (§ return peers.get(0))
            )
        )))

    ;;;
     ; <p>Construct a peer that reads/writes from the given block chain.</p>
     ;
     ; <p>Note that this does <b>NOT</b> make a connection to the given remoteAddress, it only creates a handler
     ; for a connection.  If you want to create a one-off connection, create a Peer and pass it to
     ; {@link org.bitcoinj.net.NioClientManager#openConnection(java.net.SocketAddress, StreamConnection)}
     ; or
     ; {@link org.bitcoinj.net.NioClient#NioClient(java.net.SocketAddress, StreamConnection, int)}.</p>
     ;
     ; <p>The remoteAddress provided should match the remote address of the peer which is being connected to,
     ; and is used to keep track of which peers relayed transactions and offer more descriptive logging.</p>
     ;;
    #_public
    (§ constructor Peer(NetworkParameters params, VersionMessage ver, #_nilable AbstractBlockChain chain, PeerAddress remoteAddress))
    (ß
        (§ this (params, ver, remoteAddress, chain))
    )

    ;;;
     ; <p>Construct a peer that reads/writes from the given block chain.  Transactions stored in a {@link org.bitcoinj.core.TxConfidenceTable}
     ; will have their confidence levels updated when a peer announces it, to reflect the greater likelyhood that
     ; the transaction is valid.</p>
     ;
     ; <p>Note that this does <b>NOT</b> make a connection to the given remoteAddress, it only creates a handler
     ; for a connection.  If you want to create a one-off connection, create a Peer and pass it to
     ; {@link org.bitcoinj.net.NioClientManager#openConnection(java.net.SocketAddress, StreamConnection)}
     ; or
     ; {@link org.bitcoinj.net.NioClient#NioClient(java.net.SocketAddress, StreamConnection, int)}.</p>
     ;
     ; <p>The remoteAddress provided should match the remote address of the peer which is being connected to,
     ; and is used to keep track of which peers relayed transactions and offer more descriptive logging.</p>
     ;;
    #_public
    (§ constructor Peer(NetworkParameters params, VersionMessage ver, PeerAddress remoteAddress, #_nilable AbstractBlockChain chain))
    (ß
        (§ this (params, ver, remoteAddress, chain, Integer.MAX_VALUE))
    )

    ;;;
     ; <p>Construct a peer that reads/writes from the given block chain.  Transactions stored in a {@link org.bitcoinj.core.TxConfidenceTable}
     ; will have their confidence levels updated when a peer announces it, to reflect the greater likelyhood that
     ; the transaction is valid.</p>
     ;
     ; <p>Note that this does <b>NOT</b> make a connection to the given remoteAddress, it only creates a handler
     ; for a connection.  If you want to create a one-off connection, create a Peer and pass it to
     ; {@link org.bitcoinj.net.NioClientManager#openConnection(java.net.SocketAddress, StreamConnection)}
     ; or
     ; {@link org.bitcoinj.net.NioClient#NioClient(java.net.SocketAddress, StreamConnection, int)}.</p>
     ;
     ; <p>The remoteAddress provided should match the remote address of the peer which is being connected to,
     ; and is used to keep track of which peers relayed transactions and offer more descriptive logging.</p>
     ;;
    #_public
    (§ constructor Peer(NetworkParameters params, VersionMessage ver, PeerAddress remoteAddress, #_nilable AbstractBlockChain chain, int downloadTxDependencyDepth))
    (ß
        (§ super (params, remoteAddress))

        (§ ass this.params = Preconditions.checkNotNull(params))
        (§ ass this.versionMessage = Preconditions.checkNotNull(ver))
        (§ ass this.vDownloadTxDependencyDepth = (chain != nil) ? downloadTxDependencyDepth :else 0)
        (§ ass this.blockChain = chain) ;; Allowed to be nil.
        (§ ass this.vDownloadData = (chain != nil))
        (§ ass this.getDataFutures = new CopyOnWriteArrayList<>())
        (§ ass this.getAddrFutures = new LinkedList<>())
        (§ ass this.fastCatchupTimeSecs = params.getGenesisBlock().getTimeSeconds())
        (§ ass this.pendingPings = new CopyOnWriteArrayList<>())
        (§ ass this.vMinProtocolVersion = params.getProtocolVersionNum(NetworkParameters.ProtocolVersion.PONG))
        (§ ass this.wallets = new CopyOnWriteArrayList<>())
        (§ ass this.context = Context.get())

        (§ call this.versionHandshakeFuture.addListener(new Runnable()
        (ß
            #_override
            #_public
            (§ method void run())
            (ß
                (§ call versionHandshakeComplete())
            )
        ), Threading.SAME_THREAD))
    )

    ;;;
     ; <p>Construct a peer that reads/writes from the given chain.  Automatically creates a VersionMessage for you from
     ; the given software name/version strings, which should be something like "MySimpleTool", "1.0" and which will tell
     ; the remote node to relay transaction inv messages before it has received a filter.</p>
     ;
     ; <p>Note that this does <b>NOT</b> make a connection to the given remoteAddress, it only creates a handler
     ; for a connection. If you want to create a one-off connection, create a Peer and pass it to
     ; {@link org.bitcoinj.net.NioClientManager#openConnection(java.net.SocketAddress, StreamConnection)}
     ; or
     ; {@link org.bitcoinj.net.NioClient#NioClient(java.net.SocketAddress, StreamConnection, int)}.</p>
     ;
     ; <p>The remoteAddress provided should match the remote address of the peer which is being connected to,
     ; and is used to keep track of which peers relayed transactions and offer more descriptive logging.</p>
     ;;
    #_public
    (§ constructor Peer(NetworkParameters params, AbstractBlockChain blockChain, PeerAddress peerAddress, String thisSoftwareName, String thisSoftwareVersion))
    (ß
        (§ this (params, new VersionMessage(params, blockChain.getBestChainHeight()), blockChain, peerAddress))
        (§ call this.versionMessage.appendToSubVer(thisSoftwareName, thisSoftwareVersion, nil))
    )

    ;;; Registers a listener that is invoked when new blocks are downloaded. ;;
    #_public
    (§ method void addBlocksDownloadedEventListener(BlocksDownloadedEventListener listener))
    (ß
        (§ call addBlocksDownloadedEventListener(Threading.USER_THREAD, listener))
    )

    ;;; Registers a listener that is invoked when new blocks are downloaded. ;;
    #_public
    (§ method void addBlocksDownloadedEventListener(Executor executor, BlocksDownloadedEventListener listener))
    (ß
        (§ call blocksDownloadedEventListeners.add(new ListenerRegistration(listener, executor)))
    )

    ;;; Registers a listener that is invoked when a blockchain downloaded starts. ;;
    #_public
    (§ method void addChainDownloadStartedEventListener(ChainDownloadStartedEventListener listener))
    (ß
        (§ call addChainDownloadStartedEventListener(Threading.USER_THREAD, listener))
    )

    ;;; Registers a listener that is invoked when a blockchain downloaded starts. ;;
    #_public
    (§ method void addChainDownloadStartedEventListener(Executor executor, ChainDownloadStartedEventListener listener))
    (ß
        (§ call chainDownloadStartedEventListeners.add(new ListenerRegistration(listener, executor)))
    )

    ;;; Registers a listener that is invoked when a peer is connected. ;;
    #_public
    (§ method void addConnectedEventListener(PeerConnectedEventListener listener))
    (ß
        (§ call addConnectedEventListener(Threading.USER_THREAD, listener))
    )

    ;;; Registers a listener that is invoked when a peer is connected. ;;
    #_public
    (§ method void addConnectedEventListener(Executor executor, PeerConnectedEventListener listener))
    (ß
        (§ call connectedEventListeners.add(new ListenerRegistration(listener, executor)))
    )

    ;;; Registers a listener that is invoked when a peer is disconnected. ;;
    #_public
    (§ method void addDisconnectedEventListener(PeerDisconnectedEventListener listener))
    (ß
        (§ call addDisconnectedEventListener(Threading.USER_THREAD, listener))
    )

    ;;; Registers a listener that is invoked when a peer is disconnected. ;;
    #_public
    (§ method void addDisconnectedEventListener(Executor executor, PeerDisconnectedEventListener listener))
    (ß
        (§ call disconnectedEventListeners.add(new ListenerRegistration(listener, executor)))
    )

    ;;; Registers a listener that is called when messages are received. ;;
    #_public
    (§ method void addGetDataEventListener(GetDataEventListener listener))
    (ß
        (§ call addGetDataEventListener(Threading.USER_THREAD, listener))
    )

    ;;; Registers a listener that is called when messages are received. ;;
    #_public
    (§ method void addGetDataEventListener(Executor executor, GetDataEventListener listener))
    (ß
        (§ call getDataEventListeners.add(new ListenerRegistration<>(listener, executor)))
    )

    ;;; Registers a listener that is called when a transaction is broadcast across the network. ;;
    #_public
    (§ method void addOnTransactionBroadcastListener(OnTransactionBroadcastListener listener))
    (ß
        (§ call addOnTransactionBroadcastListener(Threading.USER_THREAD, listener))
    )

    ;;; Registers a listener that is called when a transaction is broadcast across the network. ;;
    #_public
    (§ method void addOnTransactionBroadcastListener(Executor executor, OnTransactionBroadcastListener listener))
    (ß
        (§ call onTransactionEventListeners.add(new ListenerRegistration<>(listener, executor)))
    )

    ;;; Registers a listener that is called immediately before a message is received. ;;
    #_public
    (§ method void addPreMessageReceivedEventListener(PreMessageReceivedEventListener listener))
    (ß
        (§ call addPreMessageReceivedEventListener(Threading.USER_THREAD, listener))
    )

    ;;; Registers a listener that is called immediately before a message is received. ;;
    #_public
    (§ method void addPreMessageReceivedEventListener(Executor executor, PreMessageReceivedEventListener listener))
    (ß
        (§ call preMessageReceivedEventListeners.add(new ListenerRegistration<>(listener, executor)))
    )

    #_public
    (§ method boolean removeBlocksDownloadedEventListener(BlocksDownloadedEventListener listener))
    (ß
        (§ return ListenerRegistration.removeFromList(listener, blocksDownloadedEventListeners))
    )

    #_public
    (§ method boolean removeChainDownloadStartedEventListener(ChainDownloadStartedEventListener listener))
    (ß
        (§ return ListenerRegistration.removeFromList(listener, chainDownloadStartedEventListeners))
    )

    #_public
    (§ method boolean removeConnectedEventListener(PeerConnectedEventListener listener))
    (ß
        (§ return ListenerRegistration.removeFromList(listener, connectedEventListeners))
    )

    #_public
    (§ method boolean removeDisconnectedEventListener(PeerDisconnectedEventListener listener))
    (ß
        (§ return ListenerRegistration.removeFromList(listener, disconnectedEventListeners))
    )

    #_public
    (§ method boolean removeGetDataEventListener(GetDataEventListener listener))
    (ß
        (§ return ListenerRegistration.removeFromList(listener, getDataEventListeners))
    )

    #_public
    (§ method boolean removeOnTransactionBroadcastListener(OnTransactionBroadcastListener listener))
    (ß
        (§ return ListenerRegistration.removeFromList(listener, onTransactionEventListeners))
    )

    #_public
    (§ method boolean removePreMessageReceivedEventListener(PreMessageReceivedEventListener listener))
    (ß
        (§ return ListenerRegistration.removeFromList(listener, preMessageReceivedEventListeners))
    )

    #_override
    #_public
    (§ method String toString())
    (ß
        (§ var PeerAddress addr = getAddress())
        ;; if null, it's a user-provided NetworkConnection object
        (§ return (addr == nil) ? "Peer()" :else addr.toString())
    )

    #_override
    #_protected
    (§ method void timeoutOccurred())
    (ß
        (§ call super.timeoutOccurred())

        (§ if (!connectionOpenFuture.isDone()))
            ;; Invoke the event handlers to tell listeners e.g. PeerGroup that we never managed to connect.
            (§ call connectionClosed())
    )

    #_override
    #_public
    (§ method void connectionClosed())
    (ß
        (§ for (#_final ListenerRegistration<PeerDisconnectedEventListener> registration :for disconnectedEventListeners))
        (ß
            (§ call registration.executor.execute(new Runnable()
            (ß
                #_override
                #_public
                (§ method void run())
                (ß
                    (§ call registration.listener.onPeerDisconnected(Peer.this, 0))
                )
            )))
        )
    )

    #_override
    #_public
    (§ method void connectionOpened())
    (ß
        ;; Announce ourselves.  This has to come first to connect to clients beyond v0.3.20.2 which wait to hear
        ;; from us until they send their version message back.
        (§ var PeerAddress address = getAddress())
        (§ call log.info("Announcing to {} as: {}", (address == nil) ? "Peer" :else address.toSocketAddress(), versionMessage.subVer))
        (§ call sendMessage(versionMessage))
        (§ call connectionOpenFuture.set(this))
        ;; When connecting, the remote peer sends us a version message with various bits of
        ;; useful data in it.  We need to know the peer protocol version before we can talk to it.
    )

    ;;;
     ; Provides a ListenableFuture that can be used to wait for the socket to connect.  A socket connection does not
     ; mean that protocol handshake has occurred.
     ;;
    #_public
    (§ method ListenableFuture<Peer> getConnectionOpenFuture())
    (ß
        (§ return connectionOpenFuture)
    )

    #_public
    (§ method ListenableFuture<Peer> getVersionHandshakeFuture())
    (ß
        (§ return versionHandshakeFuture)
    )

    #_override
    #_protected
    (§ method void processMessage(Message m))
        (§ throws Exception)
    (ß
        ;; Allow event listeners to filter the message stream.  Listeners are allowed to drop messages by returning null.
        (§ for (ListenerRegistration<PreMessageReceivedEventListener> registration :for preMessageReceivedEventListeners))
        (ß
            ;; Skip any listeners that are supposed to run in another thread as we don't want to block waiting for it,
            ;; which might cause circular deadlock.
            (§ if (registration.executor == Threading.SAME_THREAD))
            (ß
                (§ ass m = registration.listener.onPreMessageReceived(this, m))
                (§ if (m == nil))
                    (§ break)
            )
        )
        (§ if (m == nil))
            (§ return)

        ;; If we are in the middle of receiving transactions as part of a filtered block push from the remote node,
        ;; and we receive something that's not a transaction, then we're done.
        (§ if (currentFilteredBlock != nil && !(m instanceof Transaction)))
        (ß
            (§ call endFilteredBlock(currentFilteredBlock))
            (§ ass currentFilteredBlock = nil)
        )

        ;; No further communication is possible until version handshake is complete.
        (§ if (!(m instanceof VersionMessage || m instanceof VersionAck || (versionHandshakeFuture.isDone() && !versionHandshakeFuture.isCancelled()))))
            (§ throw new ProtocolException("Received " + m.getClass().getSimpleName() + " before version handshake is complete."))

        (§ if (m instanceof Ping))
        (ß
            (§ call processPing((Ping)m))
        )
        (§ elseif (m instanceof Pong))
        (ß
            (§ call processPong((Pong)m))
        )
        (§ elseif (m instanceof NotFoundMessage))
        (ß
            ;; This is sent to us when we did a getdata on some transactions that aren't in the peers memory pool.
            ;; Because NotFoundMessage is a subclass of InventoryMessage, the test for it must come before the next.
            (§ call processNotFoundMessage((NotFoundMessage)m))
        )
        (§ elseif (m instanceof InventoryMessage))
        (ß
            (§ call processInv((InventoryMessage)m))
        )
        (§ elseif (m instanceof Block))
        (ß
            (§ call processBlock((Block)m))
        )
        (§ elseif (m instanceof FilteredBlock))
        (ß
            (§ call startFilteredBlock((FilteredBlock)m))
        )
        (§ elseif (m instanceof Transaction))
        (ß
            (§ call processTransaction((Transaction)m))
        )
        (§ elseif (m instanceof GetDataMessage))
        (ß
            (§ call processGetData((GetDataMessage)m))
        )
        (§ elseif (m instanceof AddressMessage))
        (ß
            ;; We don't care about addresses of the network right now.  But in future,
            ;; we should save them in the wallet so we don't put too much load on the seed nodes and can
            ;; properly explore the network.
            (§ call processAddressMessage((AddressMessage)m))
        )
        (§ elseif (m instanceof HeadersMessage))
        (ß
            (§ call processHeaders((HeadersMessage)m))
        )
        (§ elseif (m instanceof AlertMessage))
        (ß
            (§ call processAlert((AlertMessage)m))
        )
        (§ elseif (m instanceof VersionMessage))
        (ß
            (§ call processVersionMessage((VersionMessage)m))
        )
        (§ elseif (m instanceof VersionAck))
        (ß
            (§ call processVersionAck((VersionAck)m))
        )
        (§ elseif (m instanceof RejectMessage))
        (ß
            (§ call log.error("{} {}: Received {}", this, getPeerVersionMessage().subVer, m))
        )
        (§ else)
        (ß
            (§ call log.warn("{}: Received unhandled message: {}", this, m))
        )
    )

    #_private
    (§ method void processAddressMessage(AddressMessage m))
    (ß
        (§ var SettableFuture<AddressMessage> future)
        (§ sync getAddrFutures)
        (ß
            (§ ass future = getAddrFutures.poll())
            (§ if (future == nil)) ;; Not an addr message we are waiting for.
                (§ return)
        )
        (§ call future.set(m))
    )

    #_private
    (§ method void processVersionMessage(VersionMessage m))
        (§ throws ProtocolException)
    (ß
        (§ if (vPeerVersionMessage != nil))
            (§ throw new ProtocolException("Got two version messages from peer"))

        (§ ass vPeerVersionMessage = m)
        ;; Switch to the new protocol version.
        (§ var long peerTime = vPeerVersionMessage.time * 1000)
        (§ call log.info("{}: Got version={}, subVer='{}', services=0x{}, time={}, blocks={}", this, vPeerVersionMessage.clientVersion, vPeerVersionMessage.subVer, vPeerVersionMessage.localServices, String.format(Locale.US, "%tF %tT", peerTime, peerTime), vPeerVersionMessage.bestHeight))
        ;; bitcoinj is a client mode implementation.  That means there's not much point in us talking to other client
        ;; mode nodes because we can't download the data from them we need to find/verify transactions.  Some bogus
        ;; implementations claim to have a block chain in their services field but then report a height of zero, filter
        ;; them out here.
        (§ if (!vPeerVersionMessage.hasBlockChain() || (!params.allowEmptyPeerChain() && vPeerVersionMessage.bestHeight == 0)))
        (ß
            ;; Shut down the channel gracefully.
            (§ call log.info("{}: Peer does not have a copy of the block chain.", this))
            (§ call close())
            (§ return)
        )

        (§ if (vPeerVersionMessage.bestHeight < 0))
            ;; In this case, it's a protocol violation.
            (§ throw new ProtocolException("Peer reports invalid best height: " + vPeerVersionMessage.bestHeight))
        ;; Now it's our turn ...
        ;; Send an ACK message stating we accept the peers protocol version.
        (§ call sendMessage(new VersionAck()))
        (§ call log.debug("{}: Incoming version handshake complete.", this))
        (§ call incomingVersionHandshakeFuture.set(this))
    )

    #_private
    (§ method void processVersionAck(VersionAck m))
        (§ throws ProtocolException)
    (ß
        (§ if (vPeerVersionMessage == nil))
            (§ throw new ProtocolException("got a version ack before version"))

        (§ if (outgoingVersionHandshakeFuture.isDone()))
            (§ throw new ProtocolException("got more than one version ack"))

        (§ call log.debug("{}: Outgoing version handshake complete.", this))
        (§ call outgoingVersionHandshakeFuture.set(this))
    )

    #_private
    (§ method void versionHandshakeComplete())
    (ß
        (§ call log.debug("{}: Handshake complete.", this))
        (§ call setTimeoutEnabled(false))
        (§ for (#_final ListenerRegistration<PeerConnectedEventListener> registration :for connectedEventListeners))
        (ß
            (§ call registration.executor.execute(new Runnable()
            (ß
                #_override
                #_public
                (§ method void run())
                (ß
                    (§ call registration.listener.onPeerConnected(Peer.this, 1))
                )
            )))
        )
        ;; We check min version after onPeerConnected as channel.close() will
        ;; call onPeerDisconnected, and we should probably call onPeerConnected first.
        #_final
        (§ var int version = vMinProtocolVersion)
        (§ if (vPeerVersionMessage.clientVersion < version))
        (ß
            (§ call log.warn("Connected to a peer speaking protocol version {} but need {}, closing", vPeerVersionMessage.clientVersion, version))
            (§ call close())
        )
    )

    #_protected
    (§ method void startFilteredBlock(FilteredBlock m))
    (ß
        ;; Filtered blocks come before the data that they refer to, so stash it here and then fill it out as
        ;; messages stream in.  We'll call endFilteredBlock when a non-tx message arrives (e.g. another
        ;; FilteredBlock) or when a tx that isn't needed by that block is found.  A ping message is sent after
        ;; a getblocks, to force the non-tx message path.
        (§ ass currentFilteredBlock = m)
        ;; Potentially refresh the server side filter.  Because the remote node adds hits back into the filter
        ;; to save round-tripping back through us, the filter degrades over time as false positives get added,
        ;; triggering yet more false positives.  We refresh it every so often to get the FP rate back down.
        (§ ass filteredBlocksReceived = filteredBlocksReceived + 1)
        (§ if (filteredBlocksReceived % RESEND_BLOOM_FILTER_BLOCK_COUNT == RESEND_BLOOM_FILTER_BLOCK_COUNT - 1))
            (§ call sendMessage(vBloomFilter))
    )

    #_protected
    (§ method void processNotFoundMessage(NotFoundMessage m))
    (ß
        ;; This is received when we previously did a getdata but the peer couldn't find what we requested in it's
        ;; memory pool.  Typically, because we are downloading dependencies of a relevant transaction and reached
        ;; the bottom of the dependency tree (where the unconfirmed transactions connect to transactions that are
        ;; in the chain).
        ;;
        ;; We go through and cancel the pending getdata futures for the items we were told weren't found.
        (§ for (GetDataRequest req :for getDataFutures))
            (§ for (InventoryItem item :for m.getItems()))
                (§ if (item.hash.equals(req.hash)))
                (ß
                    (§ call log.info("{}: Bottomed out dep tree at {}", this, req.hash))
                    (§ call req.future.cancel(true))
                    (§ call getDataFutures.remove(req))
                    (§ break)
                )
    )

    #_protected
    (§ method void processAlert(AlertMessage m))
    (ß
        (§ try)
        (ß
            (§ if (m.isSignatureValid()))
                (§ call log.info("Received alert from peer {}: {}", this, m.getStatusBar()))
            (§ else)
                (§ call log.warn("Received alert with invalid signature from peer {}: {}", this, m.getStatusBar()))
        )
        (§ catch (Throwable t))
        (ß
            ;; Signature checking can FAIL on Android platforms before Gingerbread apparently due to bugs in their
            ;; BigInteger implementations!  See https://github.com/bitcoinj/bitcoinj/issues/526 for discussion.
            ;; As alerts are just optional and not that useful, we just swallow the error here.
            (§ call log.error("Failed to check signature: bug in platform libraries?", t))
        )
    )

    #_protected
    (§ method void processHeaders(HeadersMessage m))
        (§ throws ProtocolException)
    (ß
        ;; Runs in network loop thread for this peer.
        ;;
        ;; This method can run if a peer just randomly sends us a "headers" message (should never happen), or more
        ;; likely when we've requested them as part of chain download using fast catchup.  We need to add each block to
        ;; the chain if it pre-dates the fast catchup time.  If we go past it, we can stop processing the headers and
        ;; request the full blocks from that point on instead.
        (§ var boolean downloadBlockBodies)
        (§ var long fastCatchupTimeSecs)

        (§ call lock.lock())
        (§ try)
        (ß
            (§ if (blockChain == nil))
            (ß
                ;; Can happen if we are receiving unrequested data, or due to programmer error.
                (§ call log.warn("Received headers when Peer is not configured with a chain."))
                (§ return)
            )
            (§ ass fastCatchupTimeSecs = this.fastCatchupTimeSecs)
            (§ ass downloadBlockBodies = this.downloadBlockBodies)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )

        (§ try)
        (ß
            (§ call Preconditions.checkState(!downloadBlockBodies, toString()))

            (§ for (int i = 0 :for i < m.getBlockHeaders().size() :for i = i + 1))
            (ß
                (§ var Block header = m.getBlockHeaders().get(i))
                ;; Process headers until we pass the fast catchup time, or are about to catch up with the head
                ;; of the chain - always process the last block as a full/filtered block to kick us out of the
                ;; fast catchup mode (in which we ignore new blocks).
                (§ var boolean passedTime = (fastCatchupTimeSecs <= header.getTimeSeconds()))
                (§ var boolean reachedTop = (vPeerVersionMessage.bestHeight <= blockChain.getBestChainHeight()))
                (§ if (!passedTime && !reachedTop))
                (ß
                    (§ if (!vDownloadData))
                    (ß
                        ;; Not download peer anymore, some other peer probably became better.
                        (§ call log.info("Lost download peer status, throwing away downloaded headers."))
                        (§ return)
                    )
                    (§ if (blockChain.add(header)))
                    (ß
                        ;; The block was successfully linked into the chain. Notify the user of our progress.
                        (§ call invokeOnBlocksDownloaded(header, nil))
                    )
                    (§ else)
                    (ß
                        ;; This block is unconnected - we don't know how to get from it back to the genesis block yet.
                        ;; That must mean that the peer is buggy or malicious because we specifically requested for
                        ;; headers that are part of the best chain.
                        (§ throw new ProtocolException("Got unconnected header from peer: " + header.getHashAsString()))
                    )
                )
                (§ else)
                (ß
                    (§ call lock.lock())
                    (§ try)
                    (ß
                        (§ call log.info("Passed the fast catchup time ({}) at height {}, discarding {} headers and requesting full blocks", Utils.dateTimeFormat(fastCatchupTimeSecs * 1000), blockChain.getBestChainHeight() + 1, m.getBlockHeaders().size() - i))
                        (§ ass this.downloadBlockBodies = true)
                        ;; Prevent this request being seen as a duplicate.
                        (§ ass this.lastGetBlocksBegin = Sha256Hash.ZERO_HASH)
                        (§ call blockChainDownloadLocked(Sha256Hash.ZERO_HASH))
                    )
                    (§ finally)
                    (ß
                        (§ call lock.unlock())
                    )
                    (§ return)
                )
            )
            ;; We added all headers in the message to the chain.
            ;; Request some more if we got up to the limit, otherwise we are at the end of the chain.
            (§ if (HeadersMessage.MAX_HEADERS <= m.getBlockHeaders().size()))
            (ß
                (§ call lock.lock())
                (§ try)
                (ß
                    (§ call blockChainDownloadLocked(Sha256Hash.ZERO_HASH))
                )
                (§ finally)
                (ß
                    (§ call lock.unlock())
                )
            )
        )
        (§ catch (VerificationException e))
        (ß
            (§ call log.warn("Block header verification failed", e))
        )
        (§ catch (PrunedException e))
        (ß
            ;; Unreachable when in SPV mode.
            (§ throw new RuntimeException(e))
        )
    )

    #_protected
    (§ method void processGetData(GetDataMessage getdata))
    (ß
        (§ call log.info("{}: Received getdata message: {}", getAddress(), getdata.toString()))
        (§ var ArrayList<Message> items = new ArrayList<>())
        (§ for (ListenerRegistration<GetDataEventListener> registration :for getDataEventListeners))
        (ß
            (§ if (registration.executor != Threading.SAME_THREAD))
                (§ continue)
            (§ var List<Message> listenerItems = registration.listener.getData(this, getdata))
            (§ if (listenerItems == nil))
                (§ continue)
            (§ call items.addAll(listenerItems))
        )
        (§ if (!items.isEmpty()))
        (ß
            (§ call log.info("{}: Sending {} items gathered from listeners to peer", getAddress(), items.size()))
            (§ for (Message item :for items))
                (§ call sendMessage(item))
        )
    )

    #_protected
    (§ method void processTransaction(#_final Transaction tx))
        (§ throws VerificationException)
    (ß
        ;; Check a few basic syntax issues to ensure the received TX isn't nonsense.
        (§ call tx.verify())
        (§ call lock.lock())
        (§ try)
        (ß
            (§ call log.debug("{}: Received tx {}", getAddress(), tx.getHashAsString()))
            ;; Label the transaction as coming in from the P2P network (as opposed to being created by us, direct import,
            ;; etc).  This helps the wallet decide how to risk analyze it later.
            ;;
            ;; Additionally, by invoking tx.getConfidence(), this tx now pins the confidence data into the heap, meaning
            ;; we can stop holding a reference to the confidence object ourselves.  It's up to event listeners on the
            ;; Peer to stash the tx object somewhere if they want to keep receiving updates about network propagation
            ;; and so on.
            (§ var TransactionConfidence confidence = tx.getConfidence())
            (§ call confidence.setSource(TransactionConfidence.Source.NETWORK))
            (§ call pendingTxDownloads.remove(confidence))
            (§ if (maybeHandleRequestedData(tx)))
                (§ return)

            (§ if (currentFilteredBlock != nil))
            (ß
                (§ if (!currentFilteredBlock.provideTransaction(tx)))
                (ß
                    ;; Got a tx that didn't fit into the filtered block, so we must have received everything.
                    (§ call endFilteredBlock(currentFilteredBlock))
                    (§ ass currentFilteredBlock = nil)
                )
                ;; Don't tell wallets or listeners about this tx as they'll learn about it when the filtered block is
                ;; fully downloaded instead.
                (§ return)
            )

            ;; It's a broadcast transaction.  Tell all wallets about this tx so they can check if it's relevant or not.
            (§ for (#_final Wallet wallet :for wallets))
            (ß
                (§ try)
                (ß
                    (§ if (wallet.isPendingTransactionRelevant(tx)))
                    (ß
                        (§ if (0 < vDownloadTxDependencyDepth))
                        (ß
                            ;; This transaction seems interesting to us, so let's download its dependencies.  This has
                            ;; several purposes: we can check that the sender isn't attacking us by engaging in protocol
                            ;; abuse games, like depending on a time-locked transaction that will never confirm, or
                            ;; building huge chains of unconfirmed transactions (again - so they don't confirm and the
                            ;; money can be taken back with a Finney attack).  Knowing the dependencies also lets us
                            ;; store them in a serialized wallet so we always have enough data to re-announce to the
                            ;; network and get the payment into the chain, in case the sender goes away and the network
                            ;; starts to forget.
                            ;;
                            ;; TODO: Not all the above things are implemented.
                            ;;
                            ;; Note that downloading of dependencies can end up walking around 15 minutes back even
                            ;; through transactions that have confirmed, as getdata on the remote peer also checks
                            ;; relay memory not only the mempool.  Unfortunately we have no way to know that here.
                            ;; In practice it should not matter much.
                            (§ call Futures.addCallback(downloadDependencies(tx), new FutureCallback<List<Transaction>>()
                            (ß
                                #_override
                                #_public
                                (§ method void onSuccess(List<Transaction> dependencies))
                                (ß
                                    (§ try)
                                    (ß
                                        (§ call log.info("{}: Dependency download complete!", getAddress()))
                                        (§ call wallet.receivePending(tx, dependencies))
                                    )
                                    (§ catch (VerificationException e))
                                    (ß
                                        (§ call log.error("{}: Wallet failed to process pending transaction {}", getAddress(), tx.getHash()))
                                        (§ call log.error("Error was: ", e))
                                        ;; Not much more we can do at this point.
                                    )
                                )

                                #_override
                                #_public
                                (§ method void onFailure(Throwable throwable))
                                (ß
                                    (§ call log.error("Could not download dependencies of tx {}", tx.getHashAsString()))
                                    (§ call log.error("Error was: ", throwable))
                                    ;; Not much more we can do at this point.
                                )
                            )))
                        )
                        (§ else)
                        (ß
                            (§ call wallet.receivePending(tx, nil))
                        )
                    )
                )
                (§ catch (VerificationException e))
                (ß
                    (§ call log.error("Wallet failed to verify tx", e))
                    ;; Carry on, listeners may still want to know.
                )
            )
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
        ;; Tell all listeners about this tx so they can decide whether to keep it or not.  If no listener keeps a
        ;; reference around then the memory pool will forget about it after a while too because it uses weak references.
        (§ for (#_final ListenerRegistration<OnTransactionBroadcastListener> registration :for onTransactionEventListeners))
        (ß
            (§ call registration.executor.execute(new Runnable()
            (ß
                #_override
                #_public
                (§ method void run())
                (ß
                    (§ call registration.listener.onTransaction(Peer.this, tx))
                )
            )))
        )
    )

    ;;;
     ; <p>Returns a future that wraps a list of all transactions that the given transaction depends on, recursively.
     ; Only transactions in peers memory pools are included; the recursion stops at transactions that are in the
     ; current best chain.  So it doesn't make much sense to provide a tx that was already in the best chain and
     ; a precondition checks this.</p>
     ;
     ; <p>For example, if tx has 2 inputs that connect to transactions A and B, and transaction B is unconfirmed and
     ; has one input connecting to transaction C that is unconfirmed, and transaction C connects to transaction D
     ; that is in the chain, then this method will return either {B, C} or {C, B}.  No ordering is guaranteed.</p>
     ;
     ; <p>This method is useful for apps that want to learn about how long an unconfirmed transaction might take
     ; to confirm, by checking for unexpectedly time locked transactions, unusually deep dependency trees or fee-paying
     ; transactions that depend on unconfirmed free transactions.</p>
     ;
     ; <p>Note that dependencies downloaded this way will not trigger the onTransaction method of event listeners.</p>
     ;;
    #_public
    (§ method ListenableFuture<List<Transaction>> downloadDependencies(Transaction tx))
    (ß
        (§ var TransactionConfidence.ConfidenceType txConfidence = tx.getConfidence().getConfidenceType())
        (§ call Preconditions.checkArgument(txConfidence != TransactionConfidence.ConfidenceType.BUILDING))
        (§ call log.info("{}: Downloading dependencies of {}", getAddress(), tx.getHashAsString()))
        #_final
        (§ var LinkedList<Transaction> results = new LinkedList<>())
        ;; future will be invoked when the entire dependency tree has been walked and the results compiled.
        #_final
        (§ var ListenableFuture<Object> future = downloadDependenciesInternal(vDownloadTxDependencyDepth, 0, tx, new Object(), results))
        #_final
        (§ var SettableFuture<List<Transaction>> resultFuture = SettableFuture.create())
        (§ call Futures.addCallback(future, new FutureCallback<Object>()
        (ß
            #_override
            #_public
            (§ method void onSuccess(Object ignored))
            (ß
                (§ call resultFuture.set(results))
            )

            #_override
            #_public
            (§ method void onFailure(Throwable throwable))
            (ß
                (§ call resultFuture.setException(throwable))
            )
        )))
        (§ return resultFuture)
    )

    ;; The marker object in the future returned is the same as the parameter.  It is arbitrary and can be anything.
    #_protected
    (§ method ListenableFuture<Object> downloadDependenciesInternal(#_final int maxDepth, #_final int depth, #_final Transaction tx, #_final Object marker, #_final List<Transaction> results))
    (ß
        #_final
        (§ var SettableFuture<Object> resultFuture = SettableFuture.create())
        #_final
        (§ var Sha256Hash rootTxHash = tx.getHash())
        ;; We want to recursively grab its dependencies.  This is so listeners can learn important information like
        ;; whether a transaction is dependent on a timelocked transaction or has an unexpectedly deep dependency tree
        ;; or depends on a no-fee transaction.

        ;; We may end up requesting transactions that we've already downloaded and thrown away here.
        (§ var Set<Sha256Hash> needToRequest = new CopyOnWriteArraySet<>())
        (§ for (TransactionInput input :for tx.getInputs()))
        (ß
            ;; There may be multiple inputs that connect to the same transaction.
            (§ call needToRequest.add(input.getOutpoint().getHash()))
        )

        (§ call lock.lock())
        (§ try)
        (ß
            ;; Build the request for the missing dependencies.
            (§ var List<ListenableFuture<Transaction>> futures = Lists.newArrayList())
            (§ var GetDataMessage getdata = new GetDataMessage(params))

            (§ if (1 < needToRequest.size()))
                (§ call log.info("{}: Requesting {} transactions for depth {} dep resolution", getAddress(), needToRequest.size(), depth + 1))

            (§ for (Sha256Hash hash :for needToRequest))
            (ß
                (§ call getdata.addTransaction(hash))
                (§ var GetDataRequest req = new GetDataRequest(hash, SettableFuture.create()))
                (§ call futures.add(req.future))
                (§ call getDataFutures.add(req))
            )

            (§ var ListenableFuture<List<Transaction>> successful = Futures.successfulAsList(futures))
            (§ call Futures.addCallback(successful, new FutureCallback<List<Transaction>>()
            (ß
                #_override
                #_public
                (§ method void onSuccess(List<Transaction> transactions))
                (ß
                    ;; Once all transactions either were received, or we know there are no more to come, ...
                    ;; Note that transactions will contain "null" for any positions that weren't successful.
                    (§ var List<ListenableFuture<Object>> childFutures = Lists.newLinkedList())
                    (§ for (Transaction tx :for transactions))
                    (ß
                        (§ if (tx == nil))
                            (§ continue)
                        (§ call log.info("{}: Downloaded dependency of {}: {}", getAddress(), rootTxHash, tx.getHashAsString()))
                        (§ call results.add(tx))
                        ;; Now recurse into the dependencies of this transaction too.
                        (§ if (depth + 1 < maxDepth))
                            (§ call childFutures.add(downloadDependenciesInternal(maxDepth, depth + 1, tx, marker, results)))
                    )
                    (§ if (childFutures.size() == 0))
                    (ß
                        ;; Short-circuit: we're at the bottom of this part of the tree.
                        (§ call resultFuture.set(marker))
                    )
                    (§ else)
                    (ß
                        ;; There are some children to download.  Wait until it's done (and their children, and their
                        ;; children, ...) to inform the caller that we're finished.
                        (§ call Futures.addCallback(Futures.successfulAsList(childFutures), new FutureCallback<List<Object>>()
                        (ß
                            #_override
                            #_public
                            (§ method void onSuccess(List<Object> objects))
                            (ß
                                (§ call resultFuture.set(marker))
                            )

                            #_override
                            #_public
                            (§ method void onFailure(Throwable throwable))
                            (ß
                                (§ call resultFuture.setException(throwable))
                            )
                        )))
                    )
                )

                #_override
                #_public
                (§ method void onFailure(Throwable throwable))
                (ß
                    (§ call resultFuture.setException(throwable))
                )
            )))

            ;; Start the operation.
            (§ call sendMessage(getdata))
        )
        (§ catch (Exception e))
        (ß
            (§ call log.error("{}: Couldn't send getdata in downloadDependencies({})", this, tx.getHash(), e))
            (§ call resultFuture.setException(e))
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )

        (§ return resultFuture)
    )

    #_protected
    (§ method void processBlock(Block m))
    (ß
        (§ if (log.isDebugEnabled()))
            (§ call log.debug("{}: Received broadcast block {}", getAddress(), m.getHashAsString()))

        ;; Was this block requested by getBlock()?
        (§ if (maybeHandleRequestedData(m)))
            (§ return)

        (§ if (blockChain == nil))
        (ß
            (§ call log.debug("Received block but was not configured with an AbstractBlockChain"))
            (§ return)
        )

        ;; Did we lose download peer status after requesting block data?
        (§ if (!vDownloadData))
        (ß
            (§ call log.debug("{}: Received block we did not ask for: {}", getAddress(), m.getHashAsString()))
            (§ return)
        )

        (§ call pendingBlockDownloads.remove(m.getHash()))

        (§ try)
        (ß
            ;; Otherwise it's a block sent to us because the peer thought we needed it, so add it to the block chain.
            (§ if (blockChain.add(m)))
            (ß
                ;; The block was successfully linked into the chain.  Notify the user of our progress.
                (§ call invokeOnBlocksDownloaded(m, nil))
            )
            (§ else)
            (ß
                ;; This block is an orphan - we don't know how to get from it back to the genesis block yet.  That
                ;; must mean that there are blocks we are missing, so do another getblocks with a new block locator
                ;; to ask the peer to send them to us.  This can happen during the initial block chain download where
                ;; the peer will only send us 500 at a time and then sends us the head block expecting us to request
                ;; the others.
                ;;
                ;; We must do two things here:
                ;; (1) Request from current top of chain to the oldest ancestor of the received block in the orphan set.
                ;; (2) Filter out duplicate getblock requests (done in blockChainDownloadLocked).
                ;;
                ;; The reason for (1) is that otherwise if new blocks were solved during the middle of chain download
                ;; we'd do a blockChainDownloadLocked() on the new best chain head, which would cause us to try and grab the
                ;; chain twice (or more!) on the same connection!  The block chain would filter out the duplicates but
                ;; only at a huge speed penalty.  By finding the orphan root we ensure every getblocks looks the same
                ;; no matter how many blocks are solved, and therefore that the (2) duplicate filtering can work.
                ;;
                ;; We only do this if we are not currently downloading headers.  If we are then we don't want to kick
                ;; off a request for lots more headers in parallel.
                (§ call lock.lock())
                (§ try)
                (ß
                    (§ if (downloadBlockBodies))
                    (ß
                        #_final
                        (§ var Block orphanRoot = Preconditions.checkNotNull(blockChain.getOrphanRoot(m.getHash())))
                        (§ call blockChainDownloadLocked(orphanRoot.getHash()))
                    )
                    (§ else)
                    (ß
                        (§ call log.info("Did not start chain download on solved block due to in-flight header download."))
                    )
                )
                (§ finally)
                (ß
                    (§ call lock.unlock())
                )
            )
        )
        (§ catch (VerificationException e))
        (ß
            ;; We don't want verification failures to kill the thread.
            (§ call log.warn("{}: Block verification failed", getAddress(), e))
        )
        (§ catch (PrunedException e))
        (ß
            ;; Unreachable when in SPV mode.
            (§ throw new RuntimeException(e))
        )
    )

    ;; TODO: Fix this duplication.
    #_protected
    (§ method void endFilteredBlock(FilteredBlock m))
    (ß
        (§ if (log.isDebugEnabled()))
            (§ call log.debug("{}: Received broadcast filtered block {}", getAddress(), m.getHash().toString()))

        (§ if (!vDownloadData))
        (ß
            (§ call log.debug("{}: Received block we did not ask for: {}", getAddress(), m.getHash().toString()))
            (§ return)
        )

        (§ if (blockChain == nil))
        (ß
            (§ call log.debug("Received filtered block but was not configured with an AbstractBlockChain"))
            (§ return)
        )

        ;; Note that we currently do nothing about peers which maliciously do not include transactions which
        ;; actually match our filter or which simply do not send us all the transactions we need: it can be fixed
        ;; by cross-checking peers against each other.
        (§ call pendingBlockDownloads.remove(m.getBlockHeader().getHash()))

        (§ try)
        (ß
            ;; It's a block sent to us because the peer thought we needed it, so maybe add it to the block chain.
            ;; The FilteredBlock m here contains a list of hashes, and may contain Transaction objects for a subset
            ;; of the hashes (those that were sent to us by the remote peer).  Any hashes that haven't had a tx
            ;; provided in processTransaction are ones that were announced to us previously via an 'inv' so the
            ;; assumption is we have already downloaded them and either put them in the wallet, or threw them away
            ;; for being false positives.
            ;;
            ;; TODO: Fix the following protocol race.
            ;; It is possible for this code to go wrong such that we miss a confirmation.  If the remote peer announces
            ;; a relevant transaction via an 'inv' and then it immediately announces the block that confirms
            ;; the tx before we had a chance to download it+its dependencies and provide them to the wallet, then we
            ;; will add the block to the chain here without the tx being in the wallet and thus it will miss its
            ;; confirmation and become stuck forever.  The fix is to notice that there's a pending getdata for a tx
            ;; that appeared in this block and delay processing until it arrived ... it's complicated by the fact that
            ;; the data may be requested by a different peer to this one.

            ;; Ask each wallet attached to the peer/blockchain if this block exhausts the list of data items
            ;; (keys/addresses) that were used to calculate the previous filter.  If so, then it's possible this block
            ;; is only partial.  Check for discarding first so we don't check for exhaustion on blocks we already know
            ;; we're going to discard, otherwise redundant filters might end up being queued and calculated.
            (§ call lock.lock())
            (§ try)
            (ß
                (§ if (awaitingFreshFilter != nil))
                (ß
                    (§ call log.info("Discarding block {} because we're still waiting for a fresh filter", m.getHash()))
                    ;; We must record the hashes of blocks we discard because you cannot do getblocks twice on the same
                    ;; range of blocks and get an inv both times, due to the codepath in Bitcoin Core hitting
                    ;; CPeer::PushInventory() which checks CPeer::setInventoryKnown and thus deduplicates.
                    (§ call awaitingFreshFilter.add(m.getHash()))
                    (§ return) ;; Chain download process is restarted via a call to setBloomFilter.
                )

                (§ if (checkForFilterExhaustion(m)))
                (ß
                    ;; Yes, so we must abandon the attempt to process this block and any further blocks we receive,
                    ;; then wait for the Bloom filter to be recalculated, sent to this peer and for the peer to acknowledge
                    ;; that the new filter is now in use (which we have to simulate with a ping/pong), and then we can
                    ;; safely restart the chain download with the new filter that contains a new set of lookahead keys.
                    (§ call log.info("Bloom filter exhausted whilst processing block {}, discarding", m.getHash()))
                    (§ ass awaitingFreshFilter = new LinkedList<>())
                    (§ call awaitingFreshFilter.add(m.getHash()))
                    (§ call awaitingFreshFilter.addAll(blockChain.drainOrphanBlocks()))
                    (§ return) ;; Chain download process is restarted via a call to setBloomFilter.
                )
            )
            (§ finally)
            (ß
                (§ call lock.unlock())
            )

            (§ if (blockChain.add(m)))
            (ß
                ;; The block was successfully linked into the chain.  Notify the user of our progress.
                (§ call invokeOnBlocksDownloaded(m.getBlockHeader(), m))
            )
            (§ else)
            (ß
                ;; This block is an orphan - we don't know how to get from it back to the genesis block yet.  That
                ;; must mean that there are blocks we are missing, so do another getblocks with a new block locator
                ;; to ask the peer to send them to us.  This can happen during the initial block chain download where
                ;; the peer will only send us 500 at a time and then sends us the head block expecting us to request
                ;; the others.
                ;;
                ;; We must do two things here:
                ;; (1) Request from current top of chain to the oldest ancestor of the received block in the orphan set.
                ;; (2) Filter out duplicate getblock requests (done in blockChainDownloadLocked).
                ;;
                ;; The reason for (1) is that otherwise if new blocks were solved during the middle of chain download
                ;; we'd do a blockChainDownloadLocked() on the new best chain head, which would cause us to try and grab the
                ;; chain twice (or more!) on the same connection!  The block chain would filter out the duplicates but
                ;; only at a huge speed penalty.  By finding the orphan root we ensure every getblocks looks the same
                ;; no matter how many blocks are solved, and therefore that the (2) duplicate filtering can work.
                (§ call lock.lock())
                (§ try)
                (ß
                    #_final
                    (§ var Block orphanRoot = Preconditions.checkNotNull(blockChain.getOrphanRoot(m.getHash())))
                    (§ call blockChainDownloadLocked(orphanRoot.getHash()))
                )
                (§ finally)
                (ß
                    (§ call lock.unlock())
                )
            )
        )
        (§ catch (VerificationException e))
        (ß
            ;; We don't want verification failures to kill the thread.
            (§ call log.warn("{}: FilteredBlock verification failed", getAddress(), e))
        )
        (§ catch (PrunedException e))
        (ß
            ;; We pruned away some of the data we need to properly handle this block.  We need to request the needed
            ;; data from the remote peer and fix things.  Or just give up.
            ;; TODO: Request e.getHash() and submit it to the block store before any other blocks.
            (§ throw new RuntimeException(e))
        )
    )

    #_private
    (§ method boolean checkForFilterExhaustion(FilteredBlock m))
    (ß
        (§ var boolean exhausted = false)
        (§ for (Wallet wallet :for wallets))
            (§ ass exhausted = exhausted | wallet.checkForFilterExhaustion(m))
        (§ return exhausted)
    )

    #_private
    (§ method boolean maybeHandleRequestedData(Message m))
    (ß
        (§ var boolean found = false)
        (§ var Sha256Hash hash = m.getHash())
        (§ for (GetDataRequest req :for getDataFutures))
        (ß
            (§ if (hash.equals(req.hash)))
            (ß
                (§ call req.future.set(m))
                (§ call getDataFutures.remove(req))
                (§ ass found = true)
                ;; Keep going in case there are more.
            )
        )
        (§ return found)
    )

    #_private
    (§ method void invokeOnBlocksDownloaded(#_final Block block, #_nilable #_final FilteredBlock fb))
    (ß
        ;; It is possible for the peer block height difference to be negative when blocks have been solved and broadcast
        ;; since the time we first connected to the peer.  However, it's weird and unexpected to receive a callback
        ;; with negative "blocks left" in this case, so we clamp to zero so the API user doesn't have to think about it.
        #_final
        (§ var int blocksLeft = Math.max(0, (int)vPeerVersionMessage.bestHeight - Preconditions.checkNotNull(blockChain).getBestChainHeight()))
        (§ for (#_final ListenerRegistration<BlocksDownloadedEventListener> registration :for blocksDownloadedEventListeners))
        (ß
            (§ call registration.executor.execute(new Runnable()
            (ß
                #_override
                #_public
                (§ method void run())
                (ß
                    (§ call registration.listener.onBlocksDownloaded(Peer.this, block, fb, blocksLeft))
                )
            )))
        )
    )

    #_protected
    (§ method void processInv(InventoryMessage inv))
    (ß
        (§ var List<InventoryItem> items = inv.getItems())

        ;; Separate out the blocks and transactions, we'll handle them differently.
        (§ var List<InventoryItem> transactions = new LinkedList<>())
        (§ var List<InventoryItem> blocks = new LinkedList<>())

        (§ for (InventoryItem item :for items))
        (ß
            (§ switch (item.type))
            (ß
                (§ case Transaction)
                    (§ call transactions.add(item))
                    (§ break)
                (§ case Block)
                    (§ call blocks.add(item))
                    (§ break)
                (§ default)
                    (§ throw new IllegalStateException("Not implemented: " + item.type))
            )
        )

        #_final
        (§ var boolean downloadData = this.vDownloadData)

        (§ if (transactions.size() == 0 && blocks.size() == 1))
        (ß
            ;; Single block announcement.  If we're downloading the chain this is just a tickle to make us continue
            ;; (the block chain download protocol is very implicit and not well thought out).  If we're not downloading
            ;; the chain then this probably means a new block was solved and the peer believes it connects to the best
            ;; chain, so count it.  This way getBestChainHeight() can be accurate.
            (§ if (downloadData && blockChain != nil))
            (ß
                (§ if (!blockChain.isOrphan(blocks.get(0).hash)))
                (ß
                    (§ call blocksAnnounced.incrementAndGet())
                )
            )
            (§ else)
            (ß
                (§ call blocksAnnounced.incrementAndGet())
            )
        )

        (§ var GetDataMessage getdata = new GetDataMessage(params))

        (§ var Iterator<InventoryItem> it = transactions.iterator())
        (§ while (it.hasNext()))
        (ß
            (§ var InventoryItem item = it.next())
            ;; Only download the transaction if we are the first peer that saw it be advertised.  Other peers will also
            ;; see it be advertised in inv packets asynchronously, they co-ordinate via the memory pool.  We could
            ;; potentially download transactions faster by always asking every peer for a tx when advertised, as remote
            ;; peers run at different speeds.  However to conserve bandwidth on mobile devices we try to only download a
            ;; transaction once.  This means we can miss broadcasts if the peer disconnects between sending us an inv and
            ;; sending us the transaction: currently we'll never try to re-fetch after a timeout.
            ;;
            ;; The line below can trigger confidence listeners.
            (§ var TransactionConfidence conf = context.getConfidenceTable().seen(item.hash, this.getAddress()))
            (§ if (1 < conf.numBroadcastPeers()))
            (ß
                ;; Some other peer already announced this so don't download.
                (§ call it.remove())
            )
            (§ elseif (conf.getSource().equals(TransactionConfidence.Source.SELF)))
            (ß
                ;; We created this transaction ourselves, so don't download.
                (§ call it.remove())
            )
            (§ else)
            (ß
                (§ call log.debug("{}: getdata on tx {}", getAddress(), item.hash))
                (§ call getdata.addItem(item))
                ;; Register with the garbage collector that we care about the confidence data for a while.
                (§ call pendingTxDownloads.add(conf))
            )
        )

        ;; If we are requesting filteredblocks, we have to send a ping after the getdata so that we have a clear
        ;; end to the final FilteredBlock's transactions (in the form of a pong) sent to us.
        (§ var boolean pingAfterGetData = false)

        (§ call lock.lock())
        (§ try)
        (ß
            (§ if (0 < blocks.size() && downloadData && blockChain != nil))
            (ß
                ;; Ideally, we'd only ask for the data here if we actually needed it.  However that can imply a lot of
                ;; disk IO to figure out what we've got.  Normally peers will not send us inv for things we already have
                ;; so we just re-request it here, and if we get duplicates the block chain / wallet will filter them out.
                (§ for (InventoryItem item :for blocks))
                (ß
                    (§ if (blockChain.isOrphan(item.hash) && downloadBlockBodies))
                    (ß
                        ;; If an orphan was re-advertised, ask for more blocks unless we are not currently downloading
                        ;; full block data because we have a getheaders outstanding.
                        #_final
                        (§ var Block orphanRoot = Preconditions.checkNotNull(blockChain.getOrphanRoot(item.hash)))
                        (§ call blockChainDownloadLocked(orphanRoot.getHash()))
                    )
                    (§ else)
                    (ß
                        ;; Don't re-request blocks we already requested.  Normally this should not happen.  However there is
                        ;; an edge case: if a block is solved and we complete the inv<->getdata<->block<->getblocks cycle
                        ;; whilst other parts of the chain are streaming in, then the new getblocks request won't match the
                        ;; previous one: whilst the stopHash is the same (because we use the orphan root), the start hash
                        ;; will be different and so the getblocks req won't be dropped as a duplicate.  We'll end up
                        ;; requesting a subset of what we already requested, which can lead to parallel chain downloads
                        ;; and other nastyness.  So we just do a quick removal of redundant getdatas here too.
                        ;;
                        ;; Note that as of June 2012 Bitcoin Core won't actually ever interleave blocks pushed as
                        ;; part of chain download with newly announced blocks, so it should always be taken care of by
                        ;; the duplicate check in blockChainDownloadLocked().  But Bitcoin Core may change in future so
                        ;; it's better to be safe here.
                        (§ if (!pendingBlockDownloads.contains(item.hash)))
                        (ß
                            (§ if (vPeerVersionMessage.isBloomFilteringSupported() && useFilteredBlocks))
                            (ß
                                (§ call getdata.addFilteredBlock(item.hash))
                                (§ ass pingAfterGetData = true)
                            )
                            (§ else)
                            (ß
                                (§ call getdata.addItem(item))
                            )
                            (§ call pendingBlockDownloads.add(item.hash))
                        )
                    )
                )
                ;; If we're downloading the chain, doing a getdata on the last block we were told about will cause the
                ;; peer to advertize the head block to us in a single-item inv.  When we download THAT, it will be an
                ;; orphan block, meaning we'll re-enter blockChainDownloadLocked() to trigger another getblocks between the
                ;; current best block we have and the orphan block.  If more blocks arrive in the meantime they'll also
                ;; become orphan.
            )
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )

        (§ if (!getdata.getItems().isEmpty()))
        (ß
            ;; This will cause us to receive a bunch of block or tx messages.
            (§ call sendMessage(getdata))
        )

        (§ if (pingAfterGetData))
            (§ call sendMessage(new Ping((long)(Math.random() * Long.MAX_VALUE))))
    )

    ;;;
     ; Asks the connected peer for the block of the given hash, and returns a future representing the answer.
     ; If you want the block right away and don't mind waiting for it, just call .get() on the result.  Your thread
     ; will block until the peer answers.
     ;;
    #_suppress(ß "unchecked")
    ;; The 'unchecked conversion' warning being suppressed here comes from the sendSingleGetData() formally returning
    ;; ListenableFuture instead of ListenableFuture<Block>.  This is okay as sendSingleGetData() actually returns
    ;; ListenableFuture<Block> in this context.  Note that sendSingleGetData() is also used for Transactions.
    #_public
    (§ method ListenableFuture<Block> getBlock(Sha256Hash blockHash))
    (ß
        ;; This does not need to be locked.
        (§ call log.info("Request to fetch block {}", blockHash))
        (§ var GetDataMessage getdata = new GetDataMessage(params))
        (§ call getdata.addBlock(blockHash))
        (§ return sendSingleGetData(getdata))
    )

    ;;;
     ; Asks the connected peer for the given transaction from its memory pool.  Transactions in the chain cannot be
     ; retrieved this way because peers don't have a transaction ID to transaction-pos-on-disk index, and besides,
     ; in future many peers will delete old transaction data they don't need.
     ;;
    #_suppress(ß "unchecked")
    ;; The 'unchecked conversion' warning being suppressed here comes from the sendSingleGetData() formally returning
    ;; ListenableFuture instead of ListenableFuture<Transaction>.  This is okay as sendSingleGetData() actually returns
    ;; ListenableFuture<Transaction> in this context.  Note that sendSingleGetData() is also used for Blocks.
    #_public
    (§ method ListenableFuture<Transaction> getPeerMempoolTransaction(Sha256Hash hash))
    (ß
        ;; This does not need to be locked.
        (§ call log.info("Request to fetch peer mempool tx  {}", hash))
        (§ var GetDataMessage getdata = new GetDataMessage(params))
        (§ call getdata.addTransaction(hash))
        (§ return sendSingleGetData(getdata))
    )

    ;;; Sends a getdata with a single item in it. ;;
    #_private
    (§ method ListenableFuture sendSingleGetData(GetDataMessage getdata))
    (ß
        ;; This does not need to be locked.
        (§ call Preconditions.checkArgument(getdata.getItems().size() == 1))
        (§ var GetDataRequest req = new GetDataRequest(getdata.getItems().get(0).hash, SettableFuture.create()))
        (§ call getDataFutures.add(req))
        (§ call sendMessage(getdata))
        (§ return req.future)
    )

    ;;; Sends a getaddr request to the peer and returns a future that completes with the answer once the peer has replied. ;;
    #_public
    (§ method ListenableFuture<AddressMessage> getAddr())
    (ß
        (§ var SettableFuture<AddressMessage> future = SettableFuture.create())
        (§ sync getAddrFutures)
        (ß
            (§ call getAddrFutures.add(future))
        )
        (§ call sendMessage(new GetAddrMessage(params)))
        (§ return future)
    )

    ;;;
     ; When downloading the block chain, the bodies will be skipped for blocks created before the given date.
     ; Any transactions relevant to the wallet will therefore not be found, but if you know your wallet has no such
     ; transactions it doesn't matter and can save a lot of bandwidth and processing time.  Note that the times of blocks
     ; isn't known until their headers are available and they are requested in chunks, so some headers may be downloaded
     ; twice using this scheme, but this optimization can still be a large win for newly created wallets.
     ;
     ; @param secondsSinceEpoch Time in seconds since the epoch or 0 to reset to always downloading block bodies.
     ;;
    #_public
    (§ method void setDownloadParameters(long secondsSinceEpoch, boolean useFilteredBlocks))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ if (secondsSinceEpoch == 0))
            (ß
                (§ ass fastCatchupTimeSecs = params.getGenesisBlock().getTimeSeconds())
                (§ ass downloadBlockBodies = true)
            )
            (§ else)
            (ß
                (§ ass fastCatchupTimeSecs = secondsSinceEpoch)
                ;; If the given time is before the current chains head block time, then this has no effect (we already
                ;; downloaded everything we need).
                (§ if (blockChain != nil && blockChain.getChainHead().getHeader().getTimeSeconds() < fastCatchupTimeSecs))
                    (§ ass downloadBlockBodies = false)
            )
            (§ ass this.useFilteredBlocks = useFilteredBlocks)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Links the given wallet to this peer.  If you have multiple peers, you should use a {@link PeerGroup} to manage
     ; them and use the {@link PeerGroup#addWallet(Wallet)} method instead of registering the wallet with each peer
     ; independently, otherwise the wallet will receive duplicate notifications.
     ;;
    #_public
    (§ method void addWallet(Wallet wallet))
    (ß
        (§ call wallets.add(wallet))
    )

    ;;; Unlinks the given wallet from peer.  See {@link Peer#addWallet(Wallet)}. ;;
    #_public
    (§ method void removeWallet(Wallet wallet))
    (ß
        (§ call wallets.remove(wallet))
    )

    ;; Keep track of the last request we made to the peer in blockChainDownloadLocked so we can avoid redundant and harmful
    ;; getblocks requests.
    #_guarded-by(ß "lock")
    #_private
    (§ field Sha256Hash lastGetBlocksBegin, lastGetBlocksEnd)

    #_guarded-by(ß "lock")
    #_private
    (§ method void blockChainDownloadLocked(Sha256Hash toHash))
    (ß
        (§ call Preconditions.checkState(lock.isHeldByCurrentThread()))

        ;; The block chain download process is a bit complicated.  Basically, we start with one or more blocks in a
        ;; chain that we have from a previous session.  We want to catch up to the head of the chain BUT we don't know
        ;; where that chain is up to or even if the top block we have is even still in the chain - we
        ;; might have got ourselves onto a fork that was later resolved by the network.
        ;;
        ;; To solve this, we send the peer a block locator which is just a list of block hashes.  It contains the
        ;; blocks we know about, but not all of them, just enough of them so the peer can figure out if we did end up
        ;; on a fork and if so, what the earliest still valid block we know about is likely to be.
        ;;
        ;; Once it has decided which blocks we need, it will send us an inv with up to 500 block messages.  We may
        ;; have some of them already if we already have a block chain and just need to catch up.  Once we request the
        ;; last block, if there are still more to come it sends us an "inv" containing only the hash of the head
        ;; block.
        ;;
        ;; That causes us to download the head block but then we find (in processBlock) that we can't connect
        ;; it to the chain yet because we don't have the intermediate blocks.  So we rerun this function building a
        ;; new block locator describing where we're up to.
        ;;
        ;; The getblocks with the new locator gets us another inv with another bunch of blocks.  We download them once
        ;; again.  This time when the peer sends us an inv with the head block, we already have it so we won't download
        ;; it again - but we recognize this case as special and call back into blockChainDownloadLocked to continue the
        ;; process.
        ;;
        ;; So this is a complicated process but it has the advantage that we can download a chain of enormous length
        ;; in a relatively stateless manner and with constant memory usage.
        ;;
        ;; All this is made more complicated by the desire to skip downloading the bodies of blocks that pre-date the
        ;; 'fast catchup time', which is usually set to the creation date of the earliest key in the wallet.  Because
        ;; we know there are no transactions using our keys before that date, we need only the headers.  To do that we
        ;; use the "getheaders" command.  Once we find we've gone past the target date, we throw away the downloaded
        ;; headers and then request the blocks from that point onwards.  "getheaders" does not send us an inv, it just
        ;; sends us the data we requested in a "headers" message.

        ;; TODO: Block locators should be abstracted out rather than special cased here.
        (§ var List<Sha256Hash> blockLocator = new ArrayList<>(51))

        ;; For now, we don't do the exponential thinning as suggested here:
        ;;
        ;;   https://en.bitcoin.it/wiki/Protocol_specification#getblocks
        ;;
        ;; This is because it requires scanning all the block chain headers, which is very slow.  Instead we add the
        ;; top 100 block headers.  If there is a re-org deeper than that, we'll end up downloading the entire chain.
        ;; We must always put the genesis block as the first entry.

        (§ var BlockStore store = Preconditions.checkNotNull(blockChain).getBlockStore())
        (§ var StoredBlock chainHead = blockChain.getChainHead())
        (§ var Sha256Hash chainHeadHash = chainHead.getHeader().getHash())

        ;; Did we already make this request?  If so, don't do it again.
        (§ if (Objects.equal(lastGetBlocksBegin, chainHeadHash) && Objects.equal(lastGetBlocksEnd, toHash)))
        (ß
            (§ call log.info("blockChainDownloadLocked({}): ignoring duplicated request: {}", toHash, chainHeadHash))
            (§ for (Sha256Hash hash :for pendingBlockDownloads))
                (§ call log.info("Pending block download: {}", hash))
            (§ call log.info(Throwables.getStackTraceAsString(new Throwable())))
            (§ return)
        )

        (§ if (log.isDebugEnabled()))
            (§ ass log.debug("{}: blockChainDownloadLocked({}) current head = {}", this, toHash, chainHead.getHeader().getHashAsString()))

        (§ var StoredBlock cursor = chainHead)
        (§ for (int i = 100 :for cursor != nil && 0 < i :for i = i - 1))
        (ß
            (§ call blockLocator.add(cursor.getHeader().getHash()))
            (§ try)
            (ß
                (§ ass cursor = cursor.getPrev(store))
            )
            (§ catch (BlockStoreException e))
            (ß
                (§ call log.error("Failed to walk the block chain whilst constructing a locator"))
                (§ throw new RuntimeException(e))
            )
        )

        ;; Only add the locator if we didn't already do so.  If the chain is < 50 blocks we already reached it.
        (§ if (cursor != nil))
            (§ call blockLocator.add(params.getGenesisBlock().getHash()))

        ;; Record that we requested this range of blocks so we can filter out duplicate requests in the event
        ;; of a block being solved during chain download.
        (§ ass lastGetBlocksBegin = chainHeadHash)
        (§ ass lastGetBlocksEnd = toHash)

        (§ if (downloadBlockBodies))
        (ß
            (§ var GetBlocksMessage message = new GetBlocksMessage(params, blockLocator, toHash))
            (§ call sendMessage(message))
        )
        (§ else)
        (ß
            ;; Downloading headers for a while instead of full blocks.
            (§ var GetHeadersMessage message = new GetHeadersMessage(params, blockLocator, toHash))
            (§ call sendMessage(message))
        )
    )

    ;;;
     ; Starts an asynchronous download of the block chain.  The chain download is deemed to be complete once we've
     ; downloaded the same number of blocks that the peer advertised having in its version handshake message.
     ;;
    #_public
    (§ method void startBlockChainDownload())
    (ß
        (§ call setDownloadData(true))
        ;; TODO: Peer might still have blocks that we don't have, and even have a heavier
        ;; chain even if the chain block count is lower.
        #_final
        (§ var int blocksLeft = getPeerBlockHeightDifference())
        (§ if (0 <= blocksLeft))
        (ß
            (§ for (#_final ListenerRegistration<ChainDownloadStartedEventListener> registration :for chainDownloadStartedEventListeners))
            (ß
                (§ call registration.executor.execute(new Runnable()
                (ß
                    #_override
                    #_public
                    (§ method void run())
                    (ß
                        (§ call registration.listener.onChainDownloadStarted(Peer.this, blocksLeft))
                    )
                )))
            )
            ;; When we just want as many blocks as possible, we can set the target hash to zero.
            (§ call lock.lock())
            (§ try)
            (ß
                (§ call blockChainDownloadLocked(Sha256Hash.ZERO_HASH))
            )
            (§ finally)
            (ß
                (§ call lock.unlock())
            )
        )
    )

    #_private
    (§ class PendingPing
        ;; The future that will be invoked when the pong is heard back.
        #_public
        (§ field SettableFuture<Long> future)
        ;; The random nonce that lets us tell apart overlapping pings/pongs.
        #_public
        #_final
        (§ field long nonce)
        ;; Measurement of the time elapsed.
        #_public
        #_final
        (§ field long startTimeMsec)

        #_public
        (§ constructor PendingPing(long nonce))
        (ß
            (§ ass future = SettableFuture.create())
            (§ ass this.nonce = nonce)
            (§ ass startTimeMsec = Utils.currentTimeMillis())
        )

        #_public
        (§ method void complete())
        (ß
            (§ if (!future.isDone()))
            (ß
                (§ var Long elapsed = Utils.currentTimeMillis() - startTimeMsec)
                (§ call Peer.this.addPingTimeData(elapsed))
                (§ call log.debug("{}: ping time is {} msec", Peer.this.toString(), elapsed))
                (§ call future.set(elapsed))
            )
        )
    )

    ;;; Adds a ping time sample to the averaging window. ;;
    #_private
    (§ method void addPingTimeData(long sample))
    (ß
        (§ call lastPingTimesLock.lock())
        (§ try)
        (ß
            (§ if (lastPingTimes == nil))
            (ß
                (§ ass lastPingTimes = new long[PING_MOVING_AVERAGE_WINDOW])
                ;; Initialize the averaging window to the first sample.
                (§ call Arrays.fill(lastPingTimes, sample))
            )
            (§ else)
            (ß
                ;; Shift all elements backwards by one.
                (§ call System.arraycopy(lastPingTimes, 1, lastPingTimes, 0, lastPingTimes.length - 1))
                ;; And append the new sample to the end.
                (§ ass lastPingTimes[lastPingTimes.length - 1] = sample)
            )
        )
        (§ finally)
        (ß
            (§ call lastPingTimesLock.unlock())
        )
    )

    ;;;
     ; Sends the peer a ping message and returns a future that will be invoked when the pong is received back.
     ; The future provides a number which is the number of milliseconds elapsed between the ping and the pong.
     ; Once the pong is received the value returned by {@link org.bitcoinj.core.Peer#getLastPingTime()} is
     ; updated.
     ; @throws ProtocolException if the peer version is too low to support measurable pings.
     ;;
    #_public
    (§ method ListenableFuture<Long> ping())
        (§ throws ProtocolException)
    (ß
        (§ return ping((long)(Math.random() * Long.MAX_VALUE)))
    )

    #_protected
    (§ method ListenableFuture<Long> ping(long nonce))
        (§ throws ProtocolException)
    (ß
        #_final
        (§ var VersionMessage ver = vPeerVersionMessage)
        (§ if (!ver.isPingPongSupported()))
            (§ throw new ProtocolException("Peer version is too low for measurable pings: " + ver))

        (§ var PendingPing pendingPing = new PendingPing(nonce))
        (§ call pendingPings.add(pendingPing))
        (§ call sendMessage(new Ping(pendingPing.nonce)))

        (§ return pendingPing.future)
    )

    ;;;
     ; Returns the elapsed time of the last ping/pong cycle.  If {@link org.bitcoinj.core.Peer#ping()} has
     ; never been called or we did not hear back the "pong" message yet, returns {@link Long#MAX_VALUE}.
     ;;
    #_public
    (§ method long getLastPingTime())
    (ß
        (§ call lastPingTimesLock.lock())
        (§ try)
        (ß
            (§ return (lastPingTimes != nil) ? lastPingTimes[lastPingTimes.length - 1] :else Long.MAX_VALUE)
        )
        (§ finally)
        (ß
            (§ call lastPingTimesLock.unlock())
        )
    )

    ;;;
     ; Returns a moving average of the last N ping/pong cycles.  If {@link org.bitcoinj.core.Peer#ping()} has never
     ; been called or we did not hear back the "pong" message yet, returns {@link Long#MAX_VALUE}.  The moving average
     ; window is 5 buckets.
     ;;
    #_public
    (§ method long getPingTime())
    (ß
        (§ call lastPingTimesLock.lock())
        (§ try)
        (ß
            (§ if (lastPingTimes == nil))
                (§ return Long.MAX_VALUE)
            (§ var long sum = 0)
            (§ for (long i :for lastPingTimes))
                (§ ass sum = sum + i)
            (§ return (long)((double)sum / lastPingTimes.length))
        )
        (§ finally)
        (ß
            (§ call lastPingTimesLock.unlock())
        )
    )

    #_private
    (§ method void processPing(Ping m))
    (ß
        (§ if (m.hasNonce()))
            (§ call sendMessage(new Pong(m.getNonce())))
    )

    #_protected
    (§ method void processPong(Pong m))
    (ß
        ;; Iterates over a snapshot of the list, so we can run unlocked here.
        (§ for (PendingPing ping :for pendingPings))
        (ß
            (§ if (m.getNonce() == ping.nonce))
            (ß
                (§ call pendingPings.remove(ping))
                ;; This line may trigger an event listener that re-runs ping().
                (§ call ping.complete())
                (§ return)
            )
        )
    )

    ;;;
     ; Returns the difference between our best chain height and the peers, which can either be positive if we are
     ; behind the peer, or negative if the peer is ahead of us.
     ;;
    #_public
    (§ method int getPeerBlockHeightDifference())
    (ß
        (§ call Preconditions.checkNotNull(blockChain, "No block chain configured"))

        ;; Chain will overflow signed int blocks in ~41,000 years.
        (§ var int chainHeight = (int)getBestHeight())
        ;; chainHeight should not be zero/negative because we shouldn't have given the user a Peer that is to another
        ;; client-mode node, nor should it be unconnected.  If that happens it means the user overrode us somewhere or
        ;; there is a bug in the peer management code.
        (§ call Preconditions.checkState(params.allowEmptyPeerChain() || 0 < chainHeight, "Connected to peer with zero/negative chain height", chainHeight))
        (§ return chainHeight - blockChain.getBestChainHeight())
    )

    #_private
    (§ method boolean isNotFoundMessageSupported())
    (ß
        (§ return (NotFoundMessage.MIN_PROTOCOL_VERSION <= vPeerVersionMessage.clientVersion))
    )

    ;;;
     ; Returns true if this peer will try and download things it is sent in "inv" messages.
     ; Normally you only need one peer to be downloading data.  Defaults to true.
     ;;
    #_public
    (§ method boolean isDownloadData())
    (ß
        (§ return vDownloadData)
    )

    ;;;
     ; If set to false, the peer won't try and fetch blocks and transactions it hears about.  Normally, only one
     ; peer should download missing blocks.  Defaults to true.  Changing this value from false to true may trigger
     ; a request to the remote peer for the contents of its memory pool, if Bloom filtering is active.
     ;;
    #_public
    (§ method void setDownloadData(boolean downloadData))
    (ß
        (§ ass this.vDownloadData = downloadData)
    )

    ;;; Returns version data announced by the remote peer. ;;
    #_public
    (§ method VersionMessage getPeerVersionMessage())
    (ß
        (§ return vPeerVersionMessage)
    )

    ;;; Returns version data we announce to our remote peers. ;;
    #_public
    (§ method VersionMessage getVersionMessage())
    (ß
        (§ return versionMessage)
    )

    ;;;
     ; @return the height of the best chain as claimed by peer: sum of its ver announcement and blocks announced since.
     ;;
    #_public
    (§ method long getBestHeight())
    (ß
        (§ return vPeerVersionMessage.bestHeight + blocksAnnounced.get())
    )

    ;;;
     ; The minimum P2P protocol version that is accepted.  If the peer speaks a protocol version lower than this, it
     ; will be disconnected.
     ; @return true if the peer was disconnected as a result.
     ;;
    #_public
    (§ method boolean setMinProtocolVersion(int minProtocolVersion))
    (ß
        (§ ass this.vMinProtocolVersion = minProtocolVersion)

        (§ var VersionMessage ver = getPeerVersionMessage())
        (§ if (ver != nil && ver.clientVersion < minProtocolVersion))
        (ß
            (§ call log.warn("{}: Disconnecting due to new min protocol version {}, got: {}", this, minProtocolVersion, ver.clientVersion))
            (§ call close())
            (§ return true)
        )

        (§ return false)
    )

    ;;;
     ; <p>Sets a Bloom filter on this connection.  This will cause the given {@link BloomFilter} object to be sent
     ; to the remote peer and if either a memory pool has been set using the constructor or the
     ; vDownloadData property is true, a {@link MemoryPoolMessage} is sent as well to trigger downloading of any
     ; pending transactions that may be relevant.</p>
     ;
     ; <p>The Peer does not automatically request filters from any wallets added using {@link Peer#addWallet(Wallet)}.
     ; This is to allow callers to avoid redundantly recalculating the same filter repeatedly when using multiple peers
     ; and multiple wallets together.</p>
     ;
     ; <p>Therefore, you should not use this method if your app uses a {@link PeerGroup}.  It is called for you.</p>
     ;
     ; <p>If the remote peer doesn't support Bloom filtering, then this call is ignored.  Once set you presently cannot
     ; unset a filter, though the underlying p2p protocol does support it.</p>
     ;;
    #_public
    (§ method void setBloomFilter(BloomFilter filter))
    (ß
        (§ call setBloomFilter(filter, true))
    )

    ;;;
     ; <p>Sets a Bloom filter on this connection.  This will cause the given {@link BloomFilter} object to be sent
     ; to the remote peer and if requested, a {@link MemoryPoolMessage} is sent as well to trigger downloading of any
     ; pending transactions that may be relevant.</p>
     ;
     ; <p>The Peer does not automatically request filters from any wallets added using {@link Peer#addWallet(Wallet)}.
     ; This is to allow callers to avoid redundantly recalculating the same filter repeatedly when using multiple peers
     ; and multiple wallets together.</p>
     ;
     ; <p>Therefore, you should not use this method if your app uses a {@link PeerGroup}.  It is called for you.</p>
     ;
     ; <p>If the remote peer doesn't support Bloom filtering, then this call is ignored.  Once set you presently cannot
     ; unset a filter, though the underlying p2p protocol does support it.</p>
     ;;
    #_public
    (§ method void setBloomFilter(BloomFilter filter, boolean andQueryMemPool))
    (ß
        (§ call Preconditions.checkNotNull(filter, "Clearing filters is not currently supported"))

        #_final
        (§ var VersionMessage ver = vPeerVersionMessage)
        (§ if (ver != nil && ver.isBloomFilteringSupported()))
        (ß
            (§ ass vBloomFilter = filter)
            (§ call log.debug("{}: Sending Bloom filter{}", this, andQueryMemPool ? " and querying mempool" :else ""))
            (§ call sendMessage(filter))
            (§ if (andQueryMemPool))
                (§ call sendMessage(new MemoryPoolMessage()))
            (§ call maybeRestartChainDownload())
        )
    )

    #_private
    (§ method void maybeRestartChainDownload())
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ if (awaitingFreshFilter == nil))
                (§ return)

            (§ if (!vDownloadData))
            (ß
                ;; This branch should be harmless but I want to know how often it happens in reality.
                (§ call log.warn("Lost download peer status whilst awaiting fresh filter."))
                (§ return)
            )

            ;; Ping/pong to wait for blocks that are still being streamed to us to finish being downloaded and discarded.
            (§ call ping().addListener(new Runnable()
            (ß
                #_override
                #_public
                (§ method void run())
                (ß
                    (§ call lock.lock())
                    (§ call Preconditions.checkNotNull(awaitingFreshFilter))
                    (§ var GetDataMessage getdata = new GetDataMessage(params))
                    (§ for (Sha256Hash hash :for awaitingFreshFilter))
                        (§ call getdata.addFilteredBlock(hash))
                    (§ ass awaitingFreshFilter = nil)
                    (§ call lock.unlock())

                    (§ call log.info("Restarting chain download"))
                    (§ call sendMessage(getdata))
                    ;; TODO: This bizarre ping-after-getdata hack probably isn't necessary.
                    ;; It's to ensure we know when the end of a filtered block stream of txns is, but we should just be
                    ;; able to match txns with the merkleblock.  Ask Matt why it's written this way.
                    (§ call sendMessage(new Ping((long)(Math.random() * Long.MAX_VALUE))))
                )
            ), Threading.SAME_THREAD))
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Returns the last {@link BloomFilter} set by {@link Peer#setBloomFilter(BloomFilter)}.  Bloom filters tell
     ; the remote node what transactions to send us, in a compact manner.
     ;;
    #_public
    (§ method BloomFilter getBloomFilter())
    (ß
        (§ return vBloomFilter)
    )

    ;;;
     ; Returns true if this peer will use getdata/notfound messages to walk backwards through transaction dependencies
     ; before handing the transaction off to the wallet.  The wallet can do risk analysis on pending/recent transactions
     ; to try and discover if a pending tx might be at risk of double spending.
     ;;
    #_public
    (§ method boolean isDownloadTxDependencies())
    (ß
        (§ return (0 < vDownloadTxDependencyDepth))
    )

    ;;;
     ; Sets if this peer will use getdata/notfound messages to walk backwards through transaction dependencies
     ; before handing the transaction off to the wallet.  The wallet can do risk analysis on pending/recent transactions
     ; to try and discover if a pending tx might be at risk of double spending.
     ;;
    #_public
    (§ method void setDownloadTxDependencies(boolean enable))
    (ß
        (§ ass vDownloadTxDependencyDepth = enable ? Integer.MAX_VALUE :else 0)
    )

    ;;;
     ; Sets if this peer will use getdata/notfound messages to walk backwards through transaction dependencies
     ; before handing the transaction off to the wallet.  The wallet can do risk analysis on pending/recent transactions
     ; to try and discover if a pending tx might be at risk of double spending.
     ;;
    #_public
    (§ method void setDownloadTxDependencies(int depth))
    (ß
        (§ ass vDownloadTxDependencyDepth = depth)
    )
)

#_(ns org.bitcoinj.core #_"PeerAddress"
    (:import [java.io IOException OutputStream]
             [java.math BigInteger]
             [java.net InetAddress InetSocketAddress UnknownHostException])
    (:import [com.google.common.base Objects Preconditions]
             [com.google.common.net InetAddresses])
    (:import #_static #_[org.bitcoinj.core.Utils uint32ToByteStreamLE]
             #_static #_[org.bitcoinj.core.Utils uint64ToByteStreamLE]
             [org.bitcoinj.params MainNetParams]))

;;;
 ; <p>A PeerAddress holds an IP address and port number representing the network location of
 ; a peer in the Bitcoin P2P network.  It exists primarily for serialization purposes.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class PeerAddress extends ChildMessage
    #_static
    #_final
    (§ field int MESSAGE_SIZE = 30)

    #_private
    (§ field InetAddress addr)
    #_private
    (§ field String hostname) ;; Used for .onion addresses.
    #_private
    (§ field int port)
    #_private
    (§ field BigInteger services)
    #_private
    (§ field long time)

    ;;;
     ; Construct a peer address from a serialized payload.
     ;;
    #_public
    (§ constructor PeerAddress(NetworkParameters params, byte[] payload, int offset, int protocolVersion))
        (§ throws ProtocolException)
    (ß
        (§ super (params, payload, offset, protocolVersion))
    )

    ;;;
     ; Construct a peer address from a serialized payload.
     ; @param params NetworkParameters object.
     ; @param payload Bitcoin protocol formatted byte array containing message content.
     ; @param offset The location of the first payload byte within the array.
     ; @param protocolVersion Bitcoin protocol version.
     ; @param serializer The serializer to use for this message.
     ; @throws ProtocolException
     ;;
    #_public
    (§ constructor PeerAddress(NetworkParameters params, byte[] payload, int offset, int protocolVersion, Message parent, MessageSerializer serializer))
        (§ throws ProtocolException)
    (ß
        (§ super (params, payload, offset, protocolVersion, parent, serializer, UNKNOWN_LENGTH))
    )

    ;;;
     ; Construct a peer address from a memorized or hardcoded address.
     ;;
    #_public
    (§ constructor PeerAddress(NetworkParameters params, InetAddress addr, int port, int protocolVersion, BigInteger services))
    (ß
        (§ super (params))

        (§ ass this.addr = Preconditions.checkNotNull(addr))
        (§ ass this.port = port)
        (§ ass this.protocolVersion = protocolVersion)
        (§ ass this.services = services)

        (§ ass length = (31402 < protocolVersion) ? MESSAGE_SIZE :else MESSAGE_SIZE - 4)
    )

    ;;;
     ; Constructs a peer address from the given IP address and port.  Version number is default for the given parameters.
     ;;
    #_public
    (§ constructor PeerAddress(NetworkParameters params, InetAddress addr, int port))
    (ß
        (§ this (params, addr, port, params.getProtocolVersionNum(NetworkParameters.ProtocolVersion.CURRENT), BigInteger.ZERO))
    )

    ;;;
     ; Constructs a peer address from the given IP address.  Port and version number are default for the given parameters.
     ;;
    #_public
    (§ constructor PeerAddress(NetworkParameters params, InetAddress addr))
    (ß
        (§ this (params, addr, params.getPort()))
    )

    ;;;
     ; Constructs a peer address from an {@link InetSocketAddress}.  An InetSocketAddress can take in as parameters an
     ; InetAddress or a String hostname.  If you want to connect to a .onion, set the hostname to the .onion address.
     ;;
    #_public
    (§ constructor PeerAddress(NetworkParameters params, InetSocketAddress addr))
    (ß
        (§ this (params, addr.getAddress(), addr.getPort()))
    )

    ;;;
     ; Constructs a peer address from a stringified hostname+port.  Use this if you want to connect to a Tor .onion address.
     ;;
    #_public
    (§ constructor PeerAddress(NetworkParameters params, String hostname, int port))
    (ß
        (§ super (params))

        (§ ass this.hostname = hostname)
        (§ ass this.port = port)
        (§ ass this.protocolVersion = params.getProtocolVersionNum(NetworkParameters.ProtocolVersion.CURRENT))
        (§ ass this.services = BigInteger.ZERO)
    )

    #_public
    #_static
    (§ method PeerAddress localhost(NetworkParameters params))
    (ß
        (§ return new PeerAddress(params, InetAddresses.forString("127.0.0.1"), params.getPort()))
    )

    #_override
    #_protected
    (§ method void bitcoinSerializeToStream(OutputStream stream))
        (§ throws IOException)
    (ß
        (§ if (31402 <= protocolVersion))
        (ß
            ;; TODO: This appears to be dynamic because the client only ever sends out it's own address
            ;; so assumes itself to be up.  For a fuller implementation this needs to be dynamic only if
            ;; the address refers to this client.
            (§ var int secs = (int)Utils.currentTimeSeconds())
            (§ call uint32ToByteStreamLE(secs, stream))
        )
        (§ call uint64ToByteStreamLE(services, stream)) ;; nServices.
        ;; Java does not provide any utility to map an IPv4 address into IPv6 space, so we have to do it by hand.
        (§ var byte[] ipBytes = addr.getAddress())
        (§ if (ipBytes.length == 4))
        (ß
            (§ var byte[] v6addr = new byte[16])
            (§ call System.arraycopy(ipBytes, 0, v6addr, 12, 4))
            (§ ass v6addr[10] = (byte)0xff)
            (§ ass v6addr[11] = (byte)0xff)
            (§ ass ipBytes = v6addr)
        )
        (§ call stream.write(ipBytes))
        ;; And write out the port.  Unlike the rest of the protocol, address and port is in big endian byte order.
        (§ call stream.write((byte)(0xff & port >> 8)))
        (§ call stream.write((byte)(0xff & port)))
    )

    #_override
    #_protected
    (§ method void parse())
        (§ throws ProtocolException)
    (ß
        ;; Format of a serialized address:
        ;;   uint32 timestamp
        ;;   uint64 services (flags determining what the node can do)
        ;;   16 bytes ip address
        ;;   2 bytes port num
        (§ ass time = (31402 < protocolVersion) ? readUint32() :else -1)
        (§ ass services = readUint64())
        (§ var byte[] addrBytes = readBytes(16))
        (§ try)
        (ß
            (§ ass addr = InetAddress.getByAddress(addrBytes))
        )
        (§ catch (UnknownHostException e))
        (ß
            (§ throw new RuntimeException(e)) ;; Cannot happen.
        )
        (§ ass port = ((payload[cursor] & 0xff) << 8) | (payload[cursor + 1] & 0xff))
        (§ ass cursor = cursor + 2)
        ;; The 4 byte difference is the uint32 timestamp that was introduced in version 31402.
        (§ ass length = (31402 < protocolVersion) ? MESSAGE_SIZE :else MESSAGE_SIZE - 4)
    )

    #_public
    (§ method String getHostname())
    (ß
        (§ return hostname)
    )

    #_public
    (§ method InetAddress getAddr())
    (ß
        (§ return addr)
    )

    #_public
    (§ method InetSocketAddress getSocketAddress())
    (ß
        (§ return new InetSocketAddress(getAddr(), getPort()))
    )

    #_public
    (§ method int getPort())
    (ß
        (§ return port)
    )

    #_public
    (§ method BigInteger getServices())
    (ß
        (§ return services)
    )

    #_public
    (§ method long getTime())
    (ß
        (§ return time)
    )

    #_override
    #_public
    (§ method String toString())
    (ß
        (§ return (hostname != nil) ? "[" + hostname + "]:" + port :else "[" + addr.getHostAddress() + "]:" + port)
    )

    #_override
    #_public
    (§ method boolean equals(Object o))
    (ß
        (§ if (this == o))
            (§ return true)
        (§ if (o == nil || getClass() != o.getClass()))
            (§ return false)
        (§ var PeerAddress other = (PeerAddress)o)
        (§ return (other.addr.equals(addr) && other.port == port && other.time == time && other.services.equals(services)))
    )

    #_override
    #_public
    (§ method int hashCode())
    (ß
        (§ return Objects.hashCode(addr, port, time, services))
    )

    #_public
    (§ method InetSocketAddress toSocketAddress())
    (ß
        ;; Reconstruct the InetSocketAddress properly.
        (§ return (hostname != nil) ? InetSocketAddress.createUnresolved(hostname, port) :else new InetSocketAddress(addr, port))
    )
)

#_(ns org.bitcoinj.core #_"PeerException")

;;;
 ; Thrown when a problem occurs in communicating with a peer, and we should retry.
 ;;
#_public
(§ class PeerException extends Exception
    #_public
    (§ constructor PeerException(String msg))
    (ß
        (§ super (msg))
    )

    #_public
    (§ constructor PeerException(Exception e))
    (ß
        (§ super (e))
    )

    #_public
    (§ constructor PeerException(String msg, Exception e))
    (ß
        (§ super (msg, e))
    )
)

#_(ns org.bitcoinj.core #_"PeerFilterProvider")

;;;
 ; An interface which provides the information required to properly filter data downloaded from Peers.
 ; Note that an implementer is responsible for calling {@link PeerGroup#recalculateFastCatchupAndFilter(org.bitcoinj.core.PeerGroup.FilterRecalculateMode)}
 ; whenever a change occurs which effects the data provided via this interface.
 ;;
#_public
(§ interface PeerFilterProvider
    ;;;
     ; Returns the earliest timestamp (seconds since epoch) for which full/bloom-filtered blocks must be downloaded.
     ; Blocks with timestamps before this time will only have headers downloaded.  0 requires that all blocks be
     ; downloaded, and thus this should default to {@link System#currentTimeMillis()}/1000.
     ;;
    (§ method long getEarliestKeyCreationTime())

    ;;;
     ; Called on all registered filter providers before getBloomFilterElementCount and getBloomFilter are called.
     ; Once called, the provider should ensure that the items it will want to insert into the filter don't change.
     ; The reason is that all providers will have their element counts queried, and then a filter big enough for
     ; all of them will be specified.  So the provider must use consistent state.  There is guaranteed to be
     ; a matching call to endBloomFilterCalculation that can be used to e.g. unlock a lock.
     ;;
    (§ method void beginBloomFilterCalculation())

    ;;;
     ; Gets the number of elements that will be added to a bloom filter returned by
     ; {@link PeerFilterProvider#getBloomFilter(int, double, long)}.
     ;;
    (§ method int getBloomFilterElementCount())

    ;;;
     ; Gets a bloom filter that contains all the necessary elements for the listener to receive relevant transactions.
     ; Default value should be an empty bloom filter with the given size, falsePositiveRate, and nTweak.
     ;;
    (§ method BloomFilter getBloomFilter(int size, double falsePositiveRate, long nTweak))

    (§ method void endBloomFilterCalculation())
)

#_(ns org.bitcoinj.core #_"PeerGroup"
    (:import #_[java.io *]
             #_[java.net *]
             #_[java.util *]
             #_[java.util.concurrent *]
             #_[java.util.concurrent.locks *])
    (:import #_[com.google.common.annotations *]
             #_[com.google.common.base *]
             #_[com.google.common.collect *]
             #_[com.google.common.net *]
             #_[com.google.common.primitives *]
             #_[com.google.common.util.concurrent *]
             #_[net.jcip.annotations *]
             #_[org.slf4j *])
  #_(:require #_[org.bitcoinj.core.listeners *]
             #_[org.bitcoinj.net *]
             #_[org.bitcoinj.net.discovery *]
             #_[org.bitcoinj.script *]
             [org.bitcoinj.utils * Threading]
             [org.bitcoinj.wallet Wallet]
             [org.bitcoinj.wallet.listeners KeyChainEventListener WalletCoinsReceivedEventListener]))

;;;
 ; <p>Runs a set of connections to the P2P network, brings up connections to replace disconnected nodes and manages
 ; the interaction between them all.  Most applications will want to use one of these.</p>
 ;
 ; <p>PeerGroup tries to maintain a constant number of connections to a set of distinct peers.
 ; Each peer runs a network listener in its own thread.  When a connection is lost, a new peer
 ; will be tried after a delay as long as the number of connections less than the maximum.</p>
 ;
 ; <p>Connections are made to addresses from a provided list.  When that list is exhausted,
 ; we start again from the head of the list.</p>
 ;
 ; <p>The PeerGroup can broadcast a transaction to the currently connected set of peers.  It can
 ; also handle download of the blockchain from peers, restarting the process when peers die.</p>
 ;
 ; <p>A PeerGroup won't do anything until you call the {@link PeerGroup#start()} method
 ; which will block until peer discovery is completed and some outbound connections
 ; have been initiated (it will return before handshaking is done, however).
 ; You should call {@link PeerGroup#stop()} when finished.  Note that not all methods
 ; of PeerGroup are safe to call from a UI thread as some may do network IO,
 ; but starting and stopping the service should be fine.</p>
 ;;
#_public
(§ class PeerGroup implements TransactionBroadcaster
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(PeerGroup.class))

    ;; All members in this class should be marked with final, volatile, @GuardedBy or a mix as appropriate to define
    ;; their thread safety semantics.  Volatile requires a Hungarian-style v prefix.

    ;; By default we don't require any services because any peer will do.
    #_private
    (§ field long requiredServices = 0)

    ;;;
     ; The default number of connections to the p2p network the library will try to build.  This is set to 12 empirically.
     ; It used to be 4, but because we divide the connection pool in two for broadcasting transactions, that meant we
     ; were only sending transactions to two peers and sometimes this wasn't reliable enough: transactions wouldn't
     ; get through.
     ;;
    #_public
    #_static
    #_final
    (§ field int DEFAULT_CONNECTIONS = 12)
    #_private
    #_volatile
    (§ field int vMaxPeersToDiscoverCount = 100)
    #_private
    #_static
    #_final
    (§ field long DEFAULT_PEER_DISCOVERY_TIMEOUT_MILLIS = 5000)
    #_private
    #_volatile
    (§ field long vPeerDiscoveryTimeoutMillis = DEFAULT_PEER_DISCOVERY_TIMEOUT_MILLIS)

    #_protected
    #_final
    (§ field ReentrantLock lock = Threading.lock("peergroup"))

    #_protected
    #_final
    (§ field NetworkParameters params)
    #_nilable
    #_protected
    #_final
    (§ field AbstractBlockChain chain)

    ;; This executor is used to queue up jobs: it's used when we don't want to use locks for mutual exclusion,
    ;; typically because the job might call in to user provided code that needs/wants the freedom to use the API
    ;; however it wants, or because a job needs to be ordered relative to other jobs like that.
    #_protected
    #_final
    (§ field ListeningScheduledExecutorService executor)

    ;; Whether the peer group is currently running.  Once shut down it cannot be restarted.
    #_private
    #_volatile
    (§ field boolean vRunning)
    ;; Whether the peer group has been started or not.  An unstarted PG does not try to access the network.
    #_private
    #_volatile
    (§ field boolean vUsedUp)

    ;; Addresses to try to connect to, excluding active peers.
    #_guarded-by(ß "lock")
    #_private
    #_final
    (§ field PriorityQueue<PeerAddress> inactives)
    #_guarded-by(ß "lock")
    #_private
    #_final
    (§ field Map<PeerAddress, ExponentialBackoff> backoffMap)

    ;; Currently active peers.  This is an ordered list rather than a set to make unit tests predictable.
    #_private
    #_final
    (§ field CopyOnWriteArrayList<Peer> peers)
    ;; Currently connecting peers.
    #_private
    #_final
    (§ field CopyOnWriteArrayList<Peer> pendingPeers)
    #_private
    #_final
    (§ field ClientConnectionManager channels)

    ;; The peer that has been selected for the purposes of downloading announced data.
    #_guarded-by(ß "lock")
    #_private
    (§ field Peer downloadPeer)
    ;; Callback for events related to chain download.
    #_nilable
    #_guarded-by(ß "lock")
    #_private
    (§ field PeerDataEventListener downloadListener)

    #_private
    #_final
    (§ field CopyOnWriteArrayList<ListenerRegistration<BlocksDownloadedEventListener>> peersBlocksDownloadedEventListeners = new CopyOnWriteArrayList<>())
    #_private
    #_final
    (§ field CopyOnWriteArrayList<ListenerRegistration<ChainDownloadStartedEventListener>> peersChainDownloadStartedEventListeners = new CopyOnWriteArrayList<>())
    ;;; Callbacks for events related to peers connecting. ;;
    #_protected
    #_final
    (§ field CopyOnWriteArrayList<ListenerRegistration<PeerConnectedEventListener>> peerConnectedEventListeners = new CopyOnWriteArrayList<>())
    ;;; Callbacks for events related to peer connection/disconnection. ;;
    #_protected
    #_final
    (§ field CopyOnWriteArrayList<ListenerRegistration<PeerDiscoveredEventListener>> peerDiscoveredEventListeners = new CopyOnWriteArrayList<>())
    ;;; Callbacks for events related to peers disconnecting. ;;
    #_protected
    #_final
    (§ field CopyOnWriteArrayList<ListenerRegistration<PeerDisconnectedEventListener>> peerDisconnectedEventListeners = new CopyOnWriteArrayList<>())
    ;;; Callbacks for events related to peer data being received. ;;
    #_private
    #_final
    (§ field CopyOnWriteArrayList<ListenerRegistration<GetDataEventListener>> peerGetDataEventListeners = new CopyOnWriteArrayList<>())
    #_private
    #_final
    (§ field CopyOnWriteArrayList<ListenerRegistration<PreMessageReceivedEventListener>> peersPreMessageReceivedEventListeners = new CopyOnWriteArrayList<>())
    #_protected
    #_final
    (§ field CopyOnWriteArrayList<ListenerRegistration<OnTransactionBroadcastListener>> peersTransactionBroadastEventListeners = new CopyOnWriteArrayList<>())

    ;; Peer discovery sources, will be polled occasionally if there aren't enough inactives.
    #_private
    #_final
    (§ field CopyOnWriteArraySet<PeerDiscovery> peerDiscoverers)
    ;; The version message to use for new connections.
    #_guarded-by(ß "lock")
    #_private
    (§ field VersionMessage versionMessage)
    ;; Maximum depth up to which pending transaction dependencies are downloaded, or 0 for disabled.
    #_guarded-by(ß "lock")
    #_private
    (§ field int downloadTxDependencyDepth)
    ;; How many connections we want to have open at the current time.  If we lose connections, we'll try opening more
    ;; until we reach this count.
    #_guarded-by(ß "lock")
    #_private
    (§ field int maxConnections)
    ;; Minimum protocol version we will allow ourselves to connect to: require Bloom filtering.
    #_private
    #_volatile
    (§ field int vMinRequiredProtocolVersion)

    ;;; How many milliseconds to wait after receiving a pong before sending another ping. ;;
    #_public
    #_static
    #_final
    (§ field long DEFAULT_PING_INTERVAL_MSEC = 2000)
    #_guarded-by(ß "lock")
    #_private
    (§ field long pingIntervalMsec = DEFAULT_PING_INTERVAL_MSEC)

    #_guarded-by(ß "lock")
    #_private
    (§ field boolean useLocalhostPeerWhenPossible = true)
    #_guarded-by(ß "lock")
    #_private
    (§ field boolean ipv6Unreachable = false)

    #_guarded-by(ß "lock")
    #_private
    (§ field long fastCatchupTimeSecs)
    #_private
    #_final
    (§ field CopyOnWriteArrayList<Wallet> wallets)
    #_private
    #_final
    (§ field CopyOnWriteArrayList<PeerFilterProvider> peerFilterProviders)

    ;; This event listener is added to every peer.  It's here so when we announce transactions via an "inv",
    ;; every peer can fetch them.
    #_private
    #_final
    (§ field PeerListener peerListener = new PeerListener())

    #_private
    (§ field int minBroadcastConnections = 0)

    #_private
    #_final
    (§ field KeyChainEventListener walletKeyEventListener = new KeyChainEventListener()
        (ß
            #_override
            #_public
            (§ method void onKeysAdded(List<ECKey> keys))
            (ß
                (§ call recalculateFastCatchupAndFilter(FilterRecalculateMode.SEND_IF_CHANGED))
            )
        ))

    #_private
    #_final
    (§ field WalletCoinsReceivedEventListener walletCoinsReceivedEventListener = new WalletCoinsReceivedEventListener()
        (ß
            #_override
            #_public
            (§ method void onCoinsReceived(Wallet wallet, Transaction tx, Coin prevBalance, Coin newBalance))
            (ß
                ;; We received a relevant transaction.  We MAY need to recalculate and resend the Bloom filter, but only
                ;; if we have received a transaction that includes a relevant pay-to-pubkey output.
                ;;
                ;; The reason is that pay-to-pubkey outputs, when spent, will not repeat any data we can predict in their
                ;; inputs.  So a remote peer will update the Bloom filter for us when such an output is seen matching the
                ;; existing filter, so that it includes the tx hash in which the pay-to-pubkey output was observed.  Thus
                ;; the spending transaction will always match (due to the outpoint structure).
                ;;
                ;; Unfortunately, whilst this is required for correct sync of the chain in blocks, there are two edge cases.
                ;;
                ;; (1) If a wallet receives a relevant, confirmed p2pubkey output that was not broadcast across the network,
                ;; for example in a coinbase transaction, then the node that's serving us the chain will update its filter
                ;; but the rest will not.  If another transaction then spends it, the other nodes won't match/relay it.
                ;;
                ;; (2) If we receive a p2pubkey output broadcast across the network, all currently connected nodes will see
                ;; it and update their filter themselves, but any newly connected nodes will receive the last filter we
                ;; calculated, which would not include this transaction.
                ;;
                ;; For this reason we check if the transaction contained any relevant pay to pubkeys and force a recalc
                ;; and possibly retransmit if so.  The recalculation process will end up including the tx hash into the
                ;; filter.  In case (1), we need to retransmit the filter to the connected peers.  In case (2), we don't
                ;; and shouldn't, we should just recalculate and cache the new filter for next time.

                (§ for (TransactionOutput output :for tx.getOutputs()))
                (ß
                    (§ if (output.getScriptPubKey().isSentToRawPubKey() && output.isMine(wallet)))
                    (ß
                        (§ if (tx.getConfidence().getConfidenceType() == TransactionConfidence.ConfidenceType.BUILDING))
                            (§ call recalculateFastCatchupAndFilter(FilterRecalculateMode.SEND_IF_CHANGED))
                        (§ else)
                            (§ call recalculateFastCatchupAndFilter(FilterRecalculateMode.DONT_SEND))
                        (§ return)
                    )
                )
            )
        ))

    ;; Exponential backoff for peers starts at 1 second and maxes at 10 minutes.
    #_private
    #_final
    (§ field ExponentialBackoff.Params peerBackoffParams = new ExponentialBackoff.Params(1000, 1.5, 10 * 60 * 1000))
    ;; Tracks failures globally in case of a network failure.
    #_guarded-by(ß "lock")
    #_private
    (§ field ExponentialBackoff groupBackoff = new ExponentialBackoff(new ExponentialBackoff.Params(1000, 1.5, 10 * 1000)))

    ;; This is a synchronized set, so it locks on itself.  We use it to prevent TransactionBroadcast objects from
    ;; being garbage collected if nothing in the apps code holds on to them transitively.  See the discussion
    ;; in broadcastTransaction.
    #_private
    #_final
    (§ field Set<TransactionBroadcast> runningBroadcasts)

    #_private
    (§ class PeerListener implements GetDataEventListener, BlocksDownloadedEventListener
        #_public
        (§ constructor PeerListener())
        (ß
        )

        #_override
        #_public
        (§ method List<Message> getData(Peer peer, GetDataMessage m))
        (ß
            (§ return handleGetData(m))
        )

        #_override
        #_public
        (§ method void onBlocksDownloaded(Peer peer, Block block, #_nilable FilteredBlock filteredBlock, int blocksLeft))
        (ß
            (§ if (chain != nil))
            (ß
                #_final
                (§ var double rate = chain.getFalsePositiveRate())
                #_final
                (§ var double target = bloomFilterMerger.getBloomFilterFPRate() * MAX_FP_RATE_INCREASE)
                (§ if (target < rate))
                (ß
                    ;; TODO: Avoid hitting this path if the remote peer didn't acknowledge applying a new filter yet.
                    (§ if (log.isDebugEnabled()))
                        (§ call log.debug("Force update Bloom filter due to high false positive rate ({} vs {})", rate, target))

                    (§ call recalculateFastCatchupAndFilter(FilterRecalculateMode.FORCE_SEND_FOR_REFRESH))
                )
            )
        )
    )

    #_private
    (§ class PeerStartupListener implements PeerConnectedEventListener, PeerDisconnectedEventListener
        #_override
        #_public
        (§ method void onPeerConnected(Peer peer, int peerCount))
        (ß
            (§ call handleNewPeer(peer))
        )

        #_override
        #_public
        (§ method void onPeerDisconnected(Peer peer, int peerCount))
        (ß
            ;; The channel will be automatically removed from channels.
            (§ call handlePeerDeath(peer, nil))
        )
    )

    #_private
    #_final
    (§ field PeerStartupListener startupListener = new PeerStartupListener())

    ;;;
     ; The default Bloom filter false positive rate, which is selected to be extremely low such that you hardly ever
     ; download false positives.  This provides maximum performance.  Although this default can be overridden to push
     ; the FP rate higher, due to <a href="https://groups.google.com/forum/#!msg/bitcoinj/Ys13qkTwcNg/9qxnhwnkeoIJ">
     ; various complexities</a> there are still ways a remote peer can deanonymize the users wallet.  This is why the
     ; FP rate is chosen for performance rather than privacy.  If a future version of bitcoinj fixes the known
     ; de-anonymization attacks this FP rate may rise again (or more likely, become expressed as a bandwidth allowance).
     ;;
    #_public
    #_static
    #_final
    (§ field double DEFAULT_BLOOM_FILTER_FP_RATE = 0.00001)
    ;;; Maximum increase in FP rate before forced refresh of the bloom filter. ;;
    #_public
    #_static
    #_final
    (§ field double MAX_FP_RATE_INCREASE = 10.0)
    ;; An object that calculates bloom filters given a list of filter providers, whilst tracking some state useful
    ;; for privacy purposes.
    #_private
    #_final
    (§ field FilterMerger bloomFilterMerger)

    ;;; The default timeout between when a connection attempt begins and version message exchange completes. ;;
    #_public
    #_static
    #_final
    (§ field int DEFAULT_CONNECT_TIMEOUT_MILLIS = 5000)
    #_private
    #_volatile
    (§ field int vConnectTimeoutMillis = DEFAULT_CONNECT_TIMEOUT_MILLIS)

    ;;; Whether bloom filter support is enabled when using a non FullPrunedBlockchain. ;;
    #_private
    #_volatile
    (§ field boolean vBloomFilteringEnabled = true)

    ;;; See {@link #PeerGroup(Context)}. ;;
    #_public
    (§ constructor PeerGroup(NetworkParameters params))
    (ß
        (§ this (params, nil))
    )

    ;;;
     ; Creates a PeerGroup with the given context.  No chain is provided so this node will report its chain height
     ; as zero to other peers.  This constructor is useful if you just want to explore the network but aren't interested
     ; in downloading block data.
     ;;
    #_public
    (§ constructor PeerGroup(Context context))
    (ß
        (§ this (context, nil))
    )

    ;;; See {@link #PeerGroup(Context, AbstractBlockChain)}. ;;
    #_public
    (§ constructor PeerGroup(NetworkParameters params, #_nilable AbstractBlockChain chain))
    (ß
        (§ this (Context.getOrCreate(params), chain, new NioClientManager()))
    )

    ;;;
     ; Creates a PeerGroup for the given context and chain.  Blocks will be passed to the chain as they are broadcast
     ; and downloaded.  This is probably the constructor you want to use.
     ;;
    #_public
    (§ constructor PeerGroup(Context context, #_nilable AbstractBlockChain chain))
    (ß
        (§ this (context, chain, new NioClientManager()))
    )

    ;;; See {@link #PeerGroup(Context, AbstractBlockChain, ClientConnectionManager)}. ;;
    #_public
    (§ constructor PeerGroup(NetworkParameters params, #_nilable AbstractBlockChain chain, ClientConnectionManager connectionManager))
    (ß
        (§ this (Context.getOrCreate(params), chain, connectionManager))
    )

    ;;;
     ; Creates a new PeerGroup allowing you to specify the {@link ClientConnectionManager} which is used to create new
     ; connections and keep track of existing ones.
     ;;
    #_private
    (§ constructor PeerGroup(Context context, #_nilable AbstractBlockChain chain, ClientConnectionManager connectionManager))
    (ß
        (§ call Preconditions.checkNotNull(context))

        (§ ass this.params = context.getParams())
        (§ ass this.chain = chain)
        (§ ass fastCatchupTimeSecs = params.getGenesisBlock().getTimeSeconds())
        (§ ass wallets = new CopyOnWriteArrayList<>())
        (§ ass peerFilterProviders = new CopyOnWriteArrayList<>())

        (§ ass executor = createPrivateExecutor())

        ;; This default sentinel value will be overridden by one of two actions:
        ;;   - adding a peer discovery source sets it to the default.
        ;;   - using connectTo() will increment it by one.
        (§ ass maxConnections = 0)

        (§ var int height = (chain != nil) ? chain.getBestChainHeight() :else 0)
        (§ ass versionMessage = new VersionMessage(params, height))
        ;; We never request that the remote node wait for a bloom filter yet, as we have no wallets.
        (§ ass versionMessage.relayTxesBeforeFilter = true)

        (§ ass downloadTxDependencyDepth = Integer.MAX_VALUE)

        (§ ass inactives = new PriorityQueue<>(1, new Comparator<PeerAddress>()
        (ß
            #_suppress(ß "FieldAccessNotGuarded") ;; Only called when inactives is accessed, and lock is held then.
            #_override
            #_public
            (§ method int compare(PeerAddress a, PeerAddress b))
            (ß
                (§ call Preconditions.checkState(lock.isHeldByCurrentThread()))

                (§ var int result = backoffMap.get(a).compareTo(backoffMap.get(b)))
                ;; Sort by port if otherwise equals - for testing.
                (§ if (result == 0))
                    (§ ass result = Ints.compare(a.getPort(), b.getPort()))
                (§ return result)
            )
        )))
        (§ ass backoffMap = new HashMap<>())
        (§ ass peers = new CopyOnWriteArrayList<>())
        (§ ass pendingPeers = new CopyOnWriteArrayList<>())
        (§ ass channels = connectionManager)
        (§ ass peerDiscoverers = new CopyOnWriteArraySet<>())
        (§ ass runningBroadcasts = Collections.synchronizedSet(new HashSet<TransactionBroadcast>()))
        (§ ass bloomFilterMerger = new FilterMerger(DEFAULT_BLOOM_FILTER_FP_RATE))
        (§ ass vMinRequiredProtocolVersion = params.getProtocolVersionNum(NetworkParameters.ProtocolVersion.BLOOM_FILTER))
    )

    #_private
    (§ field CountDownLatch executorStartupLatch = new CountDownLatch(1))

    #_protected
    (§ method ListeningScheduledExecutorService createPrivateExecutor())
    (ß
        (§ var ListeningScheduledExecutorService result = MoreExecutors.listeningDecorator(new ScheduledThreadPoolExecutor(1, new ContextPropagatingThreadFactory("PeerGroup Thread"))))
        ;; Hack: jam the executor so jobs just queue up until the user calls start() on us.  For example, adding a wallet
        ;; results in a bloom filter recalc being queued, but we don't want to do that until we're actually started.
        (§ call result.execute(new Runnable()
        (ß
            #_override
            #_public
            (§ method void run())
            (ß
                (§ call Uninterruptibles.awaitUninterruptibly(executorStartupLatch))
            )
        )))
        (§ return result)
    )

    ;;;
     ; This is how many milliseconds we wait for peer discoveries to return their results.
     ;;
    #_public
    (§ method void setPeerDiscoveryTimeoutMillis(long peerDiscoveryTimeoutMillis))
    (ß
        (§ ass this.vPeerDiscoveryTimeoutMillis = peerDiscoveryTimeoutMillis)
    )

    ;;;
     ; Adjusts the desired number of connections that we will create to peers.  Note that if there are already peers
     ; open and the new value is lower than the current number of peers, those connections will be terminated.
     ; Likewise if there aren't enough current connections to meet the new requested max size, some will be added.
     ;;
    #_public
    (§ method void setMaxConnections(int maxConnections))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ ass this.maxConnections = maxConnections)
            (§ if (!isRunning()))
                (§ return)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )

        ;; We may now have too many or too few open connections.  Add more or drop some to get to the right amount.
        (§ var int adjustment = maxConnections - channels.getConnectedClientCount())
        (§ if (0 < adjustment))
            (§ call triggerConnections())

        (§ if (adjustment < 0))
            (§ call channels.closeConnections(-adjustment))
    )

    ;;;
     ; Configure download of pending transaction dependencies.  A change of values only takes effect for newly connected peers.
     ;;
    #_public
    (§ method void setDownloadTxDependencies(int depth))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ ass this.downloadTxDependencyDepth = depth)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    #_private
    (§ field Runnable triggerConnectionsJob = new Runnable()
        (ß
            #_private
            (§ field boolean firstRun = true)
            #_private
            #_final
            #_static
            (§ field long MIN_PEER_DISCOVERY_INTERVAL = 1000)

            #_override
            #_public
            (§ method void run())
            (ß
                (§ try)
                (ß
                    (§ call go())
                )
                (§ catch (Throwable e))
                (ß
                    (§ call log.error("Exception when trying to build connections", e)) ;; The executor swallows exceptions :( ;; )
                )
            )

            #_public
            (§ method void go())
            (ß
                (§ if (!vRunning))
                    (§ return)

                (§ var boolean doDiscovery = false)
                (§ var long now = Utils.currentTimeMillis())
                (§ call lock.lock())
                (§ try)
                (ß
                    ;; First run: try and use a local node if there is one, for the additional security it can provide.
                    ;; But, not on Android as there are none for this platform: it could only be a malicious app trying
                    ;; to hijack our traffic.
                    (§ if (!Utils.isAndroidRuntime() && useLocalhostPeerWhenPossible && maybeCheckForLocalhostPeer() && firstRun))
                    (ß
                        (§ call log.info("Localhost peer detected, trying to use it instead of P2P discovery"))
                        (§ ass maxConnections = 0)
                        (§ call connectToLocalHost())
                        (§ return)
                    )

                    (§ var boolean havePeerWeCanTry = (!inactives.isEmpty() && backoffMap.get(inactives.peek()).getRetryTime() <= now))
                    (§ ass doDiscovery = !havePeerWeCanTry)
                )
                (§ finally)
                (ß
                    (§ ass firstRun = false)
                    (§ call lock.unlock())
                )

                ;; Don't hold the lock across discovery as this process can be very slow.
                (§ var boolean discoverySuccess = false)
                (§ if (doDiscovery))
                (ß
                    (§ try)
                    (ß
                        (§ ass discoverySuccess = (0 < discoverPeers()))
                    )
                    (§ catch (PeerDiscoveryException e))
                    (ß
                        (§ call log.error("Peer discovery failure", e))
                    )
                )

                (§ var long retryTime)
                (§ var PeerAddress addrToTry)
                (§ call lock.lock())
                (§ try)
                (ß
                    (§ if (doDiscovery))
                    (ß
                        ;; Require that we have enough connections, to consider this a success,
                        ;; or we just constantly test for new peers.
                        (§ if (discoverySuccess && getMaxConnections() <= countConnectedAndPendingPeers()))
                            (§ call groupBackoff.trackSuccess())
                        (§ else)
                            (§ call groupBackoff.trackFailure())
                    )
                    ;; Inactives is sorted by backoffMap time.
                    (§ if (inactives.isEmpty()))
                    (ß
                        (§ if (countConnectedAndPendingPeers() < getMaxConnections()))
                        (ß
                            (§ var long interval = Math.max(groupBackoff.getRetryTime() - now, MIN_PEER_DISCOVERY_INTERVAL))
                            (§ call log.info("Peer discovery didn't provide us any more peers, will try again in " + interval + "ms."))
                            (§ call executor.schedule(this, interval, TimeUnit.MILLISECONDS))
                        )
                        (§ else)
                        (ß
                            ;; We have enough peers and discovery provided no more, so just settle down.
                            ;; Most likely we were given a fixed set of addresses in some test scenario.
                        )
                        (§ return)
                    )
                    (§ else)
                    (ß
                        (§ do)
                        (ß
                            (§ ass addrToTry = inactives.poll())
                        )
                        (§ again (ipv6Unreachable && addrToTry.getAddr() instanceof Inet6Address))
                        (§ ass retryTime = backoffMap.get(addrToTry).getRetryTime())
                    )
                    (§ ass retryTime = Math.max(retryTime, groupBackoff.getRetryTime()))
                    (§ if (now < retryTime))
                    (ß
                        (§ var long delay = retryTime - now)
                        (§ call log.info("Waiting {} msec before next connect attempt {}", delay, (addrToTry == nil) ? "" :else "to " + addrToTry))
                        (§ call inactives.add(addrToTry))
                        (§ call executor.schedule(this, delay, TimeUnit.MILLISECONDS))
                        (§ return)
                    )
                    (§ call connectTo(addrToTry, false, vConnectTimeoutMillis))
                )
                (§ finally)
                (ß
                    (§ call lock.unlock())
                )
                (§ if (countConnectedAndPendingPeers() < getMaxConnections()))
                (ß
                    (§ call executor.execute(this)) ;; Try next peer immediately.
                )
            )
        ))

    #_private
    (§ method void triggerConnections())
    (ß
        ;; Run on a background thread due to the need to potentially retry and back off in the background.
        (§ if (!executor.isShutdown()))
            (§ call executor.execute(triggerConnectionsJob))
    )

    ;;; The maximum number of connections that we will create to peers. ;;
    #_public
    (§ method int getMaxConnections())
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ return maxConnections)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    #_private
    (§ method List<Message> handleGetData(GetDataMessage m))
    (ß
        ;; Scans the wallets and memory pool for transactions in the getdata message and returns them.
        ;; Runs on peer threads.
        (§ call lock.lock())
        (§ try)
        (ß
            (§ var LinkedList<Message> transactions = new LinkedList<>())
            (§ var LinkedList<InventoryItem> items = new LinkedList<>(m.getItems()))
            (§ var Iterator<InventoryItem> it = items.iterator())
            (§ while (it.hasNext()))
            (ß
                (§ var InventoryItem item = it.next())
                ;; Check the wallets.
                (§ for (Wallet w :for wallets))
                (ß
                    (§ var Transaction tx = w.getTransaction(item.hash))
                    (§ if (tx != nil))
                    (ß
                        (§ call transactions.add(tx))
                        (§ call it.remove())
                        (§ break)
                    )
                )
            )
            (§ return transactions)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Sets the {@link VersionMessage} that will be announced on newly created connections.  A version message is
     ; primarily interesting because it lets you customize the "subVer" field which is used a bit like the User-Agent
     ; field from HTTP.  It means your client tells the other side what it is, see
     ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0014.mediawiki">BIP 14</a>.
     ;
     ; The VersionMessage you provide is copied and the best chain height/time filled in for each new connection,
     ; therefore you don't have to worry about setting that.  The provided object is really more of a template.
     ;;
    #_public
    (§ method void setVersionMessage(VersionMessage ver))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ ass versionMessage = ver)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Returns the version message provided by setVersionMessage or a default if none was given.
     ;;
    #_public
    (§ method VersionMessage getVersionMessage())
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ return versionMessage)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Sets information that identifies this software to remote nodes.  This is a convenience wrapper for creating
     ; a new {@link VersionMessage}, calling {@link VersionMessage#appendToSubVer(String, String, String)} on it,
     ; and then calling {@link PeerGroup#setVersionMessage(VersionMessage)} on the result of that.  See the docs for
     ; {@link VersionMessage#appendToSubVer(String, String, String)} for information on what the fields should contain.
     ;;
    #_public
    (§ method void setUserAgent(String name, String version, #_nilable String comments))
    (ß
        ;; TODO: Check that height is needed here (it wasnt, but it should be, no?)
        (§ var int height = (chain != nil) ? chain.getBestChainHeight() :else 0)
        (§ var VersionMessage ver = new VersionMessage(params, height))
        (§ ass ver.relayTxesBeforeFilter = false)
        (§ call updateVersionMessageRelayTxesBeforeFilter(ver))
        (§ call ver.appendToSubVer(name, version, comments))
        (§ call setVersionMessage(ver))
    )

    ;; Updates the relayTxesBeforeFilter flag of ver.
    #_private
    (§ method void updateVersionMessageRelayTxesBeforeFilter(VersionMessage ver))
    (ß
        ;; We will provide the remote node with a bloom filter (i.e. they shouldn't relay yet)
        ;; if chain == null || !chain.shouldVerifyTransactions() and a wallet is added and bloom filters are enabled.
        ;; Note that the default here means that no tx invs will be received if no wallet is ever added.
        (§ call lock.lock())
        (§ try)
        (ß
            (§ var boolean spvMode = (chain != nil && !chain.shouldVerifyTransactions()))
            (§ var boolean willSendFilter = (spvMode && 0 < peerFilterProviders.size() && vBloomFilteringEnabled))
            (§ ass ver.relayTxesBeforeFilter = !willSendFilter)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Sets information that identifies this software to remote nodes.  This is a convenience wrapper for creating
     ; a new {@link VersionMessage}, calling {@link VersionMessage#appendToSubVer(String, String, String)} on it,
     ; and then calling {@link PeerGroup#setVersionMessage(VersionMessage)} on the result of that.  See the docs for
     ; {@link VersionMessage#appendToSubVer(String, String, String)} for information on what the fields should contain.
     ;;
    #_public
    (§ method void setUserAgent(String name, String version))
    (ß
        (§ call setUserAgent(name, version, nil))
    )

    ;;; See {@link Peer#addBlocksDownloadedEventListener(BlocksDownloadedEventListener)}. ;;
    #_public
    (§ method void addBlocksDownloadedEventListener(BlocksDownloadedEventListener listener))
    (ß
        (§ call addBlocksDownloadedEventListener(Threading.USER_THREAD, listener))
    )

    ;;;
     ; <p>Adds a listener that will be notified on the given executor when
     ; blocks are downloaded by the download peer.</p>
     ; @see Peer#addBlocksDownloadedEventListener(Executor, BlocksDownloadedEventListener)
     ;;
    #_public
    (§ method void addBlocksDownloadedEventListener(Executor executor, BlocksDownloadedEventListener listener))
    (ß
        (§ call peersBlocksDownloadedEventListeners.add(new ListenerRegistration<>(Preconditions.checkNotNull(listener), executor)))
        (§ for (Peer peer :for getConnectedPeers()))
            (§ call peer.addBlocksDownloadedEventListener(executor, listener))
        (§ for (Peer peer :for getPendingPeers()))
            (§ call peer.addBlocksDownloadedEventListener(executor, listener))
    )

    ;;; See {@link Peer#addBlocksDownloadedEventListener(BlocksDownloadedEventListener)}. ;;
    #_public
    (§ method void addChainDownloadStartedEventListener(ChainDownloadStartedEventListener listener))
    (ß
        (§ call addChainDownloadStartedEventListener(Threading.USER_THREAD, listener))
    )

    ;;;
     ; <p>Adds a listener that will be notified on the given executor when
     ; chain download starts.</p>
     ;;
    #_public
    (§ method void addChainDownloadStartedEventListener(Executor executor, ChainDownloadStartedEventListener listener))
    (ß
        (§ call peersChainDownloadStartedEventListeners.add(new ListenerRegistration<>(Preconditions.checkNotNull(listener), executor)))
        (§ for (Peer peer :for getConnectedPeers()))
            (§ call peer.addChainDownloadStartedEventListener(executor, listener))
        (§ for (Peer peer :for getPendingPeers()))
            (§ call peer.addChainDownloadStartedEventListener(executor, listener))
    )

    ;;; See {@link Peer#addConnectedEventListener(PeerConnectedEventListener)}. ;;
    #_public
    (§ method void addConnectedEventListener(PeerConnectedEventListener listener))
    (ß
        (§ call addConnectedEventListener(Threading.USER_THREAD, listener))
    )

    ;;;
     ; <p>Adds a listener that will be notified on the given executor when
     ; new peers are connected to.</p>
     ;;
    #_public
    (§ method void addConnectedEventListener(Executor executor, PeerConnectedEventListener listener))
    (ß
        (§ call peerConnectedEventListeners.add(new ListenerRegistration<>(Preconditions.checkNotNull(listener), executor)))
        (§ for (Peer peer :for getConnectedPeers()))
            (§ call peer.addConnectedEventListener(executor, listener))
        (§ for (Peer peer :for getPendingPeers()))
            (§ call peer.addConnectedEventListener(executor, listener))
    )

    ;;; See {@link Peer#addDisconnectedEventListener(PeerDisconnectedEventListener)}. ;;
    #_public
    (§ method void addDisconnectedEventListener(PeerDisconnectedEventListener listener))
    (ß
        (§ call addDisconnectedEventListener(Threading.USER_THREAD, listener))
    )

    ;;;
     ; <p>Adds a listener that will be notified on the given executor when
     ; peers are disconnected from.</p>
     ;;
    #_public
    (§ method void addDisconnectedEventListener(Executor executor, PeerDisconnectedEventListener listener))
    (ß
        (§ call peerDisconnectedEventListeners.add(new ListenerRegistration<>(Preconditions.checkNotNull(listener), executor)))
        (§ for (Peer peer :for getConnectedPeers()))
            (§ call peer.addDisconnectedEventListener(executor, listener))
        (§ for (Peer peer :for getPendingPeers()))
            (§ call peer.addDisconnectedEventListener(executor, listener))
    )

    ;;; See {@link Peer#addDiscoveredEventListener(PeerDiscoveredEventListener)}. ;;
    #_public
    (§ method void addDiscoveredEventListener(PeerDiscoveredEventListener listener))
    (ß
        (§ call addDiscoveredEventListener(Threading.USER_THREAD, listener))
    )

    ;;;
     ; <p>Adds a listener that will be notified on the given executor when new
     ; peers are discovered.</p>
     ;;
    #_public
    (§ method void addDiscoveredEventListener(Executor executor, PeerDiscoveredEventListener listener))
    (ß
        (§ call peerDiscoveredEventListeners.add(new ListenerRegistration<>(Preconditions.checkNotNull(listener), executor)))
    )

    ;;; See {@link Peer#addGetDataEventListener(GetDataEventListener)}. ;;
    #_public
    (§ method void addGetDataEventListener(GetDataEventListener listener))
    (ß
        (§ call addGetDataEventListener(Threading.USER_THREAD, listener))
    )

    ;;; See {@link Peer#addGetDataEventListener(Executor, GetDataEventListener)}. ;;
    #_public
    (§ method void addGetDataEventListener(#_final Executor executor, #_final GetDataEventListener listener))
    (ß
        (§ call peerGetDataEventListeners.add(new ListenerRegistration<>(Preconditions.checkNotNull(listener), executor)))
        (§ for (Peer peer :for getConnectedPeers()))
            (§ call peer.addGetDataEventListener(executor, listener))
        (§ for (Peer peer :for getPendingPeers()))
            (§ call peer.addGetDataEventListener(executor, listener))
    )

    ;;; See {@link Peer#addOnTransactionBroadcastListener(OnTransactionBroadcastListener)}. ;;
    #_public
    (§ method void addOnTransactionBroadcastListener(OnTransactionBroadcastListener listener))
    (ß
        (§ call addOnTransactionBroadcastListener(Threading.USER_THREAD, listener))
    )

    ;;; See {@link Peer#addOnTransactionBroadcastListener(OnTransactionBroadcastListener)}. ;;
    #_public
    (§ method void addOnTransactionBroadcastListener(Executor executor, OnTransactionBroadcastListener listener))
    (ß
        (§ call peersTransactionBroadastEventListeners.add(new ListenerRegistration<>(Preconditions.checkNotNull(listener), executor)))
        (§ for (Peer peer :for getConnectedPeers()))
            (§ call peer.addOnTransactionBroadcastListener(executor, listener))
        (§ for (Peer peer :for getPendingPeers()))
            (§ call peer.addOnTransactionBroadcastListener(executor, listener))
    )

    ;;; See {@link Peer#addPreMessageReceivedEventListener(PreMessageReceivedEventListener)}. ;;
    #_public
    (§ method void addPreMessageReceivedEventListener(PreMessageReceivedEventListener listener))
    (ß
        (§ call addPreMessageReceivedEventListener(Threading.USER_THREAD, listener))
    )

    ;;; See {@link Peer#addPreMessageReceivedEventListener(Executor, PreMessageReceivedEventListener)}. ;;
    #_public
    (§ method void addPreMessageReceivedEventListener(Executor executor, PreMessageReceivedEventListener listener))
    (ß
        (§ call peersPreMessageReceivedEventListeners.add(new ListenerRegistration<>(Preconditions.checkNotNull(listener), executor)))
        (§ for (Peer peer :for getConnectedPeers()))
            (§ call peer.addPreMessageReceivedEventListener(executor, listener))
        (§ for (Peer peer :for getPendingPeers()))
            (§ call peer.addPreMessageReceivedEventListener(executor, listener))
    )

    #_public
    (§ method boolean removeBlocksDownloadedEventListener(BlocksDownloadedEventListener listener))
    (ß
        (§ var boolean result = ListenerRegistration.removeFromList(listener, peersBlocksDownloadedEventListeners))
        (§ for (Peer peer :for getConnectedPeers()))
            (§ call peer.removeBlocksDownloadedEventListener(listener))
        (§ for (Peer peer :for getPendingPeers()))
            (§ call peer.removeBlocksDownloadedEventListener(listener))
        (§ return result)
    )

    #_public
    (§ method boolean removeChainDownloadStartedEventListener(ChainDownloadStartedEventListener listener))
    (ß
        (§ var boolean result = ListenerRegistration.removeFromList(listener, peersChainDownloadStartedEventListeners))
        (§ for (Peer peer :for getConnectedPeers()))
            (§ call peer.removeChainDownloadStartedEventListener(listener))
        (§ for (Peer peer :for getPendingPeers()))
            (§ call peer.removeChainDownloadStartedEventListener(listener))
        (§ return result)
    )

    ;;; The given event listener will no longer be called with events. ;;
    #_public
    (§ method boolean removeConnectedEventListener(PeerConnectedEventListener listener))
    (ß
        (§ var boolean result = ListenerRegistration.removeFromList(listener, peerConnectedEventListeners))
        (§ for (Peer peer :for getConnectedPeers()))
            (§ call peer.removeConnectedEventListener(listener))
        (§ for (Peer peer :for getPendingPeers()))
            (§ call peer.removeConnectedEventListener(listener))
        (§ return result)
    )

    ;;; The given event listener will no longer be called with events. ;;
    #_public
    (§ method boolean removeDisconnectedEventListener(PeerDisconnectedEventListener listener))
    (ß
        (§ var boolean result = ListenerRegistration.removeFromList(listener, peerDisconnectedEventListeners))
        (§ for (Peer peer :for getConnectedPeers()))
            (§ call peer.removeDisconnectedEventListener(listener))
        (§ for (Peer peer :for getPendingPeers()))
            (§ call peer.removeDisconnectedEventListener(listener))
        (§ return result)
    )

    ;;; The given event listener will no longer be called with events. ;;
    #_public
    (§ method boolean removeDiscoveredEventListener(PeerDiscoveredEventListener listener))
    (ß
        (§ var boolean result = ListenerRegistration.removeFromList(listener, peerDiscoveredEventListeners))
        (§ return result)
    )

    ;;; The given event listener will no longer be called with events. ;;
    #_public
    (§ method boolean removeGetDataEventListener(GetDataEventListener listener))
    (ß
        (§ var boolean result = ListenerRegistration.removeFromList(listener, peerGetDataEventListeners))
        (§ for (Peer peer :for getConnectedPeers()))
            (§ call peer.removeGetDataEventListener(listener))
        (§ for (Peer peer :for getPendingPeers()))
            (§ call peer.removeGetDataEventListener(listener))
        (§ return result)
    )

    ;;; The given event listener will no longer be called with events. ;;
    #_public
    (§ method boolean removeOnTransactionBroadcastListener(OnTransactionBroadcastListener listener))
    (ß
        (§ var boolean result = ListenerRegistration.removeFromList(listener, peersTransactionBroadastEventListeners))
        (§ for (Peer peer :for getConnectedPeers()))
            (§ call peer.removeOnTransactionBroadcastListener(listener))
        (§ for (Peer peer :for getPendingPeers()))
            (§ call peer.removeOnTransactionBroadcastListener(listener))
        (§ return result)
    )

    #_public
    (§ method boolean removePreMessageReceivedEventListener(PreMessageReceivedEventListener listener))
    (ß
        (§ var boolean result = ListenerRegistration.removeFromList(listener, peersPreMessageReceivedEventListeners))
        (§ for (Peer peer :for getConnectedPeers()))
            (§ call peer.removePreMessageReceivedEventListener(listener))
        (§ for (Peer peer :for getPendingPeers()))
            (§ call peer.removePreMessageReceivedEventListener(listener))
        (§ return result)
    )

    ;;;
     ; Returns a newly allocated list containing the currently connected peers.
     ; If all you care about is the count, use numConnectedPeers().
     ;;
    #_public
    (§ method List<Peer> getConnectedPeers())
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ return new ArrayList<>(peers))
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Returns a list containing Peers that did not complete connection yet.
     ;;
    #_public
    (§ method List<Peer> getPendingPeers())
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ return new ArrayList<>(pendingPeers))
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Add an address to the list of potential peers to connect to.  It won't necessarily be used unless there's a need
     ; to build new connections to reach the max connection count.
     ;
     ; @param peerAddress IP/port to use.
     ;;
    #_public
    (§ method void addAddress(PeerAddress peerAddress))
    (ß
        (§ var int newMax)
        (§ call lock.lock())
        (§ try)
        (ß
            (§ call addInactive(peerAddress))
            (§ ass newMax = getMaxConnections() + 1)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
        (§ call setMaxConnections(newMax))
    )

    #_private
    (§ method void addInactive(PeerAddress peerAddress))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            ;; Deduplicate.
            (§ if (backoffMap.containsKey(peerAddress)))
                (§ return)
            (§ call backoffMap.put(peerAddress, new ExponentialBackoff(peerBackoffParams)))
            (§ call inactives.offer(peerAddress))
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Convenience for connecting only to peers that can serve specific services.
     ; It will configure suitable peer discoveries.
     ; @param requiredServices Required services as a bitmask, e.g. {@link VersionMessage#NODE_NETWORK}.
     ;;
    #_public
    (§ method void setRequiredServices(long requiredServices))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ ass this.requiredServices = requiredServices)
            (§ call peerDiscoverers.clear())
            (§ call addPeerDiscovery(MultiplexingDiscovery.forServices(params, requiredServices)))
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;; Convenience method for addAddress(new PeerAddress(address, params.port)). ;;
    #_public
    (§ method void addAddress(InetAddress address))
    (ß
        (§ call addAddress(new PeerAddress(params, address, params.getPort())))
    )

    ;;;
     ; Add addresses from a discovery source to the list of potential peers to connect to.
     ; If max connections has not been configured, or set to zero, then it's set to the default at this point.
     ;;
    #_public
    (§ method void addPeerDiscovery(PeerDiscovery peerDiscovery))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ if (getMaxConnections() == 0))
                (§ call setMaxConnections(DEFAULT_CONNECTIONS))
            (§ call peerDiscoverers.add(peerDiscovery))
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;; Returns number of discovered peers. ;;
    #_protected
    (§ method int discoverPeers())
        (§ throws PeerDiscoveryException)
    (ß
        ;; Don't hold the lock whilst doing peer discovery: it can take a long time and cause high API latency.
        (§ call Preconditions.checkState(!lock.isHeldByCurrentThread()))

        (§ var int maxPeersToDiscoverCount = this.vMaxPeersToDiscoverCount)
        (§ var long peerDiscoveryTimeoutMillis = this.vPeerDiscoveryTimeoutMillis)
        #_final
        (§ var Stopwatch watch = Stopwatch.createStarted())
        #_final
        (§ var List<PeerAddress> addressList = Lists.newLinkedList())

        (§ for (PeerDiscovery peerDiscovery :for peerDiscoverers)) ;; COW
        (ß
            (§ var InetSocketAddress[] addresses = peerDiscovery.getPeers(requiredServices, peerDiscoveryTimeoutMillis, TimeUnit.MILLISECONDS))
            (§ for (InetSocketAddress address :for addresses))
                (§ call addressList.add(new PeerAddress(params, address)))
            (§ if (maxPeersToDiscoverCount <= addressList.size()))
                (§ break)
        )

        (§ if (!addressList.isEmpty()))
        (ß
            (§ for (PeerAddress address :for addressList))
                (§ call addInactive(address))

            #_final
            (§ var ImmutableSet<PeerAddress> peersDiscoveredSet = ImmutableSet.copyOf(addressList))
            (§ for (#_final ListenerRegistration<PeerDiscoveredEventListener> registration :for peerDiscoveredEventListeners)) ;; COW
            (ß
                (§ call registration.executor.execute(new Runnable()
                (ß
                    #_override
                    #_public
                    (§ method void run())
                    (ß
                        (§ call registration.listener.onPeersDiscovered(peersDiscoveredSet))
                    )
                )))
            )
        )
        (§ call watch.stop())
        (§ call log.info("Peer discovery took {} and returned {} items", watch, addressList.size()))
        (§ return addressList.size())
    )

    #_testing
    (§ method void waitForJobQueue())
    (ß
        (§ call Futures.getUnchecked(executor.submit(Runnables.doNothing())))
    )

    #_private
    (§ method int countConnectedAndPendingPeers())
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ return peers.size() + pendingPeers.size())
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    #_private
    (§ enum LocalhostCheckState
        (§ item NOT_TRIED)
        (§ item FOUND)
        (§ item FOUND_AND_CONNECTED)
        (§ item NOT_THERE)
    )
    #_private
    (§ field LocalhostCheckState localhostCheckState = LocalhostCheckState.NOT_TRIED)

    #_private
    (§ method boolean maybeCheckForLocalhostPeer())
    (ß
        (§ call Preconditions.checkState(lock.isHeldByCurrentThread()))

        (§ if (localhostCheckState == LocalhostCheckState.NOT_TRIED))
        (ß
            ;; Do a fast blocking connect to see if anything is listening.
            (§ var Socket socket = nil)
            (§ try)
            (ß
                (§ ass socket = new Socket())
                (§ call socket.connect(new InetSocketAddress(InetAddresses.forString("127.0.0.1"), params.getPort()), vConnectTimeoutMillis))
                (§ ass localhostCheckState = LocalhostCheckState.FOUND)
                (§ return true)
            )
            (§ catch (IOException e))
            (ß
                (§ call log.info("Localhost peer not detected."))
                (§ ass localhostCheckState = LocalhostCheckState.NOT_THERE)
            )
            (§ finally)
            (ß
                (§ if (socket != nil))
                (ß
                    (§ try)
                    (ß
                        (§ call socket.close())
                    )
                    (§ catch (IOException _))
                    (ß
                        ;; Ignore.
                    )
                )
            )
        )
        (§ return false)
    )

    ;;;
     ; Starts the PeerGroup and begins network activity.
     ; @return A future that completes when first connection activity has been triggered (note: not first connection made).
     ;;
    #_public
    (§ method ListenableFuture startAsync())
    (ß
        ;; This is run in a background thread by the Service implementation.
        (§ if (chain == nil))
        (ß
            ;; Just try to help catch what might be a programming error.
            (§ call log.warn("Starting up with no attached block chain. Did you forget to pass one to the constructor?"))
        )
        (§ call Preconditions.checkState(!vUsedUp, "Cannot start a peer group twice"))

        (§ ass vRunning = true)
        (§ ass vUsedUp = true)
        (§ call executorStartupLatch.countDown())

        ;; We do blocking waits during startup, so run on the executor thread.
        (§ return executor.submit(new Runnable()
        (ß
            #_override
            #_public
            (§ method void run())
            (ß
                (§ try)
                (ß
                    (§ call log.info("Starting ..."))
                    (§ call channels.startAsync())
                    (§ call channels.awaitRunning())
                    (§ call triggerConnections())
                    (§ call setupPinging())
                )
                (§ catch (Throwable e))
                (ß
                    (§ call log.error("Exception when starting up", e)) ;; The executor swallows exceptions :( ;; )
                )
            )
        )))
    )

    ;;; Does a blocking startup. ;;
    #_public
    (§ method void start())
    (ß
        (§ call Futures.getUnchecked(startAsync()))
    )

    ;;; Can just use start() for a blocking start here instead of startAsync/awaitRunning: PeerGroup is no longer a Guava service. ;;
    #_deprecated
    #_public
    (§ method void awaitRunning())
    (ß
        (§ call waitForJobQueue())
    )

    #_public
    (§ method ListenableFuture stopAsync())
    (ß
        (§ call Preconditions.checkState(vRunning))
        (§ ass vRunning = false)
        (§ var ListenableFuture future = executor.submit(new Runnable()
        (ß
            #_override
            #_public
            (§ method void run())
            (ß
                (§ try)
                (ß
                    (§ call log.info("Stopping ..."))
                    ;; Blocking close of all sockets.
                    (§ call channels.stopAsync())
                    (§ call channels.awaitTerminated())
                    (§ for (PeerDiscovery peerDiscovery :for peerDiscoverers))
                    (ß
                        (§ call peerDiscovery.shutdown())
                    )
                    (§ ass vRunning = false)
                    (§ call log.info("Stopped."))
                )
                (§ catch (Throwable e))
                (ß
                    (§ call log.error("Exception when shutting down", e)) ;; The executor swallows exceptions :( ;; )
                )
            )
        )))
        (§ call executor.shutdown())
        (§ return future)
    )

    ;;; Does a blocking stop. ;;
    #_public
    (§ method void stop())
    (ß
        (§ try)
        (ß
            (§ call stopAsync())
            (§ call log.info("Awaiting PeerGroup shutdown ..."))
            (§ call executor.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS))
        )
        (§ catch (InterruptedException e))
        (ß
            (§ throw new RuntimeException(e))
        )
    )

    ;;; Can just use stop() here instead of stopAsync/awaitTerminated: PeerGroup is no longer a Guava service. ;;
    #_deprecated
    #_public
    (§ method void awaitTerminated())
    (ß
        (§ try)
        (ß
            (§ call executor.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS))
        )
        (§ catch (InterruptedException e))
        (ß
            (§ throw new RuntimeException(e))
        )
    )

    ;;;
     ; <p>Link the given wallet to this PeerGroup.  This is used for three purposes:</p>
     ;
     ; <ol>
     ;   <li>So the wallet receives broadcast transactions.</li>
     ;   <li>Announcing pending transactions that didn't get into the chain yet to our peers.</li>
     ;   <li>Set the fast catchup time using {@link PeerGroup#setFastCatchupTimeSecs(long)} to optimize chain download.</li>
     ; </ol>
     ;
     ; <p>Note that this should be done before chain download commences because if you add a wallet with keys earlier
     ; than the current chain head, the relevant parts of the chain won't be redownloaded for you.</p>
     ;
     ; <p>The Wallet will have an event listener registered on it, so to avoid leaks remember to use
     ; {@link PeerGroup#removeWallet(Wallet)} on it if you wish to keep the Wallet but lose the PeerGroup.</p>
     ;;
    #_public
    (§ method void addWallet(Wallet wallet))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ call Preconditions.checkNotNull(wallet))
            (§ call Preconditions.checkState(!wallets.contains(wallet)))
            (§ call wallets.add(wallet))
            (§ call wallet.setTransactionBroadcaster(this))
            (§ call wallet.addCoinsReceivedEventListener(Threading.SAME_THREAD, walletCoinsReceivedEventListener))
            (§ call wallet.addKeyChainEventListener(Threading.SAME_THREAD, walletKeyEventListener))
            (§ call addPeerFilterProvider(wallet))
            (§ for (Peer peer :for peers))
                (§ call peer.addWallet(wallet))
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; <p>Link the given PeerFilterProvider to this PeerGroup.
     ; DO NOT use this for Wallets, use {@link PeerGroup#addWallet(Wallet)} instead.</p>
     ;
     ; <p>Note that this should be done before chain download commences because if you add a listener with keys earlier
     ; than the current chain head, the relevant parts of the chain won't be redownloaded for you.</p>
     ;
     ; <p>This method invokes {@link PeerGroup#recalculateFastCatchupAndFilter(FilterRecalculateMode)}.
     ; The return value of this method is the <code>ListenableFuture</code> returned by that invocation.</p>
     ;
     ; @return a future that completes once each <code>Peer</code> in this group has had its <code>BloomFilter</code> (re)set.
     ;;
    #_public
    (§ method ListenableFuture<BloomFilter> addPeerFilterProvider(PeerFilterProvider provider))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ call Preconditions.checkNotNull(provider))
            (§ call Preconditions.checkState(!peerFilterProviders.contains(provider)))
            ;; Insert provider at the start.  This avoids various concurrency problems that could occur because we need
            ;; all providers to be in a consistent, unchanging state whilst the filter is built.  Providers can give
            ;; this guarantee by taking a lock in their begin method, but if we add to the end of the list here, it
            ;; means we establish a lock ordering a > b > c if that's the order the providers were added in.  Given that
            ;; the main wallet will usually be first, this establishes an ordering wallet > other-provider, which means
            ;; other-provider can then not call into the wallet itself.  Other providers installed by the API user should
            ;; come first so the expected ordering is preserved.  This can also manifest itself in providers that use
            ;; synchronous RPCs into an actor instead of locking, but the same issue applies.
            (§ call peerFilterProviders.add(0, provider))

            ;; Don't bother downloading block bodies before the oldest keys in all our wallets.  Make sure we recalculate
            ;; if a key is added.  Of course, by then we may have downloaded the chain already.  Ideally adding keys would
            ;; automatically rewind the block chain and redownload the blocks to find transactions relevant to those keys,
            ;; all transparently and in the background.  But we are a long way from that yet.
            (§ var ListenableFuture<BloomFilter> future = recalculateFastCatchupAndFilter(FilterRecalculateMode.SEND_IF_CHANGED))
            (§ call updateVersionMessageRelayTxesBeforeFilter(getVersionMessage()))
            (§ return future)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Opposite of {@link #addPeerFilterProvider(PeerFilterProvider)}.  Again, don't use this for wallets.  Does not
     ; trigger recalculation of the filter.
     ;;
    #_public
    (§ method void removePeerFilterProvider(PeerFilterProvider provider))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ call Preconditions.checkNotNull(provider))
            (§ call Preconditions.checkArgument(peerFilterProviders.remove(provider)))
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Unlinks the given wallet so it no longer receives broadcast transactions or has its transactions announced.
     ;;
    #_public
    (§ method void removeWallet(Wallet wallet))
    (ß
        (§ call wallets.remove(Preconditions.checkNotNull(wallet)))
        (§ call peerFilterProviders.remove(wallet))
        (§ call wallet.removeCoinsReceivedEventListener(walletCoinsReceivedEventListener))
        (§ call wallet.removeKeyChainEventListener(walletKeyEventListener))
        (§ call wallet.setTransactionBroadcaster(nil))
        (§ for (Peer peer :for peers))
            (§ call peer.removeWallet(wallet))
    )

    #_public
    (§ enum FilterRecalculateMode
        (§ item SEND_IF_CHANGED)
        (§ item FORCE_SEND_FOR_REFRESH)
        (§ item DONT_SEND)
    )

    #_private
    #_final
    (§ field Map<FilterRecalculateMode, SettableFuture<BloomFilter>> inFlightRecalculations = Maps.newHashMap())

    ;;;
     ; Recalculates the bloom filter given to peers as well as the timestamp after which full blocks are downloaded
     ; (instead of only headers).  Note that calls made one after another may return the same future, if the request
     ; wasn't processed yet (i.e. calls are deduplicated).
     ;
     ; @param mode In what situations to send the filter to connected peers.
     ; @return A future that completes once the filter has been calculated (note: this does not mean acknowledged by remote peers).
     ;;
    #_public
    (§ method ListenableFuture<BloomFilter> recalculateFastCatchupAndFilter(#_final FilterRecalculateMode mode))
    (ß
        #_final
        (§ var SettableFuture<BloomFilter> future = SettableFuture.create())
        (§ sync inFlightRecalculations)
        (ß
            (§ if (inFlightRecalculations.get(mode) != nil))
                (§ return inFlightRecalculations.get(mode))

            (§ call inFlightRecalculations.put(mode, future))
        )
        (§ var Runnable command = new Runnable()
        (ß
            #_override
            #_public
            (§ method void run())
            (ß
                (§ try)
                (ß
                    (§ call go())
                )
                (§ catch (Throwable e))
                (ß
                    (§ call log.error("Exception when trying to recalculate Bloom filter", e)) ;; The executor swallows exceptions :( ;; )
                )
            )

            #_public
            (§ method void go())
            (ß
                (§ call Preconditions.checkState(!lock.isHeldByCurrentThread()))
                ;; Fully verifying mode doesn't use this optimization (it can't as it needs to see all transactions).
                (§ if ((chain != nil && chain.shouldVerifyTransactions()) || !vBloomFilteringEnabled))
                    (§ return)

                ;; We only ever call bloomFilterMerger.calculate on jobQueue, so we cannot be calculating two filters at once.
                (§ var FilterMerger.Result result = bloomFilterMerger.calculate(ImmutableList.copyOf(peerFilterProviders))) ;; COW
                (§ var boolean send)
                (§ switch (mode))
                (ß
                    (§ case SEND_IF_CHANGED)
                        (§ ass send = result.changed)
                        (§ break)
                    (§ case DONT_SEND)
                        (§ ass send = false)
                        (§ break)
                    (§ case FORCE_SEND_FOR_REFRESH)
                        (§ ass send = true)
                        (§ break)
                    (§ default)
                        (§ throw new UnsupportedOperationException())
                )
                (§ if (send))
                (ß
                    (§ for (Peer peer :for peers)) ;; COW
                    (ß
                        ;; Only query the mempool if this recalculation request is not in order to lower the observed FP
                        ;; rate.  There's no point querying the mempool when doing this because the FP rate can only go
                        ;; down, and we will have seen all the relevant txns before: it's pointless to ask for them again.
                        (§ call peer.setBloomFilter(result.filter, mode != FilterRecalculateMode.FORCE_SEND_FOR_REFRESH))
                    )
                    ;; Reset the false positive estimate so that we don't send a flood of filter updates
                    ;; if the estimate temporarily overshoots our threshold.
                    (§ if (chain != nil))
                        (§ call chain.resetFalsePositiveEstimate())
                )
                ;; Do this last so that bloomFilter is already set when it gets called.
                (§ call setFastCatchupTimeSecs(result.earliestKeyTimeSecs))
                (§ sync inFlightRecalculations)
                (ß
                    (§ call inFlightRecalculations.put(mode, nil))
                )
                (§ call future.set(result.filter))
            )
        ))
        (§ try)
        (ß
            (§ call executor.execute(command))
        )
        (§ catch (RejectedExecutionException _))
        (ß
            ;; Can happen during shutdown.
        )
        (§ return future)
    )

    ;;;
     ; <p>Sets the false positive rate of bloom filters given to peers.  The default is {@link #DEFAULT_BLOOM_FILTER_FP_RATE}.</p>
     ;
     ; <p>Be careful regenerating the bloom filter too often, as it decreases anonymity because remote nodes can
     ; compare transactions against both the new and old filters to significantly decrease the false positive rate.</p>
     ;
     ; <p>See the docs for {@link BloomFilter#BloomFilter(int, double, long, BloomFilter.BloomUpdate)} for a brief
     ; explanation of anonymity when using bloom filters.</p>
     ;;
    #_public
    (§ method void setBloomFilterFalsePositiveRate(double bloomFilterFPRate))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ call bloomFilterMerger.setBloomFilterFPRate(bloomFilterFPRate))
            (§ call recalculateFastCatchupAndFilter(FilterRecalculateMode.SEND_IF_CHANGED))
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Returns the number of currently connected peers.  To be informed when this count changes, register a
     ; {@link org.bitcoinj.core.listeners.PeerConnectedEventListener}/{@link org.bitcoinj.core.listeners.PeerDisconnectedEventListener}
     ; and use the onPeerConnected/onPeerDisconnected methods.
     ;;
    #_public
    (§ method int numConnectedPeers())
    (ß
        (§ return peers.size())
    )

    ;;;
     ; Connect to a peer by creating a channel to the destination address.  This should not be
     ; used normally - let the PeerGroup manage connections through {@link #start()}.
     ;
     ; @param address Destination IP and port.
     ; @return The newly created Peer object or null if the peer could not be connected.
     ;         Use {@link org.bitcoinj.core.Peer#getConnectionOpenFuture()} if you
     ;         want a future which completes when the connection is open.
     ;;
    #_nilable
    #_public
    (§ method Peer connectTo(InetSocketAddress address))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ var PeerAddress peerAddress = new PeerAddress(params, address))
            (§ call backoffMap.put(peerAddress, new ExponentialBackoff(peerBackoffParams)))
            (§ return connectTo(peerAddress, true, vConnectTimeoutMillis))
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Helper for forcing a connection to localhost.  Useful when using test mode.  Returns the peer object.
     ;;
    #_nilable
    #_public
    (§ method Peer connectToLocalHost())
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            #_final
            (§ var PeerAddress localhost = PeerAddress.localhost(params))
            (§ call backoffMap.put(localhost, new ExponentialBackoff(peerBackoffParams)))
            (§ return connectTo(localhost, true, vConnectTimeoutMillis))
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Creates a version message to send, constructs a Peer object and attempts to connect it.
     ; Returns the peer on success or null on failure.
     ; @param address Remote network address.
     ; @param incrementMaxConnections Whether to consider this connection an attempt to fill our quota, or something explicitly requested.
     ; @return Peer or null.
     ;;
    #_nilable
    #_guarded-by(ß "lock")
    #_protected
    (§ method Peer connectTo(PeerAddress address, boolean incrementMaxConnections, int connectTimeoutMillis))
    (ß
        (§ call Preconditions.checkState(lock.isHeldByCurrentThread()))
        (§ var VersionMessage ver = getVersionMessage().duplicate())
        (§ ass ver.bestHeight = (chain != nil) ? chain.getBestChainHeight() :else 0)
        (§ ass ver.time = Utils.currentTimeSeconds())

        (§ var Peer peer = createPeer(address, ver))
        (§ call peer.addConnectedEventListener(Threading.SAME_THREAD, startupListener))
        (§ call peer.addDisconnectedEventListener(Threading.SAME_THREAD, startupListener))
        (§ call peer.setMinProtocolVersion(vMinRequiredProtocolVersion))
        (§ call pendingPeers.add(peer))

        (§ try)
        (ß
            (§ call log.info("Attempting connection to {}     ({} connected, {} pending, {} max)", address, peers.size(), pendingPeers.size(), maxConnections))
            (§ var ListenableFuture<SocketAddress> future = channels.openConnection(address.toSocketAddress(), peer))
            (§ if (future.isDone()))
                (§ call Uninterruptibles.getUninterruptibly(future))
        )
        (§ catch (ExecutionException e))
        (ß
            (§ var Throwable cause = Throwables.getRootCause(e))
            (§ call log.warn("Failed to connect to " + address + ": " + cause.getMessage()))
            (§ call handlePeerDeath(peer, cause))
            (§ return nil)
        )
        (§ call peer.setSocketTimeout(connectTimeoutMillis))
        ;; When the channel has connected and version negotiated successfully, handleNewPeer will end up being called
        ;; on a worker thread.
        (§ if (incrementMaxConnections))
        (ß
            ;; We don't use setMaxConnections here as that would trigger a recursive attempt to establish a new
            ;; outbound connection.
            (§ ass maxConnections = maxConnections + 1)
        )
        (§ return peer)
    )

    ;;; You can override this to customise the creation of {@link Peer} objects. ;;
    #_guarded-by(ß "lock")
    #_protected
    (§ method Peer createPeer(PeerAddress address, VersionMessage ver))
    (ß
        (§ return new Peer(params, ver, address, chain, downloadTxDependencyDepth))
    )

    ;;;
     ; Sets the timeout between when a connection attempt to a peer begins and when the version message exchange completes.
     ; This does not apply to currently pending peers.
     ;;
    #_public
    (§ method void setConnectTimeoutMillis(int connectTimeoutMillis))
    (ß
        (§ ass this.vConnectTimeoutMillis = connectTimeoutMillis)
    )

    ;;;
     ; <p>Start downloading the blockchain from the first available peer.</p>
     ;
     ; <p>If no peers are currently connected, the download will be started once a peer starts.  If the peer dies,
     ; the download will resume with another peer.</p>
     ;
     ; @param listener A listener for chain download events, may not be null.
     ;;
    #_public
    (§ method void startBlockChainDownload(PeerDataEventListener listener))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ if (downloadPeer != nil))
            (ß
                (§ if (this.downloadListener != nil))
                    (§ call removeDataEventListenerFromPeer(downloadPeer, this.downloadListener))
                (§ if (listener != nil))
                    (§ call addDataEventListenerToPeer(Threading.USER_THREAD, downloadPeer, listener))
            )
            (§ ass this.downloadListener = listener)
            ;; TODO: Be more nuanced about which peer to download from.  We can also try
            ;; downloading from multiple peers and handle the case when a new peer comes along
            ;; with a longer chain after we thought we were done.
            (§ if (!peers.isEmpty()))
                (§ call startBlockChainDownloadFromPeer(peers.iterator().next())) ;; Will add the new download listener.
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Register a data event listener against a single peer (i.e. for blockchain download).
     ; Handling registration/deregistration on peer death/add is outside the scope of these methods.
     ;;
    #_private
    #_static
    (§ method void addDataEventListenerToPeer(Executor executor, Peer peer, PeerDataEventListener downloadListener))
    (ß
        (§ call peer.addBlocksDownloadedEventListener(executor, downloadListener))
        (§ call peer.addChainDownloadStartedEventListener(executor, downloadListener))
        (§ call peer.addGetDataEventListener(executor, downloadListener))
        (§ call peer.addPreMessageReceivedEventListener(executor, downloadListener))
    )

    ;;;
     ; Remove a registered data event listener against a single peer (i.e. for blockchain download).
     ; Handling registration/deregistration on peer death/add is outside the scope of these methods.
     ;;
    #_private
    #_static
    (§ method void removeDataEventListenerFromPeer(Peer peer, PeerDataEventListener listener))
    (ß
        (§ call peer.removeBlocksDownloadedEventListener(listener))
        (§ call peer.removeChainDownloadStartedEventListener(listener))
        (§ call peer.removeGetDataEventListener(listener))
        (§ call peer.removePreMessageReceivedEventListener(listener))
    )

    ;;;
     ; Download the blockchain from peers.  Convenience that uses a {@link DownloadProgressTracker} for you.
     ;
     ; This method waits until the download is complete.  "Complete" is defined as downloading
     ; from at least one peer all the blocks that are in that peer's inventory.
     ;;
    #_public
    (§ method void downloadBlockChain())
    (ß
        (§ var DownloadProgressTracker listener = new DownloadProgressTracker())
        (§ call startBlockChainDownload(listener))
        (§ try)
        (ß
            (§ call listener.await())
        )
        (§ catch (InterruptedException e))
        (ß
            (§ throw new RuntimeException(e))
        )
    )

    #_protected
    (§ method void handleNewPeer(#_final Peer peer))
    (ß
        (§ var int newSize = -1)
        (§ call lock.lock())
        (§ try)
        (ß
            (§ call groupBackoff.trackSuccess())
            (§ call backoffMap.get(peer.getAddress()).trackSuccess())

            ;; Sets up the newly connected peer so it can do everything it needs to.
            (§ call pendingPeers.remove(peer))
            (§ call peers.add(peer))
            (§ ass newSize = peers.size())
            (§ call log.info("{}: New peer      ({} connected, {} pending, {} max)", peer, newSize, pendingPeers.size(), maxConnections))
            ;; Give the peer a filter that can be used to probabilistically drop transactions that
            ;; aren't relevant to our wallet.  We may still receive some false positives, which is
            ;; OK because it helps improve wallet privacy.  Old nodes will just ignore the message.
            (§ if (bloomFilterMerger.getLastFilter() != nil))
                (§ call peer.setBloomFilter(bloomFilterMerger.getLastFilter()))
            (§ call peer.setDownloadData(false))
            ;; TODO: The peer should calculate the fast catchup time from the added wallets here.
            (§ for (Wallet wallet :for wallets))
                (§ call peer.addWallet(wallet))
            (§ if (downloadPeer == nil))
            (ß
                ;; Kick off chain download if we aren't already doing it.
                (§ call setDownloadPeer(selectDownloadPeer(peers)))
                (§ var boolean shouldDownloadChain = (downloadListener != nil && chain != nil))
                (§ if (shouldDownloadChain))
                    (§ call startBlockChainDownloadFromPeer(downloadPeer))
            )
            ;; Make sure the peer knows how to upload transactions that are requested from us.
            (§ call peer.addBlocksDownloadedEventListener(Threading.SAME_THREAD, peerListener))
            (§ call peer.addGetDataEventListener(Threading.SAME_THREAD, peerListener))

            ;; And set up event listeners for clients.  This will allow them to find out about new transactions and blocks.
            (§ for (ListenerRegistration<BlocksDownloadedEventListener> registration :for peersBlocksDownloadedEventListeners))
                (§ call peer.addBlocksDownloadedEventListener(registration.executor, registration.listener))
            (§ for (ListenerRegistration<ChainDownloadStartedEventListener> registration :for peersChainDownloadStartedEventListeners))
                (§ call peer.addChainDownloadStartedEventListener(registration.executor, registration.listener))
            (§ for (ListenerRegistration<PeerConnectedEventListener> registration :for peerConnectedEventListeners))
                (§ call peer.addConnectedEventListener(registration.executor, registration.listener))

            ;; We intentionally do not add disconnect listeners to peers.
            (§ for (ListenerRegistration<GetDataEventListener> registration :for peerGetDataEventListeners))
                (§ call peer.addGetDataEventListener(registration.executor, registration.listener))
            (§ for (ListenerRegistration<OnTransactionBroadcastListener> registration :for peersTransactionBroadastEventListeners))
                (§ call peer.addOnTransactionBroadcastListener(registration.executor, registration.listener))
            (§ for (ListenerRegistration<PreMessageReceivedEventListener> registration :for peersPreMessageReceivedEventListeners))
                (§ call peer.addPreMessageReceivedEventListener(registration.executor, registration.listener))
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )

        #_final
        (§ var int fNewSize = newSize)
        (§ for (#_final ListenerRegistration<PeerConnectedEventListener> registration :for peerConnectedEventListeners))
        (ß
            (§ call registration.executor.execute(new Runnable()
            (ß
                #_override
                #_public
                (§ method void run())
                (ß
                    (§ call registration.listener.onPeerConnected(peer, fNewSize))
                )
            )))
        )
    )

    #_nilable
    #_private
    #_volatile
    (§ field ListenableScheduledFuture<?> vPingTask)

    #_suppress(ß "NonAtomicOperationOnVolatileField")
    #_private
    (§ method void setupPinging())
    (ß
        (§ if (getPingIntervalMsec() <= 0))
            (§ return) ;; Disabled.

        (§ ass vPingTask = executor.scheduleAtFixedRate(new Runnable()
        (ß
            #_override
            #_public
            (§ method void run())
            (ß
                (§ try)
                (ß
                    (§ if (getPingIntervalMsec() <= 0))
                    (ß
                        (§ var ListenableScheduledFuture<?> task = vPingTask)
                        (§ if (task != nil))
                        (ß
                            (§ call task.cancel(false))
                            (§ ass vPingTask = nil)
                        )
                        (§ return) ;; Disabled.
                    )
                    (§ for (Peer peer :for getConnectedPeers()))
                    (ß
                        (§ if (peer.getPeerVersionMessage().clientVersion < params.getProtocolVersionNum(NetworkParameters.ProtocolVersion.PONG)))
                            (§ continue)
                        (§ call peer.ping())
                    )
                )
                (§ catch (Throwable e))
                (ß
                    (§ call log.error("Exception in ping loop", e)) ;; The executor swallows exceptions :( ;; )
                )
            )
        ), getPingIntervalMsec(), getPingIntervalMsec(), TimeUnit.MILLISECONDS))
    )

    #_private
    (§ method void setDownloadPeer(#_nilable Peer peer))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ if (downloadPeer == peer))
                (§ return)
            (§ if (downloadPeer != nil))
            (ß
                (§ call log.info("Unsetting download peer: {}", downloadPeer))
                (§ if (downloadListener != nil))
                    (§ call removeDataEventListenerFromPeer(downloadPeer, downloadListener))
                (§ call downloadPeer.setDownloadData(false))
            )
            (§ ass downloadPeer = peer)
            (§ if (downloadPeer != nil))
            (ß
                (§ call log.info("Setting download peer: {}", downloadPeer))
                (§ if (downloadListener != nil))
                    (§ call addDataEventListenerToPeer(Threading.SAME_THREAD, peer, downloadListener))
                (§ call downloadPeer.setDownloadData(true))
                (§ if (chain != nil))
                    (§ call downloadPeer.setDownloadParameters(fastCatchupTimeSecs, bloomFilterMerger.getLastFilter() != nil))
            )
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Tells the PeerGroup to download only block headers before a certain time and bodies after that.
     ; Call this before starting block chain download.
     ; Do not use a time > NOW - 1 block, as it will break some block download logic.
     ;;
    #_public
    (§ method void setFastCatchupTimeSecs(long secondsSinceEpoch))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ call Preconditions.checkState(chain == nil || !chain.shouldVerifyTransactions(), "Fast catchup is incompatible with fully verifying"))

            (§ ass fastCatchupTimeSecs = secondsSinceEpoch)
            (§ if (downloadPeer != nil))
                (§ call downloadPeer.setDownloadParameters(secondsSinceEpoch, bloomFilterMerger.getLastFilter() != nil))
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Returns the current fast catchup time.  The contents of blocks before this time won't be downloaded as they
     ; cannot contain any interesting transactions.  If you use {@link PeerGroup#addWallet(Wallet)} this just returns
     ; the min of the wallets earliest key times.
     ; @return a time in seconds since the epoch.
     ;;
    #_public
    (§ method long getFastCatchupTimeSecs())
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ return fastCatchupTimeSecs)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    #_protected
    (§ method void handlePeerDeath(#_final Peer peer, #_nilable Throwable exception))
    (ß
        ;; Peer deaths can occur during startup if a connect attempt after peer discovery aborts immediately.
        (§ if (!isRunning()))
            (§ return)

        (§ var int numPeers)
        (§ var int numConnectedPeers = 0)
        (§ call lock.lock())
        (§ try)
        (ß
            (§ call pendingPeers.remove(peer))
            (§ call peers.remove(peer))

            (§ var PeerAddress address = peer.getAddress())

            (§ call log.info("{}: Peer died      ({} connected, {} pending, {} max)", address, peers.size(), pendingPeers.size(), maxConnections))
            (§ if (peer == downloadPeer))
            (ß
                (§ call log.info("Download peer died. Picking a new one."))
                (§ call setDownloadPeer(nil))
                ;; Pick a new one and possibly tell it to download the chain.
                #_final
                (§ var Peer newDownloadPeer = selectDownloadPeer(peers))
                (§ if (newDownloadPeer != nil))
                (ß
                    (§ call setDownloadPeer(newDownloadPeer))
                    (§ if (downloadListener != nil))
                        (§ call startBlockChainDownloadFromPeer(newDownloadPeer))
                )
            )
            (§ ass numPeers = peers.size() + pendingPeers.size())
            (§ ass numConnectedPeers = peers.size())

            (§ call groupBackoff.trackFailure())

            (§ if (exception instanceof NoRouteToHostException))
            (ß
                (§ if (address.getAddr() instanceof Inet6Address && !ipv6Unreachable))
                (ß
                    (§ ass ipv6Unreachable = true)
                    (§ call log.warn("IPv6 peer connect failed due to routing failure, ignoring IPv6 addresses from now on"))
                )
            )
            (§ else)
            (ß
                (§ call backoffMap.get(address).trackFailure())
                ;; Put back on inactive list.
                (§ call inactives.offer(address))
            )

            (§ if (numPeers < getMaxConnections()))
                (§ call triggerConnections())
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )

        (§ call peer.removeBlocksDownloadedEventListener(peerListener))
        (§ call peer.removeGetDataEventListener(peerListener))
        (§ for (Wallet wallet :for wallets))
            (§ call peer.removeWallet(wallet))

        #_final
        (§ var int fNumConnectedPeers = numConnectedPeers)

        (§ for (ListenerRegistration<BlocksDownloadedEventListener> registration :for peersBlocksDownloadedEventListeners))
            (§ call peer.removeBlocksDownloadedEventListener(registration.listener))
        (§ for (ListenerRegistration<ChainDownloadStartedEventListener> registration :for peersChainDownloadStartedEventListeners))
            (§ call peer.removeChainDownloadStartedEventListener(registration.listener))
        (§ for (ListenerRegistration<GetDataEventListener> registration :for peerGetDataEventListeners))
            (§ call peer.removeGetDataEventListener(registration.listener))
        (§ for (ListenerRegistration<PreMessageReceivedEventListener> registration :for peersPreMessageReceivedEventListeners))
            (§ call peer.removePreMessageReceivedEventListener(registration.listener))
        (§ for (ListenerRegistration<OnTransactionBroadcastListener> registration :for peersTransactionBroadastEventListeners))
            (§ call peer.removeOnTransactionBroadcastListener(registration.listener))

        (§ for (#_final ListenerRegistration<PeerDisconnectedEventListener> registration :for peerDisconnectedEventListeners))
        (ß
            (§ call registration.executor.execute(new Runnable()
            (ß
                #_override
                #_public
                (§ method void run())
                (ß
                    (§ call registration.listener.onPeerDisconnected(peer, fNumConnectedPeers))
                )
            )))
            (§ call peer.removeDisconnectedEventListener(registration.listener))
        )
    )

    #_guarded-by(ß "lock")
    #_private
    (§ field int stallPeriodSeconds = 10)
    #_guarded-by(ß "lock")
    #_private
    (§ field int stallMinSpeedBytesSec = Block.HEADER_SIZE * 20)

    ;;;
     ; Configures the stall speed: the speed at which a peer is considered to be serving us the block chain
     ; unacceptably slowly.  Once a peer has served us data slower than the given data rate for the given
     ; number of seconds, it is considered stalled and will be disconnected, forcing the chain download to continue
     ; from a different peer.  The defaults are chosen conservatively, but if you are running on a platform that is
     ; CPU constrained or on a very slow network e.g. EDGE, the default settings may need adjustment to
     ; avoid false stalls.
     ;
     ; @param periodSecs How many seconds the download speed must be below blocksPerSec, defaults to 10.
     ; @param bytesPerSecond Download speed (only blocks/txns count) must be consistently below this for a stall, defaults to the bandwidth required for 20 block headers per second.
     ;;
    #_public
    (§ method void setStallThreshold(int periodSecs, int bytesPerSecond))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ ass stallPeriodSeconds = periodSecs)
            (§ ass stallMinSpeedBytesSec = bytesPerSecond)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    #_private
    (§ class ChainDownloadSpeedCalculator implements BlocksDownloadedEventListener, Runnable
        #_private
        (§ field int blocksInLastSecond, txnsInLastSecond, origTxnsInLastSecond)
        #_private
        (§ field long bytesInLastSecond)

        ;; If we take more stalls than this, we assume we're on some kind of terminally slow network and the
        ;; stall threshold just isn't set properly.  We give up on stall disconnects after that.
        #_private
        (§ field int maxStalls = 3)

        ;; How many seconds the peer has until we start measuring its speed.
        #_private
        (§ field int warmupSeconds = -1)

        ;; Used to calculate a moving average.
        #_private
        (§ field long[] samples)
        #_private
        (§ field int cursor)

        #_private
        (§ field boolean syncDone)

        #_override
        #_public
        #_synchronized
        (§ method void onBlocksDownloaded(Peer peer, Block block, #_nilable FilteredBlock filteredBlock, int blocksLeft))
        (ß
            (§ ass blocksInLastSecond = blocksInLastSecond + 1)
            (§ ass bytesInLastSecond = bytesInLastSecond + Block.HEADER_SIZE)
            (§ var List<Transaction> blockTransactions = block.getTransactions())
            ;; This whole area of the type hierarchy is a mess.
            (§ var int txCount = (blockTransactions != nil ? countAndMeasureSize(blockTransactions) :else 0) + (filteredBlock != nil ? countAndMeasureSize(filteredBlock.getAssociatedTransactions().values()) :else 0))
            (§ ass txnsInLastSecond = txnsInLastSecond + txCount)
            (§ if (filteredBlock != nil))
                (§ ass origTxnsInLastSecond = origTxnsInLastSecond + filteredBlock.getTransactionCount())
        )

        #_private
        (§ method int countAndMeasureSize(Collection<Transaction> transactions))
        (ß
            (§ for (Transaction transaction :for transactions))
                (§ ass bytesInLastSecond = bytesInLastSecond + transaction.getMessageSize())
            (§ return transactions.size())
        )

        #_override
        #_public
        (§ method void run())
        (ß
            (§ try)
            (ß
                (§ call calculate())
            )
            (§ catch (Throwable e))
            (ß
                (§ call log.error("Error in speed calculator", e))
            )
        )

        #_private
        (§ method void calculate())
        (ß
            (§ var int minSpeedBytesPerSec)
            (§ var int period)

            (§ call lock.lock())
            (§ try)
            (ß
                (§ ass minSpeedBytesPerSec = stallMinSpeedBytesSec)
                (§ ass period = stallPeriodSeconds)
            )
            (§ finally)
            (ß
                (§ call lock.unlock())
            )

            (§ sync this)
            (ß
                (§ if (samples == nil || samples.length != period))
                (ß
                    (§ ass samples = new long[period])
                    ;; *2 because otherwise a single low sample could cause an immediate disconnect which is too harsh.
                    (§ call Arrays.fill(samples, minSpeedBytesPerSec * 2))
                    (§ ass warmupSeconds = 15)
                )

                (§ var boolean behindPeers = (chain != nil && chain.getBestChainHeight() < getMostCommonChainHeight()))
                (§ if (!behindPeers))
                    (§ ass syncDone = true)
                (§ if (!syncDone))
                (ß
                    (§ if (warmupSeconds < 0))
                    (ß
                        ;; Calculate the moving average.
                        (§ ass samples[cursor] = bytesInLastSecond)
                        (§ ass cursor = cursor + 1)
                        (§ if (cursor == samples.length))
                            (§ ass cursor = 0)
                        (§ var long average = 0)
                        (§ for (long sample :for samples))
                            (§ ass average = average + sample)
                        (§ ass average = average / samples.length)

                        (§ call log.info(String.format(Locale.US, "%d blocks/sec, %d tx/sec, %d pre-filtered tx/sec, avg/last %.2f/%.2f kilobytes per sec (stall threshold <%.2f KB/sec for %d seconds)", blocksInLastSecond, txnsInLastSecond, origTxnsInLastSecond, average / 1024.0, bytesInLastSecond / 1024.0, minSpeedBytesPerSec / 1024.0, samples.length)))

                        (§ if (average < minSpeedBytesPerSec && 0 < maxStalls))
                        (ß
                            (§ ass maxStalls = maxStalls - 1)
                            (§ if (maxStalls == 0))
                            (ß
                                ;; We could consider starting to drop the Bloom filtering FP rate at this point, because
                                ;; we tried a bunch of peers and no matter what we don't seem to be able to go any faster.
                                ;; This implies we're bandwidth bottlenecked and might want to start using bandwidth
                                ;; more effectively.  Of course if there's a MITM that is deliberately throttling us,
                                ;; this is a good way to make us take away all the FPs from our Bloom filters ... but
                                ;; as they don't give us a whole lot of privacy either way that's not inherently a big
                                ;; deal.
                                (§ call log.warn("This network seems to be slower than the requested stall threshold - won't do stall disconnects any more."))
                            )
                            (§ else)
                            (ß
                                (§ var Peer peer = getDownloadPeer())
                                (§ call log.warn(String.format(Locale.US, "Chain download stalled: received %.2f KB/sec for %d seconds, require average of %.2f KB/sec, disconnecting %s", average / 1024.0, samples.length, minSpeedBytesPerSec / 1024.0, peer)))
                                (§ call peer.close())
                                ;; Reset the sample buffer and give the next peer time to get going.
                                (§ ass samples = nil)
                                (§ ass warmupSeconds = period)
                            )
                        )
                    )
                    (§ else)
                    (ß
                        (§ ass warmupSeconds = warmupSeconds - 1)
                        (§ if (0 < bytesInLastSecond))
                            (§ call log.info(String.format(Locale.US, "%d blocks/sec, %d tx/sec, %d pre-filtered tx/sec, last %.2f kilobytes per sec", blocksInLastSecond, txnsInLastSecond, origTxnsInLastSecond, bytesInLastSecond / 1024.0)))
                    )
                )
                (§ ass blocksInLastSecond = 0)
                (§ ass txnsInLastSecond = 0)
                (§ ass origTxnsInLastSecond = 0)
                (§ ass bytesInLastSecond = 0)
            )
        )
    )
    #_nilable
    #_private
    (§ field ChainDownloadSpeedCalculator chainDownloadSpeedCalculator)

    #_private
    (§ method void startBlockChainDownloadFromPeer(Peer peer))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ call setDownloadPeer(peer))

            (§ if (chainDownloadSpeedCalculator == nil))
            (ß
                ;; Every second, run the calculator which will log how fast we are downloading the chain.
                (§ ass chainDownloadSpeedCalculator = new ChainDownloadSpeedCalculator())
                (§ call executor.scheduleAtFixedRate(chainDownloadSpeedCalculator, 1, 1, TimeUnit.SECONDS))
            )
            (§ call peer.addBlocksDownloadedEventListener(Threading.SAME_THREAD, chainDownloadSpeedCalculator))

            ;; startBlockChainDownload will setDownloadData(true) on itself automatically.
            (§ call peer.startBlockChainDownload())
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Returns a future that is triggered when the number of connected peers is equal to the given number of peers.
     ; By using this with {@link org.bitcoinj.core.PeerGroup#getMaxConnections()} you can wait until the
     ; network is fully online.  To block immediately, just call get() on the result.  Just calls
     ; {@link #waitForPeersOfVersion(int, long)} with zero as the protocol version.
     ;
     ; @param numPeers How many peers to wait for.
     ; @return a future that will be triggered when the number of connected peers >= numPeers.
     ;;
    #_public
    (§ method ListenableFuture<List<Peer>> waitForPeers(#_final int numPeers))
    (ß
        (§ return waitForPeersOfVersion(numPeers, 0))
    )

    ;;;
     ; Returns a future that is triggered when there are at least the requested number of connected peers that support
     ; the given protocol version or higher.  To block immediately, just call get() on the result.
     ;
     ; @param numPeers How many peers to wait for.
     ; @param protocolVersion The protocol version the awaited peers must implement (or better).
     ; @return a future that will be triggered when the number of connected peers implementing protocolVersion or higher >= numPeers.
     ;;
    #_public
    (§ method ListenableFuture<List<Peer>> waitForPeersOfVersion(#_final int numPeers, #_final long protocolVersion))
    (ß
        (§ var List<Peer> foundPeers = findPeersOfAtLeastVersion(protocolVersion))
        (§ if (numPeers <= foundPeers.size()))
            (§ return Futures.immediateFuture(foundPeers))

        #_final
        (§ var SettableFuture<List<Peer>> future = SettableFuture.create())
        (§ call addConnectedEventListener(new PeerConnectedEventListener()
        (ß
            #_override
            #_public
            (§ method void onPeerConnected(Peer peer, int peerCount))
            (ß
                #_final
                (§ var List<Peer> peers = findPeersOfAtLeastVersion(protocolVersion))
                (§ if (numPeers <= peers.size()))
                (ß
                    (§ call future.set(peers))
                    (§ call removeConnectedEventListener(this))
                )
            )
        )))
        (§ return future)
    )

    ;;;
     ; Returns an array list of peers that implement the given protocol version or better.
     ;;
    #_public
    (§ method List<Peer> findPeersOfAtLeastVersion(long protocolVersion))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ var ArrayList<Peer> results = new ArrayList<Peer>(peers.size()))
            (§ for (Peer peer :for peers))
                (§ if (peer.getPeerVersionMessage().clientVersion >= protocolVersion))
                    (§ call results.add(peer))
            (§ return results)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Returns a future that is triggered when there are at least the requested number of connected peers that support
     ; the given protocol version or higher.  To block immediately, just call get() on the result.
     ;
     ; @param numPeers How many peers to wait for.
     ; @param mask An integer representing a bit mask that will be ANDed with the peers advertised service masks.
     ; @return a future that will be triggered when the number of connected peers implementing protocolVersion or higher >= numPeers.
     ;;
    #_public
    (§ method ListenableFuture<List<Peer>> waitForPeersWithServiceMask(#_final int numPeers, #_final int mask))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ var List<Peer> foundPeers = findPeersWithServiceMask(mask))
            (§ if (numPeers <= foundPeers.size()))
                (§ return Futures.immediateFuture(foundPeers))

            #_final
            (§ var SettableFuture<List<Peer>> future = SettableFuture.create())
            (§ call addConnectedEventListener(new PeerConnectedEventListener()
            (ß
                #_override
                #_public
                (§ method void onPeerConnected(Peer peer, int peerCount))
                (ß
                    #_final
                    (§ var List<Peer> peers = findPeersWithServiceMask(mask))
                    (§ if (numPeers <= peers.size()))
                    (ß
                        (§ call future.set(peers))
                        (§ call removeConnectedEventListener(this))
                    )
                )
            )))
            (§ return future)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Returns an array list of peers that match the requested service bit mask.
     ;;
    #_public
    (§ method List<Peer> findPeersWithServiceMask(int mask))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ var ArrayList<Peer> results = new ArrayList<Peer>(peers.size()))
            (§ for (Peer peer :for peers))
                (§ if ((peer.getPeerVersionMessage().localServices & mask) == mask))
                    (§ call results.add(peer))
            (§ return results)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Returns the number of connections that are required before transactions will be broadcast.  If there aren't
     ; enough, {@link PeerGroup#broadcastTransaction(Transaction)} will wait until the minimum number is reached so
     ; propagation across the network can be observed.  If no value has been set using
     ; {@link PeerGroup#setMinBroadcastConnections(int)} a default of 80% of whatever
     ; {@link org.bitcoinj.core.PeerGroup#getMaxConnections()} returns is used.
     ;;
    #_public
    (§ method int getMinBroadcastConnections())
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ if (minBroadcastConnections == 0))
            (ß
                (§ var int max = getMaxConnections())
                (§ if (max <= 1))
                    (§ return max)
                (§ else)
                    (§ return (int)Math.round(getMaxConnections() * 0.8))
            )
            (§ return minBroadcastConnections)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; See {@link org.bitcoinj.core.PeerGroup#getMinBroadcastConnections()}.
     ;;
    #_public
    (§ method void setMinBroadcastConnections(int value))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ ass minBroadcastConnections = value)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Calls {@link PeerGroup#broadcastTransaction(Transaction, int)} with getMinBroadcastConnections() as the number
     ; of connections to wait for before commencing broadcast.
     ;;
    #_override
    #_public
    (§ method TransactionBroadcast broadcastTransaction(#_final Transaction tx))
    (ß
        (§ return broadcastTransaction(tx, Math.max(1, getMinBroadcastConnections())))
    )

    ;;;
     ; <p>Given a transaction, sends it un-announced to one peer and then waits for it to be received back from
     ; other peers.  Once all connected peers have announced the transaction, the future available via the
     ; {@link org.bitcoinj.core.TransactionBroadcast#future()} method will be completed.  If anything goes
     ; wrong the exception will be thrown when get() is called, or you can receive it via a callback on the
     ; {@link ListenableFuture}.  This method returns immediately, so if you want it to block just call get() on the
     ; result.</p>
     ;
     ; <p>Note that if the PeerGroup is limited to only one connection (discovery is not activated) then the future
     ; will complete as soon as the transaction was successfully written to that peer.</p>
     ;
     ; <p>The transaction won't be sent until there are at least minConnections active connections available.
     ; A good choice for proportion would be between 0.5 and 0.8 but if you want faster transmission during initial
     ; bringup of the peer group you can lower it.</p>
     ;
     ; <p>The returned {@link org.bitcoinj.core.TransactionBroadcast} object can be used to get progress feedback,
     ; which is calculated by watching the transaction propagate across the network and be announced by peers.</p>
     ;;
    #_public
    (§ method TransactionBroadcast broadcastTransaction(#_final Transaction tx, #_final int minConnections))
    (ß
        ;; If we don't have a record of where this tx came from already, set it to be ourselves so Peer doesn't end up
        ;; redownloading it from the network redundantly.
        (§ if (tx.getConfidence().getSource().equals(TransactionConfidence.Source.UNKNOWN)))
        (ß
            (§ call log.info("Transaction source unknown, setting to SELF: {}", tx.getHashAsString()))
            (§ call tx.getConfidence().setSource(TransactionConfidence.Source.SELF))
        )
        #_final
        (§ var TransactionBroadcast broadcast = new TransactionBroadcast(this, tx))
        (§ call broadcast.setMinConnections(minConnections))
        ;; Send the TX to the wallet once we have a successful broadcast.
        (§ call Futures.addCallback(broadcast.future(), new FutureCallback<Transaction>()
        (ß
            #_override
            #_public
            (§ method void onSuccess(Transaction transaction))
            (ß
                (§ call runningBroadcasts.remove(broadcast))
                ;; OK, now tell the wallet about the transaction.  If the wallet created the transaction,
                ;; then it already knows and will ignore this.  If it's a transaction we received from
                ;; somebody else via a side channel and are now broadcasting, this will put it into the
                ;; wallet now we know it's valid.
                (§ for (Wallet wallet :for wallets))
                (ß
                    ;; Assumption here is there are no dependencies of the created transaction.
                    ;;
                    ;; We may end up with two threads trying to do this in parallel - the wallet will
                    ;; ignore whichever one loses the race.
                    (§ try)
                    (ß
                        (§ call wallet.receivePending(transaction, nil))
                    )
                    (§ catch (VerificationException e))
                    (ß
                        (§ throw new RuntimeException(e)) ;; Cannot fail to verify a tx we created ourselves.
                    )
                )
            )

            #_override
            #_public
            (§ method void onFailure(Throwable throwable))
            (ß
                ;; This can happen if we get a reject message from a peer.
                (§ call runningBroadcasts.remove(broadcast))
            )
        )))
        ;; Keep a reference to the TransactionBroadcast object.  This is important because otherwise, the entire tree
        ;; of objects we just created would become garbage if the user doesn't hold on to the returned future, and
        ;; eventually be collected.  This in turn could result in the transaction not being committed to the wallet
        ;; at all.
        (§ call runningBroadcasts.add(broadcast))
        (§ call broadcast.broadcast())
        (§ return broadcast)
    )

    ;;;
     ; Returns the period between pings for an individual peer.  Setting this lower means more accurate and timely
     ; ping times are available via {@link org.bitcoinj.core.Peer#getLastPingTime()} but it increases load on the
     ; remote node.  It defaults to {@link PeerGroup#DEFAULT_PING_INTERVAL_MSEC}.
     ;;
    #_public
    (§ method long getPingIntervalMsec())
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ return pingIntervalMsec)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Sets the period between pings for an individual peer.  Setting this lower means more accurate and timely
     ; ping times are available via {@link org.bitcoinj.core.Peer#getLastPingTime()} but it increases load on the
     ; remote node.  It defaults to {@link PeerGroup#DEFAULT_PING_INTERVAL_MSEC}.
     ; Setting the value to be <= 0 disables pinging entirely, although you can still request one yourself
     ; using {@link org.bitcoinj.core.Peer#ping()}.
     ;;
    #_public
    (§ method void setPingIntervalMsec(long pingIntervalMsec))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ ass this.pingIntervalMsec = pingIntervalMsec)
            (§ var ListenableScheduledFuture<?> task = vPingTask)
            (§ if (task != nil))
                (§ call task.cancel(false))
            (§ call setupPinging())
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; If a peer is connected to that claims to speak a protocol version lower than the given version, it will
     ; be disconnected and another one will be tried instead.
     ;;
    #_public
    (§ method void setMinRequiredProtocolVersion(int minRequiredProtocolVersion))
    (ß
        (§ ass this.vMinRequiredProtocolVersion = minRequiredProtocolVersion)
    )

    ;;; The minimum protocol version required: defaults to the version required for Bloom filtering. ;;
    #_public
    (§ method int getMinRequiredProtocolVersion())
    (ß
        (§ return vMinRequiredProtocolVersion)
    )

    ;;;
     ; Returns our peers most commonly reported chain height.  If multiple heights are tied, the highest is returned.
     ; If no peers are connected, returns zero.
     ;;
    #_public
    (§ method int getMostCommonChainHeight())
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ return getMostCommonChainHeight(this.peers))
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Returns most commonly reported chain height from the given list of {@link Peer}s.
     ; If multiple heights are tied, the highest is returned.  If no peers are connected, returns zero.
     ;;
    #_public
    #_static
    (§ method int getMostCommonChainHeight(#_final List<Peer> peers))
    (ß
        (§ if (peers.isEmpty()))
            (§ return 0)

        (§ var List<Integer> heights = new ArrayList<>(peers.size()))
        (§ for (Peer peer :for peers))
            (§ call heights.add((int)peer.getBestHeight()))
        (§ return Utils.maxOfMostFreq(heights))
    )

    ;;;
     ; Given a list of Peers, return a Peer to be used as the download peer.  If you don't want PeerGroup to manage
     ; download peer statuses for you, just override this and always return null.
     ;;
    #_nilable
    #_protected
    (§ method Peer selectDownloadPeer(List<Peer> peers))
    (ß
        ;; Characteristics to select for in order of importance:
        ;;  - Chain height is reasonable (majority of nodes).
        ;;  - High enough protocol version for the features we want (but we'll settle for less).
        ;;  - Randomly, to try and spread the load.
        (§ if (peers.isEmpty()))
            (§ return nil)

        ;; Make sure we don't select a peer that is behind/synchronizing itself.
        (§ var int mostCommonChainHeight = getMostCommonChainHeight(peers))
        (§ var List<Peer> candidates = new ArrayList<>())
        (§ for (Peer peer :for peers))
            (§ if (peer.getBestHeight() == mostCommonChainHeight))
                (§ call candidates.add(peer))

        ;; Of the candidates, find the peers that meet the minimum protocol version we want to target.  We could select
        ;; the highest version we've seen on the assumption that newer versions are always better but we don't want to
        ;; zap peers if they upgrade early.  If we can't find any peers that have our preferred protocol version or
        ;; better then we'll settle for the highest we found instead.
        (§ var int highestVersion = 0, preferredVersion = 0)

        ;; if/when PREFERRED_VERSION is not equal to vMinRequiredProtocolVersion, reenable the last test in PeerGroupTest.downloadPeerSelection
        #_final
        (§ var int PREFERRED_VERSION = params.getProtocolVersionNum(NetworkParameters.ProtocolVersion.BLOOM_FILTER))
        (§ for (Peer peer :for candidates))
        (ß
            (§ ass highestVersion = Math.max(peer.getPeerVersionMessage().clientVersion, highestVersion))
            (§ ass preferredVersion = Math.min(highestVersion, PREFERRED_VERSION))
        )
        (§ var ArrayList<Peer> candidates2 = new ArrayList<>(candidates.size()))
        (§ for (Peer peer :for candidates))
        (ß
            (§ if (preferredVersion <= peer.getPeerVersionMessage().clientVersion))
                (§ call candidates2.add(peer))
        )
        (§ var int index = (int)(Math.random() * candidates2.size()))
        (§ return candidates2.get(index))
    )

    ;;;
     ; Returns the currently selected download peer.  Bear in mind that it may have changed as soon as this method
     ; returns.  Can return null if no peer was selected.
     ;;
    #_public
    (§ method Peer getDownloadPeer())
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ return downloadPeer)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Returns the maximum number of {@link Peer}s to discover.  This maximum is checked after
     ; each {@link PeerDiscovery} so this max number can be surpassed.
     ; @return the maximum number of peers to discover.
     ;;
    #_public
    (§ method int getMaxPeersToDiscoverCount())
    (ß
        (§ return vMaxPeersToDiscoverCount)
    )

    ;;;
     ; Sets the maximum number of {@link Peer}s to discover.  This maximum is checked after
     ; each {@link PeerDiscovery} so this max number can be surpassed.
     ; @param maxPeersToDiscoverCount the maximum number of peers to discover.
     ;;
    #_public
    (§ method void setMaxPeersToDiscoverCount(int maxPeersToDiscoverCount))
    (ß
        (§ ass this.vMaxPeersToDiscoverCount = maxPeersToDiscoverCount)
    )

    ;;; See {@link #setUseLocalhostPeerWhenPossible(boolean)}. ;;
    #_public
    (§ method boolean getUseLocalhostPeerWhenPossible())
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ return useLocalhostPeerWhenPossible)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; When true (the default), PeerGroup will attempt to connect to a Bitcoin node running on localhost before
     ; attempting to use the P2P network.  If successful, only localhost will be used.  This makes for a simple
     ; and easy way for a user to upgrade a bitcoinj based app running in SPV mode to fully validating security.
     ;;
    #_public
    (§ method void setUseLocalhostPeerWhenPossible(boolean useLocalhostPeerWhenPossible))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ ass this.useLocalhostPeerWhenPossible = useLocalhostPeerWhenPossible)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    #_public
    (§ method boolean isRunning())
    (ß
        (§ return vRunning)
    )

    ;;;
     ; Can be used to disable Bloom filtering entirely, even in SPV mode.  You are very unlikely to need this, it is
     ; an optimisation for rare cases when full validation is not required but it's still more efficient to download
     ; full blocks than filtered blocks.
     ;;
    #_public
    (§ method void setBloomFilteringEnabled(boolean bloomFilteringEnabled))
    (ß
        (§ ass this.vBloomFilteringEnabled = bloomFilteringEnabled)
    )

    ;;; Returns whether the Bloom filtering protocol optimisation is in use: defaults to true. ;;
    #_public
    (§ method boolean isBloomFilteringEnabled())
    (ß
        (§ return vBloomFilteringEnabled)
    )
)

#_(ns org.bitcoinj.core #_"PeerSocketHandler"
    (:import [java.io ByteArrayOutputStream IOException]
             [java.net ConnectException InetSocketAddress]
             [java.nio BufferUnderflowException ByteBuffer]
             [java.nio.channels NotYetConnectedException]
             [java.util.concurrent.locks Lock])
    (:import [com.google.common.annotations VisibleForTesting]
             [com.google.common.base Preconditions]
             [org.slf4j Logger LoggerFactory])
  #_(:require [org.bitcoinj.net AbstractTimeoutHandler MessageWriteTarget StreamConnection]
             [org.bitcoinj.utils Threading]))

;;;
 ; Handles high-level message (de)serialization for peers, acting as the bridge between the
 ; {@link org.bitcoinj.net} classes and {@link Peer}.
 ;;
#_public
#_abstract
(§ class PeerSocketHandler extends AbstractTimeoutHandler implements StreamConnection
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(PeerSocketHandler.class))

    #_private
    #_final
    (§ field MessageSerializer serializer)
    #_protected
    (§ field PeerAddress peerAddress)
    ;; If we close() before we know our writeTarget, set this to true to call writeTarget.closeConnection() right away.
    #_private
    (§ field boolean closePending)
    ;; writeTarget will be thread-safe, and may call into PeerGroup, which calls us, so we should call it unlocked.
    #_testing
    #_protected
    (§ field MessageWriteTarget writeTarget)

    ;; The ByteBuffers passed to us from the writeTarget are static in size, and usually smaller than some messages we
    ;; will receive.  For SPV clients, this should be rare (i.e. we're mostly dealing with small transactions), but for
    ;; messages which are larger than the read buffer, we have to keep a temporary buffer with its bytes.
    #_private
    (§ field byte[] largeReadBuffer)
    #_private
    (§ field int largeReadBufferPos)
    #_private
    (§ field BitcoinSerializer.BitcoinPacketHeader header)

    #_private
    (§ field Lock lock = Threading.lock("PeerSocketHandler"))

    #_public
    (§ constructor PeerSocketHandler(NetworkParameters params, InetSocketAddress remoteIp))
    (ß
        (§ call Preconditions.checkNotNull(params))
        (§ ass serializer = params.getDefaultSerializer())
        (§ ass this.peerAddress = new PeerAddress(params, remoteIp))
    )

    #_public
    (§ constructor PeerSocketHandler(NetworkParameters params, PeerAddress peerAddress))
    (ß
        (§ call Preconditions.checkNotNull(params))
        (§ ass serializer = params.getDefaultSerializer())
        (§ ass this.peerAddress = Preconditions.checkNotNull(peerAddress))
    )

    ;;;
     ; Sends the given message to the peer.  Due to the asynchronousness of network programming, there is no guarantee
     ; the peer will have received it.  Throws NotYetConnectedException if we are not yet connected to the remote peer.
     ; TODO: Maybe use something other than the unchecked NotYetConnectedException here.
     ;;
    #_public
    (§ method void sendMessage(Message message))
        (§ throws NotYetConnectedException)
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ if (writeTarget == nil))
                (§ throw new NotYetConnectedException())
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
        ;; TODO: Some round-tripping could be avoided here.
        (§ var ByteArrayOutputStream out = new ByteArrayOutputStream())
        (§ try)
        (ß
            (§ call serializer.serialize(message, out))
            (§ call writeTarget.writeBytes(out.toByteArray()))
        )
        (§ catch (IOException e))
        (ß
            (§ call exceptionCaught(e))
        )
    )

    ;;;
     ; Closes the connection to the peer if one exists, or immediately closes the connection as soon as it opens.
     ;;
    #_public
    (§ method void close())
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ if (writeTarget == nil))
            (ß
                (§ ass closePending = true)
                (§ return)
            )
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
        (§ call writeTarget.closeConnection())
    )

    #_override
    #_protected
    (§ method void timeoutOccurred())
    (ß
        (§ call log.info("{}: Timed out", getAddress()))
        (§ call close())
    )

    ;;;
     ; Called every time a message is received from the network.
     ;;
    #_protected
    #_abstract
    (§ method void processMessage(Message m))
        (§ throws Exception)

    #_override
    #_public
    (§ method int receiveBytes(ByteBuffer buff))
    (ß
        (§ call Preconditions.checkArgument(buff.position() == 0 && BitcoinSerializer.BitcoinPacketHeader.HEADER_LENGTH + 4 <= buff.capacity()))
        (§ try)
        (ß
            ;; Repeatedly try to deserialize messages until we hit a BufferUnderflowException.
            (§ var boolean firstMessage = true)
            (§ while (true))
            (ß
                ;; If we are in the middle of reading a message, try to fill that one first, before we expect another.
                (§ if (largeReadBuffer != nil))
                (ß
                    ;; This can only happen in the first iteration.
                    (§ call Preconditions.checkState(firstMessage))
                    ;; Read new bytes into the largeReadBuffer.
                    (§ var int bytesToGet = Math.min(buff.remaining(), largeReadBuffer.length - largeReadBufferPos))
                    (§ call buff.get(largeReadBuffer, largeReadBufferPos, bytesToGet))
                    (§ ass largeReadBufferPos = largeReadBufferPos + bytesToGet)
                    ;; Check the largeReadBuffer's status.
                    (§ if (largeReadBufferPos == largeReadBuffer.length))
                    (ß
                        ;; ...processing a message if one is available.
                        (§ call processMessage(serializer.deserializePayload(header, ByteBuffer.wrap(largeReadBuffer))))
                        (§ ass largeReadBuffer = nil)
                        (§ ass header = nil)
                        (§ ass firstMessage = false)
                    )
                    (§ else) ;; ...or just returning if we don't have enough bytes yet.
                        (§ return buff.position())
                )
                ;; Now try to deserialize any messages left in buff.
                (§ var Message message)
                (§ var int preSerializePosition = buff.position())
                (§ try)
                (ß
                    (§ ass message = serializer.deserialize(buff))
                )
                (§ catch (BufferUnderflowException e))
                (ß
                    ;; If we went through the whole buffer without a full message, we need to use the largeReadBuffer.
                    (§ if (firstMessage && buff.limit() == buff.capacity()))
                    (ß
                        ;; ...so reposition the buffer to 0 and read the next message header.
                        (§ call buff.position(0))
                        (§ try)
                        (ß
                            (§ call serializer.seekPastMagicBytes(buff))
                            (§ ass header = serializer.deserializeHeader(buff))
                            ;; Initialize the largeReadBuffer with the next message's size and fill it with any bytes left in buff.
                            (§ ass largeReadBuffer = new byte[header.size])
                            (§ ass largeReadBufferPos = buff.remaining())
                            (§ call buff.get(largeReadBuffer, 0, largeReadBufferPos))
                        )
                        (§ catch (BufferUnderflowException e1))
                        (ß
                            ;; If we went through a whole buffer's worth of bytes without getting a header, give up.
                            ;; In cases where the buff is just really small, we could create a second largeReadBuffer
                            ;; that we use to deserialize the magic+header, but that is rather complicated when the buff
                            ;; should probably be at least that big anyway (for efficiency).
                            (§ throw new ProtocolException("No magic bytes+header after reading " + buff.capacity() + " bytes"))
                        )
                    )
                    (§ else)
                    (ß
                        ;; Reposition the buffer to its original position, which saves us from skipping messages by
                        ;; seeking past part of the magic bytes before all of them are in the buffer.
                        (§ call buff.position(preSerializePosition))
                    )
                    (§ return buff.position())
                )
                ;; Process our freshly deserialized message.
                (§ call processMessage(message))
                (§ ass firstMessage = false)
            )
        )
        (§ catch (Exception e))
        (ß
            (§ call exceptionCaught(e))
            ;; Returning -1 also throws an IllegalStateException upstream and kills the connection.
            (§ return -1)
        )
    )

    ;;;
     ; Sets the {@link MessageWriteTarget} used to write messages to the peer.  This should almost never be called,
     ; it is called automatically by {@link org.bitcoinj.net.NioClient} or
     ; {@link org.bitcoinj.net.NioClientManager} once the socket finishes initialization.
     ;;
    #_override
    #_public
    (§ method void setWriteTarget(MessageWriteTarget writeTarget))
    (ß
        (§ call Preconditions.checkArgument(writeTarget != nil))

        (§ call lock.lock())
        (§ var boolean closeNow = false)
        (§ try)
        (ß
            (§ call Preconditions.checkArgument(this.writeTarget == nil))

            (§ ass closeNow = closePending)
            (§ ass this.writeTarget = writeTarget)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
        (§ if (closeNow))
            (§ call writeTarget.closeConnection())
    )

    #_override
    #_public
    (§ method int getMaxMessageSize())
    (ß
        (§ return Message.MAX_SIZE)
    )

    ;;;
     ; @return the IP address and port of peer.
     ;;
    #_public
    (§ method PeerAddress getAddress())
    (ß
        (§ return peerAddress)
    )

    ;;; Catch any exceptions, logging them and then closing the channel. ;;
    #_private
    (§ method void exceptionCaught(Exception e))
    (ß
        (§ var PeerAddress addr = getAddress())
        (§ var String s = (addr == nil) ? "?" :else addr.toString())
        (§ if (e instanceof ConnectException || e instanceof IOException))
        (ß
            ;; Short message for network errors
            (§ call log.info(s + " - " + e.getMessage()))
        )
        (§ else)
        (ß
            (§ call log.warn(s + " - ", e))
            (§ var Thread.UncaughtExceptionHandler handler = Threading.uncaughtExceptionHandler)
            (§ if (handler != nil))
                (§ call handler.uncaughtException(Thread.currentThread(), e))
        )

        (§ call close())
    )
)

#_(ns org.bitcoinj.core #_"Ping"
    (:import [java.io IOException OutputStream]))

;;;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class Ping extends Message
    #_private
    (§ field long nonce)
    #_private
    (§ field boolean hasNonce)

    #_public
    (§ constructor Ping(NetworkParameters params, byte[] payloadBytes))
        (§ throws ProtocolException)
    (ß
        (§ super (params, payloadBytes, 0))
    )

    ;;;
     ; Create a Ping with a nonce value.
     ; Only use this if the remote node has a protocol version > 60000.
     ;;
    #_public
    (§ constructor Ping(long nonce))
    (ß
        (§ ass this.nonce = nonce)
        (§ ass this.hasNonce = true)
    )

    ;;;
     ; Create a Ping without a nonce value.
     ; Only use this if the remote node has a protocol version <= 60000.
     ;;
    #_public
    (§ constructor Ping())
    (ß
        (§ ass this.hasNonce = false)
    )

    #_override
    #_public
    (§ method void bitcoinSerializeToStream(OutputStream stream))
        (§ throws IOException)
    (ß
        (§ if (hasNonce))
            (§ call Utils.int64ToByteStreamLE(nonce, stream))
    )

    #_override
    #_protected
    (§ method void parse())
        (§ throws ProtocolException)
    (ß
        (§ try)
        (ß
            (§ ass nonce = readInt64())
            (§ ass hasNonce = true)
        )
        (§ method catch(ProtocolException e))
        (ß
            (§ ass hasNonce = false)
        )
        (§ ass length = hasNonce ? 8 :else 0)
    )

    #_public
    (§ method boolean hasNonce())
    (ß
        (§ return hasNonce)
    )

    #_public
    (§ method long getNonce())
    (ß
        (§ return nonce)
    )
)

#_(ns org.bitcoinj.core #_"Pong"
    (:import [java.io IOException OutputStream]))

;;;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class Pong extends Message
    #_private
    (§ field long nonce)

    #_public
    (§ constructor Pong(NetworkParameters params, byte[] payloadBytes))
        (§ throws ProtocolException)
    (ß
        (§ super (params, payloadBytes, 0))
    )

    ;;;
     ; Create a Pong with a nonce value.
     ; Only use this if the remote node has a protocol version > 60000.
     ;;
    #_public
    (§ constructor Pong(long nonce))
    (ß
        (§ ass this.nonce = nonce)
    )

    #_override
    #_protected
    (§ method void parse())
        (§ throws ProtocolException)
    (ß
        (§ ass nonce = readInt64())
        (§ ass length = 8)
    )

    #_override
    #_public
    (§ method void bitcoinSerializeToStream(OutputStream stream))
        (§ throws IOException)
    (ß
        (§ call Utils.int64ToByteStreamLE(nonce, stream))
    )

    ;;; Returns the nonce sent by the remote peer. ;;
    #_public
    (§ method long getNonce())
    (ß
        (§ return nonce)
    )
)

#_(ns org.bitcoinj.core #_"ProtocolException")

#_public
(§ class ProtocolException extends VerificationException
    #_public
    (§ constructor ProtocolException(String msg))
    (ß
        (§ super (msg))
    )

    #_public
    (§ constructor ProtocolException(Exception e))
    (ß
        (§ super (e))
    )

    #_public
    (§ constructor ProtocolException(String msg, Exception e))
    (ß
        (§ super (msg, e))
    )
)

#_(ns org.bitcoinj.core #_"PrunedException")

;; TODO: Rename PrunedException to something like RequiredDataWasPrunedException.

;;;
 ; PrunedException is thrown in cases where a fully verifying node has deleted (pruned) old block data that turned
 ; out to be necessary for handling a re-org.  Normally this should never happen unless you're playing with the testnet
 ; as the pruning parameters should be set very conservatively, such that an absolutely enormous re-org would be
 ; required to trigger it.
 ;;
#_public
(§ class PrunedException extends Exception
    #_private
    (§ field Sha256Hash hash)

    #_public
    (§ constructor PrunedException(Sha256Hash hash))
    (ß
        (§ super (hash.toString()))

        (§ ass this.hash = hash)
    )

    #_public
    (§ method Sha256Hash getHash())
    (ß
        (§ return hash)
    )
)

#_(ns org.bitcoinj.core #_"RejectMessage"
    (:import [java.io IOException OutputStream]
             [java.util Locale])
    (:import [com.google.common.base Objects]))

;;;
 ; <p>A message sent by nodes when a message we sent was rejected (i.e. a transaction had too little fee/was invalid/etc).</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class RejectMessage extends Message
    #_private
    (§ field String message, reason)

    #_public
    (§ enum RejectCode
        ;;; The message was not able to be parsed. ;;
        (§ item MALFORMED((byte)0x01))
        ;;; The message described an invalid object. ;;
        (§ item INVALID((byte)0x10))
        ;;; The message was obsolete or described an object which is obsolete (e.g. unsupported, old version, v1 block). ;;
        (§ item OBSOLETE((byte)0x11))
        ;;;
         ; The message was relayed multiple times or described an object which is in conflict with another.
         ; This message can describe errors in protocol implementation or the presence of an attempt to DOUBLE SPEND.
         ;;
        (§ item DUPLICATE((byte)0x12))
        ;;;
         ; The message described an object was not standard and was thus not accepted.
         ; Bitcoin Core has a concept of standard transaction forms, which describe scripts and encodings which
         ; it is willing to relay further.  Other transactions are neither relayed nor mined, though they are considered
         ; valid if they appear in a block.
         ;;
        (§ item NONSTANDARD((byte)0x40))
        ;;;
         ; This refers to a specific form of NONSTANDARD transactions, which have an output smaller than some constant
         ; defining them as dust (this is no longer used).
         ;;
        (§ item DUST((byte)0x41))
        ;;; The messages described an object which did not have sufficient fee to be relayed further. ;;
        (§ item INSUFFICIENTFEE((byte)0x42))
        ;;; The message described a block which was invalid according to hard-coded checkpoint blocks. ;;
        (§ item CHECKPOINT((byte)0x43))
        (§ item OTHER((byte)0xff))

        (§ var byte code)

        (§ constructor RejectCode(byte code))
        (ß
            (§ ass this.code = code)
        )

        #_static
        (§ method RejectCode fromCode(byte code))
        (ß
            (§ for (RejectCode rejectCode :for RejectCode.values()))
                (§ if (rejectCode.code == code))
                    (§ return rejectCode)

            (§ return OTHER)
        )
    )

    #_private
    (§ field RejectCode code)
    #_private
    (§ field Sha256Hash messageHash)

    #_public
    (§ constructor RejectMessage(NetworkParameters params, byte[] payload))
        (§ throws ProtocolException)
    (ß
        (§ super (params, payload, 0))
    )

    ;;; Constructs a reject message that fingers the object with the given hash as rejected for the given reason. ;;
    #_public
    (§ constructor RejectMessage(NetworkParameters params, RejectCode code, Sha256Hash hash, String message, String reason))
        (§ throws ProtocolException)
    (ß
        (§ super (params))

        (§ ass this.code = code)
        (§ ass this.messageHash = hash)
        (§ ass this.message = message)
        (§ ass this.reason = reason)
    )

    #_override
    #_protected
    (§ method void parse())
        (§ throws ProtocolException)
    (ß
        (§ ass message = readStr())
        (§ ass code = RejectCode.fromCode(readBytes(1)[0]))
        (§ ass reason = readStr())
        (§ if (message.equals("block") || message.equals("tx")))
            (§ ass messageHash = readHash())
        (§ ass length = cursor - offset)
    )

    #_override
    #_public
    (§ method void bitcoinSerializeToStream(OutputStream stream))
        (§ throws IOException)
    (ß
        (§ var byte[] messageBytes = message.getBytes("UTF-8"))
        (§ call stream.write(new VarInt(messageBytes.length).encode()))
        (§ call stream.write(messageBytes))
        (§ call stream.write(code.code))
        (§ var byte[] reasonBytes = reason.getBytes("UTF-8"))
        (§ call stream.write(new VarInt(reasonBytes.length).encode()))
        (§ call stream.write(reasonBytes))
        (§ if ("block".equals(message) || "tx".equals(message)))
            (§ call stream.write(messageHash.getReversedBytes()))
    )

    ;;;
     ; Provides the type of message which was rejected by the peer.
     ; Note that this is ENTIRELY UNTRUSTED and should be sanity-checked before it is printed or processed.
     ;;
    #_public
    (§ method String getRejectedMessage())
    (ß
        (§ return message)
    )

    ;;;
     ; Provides the hash of the rejected object (if getRejectedMessage() is either "tx" or "block"), otherwise null.
     ;;
    #_public
    (§ method Sha256Hash getRejectedObjectHash())
    (ß
        (§ return messageHash)
    )

    ;;;
     ; The reason code given for why the peer rejected the message.
     ;;
    #_public
    (§ method RejectCode getReasonCode())
    (ß
        (§ return code)
    )

    ;;;
     ; The reason message given for rejection.
     ; Note that this is ENTIRELY UNTRUSTED and should be sanity-checked before it is printed or processed.
     ;;
    #_public
    (§ method String getReasonString())
    (ß
        (§ return reason)
    )

    ;;;
     ; A String representation of the relevant details of this reject message.
     ; Be aware that the value returned by this method includes the value returned by
     ; {@link #getReasonString() getReasonString}, which is taken from the reject message unchecked.
     ; Through malice or otherwise, it might contain control characters or other harmful content.
     ;;
    #_override
    #_public
    (§ method String toString())
    (ß
        (§ var Sha256Hash hash = getRejectedObjectHash())
        (§ return String.format(Locale.US, "Reject: %s %s for reason '%s' (%d)", getRejectedMessage(), (hash != nil) ? hash :for "", getReasonString(), getReasonCode().code))
    )

    #_override
    #_public
    (§ method boolean equals(Object o))
    (ß
        (§ if (this == o))
            (§ return true)
        (§ if (o == nil || getClass() != o.getClass()))
            (§ return false)
        (§ var RejectMessage other = (RejectMessage)o)
        (§ return (message.equals(other.message) && code.equals(other.code) && reason.equals(other.reason) && messageHash.equals(other.messageHash)))
    )

    #_override
    #_public
    (§ method int hashCode())
    (ß
        (§ return Objects.hashCode(message, code, reason, messageHash))
    )
)

#_(ns org.bitcoinj.core #_"RejectedTransactionException")

;;;
 ; This exception is used by the TransactionBroadcast class to indicate that a broadcast
 ; Transaction has been rejected by the network, for example because it violates a
 ; protocol rule.  Note that not all invalid transactions generate a reject message, and
 ; some peers may never do so.
 ;;
#_public
(§ class RejectedTransactionException extends Exception
    #_private
    (§ field Transaction tx)
    #_private
    (§ field RejectMessage rejectMessage)

    #_public
    (§ constructor RejectedTransactionException(Transaction tx, RejectMessage rejectMessage))
    (ß
        (§ super (rejectMessage.toString()))

        (§ ass this.tx = tx)
        (§ ass this.rejectMessage = rejectMessage)
    )

    ;;; Return the original Transaction object whose broadcast was rejected. ;;
    #_public
    (§ method Transaction getTransaction())
    (ß
        (§ return tx)
    )

    ;;; Return the RejectMessage object representing the broadcast rejection. ;;
    #_public
    (§ method RejectMessage getRejectMessage())
    (ß
        (§ return rejectMessage)
    )
)

#_(ns org.bitcoinj.core #_"ScriptException"
  #_(:require [org.bitcoinj.script ScriptError]))

#_public
(§ class ScriptException extends VerificationException
    #_private
    #_final
    (§ field ScriptError err)

    #_public
    (§ constructor ScriptException(ScriptError err, String msg))
    (ß
        (§ super (msg))
        (§ ass this.err = err)
    )

    #_public
    (§ constructor ScriptException(ScriptError err, String msg, Exception e))
    (ß
        (§ super (msg, e))
        (§ ass this.err = err)
    )

    #_public
    (§ method ScriptError getError())
    (ß
        (§ return err)
    )
)

#_(ns org.bitcoinj.core #_"Sha256Hash"
    (:import [java.io File FileInputStream IOException Serializable]
             [java.math BigInteger]
             [java.security MessageDigest NoSuchAlgorithmException]
             [java.util Arrays])
    (:import [com.google.common.base Preconditions]
             [com.google.common.io ByteStreams]
             #_[com.google.common.primitives *]))

;;;
 ; A Sha256Hash just wraps a byte[] so that equals and hashcode work correctly,
 ; allowing it to be used as keys in a map.
 ; It also checks that the length is correct and provides a bit more type safety.
 ;;
#_public
(§ class Sha256Hash implements Serializable, Comparable<Sha256Hash>
    #_public
    #_static
    #_final
    (§ field int LENGTH = 32) ;; bytes
    #_public
    #_static
    #_final
    (§ field Sha256Hash ZERO_HASH = wrap(new byte[LENGTH]))

    #_private
    #_final
    (§ field byte[] bytes)

    ;;;
     ; Use {@link #wrap(byte[])} instead.
     ;;
    #_protected
    (§ constructor Sha256Hash(byte[] rawHashBytes))
    (ß
        (§ call Preconditions.checkArgument(rawHashBytes.length == LENGTH))
        (§ ass this.bytes = rawHashBytes)
    )

    ;;;
     ; Creates a new instance that wraps the given hash value.
     ;
     ; @param rawHashBytes The raw hash bytes to wrap.
     ; @return a new instance.
     ; @throws IllegalArgumentException if the given array length is not exactly 32.
     ;;
    #_public
    #_static
    (§ method Sha256Hash wrap(byte[] rawHashBytes))
    (ß
        (§ return new Sha256Hash(rawHashBytes))
    )

    ;;;
     ; Creates a new instance that wraps the given hash value (represented as a hex string).
     ;
     ; @param hexString A hash value represented as a hex string.
     ; @return a new instance.
     ; @throws IllegalArgumentException if the given string is not a valid hex string, or if it does not represent exactly 32 bytes.
     ;;
    #_public
    #_static
    (§ method Sha256Hash wrap(String hexString))
    (ß
        (§ return wrap(Utils.HEX.decode(hexString)))
    )

    ;;;
     ; Creates a new instance that wraps the given hash value, but with byte order reversed.
     ;
     ; @param rawHashBytes The raw hash bytes to wrap.
     ; @return a new instance.
     ; @throws IllegalArgumentException if the given array length is not exactly 32.
     ;;
    #_public
    #_static
    (§ method Sha256Hash wrapReversed(byte[] rawHashBytes))
    (ß
        (§ return wrap(Utils.reverseBytes(rawHashBytes)))
    )

    ;;;
     ; Creates a new instance containing the calculated (one-time) hash of the given bytes.
     ;
     ; @param contents The bytes on which the hash value is calculated.
     ; @return a new instance containing the calculated (one-time) hash.
     ;;
    #_public
    #_static
    (§ method Sha256Hash of(byte[] contents))
    (ß
        (§ return wrap(hash(contents)))
    )

    ;;;
     ; Creates a new instance containing the hash of the calculated hash of the given bytes.
     ;
     ; @param contents The bytes on which the hash value is calculated.
     ; @return a new instance containing the calculated (two-time) hash.
     ;;
    #_public
    #_static
    (§ method Sha256Hash twiceOf(byte[] contents))
    (ß
        (§ return wrap(hashTwice(contents)))
    )

    ;;;
     ; Creates a new instance containing the calculated (one-time) hash of the given file's contents.
     ;
     ; The file contents are read fully into memory, so this method should only be used with small files.
     ;
     ; @param file The file on which the hash value is calculated.
     ; @return a new instance containing the calculated (one-time) hash.
     ; @throws IOException if an error occurs while reading the file.
     ;;
    #_public
    #_static
    (§ method Sha256Hash of(File file))
        (§ throws IOException)
    (ß
        (§ var FileInputStream in = new FileInputStream(file))
        (§ try)
        (ß
            (§ return of(ByteStreams.toByteArray(in)))
        )
        (§ finally)
        (ß
            (§ call in.close())
        )
    )

    ;;;
     ; Returns a new SHA-256 MessageDigest instance.
     ;
     ; This is a convenience method which wraps the checked
     ; exception that can never occur with a RuntimeException.
     ;
     ; @return a new SHA-256 MessageDigest instance.
     ;;
    #_public
    #_static
    (§ method MessageDigest newDigest())
    (ß
        (§ try)
        (ß
            (§ return MessageDigest.getInstance("SHA-256"))
        )
        (§ catch (NoSuchAlgorithmException e))
        (ß
            (§ throw new RuntimeException(e)) ;; Can't happen.
        )
    )

    ;;;
     ; Calculates the SHA-256 hash of the given bytes.
     ;
     ; @param input The bytes to hash.
     ; @return the hash (in big-endian order).
     ;;
    #_public
    #_static
    (§ method byte[] hash(byte[] input))
    (ß
        (§ return hash(input, 0, input.length))
    )

    ;;;
     ; Calculates the SHA-256 hash of the given byte range.
     ;
     ; @param input The array containing the bytes to hash.
     ; @param offset The offset within the array of the bytes to hash.
     ; @param length The number of bytes to hash.
     ; @return the hash (in big-endian order).
     ;;
    #_public
    #_static
    (§ method byte[] hash(byte[] input, int offset, int length))
    (ß
        (§ var MessageDigest digest = newDigest())
        (§ call digest.update(input, offset, length))
        (§ return digest.digest())
    )

    ;;;
     ; Calculates the SHA-256 hash of the given bytes,
     ; and then hashes the resulting hash again.
     ;
     ; @param input The bytes to hash.
     ; @return the double-hash (in big-endian order).
     ;;
    #_public
    #_static
    (§ method byte[] hashTwice(byte[] input))
    (ß
        (§ return hashTwice(input, 0, input.length))
    )

    ;;;
     ; Calculates the SHA-256 hash of the given byte range,
     ; and then hashes the resulting hash again.
     ;
     ; @param input The array containing the bytes to hash.
     ; @param offset The offset within the array of the bytes to hash.
     ; @param length The number of bytes to hash.
     ; @return the double-hash (in big-endian order).
     ;;
    #_public
    #_static
    (§ method byte[] hashTwice(byte[] input, int offset, int length))
    (ß
        (§ var MessageDigest digest = newDigest())
        (§ call digest.update(input, offset, length))
        (§ return digest.digest(digest.digest()))
    )

    ;;;
     ; Calculates the hash of hash on the given byte ranges.  This is equivalent to
     ; concatenating the two ranges and then passing the result to {@link #hashTwice(byte[])}.
     ;;
    #_public
    #_static
    (§ method byte[] hashTwice(byte[] input1, int offset1, int length1, byte[] input2, int offset2, int length2))
    (ß
        (§ var MessageDigest digest = newDigest())
        (§ call digest.update(input1, offset1, length1))
        (§ call digest.update(input2, offset2, length2))
        (§ return digest.digest(digest.digest()))
    )

    #_override
    #_public
    (§ method boolean equals(Object o))
    (ß
        (§ if (this == o))
            (§ return true)
        (§ if (o == nil || getClass() != o.getClass()))
            (§ return false)
        (§ return Arrays.equals(bytes, ((Sha256Hash)o).bytes))
    )

    ;;;
     ; Returns the last four bytes of the wrapped hash.  This should be unique enough to be a suitable hash code
     ; even for blocks, where the goal is to try and get the first bytes to be zeros (i.e. the value as a big integer
     ; lower than the target value).
     ;;
    #_override
    #_public
    (§ method int hashCode())
    (ß
        ;; Use the last 4 bytes, not the first 4 which are often zeros in Bitcoin.
        (§ return Ints.fromBytes(bytes[LENGTH - 4], bytes[LENGTH - 3], bytes[LENGTH - 2], bytes[LENGTH - 1]))
    )

    #_override
    #_public
    (§ method String toString())
    (ß
        (§ return Utils.HEX.encode(bytes))
    )

    ;;;
     ; Returns the bytes interpreted as a positive integer.
     ;;
    #_public
    (§ method BigInteger toBigInteger())
    (ß
        (§ return new BigInteger(1, bytes))
    )

    ;;;
     ; Returns the internal byte array, without defensively copying.  Therefore do NOT modify the returned array.
     ;;
    #_public
    (§ method byte[] getBytes())
    (ß
        (§ return bytes)
    )

    ;;;
     ; Returns a reversed copy of the internal byte array.
     ;;
    #_public
    (§ method byte[] getReversedBytes())
    (ß
        (§ return Utils.reverseBytes(bytes))
    )

    #_override
    #_public
    (§ method int compareTo(#_final Sha256Hash other))
    (ß
        (§ for (int i = LENGTH - 1 :for 0 <= i :for i = i - 1))
        (ß
            #_final
            (§ var int thisByte = this.bytes[i] & 0xff)
            #_final
            (§ var int otherByte = other.bytes[i] & 0xff)
            (§ if (thisByte > otherByte))
                (§ return 1)
            (§ if (thisByte < otherByte))
                (§ return -1)
        )
        (§ return 0)
    )
)

#_(ns org.bitcoinj.core #_"StoredBlock"
    (:import [java.math BigInteger]
             [java.nio ByteBuffer]
             [java.util Locale])
    (:import [com.google.common.base Objects Preconditions])
  #_(:require [org.bitcoinj.store BlockStore BlockStoreException]))

;;;
 ; Wraps a {@link Block} object with extra data that can be derived from the block chain but is slow or inconvenient
 ; to calculate.  By storing it alongside the block header we reduce the amount of work required significantly.
 ; Recalculation is slow because the fields are cumulative - to find the chainWork you have to iterate over every
 ; block in the chain back to the genesis block, which involves lots of seeking/loading etc.  So we just keep a
 ; running total: it's a disk space vs cpu/io tradeoff.
 ;
 ; StoredBlocks are put inside a {@link BlockStore} which saves them to memory or disk.
 ;;
#_public
(§ class StoredBlock
    ;; A BigInteger representing the total amount of work done so far on this chain.  As of May 2011 it takes
    ;; 8 bytes to represent this field, so 12 bytes should be plenty for now.
    #_public
    #_static
    #_final
    (§ field int CHAIN_WORK_BYTES = 12)
    #_public
    #_static
    #_final
    (§ field byte[] EMPTY_BYTES = new byte[CHAIN_WORK_BYTES])
    #_public
    #_static
    #_final
    (§ field int COMPACT_SERIALIZED_SIZE = Block.HEADER_SIZE + CHAIN_WORK_BYTES + 4) ;; for height

    #_private
    (§ field Block header)
    #_private
    (§ field BigInteger chainWork)
    #_private
    (§ field int height)

    #_public
    (§ constructor StoredBlock(Block header, BigInteger chainWork, int height))
    (ß
        (§ ass this.header = header)
        (§ ass this.chainWork = chainWork)
        (§ ass this.height = height)
    )

    ;;;
     ; The block header this object wraps.  The referenced block object must not have any transactions in it.
     ;;
    #_public
    (§ method Block getHeader())
    (ß
        (§ return header)
    )

    ;;;
     ; The total sum of work done in this block, and all the blocks below it in the chain.  Work is a measure of
     ; how many tries are needed to solve a block.  If the target is set to cover 10% of the total hash value space,
     ; then the work represented by a block is 10.
     ;;
    #_public
    (§ method BigInteger getChainWork())
    (ß
        (§ return chainWork)
    )

    ;;;
     ; Position in the chain for this block.  The genesis block has a height of zero.
     ;;
    #_public
    (§ method int getHeight())
    (ß
        (§ return height)
    )

    ;;; Returns true if this objects chainWork is higher than the others. ;;
    #_public
    (§ method boolean moreWorkThan(StoredBlock other))
    (ß
        (§ return (0 < chainWork.compareTo(other.chainWork)))
    )

    #_override
    #_public
    (§ method boolean equals(Object o))
    (ß
        (§ if (this == o))
            (§ return true)
        (§ if (o == nil || getClass() != o.getClass()))
            (§ return false)
        (§ var StoredBlock other = (StoredBlock)o)
        (§ return (header.equals(other.header) && chainWork.equals(other.chainWork) && height == other.height))
    )

    #_override
    #_public
    (§ method int hashCode())
    (ß
        (§ return Objects.hashCode(header, chainWork, height))
    )

    ;;;
     ; Creates a new StoredBlock, calculating the additional fields by adding to the values in this block.
     ;;
    #_public
    (§ method StoredBlock build(Block block))
        (§ throws VerificationException)
    (ß
        ;; Stored blocks track total work done in this chain, because the canonical chain is the one that represents
        ;; the largest amount of work done not the tallest.
        (§ var BigInteger chainWork = this.chainWork.add(block.getWork()))
        (§ var int height = this.height + 1)
        (§ return new StoredBlock(block, chainWork, height))
    )

    ;;;
     ; Given a block store, looks up the previous block in this chain.  Convenience method for doing
     ; <tt>store.get(this.getHeader().getPrevBlockHash())</tt>.
     ;
     ; @return the previous block in the chain or null if it was not found in the store.
     ;;
    #_public
    (§ method StoredBlock getPrev(BlockStore store))
        (§ throws BlockStoreException)
    (ß
        (§ return store.get(getHeader().getPrevBlockHash()))
    )

    ;;; Serializes the stored block to a custom packed format.  Used by {@link CheckpointManager}. ;;
    #_public
    (§ method void serializeCompact(ByteBuffer buffer))
    (ß
        (§ var byte[] chainWorkBytes = getChainWork().toByteArray())
        (§ call Preconditions.checkState(chainWorkBytes.length <= CHAIN_WORK_BYTES, "Ran out of space to store chain work!"))
        (§ if (chainWorkBytes.length < CHAIN_WORK_BYTES))
        (ß
            ;; Pad to the right size.
            (§ call buffer.put(EMPTY_BYTES, 0, CHAIN_WORK_BYTES - chainWorkBytes.length))
        )
        (§ call buffer.put(chainWorkBytes))
        (§ call buffer.putInt(getHeight()))
        ;; Using unsafeBitcoinSerialize here can give us direct access to the same bytes we read off the wire,
        ;; avoiding serialization round-trips.
        (§ var byte[] bytes = getHeader().unsafeBitcoinSerialize())
        (§ call buffer.put(bytes, 0, Block.HEADER_SIZE)) ;; Trim the trailing 00 byte (zero transactions).
    )

    ;;; De-serializes the stored block from a custom packed format.  Used by {@link CheckpointManager}. ;;
    #_public
    #_static
    (§ method StoredBlock deserializeCompact(NetworkParameters params, ByteBuffer buffer))
        (§ throws ProtocolException)
    (ß
        (§ var byte[] chainWorkBytes = new byte[StoredBlock.CHAIN_WORK_BYTES])
        (§ call buffer.get(chainWorkBytes))
        (§ var BigInteger chainWork = new BigInteger(1, chainWorkBytes))
        (§ var int height = buffer.getInt()) ;; +4 bytes
        (§ var byte[] header = new byte[Block.HEADER_SIZE + 1]) ;; Extra byte for the 00 transactions length.
        (§ call buffer.get(header, 0, Block.HEADER_SIZE))
        (§ return new StoredBlock(params.getDefaultSerializer().makeBlock(header), chainWork, height))
    )

    #_override
    #_public
    (§ method String toString())
    (ß
        (§ return String.format(Locale.US, "Block %s at height %d: %s", getHeader().getHashAsString(), getHeight(), getHeader().toString()))
    )
)

#_(ns org.bitcoinj.core #_"StoredUndoableBlock"
    (:import [java.util List]))

;;;
 ; Contains minimal data neccessary to disconnect/connect the transactions
 ; in the stored block at will.  Can either store the full set of
 ; transactions (if the inputs for the block have not been tested to work)
 ; or the set of transaction outputs created/destroyed when the block is
 ; connected.
 ;;
#_public
(§ class StoredUndoableBlock
    (§ field Sha256Hash blockHash)

    ;; Only one of either txOutChanges or transactions will be set.
    #_private
    (§ field TransactionOutputChanges txOutChanges)
    #_private
    (§ field List<Transaction> transactions)

    #_public
    (§ constructor StoredUndoableBlock(Sha256Hash hash, TransactionOutputChanges txOutChanges))
    (ß
        (§ ass this.blockHash = hash)
        (§ ass this.transactions = nil)
        (§ ass this.txOutChanges = txOutChanges)
    )

    #_public
    (§ constructor StoredUndoableBlock(Sha256Hash hash, List<Transaction> transactions))
    (ß
        (§ ass this.blockHash = hash)
        (§ ass this.txOutChanges = nil)
        (§ ass this.transactions = transactions)
    )

    ;;;
     ; Get the transaction output changes if they have been calculated, otherwise null.
     ; Only one of this and getTransactions() will return a non-null value.
     ;;
    #_public
    (§ method TransactionOutputChanges getTxOutChanges())
    (ß
        (§ return txOutChanges)
    )

    ;;;
     ; Get the full list of transactions if it is stored, otherwise null.
     ; Only one of this and getTxOutChanges() will return a non-null value.
     ;;
    #_public
    (§ method List<Transaction> getTransactions())
    (ß
        (§ return transactions)
    )

    ;;;
     ; Get the hash of the represented block.
     ;;
    #_public
    (§ method Sha256Hash getHash())
    (ß
        (§ return blockHash)
    )

    #_override
    #_public
    (§ method int hashCode())
    (ß
        (§ return blockHash.hashCode())
    )

    #_override
    #_public
    (§ method boolean equals(Object o))
    (ß
        (§ if (this == o))
            (§ return true)
        (§ if (o == nil || getClass() != o.getClass()))
            (§ return false)
        (§ return getHash().equals(((StoredUndoableBlock)o).getHash()))
    )

    #_override
    #_public
    (§ method String toString())
    (ß
        (§ return "Undoable Block " + blockHash)
    )
)

#_(ns org.bitcoinj.core #_"Transaction"
    (:import #_[java.io *]
             [java.math BigInteger]
             #_[java.util *])
    (:import [com.google.common.base Preconditions Strings]
             [com.google.common.collect ImmutableMap]
             [com.google.common.primitives Ints Longs]
             [org.slf4j Logger LoggerFactory]
             [org.spongycastle.crypto.params KeyParameter])
  #_(:require [org.bitcoinj.core.TransactionConfidence ConfidenceType]
             #_static #_[org.bitcoinj.core.Utils *]
             [org.bitcoinj.crypto TransactionSignature]
             [org.bitcoinj.script Script ScriptBuilder ScriptError ScriptOpCodes]
             [org.bitcoinj.signers TransactionSigner]
             [org.bitcoinj.utils ExchangeRate]
             [org.bitcoinj.wallet Wallet]
             [org.bitcoinj.wallet.WalletTransaction Pool]))

;;;
 ; <p>A transaction represents the movement of coins from some addresses to some other addresses.  It can also represent
 ; the minting of new coins.  A Transaction object corresponds to the equivalent in the Bitcoin C++ implementation.</p>
 ;
 ; <p>Transactions are the fundamental atoms of Bitcoin and have many powerful features.  Read
 ; <a href="https://bitcoinj.github.io/working-with-transactions">"Working with transactions"</a> in the
 ; documentation to learn more about how to use this class.</p>
 ;
 ; <p>All Bitcoin transactions are at risk of being reversed, though the risk is much less than with traditional payment
 ; systems.  Transactions have <i>confidence levels</i>, which help you decide whether to trust a transaction or not.
 ; Whether to trust a transaction is something that needs to be decided on a case by case basis - a rule that makes
 ; sense for selling MP3s might not make sense for selling cars, or accepting payments from a family member.  If you
 ; are building a wallet, how to present confidence to your users is something to consider carefully.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class Transaction extends ChildMessage
    ;;;
     ; A comparator that can be used to sort transactions by their updateTime field.
     ; The ordering goes from most recent into the past.
     ;;
    #_public
    #_static
    #_final
    (§ field Comparator<Transaction> SORT_TX_BY_UPDATE_TIME = new Comparator<Transaction>()
        (ß
            #_override
            #_public
            (§ method int compare(#_final Transaction tx1, #_final Transaction tx2))
            (ß
                #_final
                (§ var long time1 = tx1.getUpdateTime().getTime())
                #_final
                (§ var long time2 = tx2.getUpdateTime().getTime())
                #_final
                (§ var int updateTimeComparison = -Longs.compare(time1, time2))
                ;; If time1 == time2, compare by tx hash to make comparator consistent with equals.
                (§ return (updateTimeComparison != 0) ? updateTimeComparison :else tx1.getHash().compareTo(tx2.getHash()))
            )
        ))

    ;;; A comparator that can be used to sort transactions by their chain height. ;;
    #_public
    #_static
    #_final
    (§ field Comparator<Transaction> SORT_TX_BY_HEIGHT = new Comparator<Transaction>()
        (ß
            #_override
            #_public
            (§ method int compare(#_final Transaction tx1, #_final Transaction tx2))
            (ß
                #_final
                (§ var TransactionConfidence confidence1 = tx1.getConfidence())
                #_final
                (§ var int height1 = (confidence1.getConfidenceType() == ConfidenceType.BUILDING) ? confidence1.getAppearedAtChainHeight() :else Block.BLOCK_HEIGHT_UNKNOWN)
                #_final
                (§ var TransactionConfidence confidence2 = tx2.getConfidence())
                #_final
                (§ var int height2 = (confidence2.getConfidenceType() == ConfidenceType.BUILDING) ? confidence2.getAppearedAtChainHeight() :else Block.BLOCK_HEIGHT_UNKNOWN)
                #_final
                (§ var int heightComparison = -Ints.compare(height1, height2))
                ;; If height1 == height2, compare by tx hash to make comparator consistent with equals.
                (§ return (heightComparison != 0) ? heightComparison :else tx1.getHash().compareTo(tx2.getHash()))
            )
        ))

    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(Transaction.class))

    ;;; Threshold for lockTime: below this value it is interpreted as block number, otherwise as timestamp. ;;
    #_public
    #_static
    #_final
    (§ field int LOCKTIME_THRESHOLD = 500000000) ;; Tue Nov  5 00:53:20 1985 UTC
    ;;; Same, but as a BigInteger for CHECKLOCKTIMEVERIFY. ;;
    #_public
    #_static
    #_final
    (§ field BigInteger LOCKTIME_THRESHOLD_BIG = BigInteger.valueOf(LOCKTIME_THRESHOLD))

    ;;; How many bytes a transaction can be before it won't be relayed anymore.  Currently 100kb. ;;
    #_public
    #_static
    #_final
    (§ field int MAX_STANDARD_TX_SIZE = 100000)

    ;;;
     ; If feePerKb is lower than this, Bitcoin Core will treat it as if there were no fee.
     ;;
    #_public
    #_static
    #_final
    (§ field Coin REFERENCE_DEFAULT_MIN_TX_FEE = Coin.valueOf(5000)) ;; 0.05 mBTC

    ;;;
     ; If using this feePerKb, transactions will get confirmed within the next couple of blocks.
     ; This should be adjusted from time to time.  Last adjustment: February 2017.
     ;;
    #_public
    #_static
    #_final
    (§ field Coin DEFAULT_TX_FEE = Coin.valueOf(100000)) ;; 1 mBTC

    ;;;
     ; Any standard (i.e. pay-to-address) output smaller than this value (in satoshis) will most likely be rejected by the network.
     ; This is calculated by assuming a standard output will be 34 bytes, and then using the formula used in
     ; {@link TransactionOutput#getMinNonDustValue(Coin)}.
     ;;
    #_public
    #_static
    #_final
    (§ field Coin MIN_NONDUST_OUTPUT = Coin.valueOf(2730)) ;; satoshis

    ;; These are bitcoin serialized.
    #_private
    (§ field long version)
    #_private
    (§ field ArrayList<TransactionInput> inputs)
    #_private
    (§ field ArrayList<TransactionOutput> outputs)

    #_private
    (§ field long lockTime)

    ;; This is either the time the transaction was broadcast as measured from the local clock, or the time from the
    ;; block in which it was included.  Note that this can be changed by re-orgs so the wallet may update this field.
    ;; Old serialized transactions don't have this field, thus null is valid.  It is used for returning an ordered
    ;; list of transactions from a wallet, which is helpful for presenting to users.
    #_private
    (§ field Date updatedAt)

    ;; This is an in memory helper only.
    #_private
    (§ field Sha256Hash hash)

    ;; Data about how confirmed this tx is.  Serialized, may be null.
    #_nilable
    #_private
    (§ field TransactionConfidence confidence)

    ;; Records a map of which blocks the transaction has appeared in (keys) to an index within that block (values).
    ;; The "index" is not a real index, instead the values are only meaningful relative to each other.  For example,
    ;; consider two transactions that appear in the same block, t1 and t2, where t2 spends an output of t1.  Both
    ;; will have the same block hash as a key in their appearsInHashes, but the counter would be 1 and 2 respectively
    ;; regardless of where they actually appeared in the block.
    ;;
    ;; If this transaction is not stored in the wallet, appearsInHashes is null.
    #_private
    (§ field Map<Sha256Hash, Integer> appearsInHashes)

    ;; Transactions can be encoded in a way that will use more bytes than is optimal
    ;; (due to VarInts having multiple encodings).
    ;; MAX_BLOCK_SIZE must be compared to the optimal encoding, not the actual encoding, so when parsing, we keep track
    ;; of the size of the ideal encoding in addition to the actual message size (which Message needs) so that Blocks
    ;; can properly keep track of optimal encoded size.
    #_private
    (§ field int optimalEncodingMessageSize)

    ;;;
     ; This enum describes the underlying reason the transaction was created.  It's useful for rendering wallet GUIs
     ; more appropriately.
     ;;
    #_public
    (§ enum Purpose
        ;;; Used when the purpose of a transaction is genuinely unknown. ;;
        (§ item UNKNOWN)
        ;;; Transaction created to satisfy a user payment request. ;;
        (§ item USER_PAYMENT)
        ;;; Transaction automatically created and broadcast in order to reallocate money from old to new keys. ;;
        (§ item KEY_ROTATION)
        ;;; Transaction that uses up pledges to an assurance contract. ;;
        (§ item ASSURANCE_CONTRACT_CLAIM)
        ;;; Transaction that makes a pledge to an assurance contract. ;;
        (§ item ASSURANCE_CONTRACT_PLEDGE)
        ;;; Send-to-self transaction that exists just to create an output of the right size we can pledge. ;;
        (§ item ASSURANCE_CONTRACT_STUB)
        ;;; Raise fee, e.g. child-pays-for-parent. ;;
        (§ item RAISE_FEE)
        ;; In future: de/refragmentation, privacy boosting/mixing, etc.
        ;; When adding a value, it also needs to be added to wallet.proto, WalletProtobufSerialize.makeTxProto()
        ;; and WalletProtobufSerializer.readTransaction()!
    )

    #_private
    (§ field Purpose purpose = Purpose.UNKNOWN)

    ;;;
     ; This field can be used by applications to record the exchange rate that was valid when the transaction happened.
     ; It's optional.
     ;;
    #_nilable
    #_private
    (§ field ExchangeRate exchangeRate)

    ;;;
     ; This field can be used to record the memo of the payment request that initiated the transaction.
     ; It's optional.
     ;;
    #_nilable
    #_private
    (§ field String memo)

    ;; Below flags apply in the context of BIP 68.
     ; If this flag set, CTxIn::nSequence is NOT interpreted as a relative lock-time.
     ;;
    #_public
    #_static
    #_final
    (§ field long SEQUENCE_LOCKTIME_DISABLE_FLAG = 1 << 31)

    ;; If CTxIn::nSequence encodes a relative lock-time and this flag
     ; is set, the relative lock-time has units of 512 seconds,
     ; otherwise it specifies blocks with a granularity of 1.
     ;;
    #_public
    #_static
    #_final
    (§ field long SEQUENCE_LOCKTIME_TYPE_FLAG = 1 << 22)

    ;; If CTxIn::nSequence encodes a relative lock-time, this mask is
     ; applied to extract that lock-time from the sequence field.
     ;;
    #_public
    #_static
    #_final
    (§ field long SEQUENCE_LOCKTIME_MASK = 0x0000ffff)

    #_public
    (§ constructor Transaction(NetworkParameters params))
    (ß
        (§ super (params))

        (§ ass version = 1)
        (§ ass inputs = new ArrayList<>())
        (§ ass outputs = new ArrayList<>())
        ;; We don't initialize appearsIn deliberately as it's only useful for transactions stored in the wallet.
        (§ ass length = 8) ;; 8 for std fields
    )

    ;;;
     ; Creates a transaction from the given serialized bytes, e.g. from a block or a tx network message.
     ;;
    #_public
    (§ constructor Transaction(NetworkParameters params, byte[] payloadBytes))
        (§ throws ProtocolException)
    (ß
        (§ super (params, payloadBytes, 0))
    )

    ;;;
     ; Creates a transaction by reading payload starting from offset bytes in.  Length of a transaction is fixed.
     ;;
    #_public
    (§ constructor Transaction(NetworkParameters params, byte[] payload, int offset))
        (§ throws ProtocolException)
    (ß
        (§ super (params, payload, offset))
        ;; inputs/outputs will be created in parse()
    )

    ;;;
     ; Creates a transaction by reading payload starting from offset bytes in.  Length of a transaction is fixed.
     ; @param params NetworkParameters object.
     ; @param payload Bitcoin protocol formatted byte array containing message content.
     ; @param offset The location of the first payload byte within the array.
     ; @param parseRetain Whether to retain the backing byte array for quick reserialization.
     ; If true and the backing byte array is invalidated due to modification of a field, then
     ; the cached bytes may be repopulated and retained if the message is serialized again in the future.
     ; @param length The length of message if known.  Usually this is provided when deserializing of the wire
     ; as the length will be provided as part of the header.  Set to Message.UNKNOWN_LENGTH, if not known.
     ; @throws ProtocolException
     ;;
    #_public
    (§ constructor Transaction(NetworkParameters params, byte[] payload, int offset, #_nilable Message parent, MessageSerializer setSerializer, int length))
        (§ throws ProtocolException)
    (ß
        (§ super (params, payload, offset, parent, setSerializer, length))
    )

    ;;;
     ; Creates a transaction by reading payload.  Length of a transaction is fixed.
     ;;
    #_public
    (§ constructor Transaction(NetworkParameters params, byte[] payload, #_nilable Message parent, MessageSerializer setSerializer, int length))
        (§ throws ProtocolException)
    (ß
        (§ super (params, payload, 0, parent, setSerializer, length))
    )

    ;;;
     ; Returns the transaction hash as you see them in the block explorer.
     ;;
    #_override
    #_public
    (§ method Sha256Hash getHash())
    (ß
        (§ if (hash == nil))
            (§ ass hash = Sha256Hash.wrapReversed(Sha256Hash.hashTwice(unsafeBitcoinSerialize())))
        (§ return hash)
    )

    ;;;
     ; Used by BitcoinSerializer.  The serializer has to calculate a hash for checksumming so to
     ; avoid wasting the considerable effort a set method is provided so the serializer can set it.
     ;
     ; No verification is performed on this hash.
     ;;
    (§ method void setHash(Sha256Hash hash))
    (ß
        (§ ass this.hash = hash)
    )

    #_public
    (§ method String getHashAsString())
    (ß
        (§ return getHash().toString())
    )

    ;;;
     ; Gets the sum of the inputs, regardless of who owns them.
     ;;
    #_public
    (§ method Coin getInputSum())
    (ß
        (§ var Coin inputTotal = Coin.ZERO)

        (§ for (TransactionInput input :for inputs))
        (ß
            (§ var Coin inputValue = input.getValue())
            (§ if (inputValue != nil))
                (§ ass inputTotal = inputTotal.add(inputValue))
        )

        (§ return inputTotal)
    )

    ;;;
     ; Calculates the sum of the outputs that are sending coins to a key in the wallet.
     ;;
    #_public
    (§ method Coin getValueSentToMe(TransactionBag transactionBag))
    (ß
        ;; This is tested in WalletTest.
        (§ var Coin v = Coin.ZERO)
        (§ for (TransactionOutput o :for outputs))
            (§ if (o.isMine(transactionBag)))
                (§ ass v = v.add(o.getValue()))
        (§ return v)
    )

    ;;;
     ; Returns a map of block [hashes] which contain the transaction mapped to relativity counters, or null if this
     ; transaction doesn't have that data because it's not stored in the wallet or because it has never appeared in a
     ; block.
     ;;
    #_nilable
    #_public
    (§ method Map<Sha256Hash, Integer> getAppearsInHashes())
    (ß
        (§ return (appearsInHashes != nil) ? ImmutableMap.copyOf(appearsInHashes) :else nil)
    )

    ;;;
     ; Convenience wrapper around getConfidence().getConfidenceType().
     ; @return true if this transaction hasn't been seen in any block yet.
     ;;
    #_public
    (§ method boolean isPending())
    (ß
        (§ return (getConfidence().getConfidenceType() == TransactionConfidence.ConfidenceType.PENDING))
    )

    ;;;
     ; <p>Puts the given block in the internal set of blocks in which this transaction appears.  This is
     ; used by the wallet to ensure transactions that appear on side chains are recorded properly even though
     ; the block stores do not save the transaction data at all.</p>
     ;
     ; <p>If there is a re-org this will be called once for each block that was previously seen, to update which block
     ; is the best chain.  The best chain block is guaranteed to be called last. So this must be idempotent.</p>
     ;
     ; <p>Sets updatedAt to be the earliest valid block time where this tx was seen.</p>
     ;
     ; @param block     The {@link StoredBlock} in which the transaction has appeared.
     ; @param bestChain Whether to set the updatedAt timestamp from the block header (only if not already set).
     ; @param relativityOffset A number that disambiguates the order of transactions within a block.
     ;;
    #_public
    (§ method void setBlockAppearance(StoredBlock block, boolean bestChain, int relativityOffset))
    (ß
        (§ var long blockTime = block.getHeader().getTimeSeconds() * 1000)
        (§ if (bestChain && (updatedAt == nil || updatedAt.getTime() == 0 || blockTime < updatedAt.getTime())))
            (§ ass updatedAt = new Date(blockTime))

        (§ call addBlockAppearance(block.getHeader().getHash(), relativityOffset))

        (§ if (bestChain))
        (ß
            (§ var TransactionConfidence transactionConfidence = getConfidence())
            ;; This sets type to BUILDING and depth to one.
            (§ call transactionConfidence.setAppearedAtChainHeight(block.getHeight()))
        )
    )

    #_public
    (§ method void addBlockAppearance(#_final Sha256Hash blockHash, int relativityOffset))
    (ß
        ;; TODO: This could be a lot more memory efficient as we'll typically only store one element.
        (§ if (appearsInHashes == nil))
            (§ ass appearsInHashes = new TreeMap<>())

        (§ call appearsInHashes.put(blockHash, relativityOffset))
    )

    ;;;
     ; Calculates the sum of the inputs that are spending coins with keys in the wallet.  This requires the
     ; transactions sending coins to those keys to be in the wallet.  This method will not attempt to download
     ; the blocks containing the input transactions if the key is in the wallet but the transactions are not.
     ;
     ; @return sum of the inputs that are spending coins with keys in the wallet.
     ;;
    #_public
    (§ method Coin getValueSentFromMe(TransactionBag wallet))
        (§ throws ScriptException)
    (ß
        ;; This is tested in WalletTest.
        (§ var Coin v = Coin.ZERO)
        (§ for (TransactionInput input :for inputs))
        (ß
            ;; This input is taking value from a transaction in our wallet.  To discover the value,
            ;; we must find the connected transaction.
            (§ var TransactionOutput connected = input.getConnectedOutput(wallet.getTransactionPool(Pool.UNSPENT)))
            (§ if (connected == nil))
                (§ ass connected = input.getConnectedOutput(wallet.getTransactionPool(Pool.SPENT)))
            (§ if (connected == nil))
                (§ ass connected = input.getConnectedOutput(wallet.getTransactionPool(Pool.PENDING)))

            ;; The connected output may be the change to the sender of a previous input sent to this wallet.
            ;; In this case we ignore it.
            (§ if (connected != nil && connected.isMine(wallet)))
                (§ ass v = v.add(connected.getValue()))
        )
        (§ return v)
    )

    ;;;
     ; Gets the sum of the outputs of the transaction.  If the outputs are less than the inputs, it does not count the fee.
     ; @return the sum of the outputs regardless of who owns them.
     ;;
    #_public
    (§ method Coin getOutputSum())
    (ß
        (§ var Coin totalOut = Coin.ZERO)

        (§ for (TransactionOutput output :for outputs))
            (§ ass totalOut = totalOut.add(output.getValue()))

        (§ return totalOut)
    )

    #_nilable
    #_private
    (§ field Coin cachedValue)
    #_nilable
    #_private
    (§ field TransactionBag cachedForBag)

    ;;;
     ; Returns the difference of {@link Transaction#getValueSentToMe(TransactionBag)} and {@link Transaction#getValueSentFromMe(TransactionBag)}.
     ;;
    #_public
    (§ method Coin getValue(TransactionBag wallet))
        (§ throws ScriptException)
    (ß
        ;; FIXME: TEMP PERF HACK FOR ANDROID - this crap can go away once we have a real payments API.
        (§ var boolean isAndroid = Utils.isAndroidRuntime())
        (§ if (isAndroid && cachedValue != nil && cachedForBag == wallet))
            (§ return cachedValue)

        (§ var Coin result = getValueSentToMe(wallet).subtract(getValueSentFromMe(wallet)))
        (§ if (isAndroid))
        (ß
            (§ ass cachedValue = result)
            (§ ass cachedForBag = wallet)
        )
        (§ return result)
    )

    ;;;
     ; The transaction fee is the difference of the value of all inputs and the value of all outputs.
     ; Currently, the fee can only be determined for transactions created by us.
     ;
     ; @return fee, or null if it cannot be determined.
     ;;
    #_public
    (§ method Coin getFee())
    (ß
        (§ var Coin fee = Coin.ZERO)
        (§ if (inputs.isEmpty() || outputs.isEmpty())) ;; Incomplete transaction.
            (§ return nil)

        (§ for (TransactionInput input :for inputs))
        (ß
            (§ if (input.getValue() == nil))
                (§ return nil)
            (§ ass fee = fee.add(input.getValue()))
        )
        (§ for (TransactionOutput output :for outputs))
        (ß
            (§ ass fee = fee.subtract(output.getValue()))
        )
        (§ return fee)
    )

    ;;;
     ; Returns true if any of the outputs is marked as spent.
     ;;
    #_public
    (§ method boolean isAnyOutputSpent())
    (ß
        (§ for (TransactionOutput output :for outputs))
            (§ if (!output.isAvailableForSpending()))
                (§ return true)

        (§ return false)
    )

    ;;;
     ; Returns false if this transaction has at least one output that is owned by the given wallet and unspent,
     ; true otherwise.
     ;;
    #_public
    (§ method boolean isEveryOwnedOutputSpent(TransactionBag transactionBag))
    (ß
        (§ for (TransactionOutput output :for outputs))
            (§ if (output.isAvailableForSpending() && output.isMine(transactionBag)))
                (§ return false)

        (§ return true)
    )

    ;;;
     ; Returns the earliest time at which the transaction was seen (broadcast or included into the chain),
     ; or the epoch if that information isn't available.
     ;;
    #_public
    (§ method Date getUpdateTime())
    (ß
        ;; Older wallets did not store this field.  Set to the epoch.
        (§ if (updatedAt == nil))
            (§ ass updatedAt = new Date(0))
        (§ return updatedAt)
    )

    #_public
    (§ method void setUpdateTime(Date updatedAt))
    (ß
        (§ ass this.updatedAt = updatedAt)
    )

    ;;;
     ; These constants are a part of a scriptSig signature on the inputs.  They define the details of how a
     ; transaction can be redeemed, specifically, they control how the hash of the transaction is calculated.
     ;;
    #_public
    (§ enum SigHash
        (§ item ALL(1))
        (§ item NONE(2))
        (§ item SINGLE(3))
        (§ item ANYONECANPAY(0x80)) ;; Caution: Using this type in isolation is non-standard.  Treated similar to ANYONECANPAY_ALL.
        (§ item ANYONECANPAY_ALL(0x81))
        (§ item ANYONECANPAY_NONE(0x82))
        (§ item ANYONECANPAY_SINGLE(0x83))
        (§ item UNSET(0)) ;; Caution: Using this type in isolation is non-standard.  Treated similar to ALL.

        #_public
        #_final
        (§ field int value)

        ;;;
         ; @param value
         ;;
        #_private
        (§ constructor SigHash(#_final int value))
        (ß
            (§ ass this.value = value)
        )

        ;;;
         ; @return the value as a byte.
         ;;
        #_public
        (§ method byte byteValue())
        (ß
            (§ return (byte)this.value)
        )
    )

    #_override
    #_protected
    (§ method void unCache())
    (ß
        (§ call super.unCache())
        (§ ass hash = nil)
    )

    #_protected
    #_static
    (§ method int calcLength(byte[] buf, int offset))
    (ß
        ;; jump past version (uint32)
        (§ var int cursor = offset + 4)

        (§ var VarInt varint = new VarInt(buf, cursor))
        (§ var long txInCount = varint.value)
        (§ ass cursor = cursor + varint.getOriginalSizeInBytes())

        (§ for (int i = 0 :for i < txInCount :for i = i + 1))
        (ß
            ;; 36 = length of previous_outpoint
            (§ ass cursor = cursor + 36)
            (§ ass varint = new VarInt(buf, cursor))
            (§ var long scriptLen = varint.value)
            ;; 4 = length of sequence field (unint32)
            (§ ass cursor = cursor + scriptLen + 4 + varint.getOriginalSizeInBytes())
        )

        (§ ass varint = new VarInt(buf, cursor))
        (§ var long txOutCount = varint.value)
        (§ ass cursor = cursor + varint.getOriginalSizeInBytes())

        (§ for (int i = 0 :for i < txOutCount :for i = i + 1))
        (ß
            ;; 8 = length of tx value field (uint64)
            (§ ass cursor = cursor + 8)
            (§ ass varint = new VarInt(buf, cursor))
            (§ var long scriptLen = varint.value)
            (§ ass cursor = cursor + scriptLen + varint.getOriginalSizeInBytes())
        )
        ;; 4 = length of lock_time field (uint32)
        (§ return cursor - offset + 4)
    )

    #_override
    #_protected
    (§ method void parse())
        (§ throws ProtocolException)
    (ß
        (§ ass cursor = offset)

        (§ ass version = readUint32())
        (§ ass optimalEncodingMessageSize = 4)

        ;; First come the inputs.
        (§ var long numInputs = readVarInt())
        (§ ass optimalEncodingMessageSize = optimalEncodingMessageSize + VarInt.sizeOf(numInputs))
        (§ ass inputs = new ArrayList<>((int)numInputs))
        (§ for (long i = 0 :for i < numInputs :for i = i + 1))
        (ß
            (§ var TransactionInput input = new TransactionInput(params, this, payload, cursor, serializer))
            (§ call inputs.add(input))
            (§ var long scriptLen = readVarInt(TransactionOutPoint.MESSAGE_LENGTH))
            (§ ass optimalEncodingMessageSize = optimalEncodingMessageSize + TransactionOutPoint.MESSAGE_LENGTH + VarInt.sizeOf(scriptLen) + scriptLen + 4)
            (§ ass cursor = cursor + scriptLen + 4)
        )
        ;; Now the outputs.
        (§ var long numOutputs = readVarInt())
        (§ ass optimalEncodingMessageSize = optimalEncodingMessageSize + VarInt.sizeOf(numOutputs))
        (§ ass outputs = new ArrayList<>((int)numOutputs))
        (§ for (long i = 0 :for i < numOutputs :for i = i + 1))
        (ß
            (§ var TransactionOutput output = new TransactionOutput(params, this, payload, cursor, serializer))
            (§ call outputs.add(output))
            (§ var long scriptLen = readVarInt(8))
            (§ ass optimalEncodingMessageSize = optimalEncodingMessageSize + 8 + VarInt.sizeOf(scriptLen) + scriptLen)
            (§ ass cursor = cursor + scriptLen)
        )
        (§ ass lockTime = readUint32())
        (§ ass optimalEncodingMessageSize = optimalEncodingMessageSize + 4)
        (§ ass length = cursor - offset)
    )

    #_public
    (§ method int getOptimalEncodingMessageSize())
    (ß
        (§ if (optimalEncodingMessageSize != 0))
            (§ return optimalEncodingMessageSize)

        (§ ass optimalEncodingMessageSize = getMessageSize())
        (§ return optimalEncodingMessageSize)
    )

    ;;;
     ; The priority (coin age) calculation doesn't use the regular message size, but rather one adjusted downwards
     ; for the number of inputs.  The goal is to incentivise cleaning up the UTXO set with free transactions, if one
     ; can do so.
     ;;
    #_public
    (§ method int getMessageSizeForPriorityCalc())
    (ß
        (§ var int size = getMessageSize())
        (§ for (TransactionInput input :for inputs))
        (ß
            ;; 41: min size of an input
            ;; 110: enough to cover a compressed pubkey p2sh redemption (somewhat arbitrary)
            (§ var int benefit = 41 + Math.min(110, input.getScriptSig().getProgram().length))
            (§ if (benefit < size))
                (§ ass size = size - benefit)
        )
        (§ return size)
    )

    ;;;
     ; A coinbase transaction is one that creates a new coin.  They are the first transaction in each block and their
     ; value is determined by a formula that all implementations of Bitcoin share.  In 2011 the value of a coinbase
     ; transaction is 50 coins, but in future it will be less.  A coinbase transaction is defined not only by its
     ; position in a block but by the data in the inputs.
     ;;
    #_public
    (§ method boolean isCoinBase())
    (ß
        (§ return (inputs.size() == 1 && inputs.get(0).isCoinBase()))
    )

    ;;;
     ; A transaction is mature if it is either a building coinbase tx that is as deep or deeper than the required coinbase depth, or a non-coinbase tx.
     ;;
    #_public
    (§ method boolean isMature())
    (ß
        (§ if (!isCoinBase()))
            (§ return true)

        (§ if (getConfidence().getConfidenceType() != ConfidenceType.BUILDING))
            (§ return false)

        (§ return (params.getSpendableCoinbaseDepth() <= getConfidence().getDepthInBlocks()))
    )

    #_override
    #_public
    (§ method String toString())
    (ß
        (§ return toString(nil))
    )

    ;;;
     ; A human readable version of the transaction useful for debugging.  The format is not guaranteed to be stable.
     ; @param chain If provided, will be used to estimate lock times (if set).  Can be null.
     ;;
    #_public
    (§ method String toString(#_nilable AbstractBlockChain chain))
    (ß
        (§ var StringBuilder sb = new StringBuilder())
        (§ call sb.append("  ").append(getHashAsString()).append("\n"))
        (§ if (updatedAt != nil))
            (§ call sb.append("  updated: ").append(Utils.dateTimeFormat(updatedAt)).append("\n"))
        (§ if (version != 1))
            (§ call sb.append("  version ").append(version).append("\n"))
        (§ if (isTimeLocked()))
        (ß
            (§ call sb.append("  time locked until "))
            (§ if (lockTime < LOCKTIME_THRESHOLD))
            (ß
                (§ call sb.append("block ").append(lockTime))
                (§ if (chain != nil))
                    (§ call sb.append(" (estimated to be reached at ").append(Utils.dateTimeFormat(chain.estimateBlockTime((int)lockTime))).append(")"))
            )
            (§ else)
            (ß
                (§ call sb.append(Utils.dateTimeFormat(lockTime * 1000)))
            )
            (§ call sb.append("\n"))
        )
        (§ if (isOptInFullRBF()))
        (ß
            (§ call sb.append("  opts into full replace-by-fee\n"))
        )
        (§ if (isCoinBase()))
        (ß
            (§ var String script)
            (§ var String script2)
            (§ try)
            (ß
                (§ ass script = inputs.get(0).getScriptSig().toString())
                (§ ass script2 = outputs.get(0).getScriptPubKey().toString())
            )
            (§ catch (ScriptException _))
            (ß
                (§ ass script = "???")
                (§ ass script2 = "???")
            )
            (§ call sb.append("     == COINBASE TXN (scriptSig ").append(script).append(")  (scriptPubKey ").append(script2).append(")\n"))
            (§ return sb.toString())
        )

        (§ if (!inputs.isEmpty()))
        (ß
            (§ for (TransactionInput in :for inputs))
            (ß
                (§ call sb.append("     in   "))

                (§ try)
                (ß
                    (§ var String scriptSigStr = in.getScriptSig().toString())
                    (§ call sb.append(!Strings.isNullOrEmpty(scriptSigStr) ? scriptSigStr :else "<no scriptSig>"))
                    #_final
                    (§ var Coin value = in.getValue())
                    (§ if (value != nil))
                        (§ call sb.append(" ").append(value.toFriendlyString()))
                    (§ call sb.append("\n          outpoint:"))
                    #_final
                    (§ var TransactionOutPoint outpoint = in.getOutpoint())
                    (§ call sb.append(outpoint.toString()))
                    #_final
                    (§ var TransactionOutput connectedOutput = outpoint.getConnectedOutput())
                    (§ if (connectedOutput != nil))
                    (ß
                        (§ var Script scriptPubKey = connectedOutput.getScriptPubKey())
                        (§ if (scriptPubKey.isSentToAddress() || scriptPubKey.isPayToScriptHash()))
                            (§ call sb.append(" hash160:").append(Utils.HEX.encode(scriptPubKey.getPubKeyHash())))
                    )
                    (§ if (in.hasSequence()))
                    (ß
                        (§ call sb.append("\n          sequence:").append(Long.toHexString(in.getSequenceNumber())))
                        (§ if (in.isOptInFullRBF()))
                            (§ call sb.append(", opts into full RBF"))
                    )
                )
                (§ catch (Exception e))
                (ß
                    (§ call sb.append("[exception: ").append(e.getMessage()).append("]"))
                )
                (§ call sb.append("\n"))
            )
        )
        (§ else)
        (ß
            (§ call sb.append("     INCOMPLETE: No inputs!\n"))
        )

        (§ for (TransactionOutput out :for outputs))
        (ß
            (§ call sb.append("     out  "))
            (§ try)
            (ß
                (§ var String scriptPubKeyStr = out.getScriptPubKey().toString())
                (§ call sb.append(!Strings.isNullOrEmpty(scriptPubKeyStr) ? scriptPubKeyStr :else "<no scriptPubKey>").append(" ").append(out.getValue().toFriendlyString()))
                (§ if (!out.isAvailableForSpending()))
                    (§ call sb.append(" Spent"))
                #_final
                (§ var TransactionInput spentBy = out.getSpentBy())
                (§ if (spentBy != nil))
                    (§ call sb.append(" by ").append(spentBy.getParentTransaction().getHashAsString()))
            )
            (§ catch (Exception e))
            (ß
                (§ call sb.append("[exception: ").append(e.getMessage()).append("]"))
            )
            (§ call sb.append("\n"))
        )

        #_final
        (§ var Coin fee = getFee())
        (§ if (fee != nil))
        (ß
            #_final
            (§ var int size = unsafeBitcoinSerialize().length)
            (§ call sb.append("     fee  ").append(fee.multiply(1000).divide(size).toFriendlyString()).append("/kB, ").append(fee.toFriendlyString()).append(" for ").append(size).append(" bytes\n"))
        )
        (§ if (purpose != nil))
            (§ call sb.append("     prps ").append(purpose).append("\n"))
        (§ return sb.toString())
    )

    ;;;
     ; Removes all the inputs from this transaction.
     ; Note that this also invalidates the length attribute.
     ;;
    #_public
    (§ method void clearInputs())
    (ß
        (§ call unCache())
        (§ for (TransactionInput input :for inputs))
            (§ call input.setParent(nil))
        (§ call inputs.clear())
        ;; You wanted to reserialize, right?
        (§ ass this.length = this.unsafeBitcoinSerialize().length)
    )

    ;;;
     ; Adds an input to this transaction that imports value from the given output.  Note that this input is <i>not</i>
     ; complete and after every input is added with {@link #addInput()} and every output is added with {@link #addOutput()},
     ; a {@link TransactionSigner} must be used to finalize the transaction and finish the inputs off.
     ; Otherwise it won't be accepted by the network.
     ; @return the newly created input.
     ;;
    #_public
    (§ method TransactionInput addInput(TransactionOutput from))
    (ß
        (§ return addInput(new TransactionInput(params, this, from)))
    )

    ;;;
     ; Adds an input directly, with no checking that it's valid.
     ; @return the new input.
     ;;
    #_public
    (§ method TransactionInput addInput(TransactionInput input))
    (ß
        (§ call unCache())
        (§ call input.setParent(this))
        (§ call inputs.add(input))
        (§ call adjustLength(inputs.size(), input.length))
        (§ return input)
    )

    ;;;
     ; Creates and adds an input to this transaction, with no checking that it's valid.
     ; @return the newly created input.
     ;;
    #_public
    (§ method TransactionInput addInput(Sha256Hash spendTxHash, long outputIndex, Script script))
    (ß
        (§ return addInput(new TransactionInput(params, this, script.getProgram(), new TransactionOutPoint(params, outputIndex, spendTxHash))))
    )

    ;;;
     ; Adds a new and fully signed input for the given parameters.  Note that this method is <b>not</b> thread safe
     ; and requires external synchronization.  Please refer to general documentation on Bitcoin scripting and contracts
     ; to understand the values of sigHash and anyoneCanPay: otherwise you can use the other form of this method
     ; that sets them to typical defaults.
     ;
     ; @throws ScriptException if the scriptPubKey is not a pay to address or pay to pubkey script.
     ;;
    #_public
    (§ method TransactionInput addSignedInput(TransactionOutPoint prevOut, Script scriptPubKey, ECKey sigKey, SigHash sigHash, boolean anyoneCanPay))
        (§ throws ScriptException)
    (ß
        ;; Verify the API user didn't try to do operations out of order.
        (§ call Preconditions.checkState(!outputs.isEmpty(), "Attempting to sign tx without outputs."))

        (§ var TransactionInput input = new TransactionInput(params, this, new byte[] (ß ), prevOut))
        (§ call addInput(input))
        (§ var Sha256Hash hash = hashForSignature(inputs.size() - 1, scriptPubKey, sigHash, anyoneCanPay))
        (§ var ECKey.ECDSASignature ecSig = sigKey.sign(hash))
        (§ var TransactionSignature txSig = new TransactionSignature(ecSig, sigHash, anyoneCanPay))
        (§ if (scriptPubKey.isSentToRawPubKey()))
            (§ call input.setScriptSig(ScriptBuilder.createInputScript(txSig)))
        (§ elseif (scriptPubKey.isSentToAddress()))
            (§ call input.setScriptSig(ScriptBuilder.createInputScript(txSig, sigKey)))
        (§ else)
            (§ throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "Don't know how to sign for this kind of scriptPubKey: " + scriptPubKey))
        (§ return input)
    )

    ;;;
     ; Same as {@link #addSignedInput(TransactionOutPoint, org.bitcoinj.script.Script, ECKey, org.bitcoinj.core.Transaction.SigHash, boolean)},
     ; but defaults to {@link SigHash#ALL} and "false" for the anyoneCanPay flag.  This is normally what you want.
     ;;
    #_public
    (§ method TransactionInput addSignedInput(TransactionOutPoint prevOut, Script scriptPubKey, ECKey sigKey))
        (§ throws ScriptException)
    (ß
        (§ return addSignedInput(prevOut, scriptPubKey, sigKey, SigHash.ALL, false))
    )

    ;;;
     ; Adds an input that points to the given output and contains a valid signature for it, calculated using the
     ; signing key.
     ;;
    #_public
    (§ method TransactionInput addSignedInput(TransactionOutput output, ECKey signingKey))
    (ß
        (§ return addSignedInput(output.getOutPointFor(), output.getScriptPubKey(), signingKey))
    )

    ;;;
     ; Adds an input that points to the given output and contains a valid signature for it, calculated using the
     ; signing key.
     ;;
    #_public
    (§ method TransactionInput addSignedInput(TransactionOutput output, ECKey signingKey, SigHash sigHash, boolean anyoneCanPay))
    (ß
        (§ return addSignedInput(output.getOutPointFor(), output.getScriptPubKey(), signingKey, sigHash, anyoneCanPay))
    )

    ;;;
     ; Removes all the outputs from this transaction.
     ; Note that this also invalidates the length attribute.
     ;;
    #_public
    (§ method void clearOutputs())
    (ß
        (§ call unCache())
        (§ for (TransactionOutput output :for outputs))
            (§ call output.setParent(nil))
        (§ call outputs.clear())
        ;; You wanted to reserialize, right?
        (§ ass this.length = this.unsafeBitcoinSerialize().length)
    )

    ;;;
     ; Adds the given output to this transaction.  The output must be completely initialized.  Returns the given output.
     ;;
    #_public
    (§ method TransactionOutput addOutput(TransactionOutput to))
    (ß
        (§ call unCache())
        (§ call to.setParent(this))
        (§ call outputs.add(to))
        (§ call adjustLength(outputs.size(), to.length))
        (§ return to)
    )

    ;;;
     ; Creates an output based on the given address and value, adds it to this transaction, and returns the new output.
     ;;
    #_public
    (§ method TransactionOutput addOutput(Coin value, Address address))
    (ß
        (§ return addOutput(new TransactionOutput(params, this, value, address)))
    )

    ;;;
     ; Creates an output that pays to the given pubkey directly (no address) with the given value, adds it to this
     ; transaction, and returns the new output.
     ;;
    #_public
    (§ method TransactionOutput addOutput(Coin value, ECKey pubkey))
    (ß
        (§ return addOutput(new TransactionOutput(params, this, value, pubkey)))
    )

    ;;;
     ; Creates an output that pays to the given script.  The address and key forms are specialisations of this method,
     ; you won't normally need to use it unless you're doing unusual things.
     ;;
    #_public
    (§ method TransactionOutput addOutput(Coin value, Script script))
    (ß
        (§ return addOutput(new TransactionOutput(params, this, value, script.getProgram())))
    )

    ;;;
     ; Calculates a signature that is valid for being inserted into the input at the given position.  This is simply
     ; a wrapper around calling {@link Transaction#hashForSignature(int, byte[], org.bitcoinj.core.Transaction.SigHash, boolean)}
     ; followed by {@link ECKey#sign(Sha256Hash)} and then returning a new {@link TransactionSignature}.  The key
     ; must be usable for signing as-is: if the key is encrypted it must be decrypted first external to this method.
     ;
     ; @param inputIndex Which input to calculate the signature for, as an index.
     ; @param key The private key used to calculate the signature.
     ; @param redeemScript Byte-exact contents of the scriptPubKey that is being satisified, or the P2SH redeem script.
     ; @param hashType Signing mode, see the enum for documentation.
     ; @param anyoneCanPay Signing mode, see the SigHash enum for documentation.
     ; @return A newly calculated signature object that wraps the r, s and sighash components.
     ;;
    #_public
    (§ method TransactionSignature calculateSignature(int inputIndex, ECKey key, byte[] redeemScript, SigHash hashType, boolean anyoneCanPay))
    (ß
        (§ var Sha256Hash hash = hashForSignature(inputIndex, redeemScript, hashType, anyoneCanPay))
        (§ return new TransactionSignature(key.sign(hash), hashType, anyoneCanPay))
    )

    ;;;
     ; Calculates a signature that is valid for being inserted into the input at the given position.  This is simply
     ; a wrapper around calling {@link Transaction#hashForSignature(int, byte[], org.bitcoinj.core.Transaction.SigHash, boolean)}
     ; followed by {@link ECKey#sign(Sha256Hash)} and then returning a new {@link TransactionSignature}.
     ;
     ; @param inputIndex Which input to calculate the signature for, as an index.
     ; @param key The private key used to calculate the signature.
     ; @param redeemScript The scriptPubKey that is being satisified, or the P2SH redeem script.
     ; @param hashType Signing mode, see the enum for documentation.
     ; @param anyoneCanPay Signing mode, see the SigHash enum for documentation.
     ; @return A newly calculated signature object that wraps the r, s and sighash components.
     ;;
    #_public
    (§ method TransactionSignature calculateSignature(int inputIndex, ECKey key, Script redeemScript, SigHash hashType, boolean anyoneCanPay))
    (ß
        (§ var Sha256Hash hash = hashForSignature(inputIndex, redeemScript.getProgram(), hashType, anyoneCanPay))
        (§ return new TransactionSignature(key.sign(hash), hashType, anyoneCanPay))
    )

    ;;;
     ; Calculates a signature that is valid for being inserted into the input at the given position.  This is simply
     ; a wrapper around calling {@link Transaction#hashForSignature(int, byte[], org.bitcoinj.core.Transaction.SigHash, boolean)}
     ; followed by {@link ECKey#sign(Sha256Hash)} and then returning a new {@link TransactionSignature}.  The key
     ; must be usable for signing as-is: if the key is encrypted it must be decrypted first external to this method.
     ;
     ; @param inputIndex Which input to calculate the signature for, as an index.
     ; @param key The private key used to calculate the signature.
     ; @param aesKey The AES key to use for decryption of the private key.  If null then no decryption is required.
     ; @param redeemScript Byte-exact contents of the scriptPubKey that is being satisified, or the P2SH redeem script.
     ; @param hashType Signing mode, see the enum for documentation.
     ; @param anyoneCanPay Signing mode, see the SigHash enum for documentation.
     ; @return A newly calculated signature object that wraps the r, s and sighash components.
     ;;
    #_public
    (§ method TransactionSignature calculateSignature(int inputIndex, ECKey key, #_nilable KeyParameter aesKey, byte[] redeemScript, SigHash hashType, boolean anyoneCanPay))
    (ß
        (§ var Sha256Hash hash = hashForSignature(inputIndex, redeemScript, hashType, anyoneCanPay))
        (§ return new TransactionSignature(key.sign(hash, aesKey), hashType, anyoneCanPay))
    )

    ;;;
     ; Calculates a signature that is valid for being inserted into the input at the given position.  This is simply
     ; a wrapper around calling {@link Transaction#hashForSignature(int, byte[], org.bitcoinj.core.Transaction.SigHash, boolean)}
     ; followed by {@link ECKey#sign(Sha256Hash)} and then returning a new {@link TransactionSignature}.
     ;
     ; @param inputIndex Which input to calculate the signature for, as an index.
     ; @param key The private key used to calculate the signature.
     ; @param aesKey The AES key to use for decryption of the private key.  If null then no decryption is required.
     ; @param redeemScript The scriptPubKey that is being satisified, or the P2SH redeem script.
     ; @param hashType Signing mode, see the enum for documentation.
     ; @param anyoneCanPay Signing mode, see the SigHash enum for documentation.
     ; @return A newly calculated signature object that wraps the r, s and sighash components.
     ;;
    #_public
    (§ method TransactionSignature calculateSignature(int inputIndex, ECKey key, #_nilable KeyParameter aesKey, Script redeemScript, SigHash hashType, boolean anyoneCanPay))
    (ß
        (§ var Sha256Hash hash = hashForSignature(inputIndex, redeemScript.getProgram(), hashType, anyoneCanPay))
        (§ return new TransactionSignature(key.sign(hash, aesKey), hashType, anyoneCanPay))
    )

    ;;;
     ; <p>Calculates a signature hash, that is, a hash of a simplified form of the transaction.  How exactly the transaction
     ; is simplified is specified by the type and anyoneCanPay parameters.</p>
     ;
     ; <p>This is a low level API and when using the regular {@link Wallet} class you don't have to call this yourself.
     ; When working with more complex transaction types and contracts, it can be necessary.  When signing a P2SH output
     ; the redeemScript should be the script encoded into the scriptSig field, for normal transactions, it's the
     ; scriptPubKey of the output you're signing for.</p>
     ;
     ; @param inputIndex Input the signature is being calculated for.  Tx signatures are always relative to an input.
     ; @param redeemScript The bytes that should be in the given input during signing.
     ; @param type Should be SigHash.ALL.
     ; @param anyoneCanPay Should be false.
     ;;
    #_public
    (§ method Sha256Hash hashForSignature(int inputIndex, byte[] redeemScript, SigHash type, boolean anyoneCanPay))
    (ß
        (§ var byte sigHashType = (byte)TransactionSignature.calcSigHashValue(type, anyoneCanPay))
        (§ return hashForSignature(inputIndex, redeemScript, sigHashType))
    )

    ;;;
     ; <p>Calculates a signature hash, that is, a hash of a simplified form of the transaction.  How exactly the transaction
     ; is simplified is specified by the type and anyoneCanPay parameters.</p>
     ;
     ; <p>This is a low level API and when using the regular {@link Wallet} class you don't have to call this yourself.
     ; When working with more complex transaction types and contracts, it can be necessary.  When signing a P2SH output
     ; the redeemScript should be the script encoded into the scriptSig field, for normal transactions, it's the
     ; scriptPubKey of the output you're signing for.</p>
     ;
     ; @param inputIndex Input the signature is being calculated for.  Tx signatures are always relative to an input.
     ; @param redeemScript The script that should be in the given input during signing.
     ; @param type Should be SigHash.ALL.
     ; @param anyoneCanPay Should be false.
     ;;
    #_public
    (§ method Sha256Hash hashForSignature(int inputIndex, Script redeemScript, SigHash type, boolean anyoneCanPay))
    (ß
        (§ var int sigHash = TransactionSignature.calcSigHashValue(type, anyoneCanPay))
        (§ return hashForSignature(inputIndex, redeemScript.getProgram(), (byte)sigHash))
    )

    ;;;
     ; This is required for signatures which use a sigHashType which cannot be represented using SigHash and anyoneCanPay.
     ; See transaction c99c49da4c38af669dea436d3e73780dfdb6c1ecf9958baa52960e8baee30e73, which has sigHashType 0.
     ;;
    #_public
    (§ method Sha256Hash hashForSignature(int inputIndex, byte[] connectedScript, byte sigHashType))
    (ß
        ;; The SIGHASH flags are used in the design of contracts, please see this page for a further understanding of
        ;; the purposes of the code in this method:
        ;;
        ;;   https://en.bitcoin.it/wiki/Contracts

        (§ try)
        (ß
            ;; Create a copy of this transaction to operate upon because we need make changes to the inputs and outputs.
            ;; It would not be thread-safe to change the attributes of the transaction object itself.
            (§ var Transaction tx = this.params.getDefaultSerializer().makeTransaction(this.bitcoinSerialize()))

            ;; Clear input scripts in preparation for signing.  If we're signing a fresh transaction that step isn't very
            ;; helpful, but it doesn't add much cost relative to the actual EC math so we'll do it anyway.
            (§ for (int i = 0 :for i < tx.inputs.size() :for i = i + 1))
                (§ call tx.inputs.get(i).clearScriptBytes())

            ;; This step has no purpose beyond being synchronized with Bitcoin Core's bugs.  OP_CODESEPARATOR
            ;; is a legacy holdover from a previous, broken design of executing scripts that shipped in Bitcoin 0.1.
            ;; It was seriously flawed and would have let anyone take anyone elses money.  Later versions switched to
            ;; the design we use today where scripts are executed independently but share a stack.  This left the
            ;; OP_CODESEPARATOR instruction having no purpose as it was only meant to be used internally, not actually
            ;; ever put into scripts.  Deleting OP_CODESEPARATOR is a step that should never be required but if we don't
            ;; do it, we could split off the main chain.
            (§ ass connectedScript = Script.removeAllInstancesOfOp(connectedScript, ScriptOpCodes.OP_CODESEPARATOR))

            ;; Set the input to the script of its output.  Bitcoin Core does this but the step has no obvious purpose as
            ;; the signature covers the hash of the prevout transaction which obviously includes the output script
            ;; already.  Perhaps it felt safer to him in some way, or is another leftover from how the code was written.
            (§ var TransactionInput input = tx.inputs.get(inputIndex))
            (§ call input.setScriptBytes(connectedScript))

            (§ if ((sigHashType & 0x1f) == SigHash.NONE.value))
            (ß
                ;; SIGHASH_NONE means no outputs are signed at all - the signature is effectively for a "blank cheque".
                (§ ass tx.outputs = new ArrayList<>(0))
                ;; The signature isn't broken by new versions of the transaction issued by other parties.
                (§ for (int i = 0 :for i < tx.inputs.size() :for i = i + 1))
                    (§ if (i != inputIndex))
                        (§ call tx.inputs.get(i).setSequenceNumber(0))
            )
            (§ elseif ((sigHashType & 0x1f) == SigHash.SINGLE.value))
            (ß
                ;; SIGHASH_SINGLE means only sign the output at the same index as the input (i.e. my output).
                (§ if (tx.outputs.size() <= inputIndex))
                (ß
                    ;; The input index is beyond the number of outputs, it's a buggy signature made by a broken
                    ;; Bitcoin implementation.  Bitcoin Core also contains a bug in handling this case:
                    ;; any transaction output that is signed in this case will result in both the signed output
                    ;; and any future outputs to this public key being steal-able by anyone who has
                    ;; the resulting signature and the public key (both of which are part of the signed tx input).

                    ;; Bitcoin Core's bug is that SignatureHash was supposed to return a hash and on this codepath it
                    ;; actually returns the constant "1" to indicate an error, which is never checked for.  Oops.
                    (§ return Sha256Hash.wrap("0100000000000000000000000000000000000000000000000000000000000000"))
                )
                ;; In SIGHASH_SINGLE the outputs after the matching input index are deleted, and the outputs before
                ;; that position are "nulled out".  Unintuitively, the value in a "null" transaction is set to -1.
                (§ ass tx.outputs = new ArrayList<>(tx.outputs.subList(0, inputIndex + 1)))
                (§ for (int i = 0 :for i < inputIndex :for i = i + 1))
                    (§ call tx.outputs.set(i, new TransactionOutput(tx.params, tx, Coin.NEGATIVE_SATOSHI, new byte[] (ß ))))
                ;; The signature isn't broken by new versions of the transaction issued by other parties.
                (§ for (int i = 0 :for i < tx.inputs.size() :for i = i + 1))
                    (§ if (i != inputIndex))
                        (§ call tx.inputs.get(i).setSequenceNumber(0))
            )

            (§ if ((sigHashType & SigHash.ANYONECANPAY.value) == SigHash.ANYONECANPAY.value))
            (ß
                ;; SIGHASH_ANYONECANPAY means the signature in the input is not broken by changes/additions/removals
                ;; of other inputs.  For example, this is useful for building assurance contracts.
                (§ ass tx.inputs = new ArrayList<TransactionInput>())
                (§ call tx.inputs.add(input))
            )

            (§ var ByteArrayOutputStream bos = new UnsafeByteArrayOutputStream((tx.length == UNKNOWN_LENGTH) ? 256 :else tx.length + 4))
            (§ call tx.bitcoinSerialize(bos))
            ;; We also have to write a hash type (sigHashType is actually an unsigned char).
            (§ call uint32ToByteStreamLE(0x000000ff & sigHashType, bos))
            ;; Note that this is NOT reversed to ensure it will be signed correctly.  If it were to be printed out
            ;; however then we would expect that it is IS reversed.
            (§ var Sha256Hash hash = Sha256Hash.twiceOf(bos.toByteArray()))
            (§ call bos.close())

            (§ return hash)
        )
        (§ catch (IOException e))
        (ß
            (§ throw new RuntimeException(e)) ;; Cannot happen.
        )
    )

    #_override
    #_protected
    (§ method void bitcoinSerializeToStream(OutputStream stream))
        (§ throws IOException)
    (ß
        (§ call uint32ToByteStreamLE(version, stream))
        (§ call stream.write(new VarInt(inputs.size()).encode()))
        (§ for (TransactionInput in :for inputs))
            (§ call in.bitcoinSerialize(stream))
        (§ call stream.write(new VarInt(outputs.size()).encode()))
        (§ for (TransactionOutput out :for outputs))
            (§ call out.bitcoinSerialize(stream))
        (§ call uint32ToByteStreamLE(lockTime, stream))
    )

    ;;;
     ; Transactions can have an associated lock time, specified either as a block height or in seconds since the
     ; UNIX epoch.  A transaction is not allowed to be confirmed by miners until the lock time is reached, and
     ; since Bitcoin 0.8+ a transaction that did not end its lock period (non final) is considered to be non
     ; standard and won't be relayed or included in the memory pool either.
     ;;
    #_public
    (§ method long getLockTime())
    (ß
        (§ return lockTime)
    )

    ;;;
     ; Transactions can have an associated lock time, specified either as a block height or in seconds since the
     ; UNIX epoch.  A transaction is not allowed to be confirmed by miners until the lock time is reached, and
     ; since Bitcoin 0.8+ a transaction that did not end its lock period (non final) is considered to be non
     ; standard and won't be relayed or included in the memory pool either.
     ;;
    #_public
    (§ method void setLockTime(long lockTime))
    (ß
        (§ call unCache())
        (§ var boolean seqNumSet = false)
        (§ for (TransactionInput input :for inputs))
        (ß
            (§ if (input.getSequenceNumber() != TransactionInput.NO_SEQUENCE))
            (ß
                (§ ass seqNumSet = true)
                (§ break)
            )
        )
        (§ if (lockTime != 0 && (!seqNumSet || inputs.isEmpty())))
        (ß
            ;; At least one input must have a non-default sequence number for lock times to have any effect.
            ;; For instance one of them can be set to zero to make this feature work.
            (§ call log.warn("You are setting the lock time on a transaction but none of the inputs have non-default sequence numbers. This will not do what you expect!"))
        )
        (§ ass this.lockTime = lockTime)
    )

    #_public
    (§ method long getVersion())
    (ß
        (§ return version)
    )

    #_public
    (§ method void setVersion(int version))
    (ß
        (§ ass this.version = version)
        (§ call unCache())
    )

    ;;; Returns an unmodifiable view of all inputs. ;;
    #_public
    (§ method List<TransactionInput> getInputs())
    (ß
        (§ return Collections.unmodifiableList(inputs))
    )

    ;;; Returns an unmodifiable view of all outputs. ;;
    #_public
    (§ method List<TransactionOutput> getOutputs())
    (ß
        (§ return Collections.unmodifiableList(outputs))
    )

    ;;;
     ; <p>Returns the list of transacion outputs, whether spent or unspent, that match a wallet by address or that are
     ; watched by a wallet, i.e. transaction outputs whose script's address is controlled by the wallet and transaction
     ; outputs whose script is watched by the wallet.</p>
     ;
     ; @param transactionBag The wallet that controls addresses and watches scripts.
     ; @return linked list of outputs relevant to the wallet in this transaction.
     ;;
    #_public
    (§ method List<TransactionOutput> getWalletOutputs(TransactionBag transactionBag))
    (ß
        (§ var List<TransactionOutput> walletOutputs = new LinkedList<>())

        (§ for (TransactionOutput o :for outputs))
            (§ if (o.isMine(transactionBag)))
                (§ call walletOutputs.add(o))

        (§ return walletOutputs)
    )

    ;;; Randomly re-orders the transaction outputs: good for privacy. ;;
    #_public
    (§ method void shuffleOutputs())
    (ß
        (§ call Collections.shuffle(outputs))
    )

    ;;; Same as getInputs().get(index). ;;
    #_public
    (§ method TransactionInput getInput(long index))
    (ß
        (§ return inputs.get((int)index))
    )

    ;;; Same as getOutputs().get(index). ;;
    #_public
    (§ method TransactionOutput getOutput(long index))
    (ß
        (§ return outputs.get((int)index))
    )

    ;;;
     ; Returns the confidence object for this transaction from the {@link org.bitcoinj.core.TxConfidenceTable}
     ; referenced by the implicit {@link Context}.
     ;;
    #_public
    (§ method TransactionConfidence getConfidence())
    (ß
        (§ return getConfidence(Context.get()))
    )

    ;;;
     ; Returns the confidence object for this transaction from the {@link org.bitcoinj.core.TxConfidenceTable}
     ; referenced by the given {@link Context}.
     ;;
    #_public
    (§ method TransactionConfidence getConfidence(Context context))
    (ß
        (§ return getConfidence(context.getConfidenceTable()))
    )

    ;;;
     ; Returns the confidence object for this transaction from the {@link org.bitcoinj.core.TxConfidenceTable}.
     ;;
    #_public
    (§ method TransactionConfidence getConfidence(TxConfidenceTable table))
    (ß
        (§ if (confidence == nil))
            (§ ass confidence = table.getOrCreate(getHash()))
        (§ return confidence)
    )

    ;;; Check if the transaction has a known confidence. ;;
    #_public
    (§ method boolean hasConfidence())
    (ß
        (§ return (getConfidence().getConfidenceType() != TransactionConfidence.ConfidenceType.UNKNOWN))
    )

    #_override
    #_public
    (§ method boolean equals(Object o))
    (ß
        (§ if (this == o))
            (§ return true)
        (§ if (o == nil || getClass() != o.getClass()))
            (§ return false)
        (§ return getHash().equals(((Transaction)o).getHash()))
    )

    #_override
    #_public
    (§ method int hashCode())
    (ß
        (§ return getHash().hashCode())
    )

    ;;;
     ; Gets the count of regular SigOps in this transactions.
     ;;
    #_public
    (§ method int getSigOpCount())
        (§ throws ScriptException)
    (ß
        (§ var int sigOps = 0)
        (§ for (TransactionInput input :for inputs))
            (§ ass sigOps = sigOps + Script.getSigOpCount(input.getScriptBytes()))
        (§ for (TransactionOutput output :for outputs))
            (§ ass sigOps = sigOps + Script.getSigOpCount(output.getScriptBytes()))
        (§ return sigOps)
    )

    ;;;
     ; Check block height is in coinbase input script, for use after BIP 34
     ; enforcement is enabled.
     ;;
    #_public
    (§ method void checkCoinBaseHeight(#_final int height))
        (§ throws VerificationException)
    (ß
        (§ call Preconditions.checkArgument(Block.BLOCK_HEIGHT_GENESIS <= height))
        (§ call Preconditions.checkState(isCoinBase()))

        ;; Check block height is in coinbase input script.
        #_final
        (§ var TransactionInput in = this.getInputs().get(0))
        #_final
        (§ var ScriptBuilder builder = new ScriptBuilder())
        (§ call builder.number(height))
        #_final
        (§ var byte[] expected = builder.build().getProgram())
        #_final
        (§ var byte[] actual = in.getScriptBytes())
        (§ if (actual.length < expected.length))
            (§ throw new VerificationException.CoinbaseHeightMismatch("Block height mismatch in coinbase."))

        (§ for (int scriptIdx = 0 :for scriptIdx < expected.length :for scriptIdx = scriptIdx + 1))
            (§ if (actual[scriptIdx] != expected[scriptIdx]))
                (§ throw new VerificationException.CoinbaseHeightMismatch("Block height mismatch in coinbase."))
    )

    ;;;
     ; <p>Checks the transaction contents for sanity, in ways that can be done in a standalone manner.
     ; Does <b>not</b> perform all checks on a transaction such as whether the inputs are already spent.
     ; Specifically this method verifies:</p>
     ;
     ; <ul>
     ;     <li>That there is at least one input and output.</li>
     ;     <li>That the serialized size is not larger than the max block size.</li>
     ;     <li>That no outputs have negative value.</li>
     ;     <li>That the outputs do not sum to larger than the max allowed quantity of coin in the system.</li>
     ;     <li>If the tx is a coinbase tx, the coinbase scriptSig size is within range.  Otherwise that
     ;     there are no coinbase inputs in the tx.</li>
     ; </ul>
     ;
     ; @throws VerificationException
     ;;
    #_public
    (§ method void verify())
        (§ throws VerificationException)
    (ß
        (§ if (inputs.size() == 0 || outputs.size() == 0))
            (§ throw new VerificationException.EmptyInputsOrOutputs())
        (§ if (Block.MAX_BLOCK_SIZE < this.getMessageSize()))
            (§ throw new VerificationException.LargerThanMaxBlockSize())

        (§ var Coin valueOut = Coin.ZERO)
        (§ var HashSet<TransactionOutPoint> outpoints = new HashSet<>())
        (§ for (TransactionInput input :for inputs))
        (ß
            (§ if (outpoints.contains(input.getOutpoint())))
                (§ throw new VerificationException.DuplicatedOutPoint())
            (§ call outpoints.add(input.getOutpoint()))
        )
        (§ try)
        (ß
            (§ for (TransactionOutput output :for outputs))
            (ß
                (§ if (output.getValue().signum() < 0)) ;; getValue() can throw IllegalStateException
                    (§ throw new VerificationException.NegativeValueOutput())

                (§ ass valueOut = valueOut.add(output.getValue()))
                (§ if (params.hasMaxMoney() && 0 < valueOut.compareTo(params.getMaxMoney())))
                    (§ throw new IllegalArgumentException())
            )
        )
        (§ catch (IllegalStateException _))
        (ß
            (§ throw new VerificationException.ExcessiveValue())
        )
        (§ catch (IllegalArgumentException _))
        (ß
            (§ throw new VerificationException.ExcessiveValue())
        )

        (§ if (isCoinBase()))
        (ß
            (§ var int n = inputs.get(0).getScriptBytes().length)
            (§ if (n < 2 || 100 < n))
                (§ throw new VerificationException.CoinbaseScriptSizeOutOfRange())
        )
        (§ else)
        (ß
            (§ for (TransactionInput input :for inputs))
                (§ if (input.isCoinBase()))
                    (§ throw new VerificationException.UnexpectedCoinbaseInput())
        )
    )

    ;;;
     ; <p>A transaction is time locked if at least one of its inputs is non-final and it has a lock time.</p>
     ;
     ; <p>To check if this transaction is final at a given height and time, see {@link Transaction#isFinal(int, long)}.</p>
     ;;
    #_public
    (§ method boolean isTimeLocked())
    (ß
        (§ if (getLockTime() == 0))
            (§ return false)
        (§ for (TransactionInput input :for getInputs()))
            (§ if (input.hasSequence()))
                (§ return true)
        (§ return false)
    )

    ;;;
     ; Returns whether this transaction will opt into the
     ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki">full replace-by-fee</a> semantics.
     ;;
    #_public
    (§ method boolean isOptInFullRBF())
    (ß
        (§ for (TransactionInput input :for getInputs()))
            (§ if (input.isOptInFullRBF()))
                (§ return true)
        (§ return false)
    )

    ;;;
     ; <p>Returns true if this transaction is considered finalized and can be placed in a block.  Non-finalized
     ; transactions won't be included by miners and can be replaced with newer versions using sequence numbers.
     ; This is useful in certain types of <a href="http://en.bitcoin.it/wiki/Contracts">contracts</a>, such as
     ; micropayment channels.</p>
     ;
     ; <p>Note that currently the replacement feature is disabled in Bitcoin Core and will need to be
     ; re-activated before this functionality is useful.</p>
     ;;
    #_public
    (§ method boolean isFinal(int height, long blockTimeSeconds))
    (ß
        (§ var long time = getLockTime())
        (§ return (time < (time < LOCKTIME_THRESHOLD ? height :else blockTimeSeconds) || !isTimeLocked()))
    )

    ;;;
     ; Returns either the lock time as a date, if it was specified in seconds, or an estimate based on the time in
     ; the current head block if it was specified as a block time.
     ;;
    #_public
    (§ method Date estimateLockTime(AbstractBlockChain chain))
    (ß
        (§ return (lockTime < LOCKTIME_THRESHOLD) ? chain.estimateBlockTime((int)getLockTime()) :else new Date(getLockTime() * 1000))
    )

    ;;;
     ; Returns the purpose for which this transaction was created.  See the javadoc for {@link Purpose} for more
     ; information on the point of this field and what it can be.
     ;;
    #_public
    (§ method Purpose getPurpose())
    (ß
        (§ return purpose)
    )

    ;;;
     ; Marks the transaction as being created for the given purpose.  See the javadoc for {@link Purpose} for more
     ; information on the point of this field and what it can be.
     ;;
    #_public
    (§ method void setPurpose(Purpose purpose))
    (ß
        (§ ass this.purpose = purpose)
    )

    ;;;
     ; Getter for {@link #exchangeRate}.
     ;;
    #_nilable
    #_public
    (§ method ExchangeRate getExchangeRate())
    (ß
        (§ return exchangeRate)
    )

    ;;;
     ; Setter for {@link #exchangeRate}.
     ;;
    #_public
    (§ method void setExchangeRate(ExchangeRate exchangeRate))
    (ß
        (§ ass this.exchangeRate = exchangeRate)
    )

    ;;;
     ; Returns the transaction {@link #memo}.
     ;;
    #_public
    (§ method String getMemo())
    (ß
        (§ return memo)
    )

    ;;;
     ; Set the transaction {@link #memo}.  It can be used to record the memo of the payment request that initiated the
     ; transaction.
     ;;
    #_public
    (§ method void setMemo(String memo))
    (ß
        (§ ass this.memo = memo)
    )
)

#_(ns org.bitcoinj.core #_"TransactionBag"
    (:import [java.util Map])
  #_(:require [org.bitcoinj.script Script]
             [org.bitcoinj.wallet WalletTransaction]))

;;;
 ; This interface is used to abstract the {@link org.bitcoinj.wallet.Wallet} and the {@link org.bitcoinj.core.Transaction}.
 ;;
#_public
(§ interface TransactionBag
    ;;; Returns true if this wallet contains a public key which hashes to the given hash. ;;
    (§ method boolean isPubKeyHashMine(byte[] pubkeyHash))

    ;;; Returns true if this wallet contains a keypair with the given public key. ;;
    (§ method boolean isPubKeyMine(byte[] pubkey))

    ;;; Returns true if this wallet knows the script corresponding to the given hash. ;;
    (§ method boolean isPayToScriptHashMine(byte[] payToScriptHash))

    ;;; Returns transactions from a specific pool. ;;
    (§ method Map<Sha256Hash, Transaction> getTransactionPool(WalletTransaction.Pool pool))
)

#_(ns org.bitcoinj.core #_"TransactionBroadcast"
    (:import #_[java.util *]
             #_[java.util.concurrent *])
    (:import #_[com.google.common.annotations *]
             #_[com.google.common.base *]
             #_[com.google.common.util.concurrent *]
             #_[org.slf4j *])
  #_(:require [org.bitcoinj.core.listeners PreMessageReceivedEventListener]
             #_[org.bitcoinj.utils *]
             [org.bitcoinj.wallet Wallet]))

;;;
 ; Represents a single transaction broadcast that we are performing.  A broadcast occurs after a new transaction is created
 ; (typically by a {@link Wallet}) and needs to be sent to the network.  A broadcast can succeed or fail.  A success is
 ; defined as seeing the transaction be announced by peers via inv messages, thus indicating their acceptance.  A failure
 ; is defined as not reaching acceptance within a timeout period, or getting an explicit reject message from a peer
 ; indicating that the transaction was not acceptable.
 ;;
#_public
(§ class TransactionBroadcast
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(TransactionBroadcast.class))

    #_private
    #_final
    (§ field SettableFuture<Transaction> future = SettableFuture.create())
    #_private
    #_final
    (§ field PeerGroup peerGroup)
    #_private
    #_final
    (§ field Transaction tx)
    #_private
    (§ field int minConnections)
    #_private
    (§ field int numWaitingFor)

    ;;; Used for shuffling the peers before broadcast: unit tests can replace this to make themselves deterministic. ;;
    #_testing
    #_public
    #_static
    (§ field Random random = new Random())

    ;; Tracks which nodes sent us a reject message about this broadcast, if any.  Useful for debugging.
    #_private
    (§ field Map<Peer, RejectMessage> rejects = Collections.synchronizedMap(new HashMap<Peer, RejectMessage>()))

    (§ constructor TransactionBroadcast(PeerGroup peerGroup, Transaction tx))
    (ß
        (§ ass this.peerGroup = peerGroup)
        (§ ass this.tx = tx)
        (§ ass this.minConnections = Math.max(1, peerGroup.getMinBroadcastConnections()))
    )

    ;; Only for mock broadcasts.
    #_private
    (§ constructor TransactionBroadcast(Transaction tx))
    (ß
        (§ ass this.peerGroup = nil)
        (§ ass this.tx = tx)
    )

    #_testing
    #_public
    #_static
    (§ method TransactionBroadcast createMockBroadcast(Transaction tx, #_final SettableFuture<Transaction> future))
    (ß
        (§ return new TransactionBroadcast(tx)
        (ß
            #_override
            #_public
            (§ method ListenableFuture<Transaction> broadcast())
            (ß
                (§ return future)
            )

            #_override
            #_public
            (§ method ListenableFuture<Transaction> future())
            (ß
                (§ return future)
            )
        ))
    )

    #_public
    (§ method ListenableFuture<Transaction> future())
    (ß
        (§ return future)
    )

    #_public
    (§ method void setMinConnections(int minConnections))
    (ß
        (§ ass this.minConnections = minConnections)
    )

    #_private
    (§ field PreMessageReceivedEventListener rejectionListener = new PreMessageReceivedEventListener()
        (ß
            #_override
            #_public
            (§ method Message onPreMessageReceived(Peer peer, Message m))
            (ß
                (§ if (m instanceof RejectMessage))
                (ß
                    (§ var RejectMessage rejectMessage = (RejectMessage)m)
                    (§ if (tx.getHash().equals(rejectMessage.getRejectedObjectHash())))
                    (ß
                        (§ call rejects.put(peer, rejectMessage))
                        (§ var int size = rejects.size())
                        (§ var long threshold = Math.round(numWaitingFor / 2.0))
                        (§ if (threshold < size))
                        (ß
                            (§ call log.warn("Threshold for considering broadcast rejected has been reached ({}/{})", size, threshold))
                            (§ call future.setException(new RejectedTransactionException(tx, rejectMessage)))
                            (§ call peerGroup.removePreMessageReceivedEventListener(this))
                        )
                    )
                )
                (§ return m)
            )
        ))

    #_public
    (§ method ListenableFuture<Transaction> broadcast())
    (ß
        (§ call peerGroup.addPreMessageReceivedEventListener(Threading.SAME_THREAD, rejectionListener))
        (§ call log.info("Waiting for {} peers required for broadcast, we have {} ...", minConnections, peerGroup.getConnectedPeers().size()))
        (§ call peerGroup.waitForPeers(minConnections).addListener(new EnoughAvailablePeers(), Threading.SAME_THREAD))
        (§ return future)
    )

    #_private
    (§ class EnoughAvailablePeers implements Runnable
        #_override
        #_public
        (§ method void run())
        (ß
            ;; We now have enough connected peers to send the transaction.
            ;; This can be called immediately if we already have enough.  Otherwise it'll be called from a peer thread.

            ;; We will send the tx simultaneously to half the connected peers and wait to hear back from at least half
            ;; of the other half, i.e. with 4 peers connected we will send the tx to 2 randomly chosen peers, and then
            ;; wait for it to show up on one of the other two.  This will be taken as sign of network acceptance.  As can
            ;; be seen, 4 peers is probably too little - it doesn't taken many broken peers for tx propagation to have
            ;; a big effect.
            (§ var List<Peer> peers = peerGroup.getConnectedPeers()) ;; snapshots
            ;; Prepare to send the transaction by adding a listener that'll be called when confidence changes.
            ;; Only bother with this if we might actually hear back:
            (§ if (1 < minConnections))
                (§ call tx.getConfidence().addEventListener(new ConfidenceChange()))
            ;; Bitcoin Core sends an inv in this case and then lets the peer request the tx data.  We just
            ;; blast out the TX here for a couple of reasons.  Firstly it's simpler: in the case where we have
            ;; just a single connection we don't have to wait for getdata to be received and handled before
            ;; completing the future in the code immediately below.  Secondly, it's faster.  The reason the
            ;; Bitcoin Core sends an inv is privacy - it means you can't tell if the peer originated the
            ;; transaction or not.  However, we are not a fully validating node and this is advertised in
            ;; our version message, as SPV nodes cannot relay it doesn't give away any additional information
            ;; to skip the inv here - we wouldn't send invs anyway.
            (§ var int numConnected = peers.size())
            (§ var int numToBroadcastTo = (int)Math.max(1, Math.round(Math.ceil(peers.size() / 2.0))))
            (§ ass numWaitingFor = (int)Math.ceil((peers.size() - numToBroadcastTo) / 2.0))
            (§ call Collections.shuffle(peers, random))
            (§ ass peers = peers.subList(0, numToBroadcastTo))
            (§ call log.info("broadcastTransaction: We have {} peers, adding {} to the memory pool", numConnected, tx.getHashAsString()))
            (§ call log.info("Sending to {} peers, will wait for {}, sending to: {}", numToBroadcastTo, numWaitingFor, Joiner.on(",").join(peers)))
            (§ for (Peer peer :for peers))
            (ß
                (§ try)
                (ß
                    (§ call peer.sendMessage(tx))
                    ;; We don't record the peer as having seen the tx in the memory pool because we want to track only
                    ;; how many peers announced to us.
                )
                (§ catch (Exception e))
                (ß
                    (§ call log.error("Caught exception sending to {}", peer, e))
                )
            )
            ;; If we've been limited to talk to only one peer, we can't wait to hear back because the
            ;; remote peer won't tell us about transactions we just announced to it for obvious reasons.
            ;; So we just have to assume we're done, at that point.  This happens when we're not given
            ;; any peer discovery source and the user just calls connectTo() once.
            (§ if (minConnections == 1))
            (ß
                (§ call peerGroup.removePreMessageReceivedEventListener(rejectionListener))
                (§ call future.set(tx))
            )
        )
    )

    #_private
    (§ field int numSeemPeers)
    #_private
    (§ field boolean mined)

    #_private
    (§ class ConfidenceChange implements TransactionConfidence.Listener
        #_override
        #_public
        (§ method void onConfidenceChanged(TransactionConfidence conf, ChangeReason reason))
        (ß
            ;; The number of peers that announced this tx has gone up.
            (§ var int numSeenPeers = conf.numBroadcastPeers() + rejects.size())
            (§ var boolean mined = (tx.getAppearsInHashes() != nil))
            (§ call log.info("broadcastTransaction: {}:  TX {} seen by {} peers{}", reason, tx.getHashAsString(), numSeenPeers, mined ? " and mined" :else ""))

            ;; Progress callback on the requested thread.
            (§ call invokeAndRecord(numSeenPeers, mined))

            (§ if (numWaitingFor <= numSeenPeers || mined))
            (ß
                ;; We've seen the min required number of peers announce the transaction, or it was included
                ;; in a block.  Normally we'd expect to see it fully propagate before it gets mined, but
                ;; it can be that a block is solved very soon after broadcast, and it's also possible that
                ;; due to version skew and changes in the relay rules our transaction is not going to
                ;; fully propagate yet can get mined anyway.
                ;;
                ;; Note that we can't wait for the current number of connected peers right now because we
                ;; could have added more peers after the broadcast took place, which means they won't
                ;; have seen the transaction.  In future when peers sync up their memory pools after they
                ;; connect we could come back and change this.
                ;;
                ;; We're done!  It's important that the PeerGroup lock is not held (by this thread) at this
                ;; point to avoid triggering inversions when the Future completes.
                (§ call log.info("broadcastTransaction: {} complete", tx.getHash()))
                (§ call peerGroup.removePreMessageReceivedEventListener(rejectionListener))
                (§ call conf.removeEventListener(this))
                (§ call future.set(tx)) ;; RE-ENTRANCY POINT
            )
        )
    )

    #_private
    (§ method void invokeAndRecord(int numSeenPeers, boolean mined))
    (ß
        (§ sync this)
        (ß
            (§ ass this.numSeemPeers = numSeenPeers)
            (§ ass this.mined = mined)
        )
        (§ call invokeProgressCallback(numSeenPeers, mined))
    )

    #_private
    (§ method void invokeProgressCallback(int numSeenPeers, boolean mined))
    (ß
        #_final
        (§ var ProgressCallback callback)
        (§ var Executor executor)
        (§ sync this)
        (ß
            (§ ass callback = this.callback)
            (§ ass executor = this.progressCallbackExecutor)
        )
        (§ if (callback != nil))
        (ß
            #_final
            (§ var double progress = Math.min(1.0, mined ? 1.0 :else numSeenPeers / (double)numWaitingFor))
            (§ call Preconditions.checkState(0.0 <= progress && progress <= 1.0, progress))
            (§ try)
            (ß
                (§ if (executor == nil))
                    (§ call callback.onBroadcastProgress(progress))
                (§ else)
                    (§ call executor.execute(new Runnable()
                    (ß
                        #_override
                        #_public
                        (§ method void run())
                        (ß
                            (§ call callback.onBroadcastProgress(progress))
                        )
                    )))
            )
            (§ catch (Throwable e))
            (ß
                (§ call log.error("Exception during progress callback", e))
            )
        )
    )

    ;;; An interface for receiving progress information on the propagation of the tx, from 0.0 to 1.0 ;;
    #_public
    (§ interface ProgressCallback
        ;;;
         ; onBroadcastProgress will be invoked on the provided executor when the progress of the transaction
         ; broadcast has changed, because the transaction has been announced by another peer or because the transaction
         ; was found inside a mined block (in this case progress will go to 1.0 immediately).  Any exceptions thrown
         ; by this callback will be logged and ignored.
         ;;
        (§ method void onBroadcastProgress(double progress))
    )

    #_nilable
    #_private
    (§ field ProgressCallback callback)
    #_nilable
    #_private
    (§ field Executor progressCallbackExecutor)

    ;;;
     ; Sets the given callback for receiving progress values, which will run on the user thread.
     ; See {@link org.bitcoinj.utils.Threading} for details.  If the broadcast has already started then the callback will
     ; be invoked immediately with the current progress.
     ;;
    #_public
    (§ method void setProgressCallback(ProgressCallback callback))
    (ß
        (§ call setProgressCallback(callback, Threading.USER_THREAD))
    )

    ;;;
     ; Sets the given callback for receiving progress values, which will run on the given executor.  If the executor
     ; is null, then the callback will run on a network thread and may be invoked multiple times in parallel.  You
     ; probably want to provide your UI thread or Threading.USER_THREAD for the second parameter.  If the broadcast
     ; has already started, then the callback will be invoked immediately with the current progress.
     ;;
    #_public
    (§ method void setProgressCallback(ProgressCallback callback, #_nilable Executor executor))
    (ß
        (§ var boolean shouldInvoke)
        (§ var int num)
        (§ var boolean mined)
        (§ sync this)
        (ß
            (§ ass this.callback = callback)
            (§ ass this.progressCallbackExecutor = executor)
            (§ ass num = this.numSeemPeers)
            (§ ass mined = this.mined)
            (§ ass shouldInvoke = (0 < numWaitingFor))
        )
        (§ if (shouldInvoke))
            (§ call invokeProgressCallback(num, mined))
    )
)

#_(ns org.bitcoinj.core #_"TransactionBroadcaster")

;;;
 ; A general interface which declares the ability to broadcast transactions.
 ; This is implemented by {@link org.bitcoinj.core.PeerGroup}.
 ;;
#_public
(§ interface TransactionBroadcaster
    ;;; Broadcast the given transaction on the network. ;;
    (§ method TransactionBroadcast broadcastTransaction(#_final Transaction tx))
)

#_(ns org.bitcoinj.core #_"TransactionConfidence"
    (:import #_[java.util *]
             #_[java.util.concurrent *])
    (:import [com.google.common.base Preconditions]
             #_[com.google.common.collect *]
             #_[com.google.common.util.concurrent *])
  #_(:require #_[org.bitcoinj.utils *]
             [org.bitcoinj.wallet Wallet]))

;; TODO: Modify the getDepthInBlocks method to require the chain height to be specified, in preparation for ceasing to touch every tx on every block.

;;;
 ; <p>A TransactionConfidence object tracks data you can use to make a confidence decision about a transaction.
 ; It also contains some pre-canned rules for common scenarios: if you aren't really sure what level of confidence
 ; you need, these should prove useful.  You can get a confidence object using {@link Transaction#getConfidence()}.
 ; They cannot be constructed directly.</p>
 ;
 ; <p>Confidence in a transaction can come in multiple ways:</p>
 ;
 ; <ul>
 ; <li>Because you created it yourself and only you have the necessary keys.</li>
 ; <li>Receiving it from a fully validating peer you know is trustworthy, for instance, because it's run by yourself.</li>
 ; <li>Receiving it from a peer on the network you randomly chose.  If your network connection is not being
 ;     intercepted, you have a pretty good chance of connecting to a node that is following the rules.</li>
 ; <li>Receiving it from multiple peers on the network.  If your network connection is not being intercepted,
 ;     hearing about a transaction from multiple peers indicates the network has accepted the transaction and
 ;     thus miners likely have too (miners have the final say in whether a transaction becomes valid or not).</li>
 ; <li>Seeing the transaction appear appear in a block on the main chain.  Your confidence increases as the transaction
 ;     becomes further buried under work.  Work can be measured either in blocks (roughly, units of time), or
 ;     amount of work done.</li>
 ; </ul>
 ;
 ; <p>Alternatively, you may know that the transaction is "dead", that is, one or more of its inputs have
 ; been double spent and will never confirm unless there is another re-org.</p>
 ;
 ; <p>TransactionConfidence is updated via the {@link org.bitcoinj.core.TransactionConfidence#incrementDepthInBlocks()}
 ; method to ensure the block depth is up to date.</p>
 ; To make a copy that won't be changed, use {@link org.bitcoinj.core.TransactionConfidence#duplicate()}.
 ;;
#_public
(§ class TransactionConfidence
    ;;;
     ; The peers that have announced the transaction to us.  Network nodes don't have stable identities, so we use
     ; IP address as an approximation.  It's obviously vulnerable to being gamed if we allow arbitrary people to connect
     ; to us, so only peers we explicitly connected to should go here.
     ;;
    #_private
    (§ field CopyOnWriteArrayList<PeerAddress> broadcastBy)
    ;;; The time the transaction was last announced to us. ;;
    #_private
    (§ field Date lastBroadcastedAt)
    ;;; The Transaction that this confidence object is associated with. ;;
    #_private
    #_final
    (§ field Sha256Hash hash)
    ;; Lazily created listeners array.
    #_private
    (§ field CopyOnWriteArrayList<ListenerRegistration<Listener>> listeners)

    ;; The depth of the transaction on the best chain in blocks.  An unconfirmed block has depth 0.
    #_private
    (§ field int depth)

    ;;; Describes the state of the transaction in general terms.  Properties can be read to learn specifics. ;;
    #_public
    (§ enum ConfidenceType
        ;;; If BUILDING, then the transaction is included in the best chain and your confidence in it is increasing. ;;
        (§ item BUILDING(1))

        ;;;
         ; If PENDING, then the transaction is unconfirmed and should be included shortly, as long as it is being
         ; announced and is considered valid by the network.  A pending transaction will be announced if the containing
         ; wallet has been attached to a live {@link PeerGroup} using {@link PeerGroup#addWallet(Wallet)}.
         ; You can estimate how likely the transaction is to be included by connecting to a bunch of nodes then measuring
         ; how many announce it, using {@link org.bitcoinj.core.TransactionConfidence#numBroadcastPeers()}.
         ; Or if you saw it from a trusted peer, you can assume it's valid and will get mined sooner or later as well.
         ;;
        (§ item PENDING(2))

        ;;;
         ; If DEAD, then it means the transaction won't confirm unless there is another re-org,
         ; because some other transaction is spending one of its inputs.  Such transactions should be alerted to the user
         ; so they can take action, e.g. suspending shipment of goods if they are a merchant.
         ; It can also mean that a coinbase transaction has been made dead from it being moved onto a side chain.
         ;;
        (§ item DEAD(4))

        ;;;
         ; If IN_CONFLICT, then it means there is another transaction (or several other transactions) spending one
         ; (or several) of its inputs but nor this transaction nor the other/s transaction/s are included in the best chain.
         ; The other/s transaction/s should be IN_CONFLICT too.
         ; IN_CONFLICT can be thought as an intermediary state between a. PENDING and BUILDING or b. PENDING and DEAD.
         ; Another common name for this situation is "double spend".
         ;;
        (§ item IN_CONFLICT(5))

        ;;;
         ; If a transaction hasn't been broadcast yet, or there's no record of it, its confidence is UNKNOWN.
         ;;
        (§ item UNKNOWN(0))

        #_private
        (§ field int value)

        (§ constructor ConfidenceType(int value))
        (ß
            (§ ass this.value = value)
        )

        #_public
        (§ method int getValue())
        (ß
            (§ return value)
        )
    )

    #_private
    (§ field ConfidenceType confidenceType = ConfidenceType.UNKNOWN)
    #_private
    (§ field int appearedAtChainHeight = -1)
    ;; The transaction that double spent this one, if any.
    #_private
    (§ field Transaction overridingTransaction)

    ;;;
     ; Information about where the transaction was first seen (network, sent direct from peer, created by ourselves).
     ; Useful for risk analyzing pending transactions.  Probably not that useful after a tx is included in the chain,
     ; unless re-org double spends start happening frequently.
     ;;
    #_public
    (§ enum Source
        ;;; We don't know where the transaction came from. ;;
        (§ item UNKNOWN)
        ;;; We got this transaction from a network peer. ;;
        (§ item NETWORK)
        ;;; This transaction was created by our own wallet, so we know it's not a double spend. ;;
        (§ item SELF)
    )
    #_private
    (§ field Source source = Source.UNKNOWN)

    #_public
    (§ constructor TransactionConfidence(Sha256Hash hash))
    (ß
        ;; Assume a default number of peers for our set.
        (§ ass broadcastBy = new CopyOnWriteArrayList<>())
        (§ ass listeners = new CopyOnWriteArrayList<>())
        (§ ass this.hash = hash)
    )

    ;;;
     ; <p>A confidence listener is informed when the level of {@link TransactionConfidence} is updated by something, like
     ; for example a {@link Wallet}.  You can add listeners to update your user interface or manage your order tracking
     ; system when confidence levels pass a certain threshold.  <b>Note that confidence can go down as well as up.</b>
     ; For example, this can happen if somebody is doing a double-spend attack against you.  Whilst it's unlikely, your
     ; code should be able to handle that in order to be correct.</p>
     ;
     ; <p>During listener execution, it's safe to remove the current listener but not others.</p>
     ;;
    #_public
    (§ interface Listener
        ;;; An enum that describes why a transaction confidence listener is being invoked (i.e. the class of change). ;;
        (§ enum ChangeReason
            ;;;
             ; Occurs when the type returned by {@link org.bitcoinj.core.TransactionConfidence#getConfidenceType()}
             ; has changed.  For example, if a PENDING transaction changes to BUILDING or DEAD, then this reason will
             ; be given.  It's a high level summary.
             ;;
            (§ item TYPE)

            ;;;
             ; Occurs when a transaction that is in the best known block chain gets buried by another block.  If you're
             ; waiting for a certain number of confirmations, this is the reason to watch out for.
             ;;
            (§ item DEPTH)

            ;;;
             ; Occurs when a pending transaction (not in the chain) was announced by another connected peers.  By
             ; watching the number of peers that announced a transaction go up, you can see whether it's being
             ; accepted by the network or not.  If all your peers announce, it's a pretty good bet the transaction
             ; is considered relayable and has thus reached the miners.
             ;;
            (§ item SEEN_PEERS)
        )

        (§ method void onConfidenceChanged(TransactionConfidence confidence, ChangeReason reason))
    )

    ;; This is used to ensure that confidence objects which aren't referenced from anywhere but which have an event
    ;; listener set on them don't become eligible for garbage collection.  Otherwise the TxConfidenceTable, which only
    ;; has weak references to these objects, would not be enough to keep the event listeners working as transactions
    ;; propagate around the network - it cannot know directly if the API user is interested in the object, so it uses
    ;; heap reachability as a proxy for interest.
    ;;
    ;; We add ourselves to this set when a listener is added and remove ourselves when the listener list is empty.
    #_private
    #_static
    #_final
    (§ field Set<TransactionConfidence> pinnedConfidenceObjects = Collections.synchronizedSet(new HashSet<TransactionConfidence>()))

    ;;;
     ; <p>Adds an event listener that will be run when this confidence object is updated.  The listener will be locked
     ; and is likely to be invoked on a peer thread.</p>
     ;
     ; <p>Note that this is NOT called when every block arrives.  Instead it is called when the transaction
     ; transitions between confidence states, i.e. from not being seen in the chain to being seen (not necessarily in
     ; the best chain).  If you want to know when the transaction gets buried under another block, consider using
     ; a future from {@link #getDepthFuture(int)}.</p>
     ;;
    #_public
    (§ method void addEventListener(Executor executor, Listener listener))
    (ß
        (§ call Preconditions.checkNotNull(listener))

        (§ call listeners.addIfAbsent(new ListenerRegistration<>(listener, executor)))
        (§ call pinnedConfidenceObjects.add(this))
    )

    ;;;
     ; <p>Adds an event listener that will be run when this confidence object is updated.  The listener will be locked
     ; and is likely to be invoked on a peer thread.</p>
     ;
     ; <p>Note that this is NOT called when every block arrives.  Instead it is called when the transaction
     ; transitions between confidence states, i.e. from not being seen in the chain to being seen (not necessarily in
     ; the best chain).  If you want to know when the transaction gets buried under another block, implement a
     ; {@link BlockChainListener}, attach it to a {@link BlockChain} and then use the getters on the
     ; confidence object to determine the new depth.</p>
     ;;
    #_public
    (§ method void addEventListener(Listener listener))
    (ß
        (§ call addEventListener(Threading.USER_THREAD, listener))
    )

    #_public
    (§ method boolean removeEventListener(Listener listener))
    (ß
        (§ call Preconditions.checkNotNull(listener))

        (§ var boolean removed = ListenerRegistration.removeFromList(listener, listeners))
        (§ if (listeners.isEmpty()))
            (§ call pinnedConfidenceObjects.remove(this))
        (§ return removed)
    )

    ;;;
     ; Returns the chain height at which the transaction appeared if confidence type is BUILDING.
     ; @throws IllegalStateException if the confidence type is not BUILDING.
     ;;
    #_public
    #_synchronized
    (§ method int getAppearedAtChainHeight())
    (ß
        (§ if (getConfidenceType() != ConfidenceType.BUILDING))
            (§ throw new IllegalStateException("Confidence type is " + getConfidenceType() + ", not BUILDING"))
        (§ return appearedAtChainHeight)
    )

    ;;;
     ; The chain height at which the transaction appeared, if it has been seen in the best chain.
     ; Automatically sets the current type to {@link ConfidenceType#BUILDING} and depth to one.
     ;;
    #_public
    #_synchronized
    (§ method void setAppearedAtChainHeight(int appearedAtChainHeight))
    (ß
        (§ if (appearedAtChainHeight < 0))
            (§ throw new IllegalArgumentException("appearedAtChainHeight out of range"))

        (§ ass this.appearedAtChainHeight = appearedAtChainHeight)
        (§ ass this.depth = 1)
        (§ call setConfidenceType(ConfidenceType.BUILDING))
    )

    ;;;
     ; Returns a general statement of the level of confidence you can have in this transaction.
     ;;
    #_public
    #_synchronized
    (§ method ConfidenceType getConfidenceType())
    (ß
        (§ return confidenceType)
    )

    ;;;
     ; Called by other objects in the system, like a {@link Wallet}, when new information about the confidence
     ; of a transaction becomes available.
     ;;
    #_public
    #_synchronized
    (§ method void setConfidenceType(ConfidenceType confidenceType))
    (ß
        (§ if (confidenceType == this.confidenceType))
            (§ return)

        (§ ass this.confidenceType = confidenceType)
        (§ if (confidenceType != ConfidenceType.DEAD))
            (§ ass overridingTransaction = nil)
        (§ if (confidenceType == ConfidenceType.PENDING || confidenceType == ConfidenceType.IN_CONFLICT))
        (ß
            (§ ass depth = 0)
            (§ ass appearedAtChainHeight = -1)
        )
    )

    ;;;
     ; Called by a {@link Peer} when a transaction is pending and announced by a peer.  The more peers announce
     ; the transaction, the more peers have validated it (assuming your internet connection is not being intercepted).
     ; If confidence is currently unknown, sets it to {@link ConfidenceType#PENDING}.  Does not run listeners.
     ;
     ; @param address IP address of the peer, used as a proxy for identity.
     ; @return true if marked, false if this address was already seen.
     ;;
    #_public
    (§ method boolean markBroadcastBy(PeerAddress address))
    (ß
        (§ ass lastBroadcastedAt = Utils.now())
        (§ if (!broadcastBy.addIfAbsent(address)))
            (§ return false) ;; Duplicate.

        (§ sync this)
        (ß
            (§ if (getConfidenceType() == ConfidenceType.UNKNOWN))
                (§ ass this.confidenceType = ConfidenceType.PENDING)
        )
        (§ return true)
    )

    ;;;
     ; Returns how many peers have been passed to {@link TransactionConfidence#markBroadcastBy}.
     ;;
    #_public
    (§ method int numBroadcastPeers())
    (ß
        (§ return broadcastBy.size())
    )

    ;;;
     ; Returns a snapshot of {@link PeerAddress}es that announced the transaction.
     ;;
    #_public
    (§ method Set<PeerAddress> getBroadcastBy())
    (ß
        (§ var ListIterator<PeerAddress> iterator = broadcastBy.listIterator())
        (§ return Sets.newHashSet(iterator))
    )

    ;;; Returns true if the given address has been seen via markBroadcastBy(). ;;
    #_public
    (§ method boolean wasBroadcastBy(PeerAddress address))
    (ß
        (§ return broadcastBy.contains(address))
    )

    ;;; Return the time the transaction was last announced to us. ;;
    #_public
    (§ method Date getLastBroadcastedAt())
    (ß
        (§ return lastBroadcastedAt)
    )

    ;;; Set the time the transaction was last announced to us. ;;
    #_public
    (§ method void setLastBroadcastedAt(Date lastBroadcastedAt))
    (ß
        (§ ass this.lastBroadcastedAt = lastBroadcastedAt)
    )

    #_override
    #_public
    #_synchronized
    (§ method String toString())
    (ß
        (§ var StringBuilder sb = new StringBuilder())
        (§ var int peers = numBroadcastPeers())
        (§ if (0 < peers))
        (ß
            (§ call sb.append("Seen by ").append(peers).append((1 < peers) ? " peers" :else " peer"))
            (§ if (lastBroadcastedAt != nil))
                (§ call sb.append(" (most recently: ").append(Utils.dateTimeFormat(lastBroadcastedAt)).append(")"))
            (§ call sb.append(". "))
        )
        (§ switch (getConfidenceType()))
        (ß
            (§ case UNKNOWN)
                (§ call sb.append("Unknown confidence level."))
                (§ break)
            (§ case DEAD)
                (§ call sb.append("Dead: overridden by double spend and will not confirm."))
                (§ break)
            (§ case PENDING)
                (§ call sb.append("Pending/unconfirmed."))
                (§ break)
            (§ case IN_CONFLICT)
                (§ call sb.append("In conflict."))
                (§ break)
            (§ case BUILDING)
                (§ call sb.append(String.format(Locale.US, "Appeared in best chain at height %d, depth %d.", getAppearedAtChainHeight(), getDepthInBlocks())))
                (§ break)
        )
        (§ if (source != Source.UNKNOWN))
            (§ call sb.append(" Source: ").append(source))
        (§ return sb.toString())
    )

    ;;;
     ; Called by the wallet when the tx appears on the best chain and a new block is added to the top.
     ; Updates the internal counter that tracks how deeply buried the block is.
     ;
     ; @return the new depth
     ;;
    #_public
    #_synchronized
    (§ method int incrementDepthInBlocks())
    (ß
        (§ ass this.depth = this.depth + 1)
        (§ return this.depth)
    )

    ;;;
     ; <p>Depth in the chain is an approximation of how much time has elapsed since the transaction has been confirmed.
     ; On average there is supposed to be a new block every 10 minutes, but the actual rate may vary.  Bitcoin Core
     ; considers a transaction impractical to reverse after 6 blocks, but as of EOY 2011 network
     ; security is high enough that often only one block is considered enough even for high value transactions.
     ; For low value transactions like songs, or other cheap items, no blocks at all may be necessary.</p>
     ;
     ; <p>If the transaction appears in the top block, the depth is one.  If it's anything else (pending, dead, unknown)
     ; the depth is zero.</p>
     ;;
    #_public
    #_synchronized
    (§ method int getDepthInBlocks())
    (ß
        (§ return depth)
    )

    ;;
     ; Set the depth in blocks.  Having one block confirmation is a depth of one.
     ;;
    #_public
    #_synchronized
    (§ method void setDepthInBlocks(int depth))
    (ß
        (§ ass this.depth = depth)
    )

    ;;;
     ; Erases the set of broadcast/seen peers.  This cannot be called whilst the confidence is PENDING.  It is useful
     ; for saving memory and wallet space once a tx is buried so deep it doesn't seem likely to go pending again.
     ;;
    #_public
    (§ method void clearBroadcastBy())
    (ß
        (§ call Preconditions.checkState(getConfidenceType() != ConfidenceType.PENDING))
        (§ call broadcastBy.clear())
        (§ ass lastBroadcastedAt = nil)
    )

    ;;;
     ; If this transaction has been overridden by a double spend (is dead), this call returns the overriding transaction.
     ; Note that this call <b>can return null</b> if you have migrated an old wallet, as pre-Jan 2012 wallets did not
     ; store this information.
     ;
     ; @return the transaction that double spent this one.
     ; @throws IllegalStateException if confidence type is not DEAD.
     ;;
    #_public
    #_synchronized
    (§ method Transaction getOverridingTransaction())
    (ß
        (§ if (getConfidenceType() != ConfidenceType.DEAD))
            (§ throw new IllegalStateException("Confidence type is " + getConfidenceType() + ", not DEAD"))
        (§ return overridingTransaction)
    )

    ;;;
     ; Called when the transaction becomes newly dead, that is, we learn that one of its inputs has already been spent
     ; in such a way that the double-spending transaction takes precedence over this one.  It will not become valid now
     ; unless there is a re-org.  Automatically sets the confidence type to DEAD.  The overriding transaction may not
     ; directly double spend this one, but could also have double spent a dependency of this tx.
     ;;
    #_public
    #_synchronized
    (§ method void setOverridingTransaction(#_nilable Transaction overridingTransaction))
    (ß
        (§ ass this.overridingTransaction = overridingTransaction)
        (§ call setConfidenceType(ConfidenceType.DEAD))
    )

    ;;; Returns a copy of this object.  Event listeners are not duplicated. ;;
    #_public
    (§ method TransactionConfidence duplicate())
    (ß
        (§ var TransactionConfidence c = new TransactionConfidence(hash))
        (§ call c.broadcastBy.addAll(broadcastBy))
        (§ ass c.lastBroadcastedAt = lastBroadcastedAt)
        (§ sync this)
        (ß
            (§ ass c.confidenceType = confidenceType)
            (§ ass c.overridingTransaction = overridingTransaction)
            (§ ass c.appearedAtChainHeight = appearedAtChainHeight)
        )
        (§ return c)
    )

    ;;;
     ; Call this after adjusting the confidence, for cases where listeners should be notified.  This has to be done
     ; explicitly rather than being done automatically because sometimes complex changes to transaction states can
     ; result in a series of confidence changes that are not really useful to see separately.  By invoking listeners
     ; explicitly, more precise control is available.  Note that this will run the listeners on the user code thread.
     ;;
    #_public
    (§ method void queueListeners(#_final Listener.ChangeReason reason))
    (ß
        (§ for (#_final ListenerRegistration<Listener> registration :for listeners))
        (ß
            (§ call registration.executor.execute(new Runnable()
            (ß
                #_override
                #_public
                (§ method void run())
                (ß
                    (§ call registration.listener.onConfidenceChanged(TransactionConfidence.this, reason))
                )
            )))
        )
    )

    ;;;
     ; The source of a transaction tries to identify where it came from originally.  For instance, did we download it
     ; from the peer to peer network, or make it ourselves, or receive it via Bluetooth, or import it from another app,
     ; and so on.  This information is useful for {@link org.bitcoinj.wallet.CoinSelector} implementations to risk analyze
     ; transactions and decide when to spend them.
     ;;
    #_public
    #_synchronized
    (§ method Source getSource())
    (ß
        (§ return source)
    )

    ;;;
     ; The source of a transaction tries to identify where it came from originally.  For instance, did we download it
     ; from the peer to peer network, or make it ourselves, or receive it via Bluetooth, or import it from another app,
     ; and so on.  This information is useful for {@link org.bitcoinj.wallet.CoinSelector} implementations to risk analyze
     ; transactions and decide when to spend them.
     ;;
    #_public
    #_synchronized
    (§ method void setSource(Source source))
    (ß
        (§ ass this.source = source)
    )

    ;;;
     ; Returns a future that completes when the transaction has been confirmed by "depth" blocks.  For instance setting
     ; depth to one will wait until it appears in a block on the best chain, and zero will wait until it has been seen
     ; on the network.
     ;;
    #_public
    #_synchronized
    (§ method ListenableFuture<TransactionConfidence> getDepthFuture(#_final int depth, Executor executor))
    (ß
        #_final
        (§ var SettableFuture<TransactionConfidence> result = SettableFuture.create())
        (§ if (depth <= getDepthInBlocks()))
            (§ call result.set(this))

        (§ call addEventListener(executor, new Listener()
        (ß
            #_override
            #_public
            (§ method void onConfidenceChanged(TransactionConfidence confidence, ChangeReason reason))
            (ß
                (§ if (depth <= getDepthInBlocks()))
                (ß
                    (§ call removeEventListener(this))
                    (§ call result.set(confidence))
                )
            )
        )))
        (§ return result)
    )

    #_public
    #_synchronized
    (§ method ListenableFuture<TransactionConfidence> getDepthFuture(#_final int depth))
    (ß
        (§ return getDepthFuture(depth, Threading.USER_THREAD))
    )

    #_public
    (§ method Sha256Hash getTransactionHash())
    (ß
        (§ return hash)
    )
)

#_(ns org.bitcoinj.core #_"TransactionInput"
    (:import [java.io IOException OutputStream]
             [java.lang.ref WeakReference]
             [java.util Arrays Map])
    (:import [com.google.common.base Joiner Objects Preconditions])
  #_(:require [org.bitcoinj.script Script ScriptError]
             [org.bitcoinj.wallet DefaultRiskAnalysis KeyBag RedeemData]))

;;;
 ; <p>A transfer of coins from one address to another creates a transaction in which the outputs
 ; can be claimed by the recipient in the input of another transaction.  You can imagine a
 ; transaction as being a module which is wired up to others, the inputs of one have to be wired
 ; to the outputs of another.  The exceptions are coinbase transactions, which create new coins.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class TransactionInput extends ChildMessage
    ;;; Magic sequence number that indicates there is no sequence number. ;;
    #_public
    #_static
    #_final
    (§ field long NO_SEQUENCE = 0xffffffff)
    #_private
    #_static
    #_final
    (§ field byte[] EMPTY_ARRAY = new byte[0])
    ;; Magic outpoint index that indicates the input is in fact unconnected.
    #_private
    #_static
    #_final
    (§ field long UNCONNECTED = 0xffffffff)

    ;; Allows for altering transactions after they were broadcast.  Values below NO_SEQUENCE-1 mean it can be altered.
    #_private
    (§ field long sequence)
    ;; Data needed to connect to the output of the transaction we're gathering coins from.
    #_private
    (§ field TransactionOutPoint outpoint)
    ;; The "script bytes" might not actually be a script.  In coinbase transactions where new coins are minted there
    ;; is no input transaction, so instead the scriptBytes contains some extra stuff (like a rollover nonce) that we
    ;; don't care about much.  The bytes are turned into a Script object (cached below) on demand via a getter.
    #_private
    (§ field byte[] scriptBytes)
    ;; The Script object obtained from parsing scriptBytes.  Only filled in on demand and if the transaction is not
    ;; coinbase.
    #_private
    (§ field WeakReference<Script> scriptSig)
    ;;; Value of the output connected to the input, if known.  This field does not participate in equals()/hashCode(). ;;
    #_nilable
    #_private
    (§ field Coin value)

    ;;;
     ; Creates an input that connects to nothing - used only in creation of coinbase transactions.
     ;;
    #_public
    (§ constructor TransactionInput(NetworkParameters params, #_nilable Transaction parentTransaction, byte[] scriptBytes))
    (ß
        (§ this (params, parentTransaction, scriptBytes, new TransactionOutPoint(params, UNCONNECTED, (Transaction) nil)))
    )

    #_public
    (§ constructor TransactionInput(NetworkParameters params, #_nilable Transaction parentTransaction, byte[] scriptBytes, TransactionOutPoint outpoint))
    (ß
        (§ this (params, parentTransaction, scriptBytes, outpoint, nil))
    )

    #_public
    (§ constructor TransactionInput(NetworkParameters params, #_nilable Transaction parentTransaction, byte[] scriptBytes, TransactionOutPoint outpoint, #_nilable Coin value))
    (ß
        (§ super (params))

        (§ ass this.scriptBytes = scriptBytes)
        (§ ass this.outpoint = outpoint)
        (§ ass this.sequence = NO_SEQUENCE)
        (§ ass this.value = value)
        (§ call setParent(parentTransaction))
        (§ ass length = 40 + (scriptBytes != nil ? VarInt.sizeOf(scriptBytes.length) + scriptBytes.length :else 1))
    )

    ;;;
     ; Creates an UNSIGNED input that links to the given output.
     ;;
    (§ constructor TransactionInput(NetworkParameters params, Transaction parentTransaction, TransactionOutput output))
    (ß
        (§ super (params))

        (§ var long outputIndex = output.getIndex())
        (§ if (output.getParentTransaction() != nil ))
            (§ ass outpoint = new TransactionOutPoint(params, outputIndex, output.getParentTransaction()))
        (§ else)
            (§ ass outpoint = new TransactionOutPoint(params, output))
        (§ ass scriptBytes = EMPTY_ARRAY)
        (§ ass sequence = NO_SEQUENCE)
        (§ call setParent(parentTransaction))
        (§ ass this.value = output.getValue())
        (§ ass length = 41)
    )

    ;;;
     ; Deserializes an input message.  This is usually part of a transaction message.
     ;;
    #_public
    (§ constructor TransactionInput(NetworkParameters params, #_nilable Transaction parentTransaction, byte[] payload, int offset))
        (§ throws ProtocolException)
    (ß
        (§ super (params, payload, offset))

        (§ call setParent(parentTransaction))
        (§ ass this.value = nil)
    )

    ;;;
     ; Deserializes an input message.  This is usually part of a transaction message.
     ; @param params NetworkParameters object.
     ; @param payload Bitcoin protocol formatted byte array containing message content.
     ; @param offset The location of the first payload byte within the array.
     ; @param serializer The serializer to use for this message.
     ; @throws ProtocolException
     ;;
    #_public
    (§ constructor TransactionInput(NetworkParameters params, Transaction parentTransaction, byte[] payload, int offset, MessageSerializer serializer))
        (§ throws ProtocolException)
    (ß
        (§ super (params, payload, offset, parentTransaction, serializer, UNKNOWN_LENGTH))

        (§ ass this.value = nil)
    )

    #_override
    #_protected
    (§ method void parse())
        (§ throws ProtocolException)
    (ß
        (§ ass outpoint = new TransactionOutPoint(params, payload, cursor, this, serializer))
        (§ ass cursor = cursor + outpoint.getMessageSize())
        (§ var int scriptLen = (int)readVarInt())
        (§ ass length = cursor - offset + scriptLen + 4)
        (§ ass scriptBytes = readBytes(scriptLen))
        (§ ass sequence = readUint32())
    )

    #_override
    #_protected
    (§ method void bitcoinSerializeToStream(OutputStream stream))
        (§ throws IOException)
    (ß
        (§ call outpoint.bitcoinSerialize(stream))
        (§ call stream.write(new VarInt(scriptBytes.length).encode()))
        (§ call stream.write(scriptBytes))
        (§ call Utils.uint32ToByteStreamLE(sequence, stream))
    )

    ;;;
     ; Coinbase transactions have special inputs with hashes of zero.  If this is such an input, returns true.
     ;;
    #_public
    (§ method boolean isCoinBase())
    (ß
        (§ return (outpoint.getHash().equals(Sha256Hash.ZERO_HASH) && (outpoint.getIndex() & 0xffffffff) == 0xffffffff)) ;; -1 but all is serialized to the wire as unsigned int.
    )

    ;;;
     ; Returns the script that is fed to the referenced output (scriptPubKey) script in order to satisfy it: usually
     ; contains signatures and maybe keys, but can contain arbitrary data if the output script accepts it.
     ;;
    #_public
    (§ method Script getScriptSig())
        (§ throws ScriptException)
    (ß
        ;; Transactions that generate new coins don't actually have a script.
        ;; Instead this parameter is overloaded to be something totally different.
        (§ var Script script = (scriptSig != nil) ? scriptSig.get() :else nil)
        (§ if (script == nil))
        (ß
            (§ ass script = new Script(scriptBytes))
            (§ ass scriptSig = new WeakReference<>(script))
        )
        (§ return script)
    )

    ;;; Set the given program as the scriptSig that is supposed to satisfy the connected output script. ;;
    #_public
    (§ method void setScriptSig(Script scriptSig))
    (ß
        (§ ass this.scriptSig = new WeakReference<>(Preconditions.checkNotNull(scriptSig)))
        ;; TODO: This should all be cleaned up so we have a consistent internal representation.
        (§ call setScriptBytes(scriptSig.getProgram()))
    )

    ;;;
     ; Convenience method that returns the from address of this input by parsing the scriptSig.  The concept of
     ; a "from address" is not well defined in Bitcoin and you should not assume that senders of a transaction can
     ; actually receive coins on the same address they used to sign (e.g. this is not true for shared wallets).
     ;;
    #_deprecated
    #_public
    (§ method Address getFromAddress())
        (§ throws ScriptException)
    (ß
        (§ if (isCoinBase()))
            (§ throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "This is a coinbase transaction which generates new coins. It does not have a from address."))

        (§ return getScriptSig().getFromAddress(params))
    )

    ;;;
     ; Sequence numbers allow participants in a multi-party transaction signing protocol to create new versions of the
     ; transaction independently of each other.  Newer versions of a transaction can replace an existing version that's
     ; in nodes memory pools if the existing version is time locked.  See the Contracts page on the Bitcoin wiki for
     ; examples of how you can use this feature to build contract protocols.
     ;;
    #_public
    (§ method long getSequenceNumber())
    (ß
        (§ return sequence)
    )

    ;;;
     ; Sequence numbers allow participants in a multi-party transaction signing protocol to create new versions of the
     ; transaction independently of each other.  Newer versions of a transaction can replace an existing version that's
     ; in nodes memory pools if the existing version is time locked.  See the Contracts page on the Bitcoin wiki for
     ; examples of how you can use this feature to build contract protocols.
     ;;
    #_public
    (§ method void setSequenceNumber(long sequence))
    (ß
        (§ call unCache())
        (§ ass this.sequence = sequence)
    )

    ;;;
     ; @return The previous output transaction reference, as an OutPoint structure.  This contains the
     ; data needed to connect to the output of the transaction we're gathering coins from.
     ;;
    #_public
    (§ method TransactionOutPoint getOutpoint())
    (ß
        (§ return outpoint)
    )

    ;;;
     ; The "script bytes" might not actually be a script.  In coinbase transactions where new coins are minted there
     ; is no input transaction, so instead the scriptBytes contains some extra stuff (like a rollover nonce) that we
     ; don't care about much.  The bytes are turned into a Script object (cached below) on demand via a getter.
     ; @return the scriptBytes
     ;;
    #_public
    (§ method byte[] getScriptBytes())
    (ß
        (§ return scriptBytes)
    )

    ;;; Clear input scripts, e.g. in preparation for signing. ;;
    #_public
    (§ method void clearScriptBytes())
    (ß
        (§ call setScriptBytes(TransactionInput.EMPTY_ARRAY))
    )

    ;;;
     ; @param scriptBytes The scriptBytes to set.
     ;;
    (§ method void setScriptBytes(byte[] scriptBytes))
    (ß
        (§ call unCache())
        (§ ass this.scriptSig = nil)
        (§ var int oldLength = length)
        (§ ass this.scriptBytes = scriptBytes)
        ;; 40 = previous_outpoint (36) + sequence (4)
        (§ var int newLength = 40 + (scriptBytes != nil ? VarInt.sizeOf(scriptBytes.length) + scriptBytes.length :else 1))
        (§ call adjustLength(newLength - oldLength))
    )

    ;;;
     ; @return the Transaction that owns this input.
     ;;
    #_public
    (§ method Transaction getParentTransaction())
    (ß
        (§ return (Transaction)parent)
    )

    ;;;
     ; @return the value of the output connected to this input.
     ;;
    #_nilable
    #_public
    (§ method Coin getValue())
    (ß
        (§ return value)
    )

    #_public
    (§ enum ConnectionResult
        (§ item NO_SUCH_TX)
        (§ item ALREADY_SPENT)
        (§ item SUCCESS)
    )

    ;; TODO: Clean all this up once TransactionOutPoint disappears.

    ;;;
     ; Locates the referenced output from the given pool of transactions.
     ;
     ; @return the TransactionOutput (or null) if the transaction's map doesn't contain the referenced tx.
     ;;
    #_nilable
    (§ method TransactionOutput getConnectedOutput(Map<Sha256Hash, Transaction> transactions))
    (ß
        (§ var Transaction tx = transactions.get(outpoint.getHash()))
        (§ return (tx != nil) ? tx.getOutputs().get((int)outpoint.getIndex()) :else nil)
    )

    ;;;
     ; Alias for getOutpoint().getConnectedRedeemData(keyBag).
     ; @see TransactionOutPoint#getConnectedRedeemData(org.bitcoinj.wallet.KeyBag)
     ;;
    #_nilable
    #_public
    (§ method RedeemData getConnectedRedeemData(KeyBag keyBag))
        (§ throws ScriptException)
    (ß
        (§ return getOutpoint().getConnectedRedeemData(keyBag))
    )

    #_public
    (§ enum ConnectMode
        (§ item DISCONNECT_ON_CONFLICT)
        (§ item ABORT_ON_CONFLICT)
    )

    ;;;
     ; Connects this input to the relevant output of the referenced transaction if it's in the given map.
     ; Connecting means updating the internal pointers and spent flags.  If the mode is to ABORT_ON_CONFLICT,
     ; then the spent output won't be changed, but the outpoint.fromTx pointer will still be updated.
     ;
     ; @param transactions Map of txhash->transaction.
     ; @param mode Whether to abort if there's a pre-existing connection or not.
     ; @return NO_SUCH_TX if the prevtx wasn't found, ALREADY_SPENT if there was a conflict, SUCCESS if not.
     ;;
    #_public
    (§ method ConnectionResult connect(Map<Sha256Hash, Transaction> transactions, ConnectMode mode))
    (ß
        (§ var Transaction tx = transactions.get(outpoint.getHash()))
        (§ return (tx != nil) ? connect(tx, mode) :else TransactionInput.ConnectionResult.NO_SUCH_TX)
    )

    ;;;
     ; Connects this input to the relevant output of the referenced transaction.
     ; Connecting means updating the internal pointers and spent flags.  If the mode is to ABORT_ON_CONFLICT,
     ; then the spent output won't be changed, but the outpoint.fromTx pointer will still be updated.
     ;
     ; @param transaction The transaction to try.
     ; @param mode Whether to abort if there's a pre-existing connection or not.
     ; @return NO_SUCH_TX if transaction is not the prevtx, ALREADY_SPENT if there was a conflict, SUCCESS if not.
     ;;
    #_public
    (§ method ConnectionResult connect(Transaction transaction, ConnectMode mode))
    (ß
        (§ if (!transaction.getHash().equals(outpoint.getHash())))
            (§ return ConnectionResult.NO_SUCH_TX)

        (§ call Preconditions.checkElementIndex((int)outpoint.getIndex(), transaction.getOutputs().size(), "Corrupt transaction"))

        (§ var TransactionOutput out = transaction.getOutput((int)outpoint.getIndex()))
        (§ if (!out.isAvailableForSpending()))
        (ß
            (§ if (getParentTransaction().equals(outpoint.fromTx)))
            (ß
                ;; Already connected.
                (§ return ConnectionResult.SUCCESS)
            )
            (§ elseif (mode == ConnectMode.DISCONNECT_ON_CONFLICT))
            (ß
                (§ call out.markAsUnspent())
            )
            (§ elseif (mode == ConnectMode.ABORT_ON_CONFLICT))
            (ß
                (§ ass outpoint.fromTx = out.getParentTransaction())
                (§ return TransactionInput.ConnectionResult.ALREADY_SPENT)
            )
        )
        (§ call connect(out))
        (§ return TransactionInput.ConnectionResult.SUCCESS)
    )

    ;;; Internal use only: connects this TransactionInput to the given output (updates pointers and spent flags). ;;
    #_public
    (§ method void connect(TransactionOutput out))
    (ß
        (§ ass outpoint.fromTx = out.getParentTransaction())
        (§ call out.markAsSpent(this))
        (§ ass value = out.getValue())
    )

    ;;;
     ; If this input is connected, check the output is connected back to this input and release it if so, making
     ; it spendable once again.
     ;
     ; @return true if the disconnection took place, false if it was not connected.
     ;;
    #_public
    (§ method boolean disconnect())
    (ß
        (§ var TransactionOutput connectedOutput)
        (§ if (outpoint.fromTx != nil))
        (ß
            ;; The outpoint is connected using a "standard" wallet, disconnect it.
            (§ ass connectedOutput = outpoint.fromTx.getOutput((int)outpoint.getIndex()))
            (§ ass outpoint.fromTx = nil)
        )
        (§ elseif (outpoint.connectedOutput != nil))
        (ß
            ;; The outpoint is connected using a UTXO based wallet, disconnect it.
            (§ ass connectedOutput = outpoint.connectedOutput)
            (§ ass outpoint.connectedOutput = nil)
        )
        (§ else)
        (ß
            ;; The outpoint is not connected, do nothing.
            (§ return false)
        )

        (§ if (connectedOutput != nil && connectedOutput.getSpentBy() == this))
        (ß
            ;; The outpoint was connected to an output, disconnect the output.
            (§ call connectedOutput.markAsUnspent())
            (§ return true)
        )

        (§ return false)
    )

    ;;;
     ; @return true if this transaction's sequence number is set (i.e. it may be a part of a time-locked transaction).
     ;;
    #_public
    (§ method boolean hasSequence())
    (ß
        (§ return (sequence != NO_SEQUENCE))
    )

    ;;;
     ; Returns whether this input will cause a transaction to opt into the
     ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki">full replace-by-fee</a> semantics.
     ;;
    #_public
    (§ method boolean isOptInFullRBF())
    (ß
        (§ return (sequence < NO_SEQUENCE - 1))
    )

    ;;;
     ; For a connected transaction, runs the script against the connected pubkey and verifies they are correct.
     ; @throws ScriptException if the script did not verify.
     ; @throws VerificationException if the outpoint doesn't match the given output.
     ;;
    #_public
    (§ method void verify())
        (§ throws VerificationException)
    (ß
        #_final
        (§ var Transaction fromTx = getOutpoint().fromTx)
        (§ var long spendingIndex = getOutpoint().getIndex())

        (§ call Preconditions.checkNotNull(fromTx, "Not connected"))

        #_final
        (§ var TransactionOutput output = fromTx.getOutput((int)spendingIndex))
        (§ call verify(output))
    )

    ;;;
     ; Verifies that this input can spend the given output.  Note that this input must be a part of a transaction.
     ; Also note that the consistency of the outpoint will be checked, even if this input has not been connected.
     ;
     ; @param output The output that this input is supposed to spend.
     ; @throws ScriptException if the script doesn't verify.
     ; @throws VerificationException if the outpoint doesn't match the given output.
     ;;
    #_public
    (§ method void verify(TransactionOutput output))
        (§ throws VerificationException)
    (ß
        (§ if (output.parent != nil))
        (ß
            (§ if (!getOutpoint().getHash().equals(output.getParentTransaction().getHash())))
                (§ throw new VerificationException("This input does not refer to the tx containing the output."))
            (§ if (getOutpoint().getIndex() != output.getIndex()))
                (§ throw new VerificationException("This input refers to a different output on the given tx."))
        )
        (§ var Script pubKey = output.getScriptPubKey())
        (§ var int myIndex = getParentTransaction().getInputs().indexOf(this))
        (§ call getScriptSig().correctlySpends(getParentTransaction(), myIndex, pubKey))
    )

    ;;;
     ; Returns the connected output, assuming the input was connected with
     ; {@link TransactionInput#connect(TransactionOutput)} or variants at some point.
     ; If it wasn't connected, then this method returns null.
     ;;
    #_nilable
    #_public
    (§ method TransactionOutput getConnectedOutput())
    (ß
        (§ return getOutpoint().getConnectedOutput())
    )

    ;;;
     ; Returns the connected transaction, assuming the input was connected with
     ; {@link TransactionInput#connect(TransactionOutput)} or variants at some point.
     ; If it wasn't connected, then this method returns null.
     ;;
    #_nilable
    #_public
    (§ method Transaction getConnectedTransaction())
    (ß
        (§ return getOutpoint().fromTx)
    )

    ;;; Returns a copy of the input detached from its containing transaction, if need be. ;;
    #_public
    (§ method TransactionInput duplicateDetached())
    (ß
        (§ return new TransactionInput(params, nil, bitcoinSerialize(), 0))
    )

    ;;;
     ; <p>Returns either RuleViolation.NONE if the input is standard, or which rule makes it non-standard if so.
     ; The "IsStandard" rules control whether the default Bitcoin Core client blocks relay of a tx / refuses to mine it,
     ; however, non-standard transactions can still be included in blocks and will be accepted as valid if so.</p>
     ;
     ; <p>This method simply calls <tt>DefaultRiskAnalysis.isInputStandard(this)</tt>.</p>
     ;;
    #_public
    (§ method DefaultRiskAnalysis.RuleViolation isStandard())
    (ß
        (§ return DefaultRiskAnalysis.isInputStandard(this))
    )

    #_override
    #_public
    (§ method boolean equals(Object o))
    (ß
        (§ if (this == o))
            (§ return true)
        (§ if (o == nil || getClass() != o.getClass()))
            (§ return false)
        (§ var TransactionInput other = (TransactionInput)o)
        (§ return (sequence == other.sequence && parent == other.parent && outpoint.equals(other.outpoint) && Arrays.equals(scriptBytes, other.scriptBytes)))
    )

    #_override
    #_public
    (§ method int hashCode())
    (ß
        (§ return Objects.hashCode(sequence, outpoint, Arrays.hashCode(scriptBytes)))
    )

    ;;;
     ; Returns a human readable debug string.
     ;;
    #_override
    #_public
    (§ method String toString())
    (ß
        (§ try)
        (ß
            (§ var StringBuilder sb = new StringBuilder("TxIn"))
            (§ if (isCoinBase()))
            (ß
                (§ call sb.append(": COINBASE"))
            )
            (§ else)
            (ß
                (§ call sb.append(" for [").append(outpoint).append("]: ").append(getScriptSig()))
                (§ var String flags = Joiner.on(", ").skipNulls().join(hasSequence() ? "sequence: " + Long.toHexString(sequence) :else nil, isOptInFullRBF() ? "opts into full RBF" :else nil))
                (§ if (!flags.isEmpty()))
                    (§ call sb.append(" (").append(flags).append(")"))
            )
            (§ return sb.toString())
        )
        (§ catch (ScriptException e))
        (ß
            (§ throw new RuntimeException(e))
        )
    )
)

#_(ns org.bitcoinj.core #_"TransactionOutPoint"
    (:import #_[java.io *])
    (:import [com.google.common.base Objects Preconditions])
  #_(:require #_[org.bitcoinj.script *]
             #_[org.bitcoinj.wallet *]))

;;;
 ; <p>This message is a reference or pointer to an output of a different transaction.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class TransactionOutPoint extends ChildMessage
    #_static
    #_final
    (§ field int MESSAGE_LENGTH = 36)

    ;;; Hash of the transaction to which we refer. ;;
    #_private
    (§ field Sha256Hash hash)
    ;;; Which output of that transaction we are talking about. ;;
    #_private
    (§ field long index)

    ;; This is not part of bitcoin serialization.  It points to the connected transaction.
    (§ field Transaction fromTx)

    ;; The connected output.
    (§ field TransactionOutput connectedOutput)

    #_public
    (§ constructor TransactionOutPoint(NetworkParameters params, long index, #_nilable Transaction fromTx))
    (ß
        (§ super (params))

        (§ ass this.index = index)
        (§ if (fromTx != nil))
        (ß
            (§ ass this.hash = fromTx.getHash())
            (§ ass this.fromTx = fromTx)
        )
        (§ else)
        (ß
            ;; This happens when constructing the genesis block.
            (§ ass hash = Sha256Hash.ZERO_HASH)
        )
        (§ ass length = MESSAGE_LENGTH)
    )

    #_public
    (§ constructor TransactionOutPoint(NetworkParameters params, long index, Sha256Hash hash))
    (ß
        (§ super (params))

        (§ ass this.index = index)
        (§ ass this.hash = hash)
        (§ ass length = MESSAGE_LENGTH)
    )

    #_public
    (§ constructor TransactionOutPoint(NetworkParameters params, TransactionOutput connectedOutput))
    (ß
        (§ this (params, connectedOutput.getIndex(), connectedOutput.getParentTransactionHash()))
        (§ ass this.connectedOutput = connectedOutput)
    )

    ;;;
     ; Deserializes the message.  This is usually part of a transaction message.
     ;;
    #_public
    (§ constructor TransactionOutPoint(NetworkParameters params, byte[] payload, int offset))
        (§ throws ProtocolException)
    (ß
        (§ super (params, payload, offset))
    )

    ;;;
     ; Deserializes the message.  This is usually part of a transaction message.
     ; @param params NetworkParameters object.
     ; @param offset The location of the first payload byte within the array.
     ; @param serializer The serializer to use for this message.
     ; @throws ProtocolException
     ;;
    #_public
    (§ constructor TransactionOutPoint(NetworkParameters params, byte[] payload, int offset, Message parent, MessageSerializer serializer))
        (§ throws ProtocolException)
    (ß
        (§ super (params, payload, offset, parent, serializer, MESSAGE_LENGTH))
    )

    #_override
    #_protected
    (§ method void parse())
        (§ throws ProtocolException)
    (ß
        (§ ass length = MESSAGE_LENGTH)
        (§ ass hash = readHash())
        (§ ass index = readUint32())
    )

    #_override
    #_protected
    (§ method void bitcoinSerializeToStream(OutputStream stream))
        (§ throws IOException)
    (ß
        (§ call stream.write(hash.getReversedBytes()))
        (§ call Utils.uint32ToByteStreamLE(index, stream))
    )

    ;;;
     ; An outpoint is a part of a transaction input that points to the output of another transaction.  If we have both
     ; sides in memory, and they have been linked together, this returns a pointer to the connected output, or null
     ; if there is no such connection.
     ;;
    #_nilable
    #_public
    (§ method TransactionOutput getConnectedOutput())
    (ß
        (§ if (fromTx != nil))
            (§ return fromTx.getOutputs().get((int)index))
        (§ if (connectedOutput != nil))
            (§ return connectedOutput)
        (§ return nil)
    )

    ;;;
     ; Returns the pubkey script from the connected output.
     ; @throws java.lang.NullPointerException if there is no connected output.
     ;;
    #_public
    (§ method byte[] getConnectedPubKeyScript())
    (ß
        (§ var byte[] result = Preconditions.checkNotNull(getConnectedOutput()).getScriptBytes())
        (§ call Preconditions.checkState(0 < result.length))
        (§ return result)
    )

    ;;;
     ; Returns the ECKey identified in the connected output, for either pay-to-address scripts or pay-to-key scripts.
     ; For P2SH scripts you can use {@link #getConnectedRedeemData(org.bitcoinj.wallet.KeyBag)} and then get the
     ; key from RedeemData.
     ; If the script form cannot be understood, throws ScriptException.
     ;
     ; @return an ECKey or null if the connected key cannot be found in the wallet.
     ;;
    #_nilable
    #_public
    (§ method ECKey getConnectedKey(KeyBag keyBag))
        (§ throws ScriptException)
    (ß
        (§ var TransactionOutput connectedOutput = getConnectedOutput())
        (§ call Preconditions.checkNotNull(connectedOutput, "Input is not connected so cannot retrieve key"))
        (§ var Script connectedScript = connectedOutput.getScriptPubKey())

        (§ if (connectedScript.isSentToAddress()))
        (ß
            (§ var byte[] addressBytes = connectedScript.getPubKeyHash())
            (§ return keyBag.findKeyFromPubHash(addressBytes))
        )

        (§ if (connectedScript.isSentToRawPubKey()))
        (ß
            (§ var byte[] pubkeyBytes = connectedScript.getPubKey())
            (§ return keyBag.findKeyFromPubKey(pubkeyBytes))
        )

        (§ throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "Could not understand form of connected output script: " + connectedScript))
    )

    ;;;
     ; Returns the RedeemData identified in the connected output, for either pay-to-address scripts, pay-to-key
     ; or P2SH scripts.
     ; If the script forms cannot be understood, throws ScriptException.
     ;
     ; @return a RedeemData or null if the connected data cannot be found in the wallet.
     ;;
    #_nilable
    #_public
    (§ method RedeemData getConnectedRedeemData(KeyBag keyBag))
        (§ throws ScriptException)
    (ß
        (§ var TransactionOutput connectedOutput = getConnectedOutput())
        (§ call Preconditions.checkNotNull(connectedOutput, "Input is not connected so cannot retrieve key"))
        (§ var Script connectedScript = connectedOutput.getScriptPubKey())

        (§ if (connectedScript.isSentToAddress()))
        (ß
            (§ var byte[] addressBytes = connectedScript.getPubKeyHash())
            (§ return RedeemData.of(keyBag.findKeyFromPubHash(addressBytes), connectedScript))
        )

        (§ if (connectedScript.isSentToRawPubKey()))
        (ß
            (§ var byte[] pubkeyBytes = connectedScript.getPubKey())
            (§ return RedeemData.of(keyBag.findKeyFromPubKey(pubkeyBytes), connectedScript))
        )

        (§ if (connectedScript.isPayToScriptHash()))
        (ß
            (§ var byte[] scriptHash = connectedScript.getPubKeyHash())
            (§ return keyBag.findRedeemDataFromScriptHash(scriptHash))
        )

        (§ throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "Could not understand form of connected output script: " + connectedScript))
    )

    #_override
    #_public
    (§ method String toString())
    (ß
        (§ return hash + ":" + index)
    )

    ;;;
     ; Returns the hash of the transaction this outpoint references/spends/is connected to.
     ;;
    #_override
    #_public
    (§ method Sha256Hash getHash())
    (ß
        (§ return hash)
    )

    (§ method void setHash(Sha256Hash hash))
    (ß
        (§ ass this.hash = hash)
    )

    #_public
    (§ method long getIndex())
    (ß
        (§ return index)
    )

    #_public
    (§ method void setIndex(long index))
    (ß
        (§ ass this.index = index)
    )

    #_override
    #_public
    (§ method boolean equals(Object o))
    (ß
        (§ if (this == o))
            (§ return true)
        (§ if (o == nil || getClass() != o.getClass()))
            (§ return false)
        (§ var TransactionOutPoint other = (TransactionOutPoint)o)
        (§ return (getIndex() == other.getIndex() && getHash().equals(other.getHash())))
    )

    #_override
    #_public
    (§ method int hashCode())
    (ß
        (§ return Objects.hashCode(getIndex(), getHash()))
    )
)

#_(ns org.bitcoinj.core #_"TransactionOutput"
    (:import #_[java.io *]
             #_[java.util *])
    (:import [com.google.common.base Objects Preconditions]
             #_[org.slf4j *])
  #_(:require #_[org.bitcoinj.script *]
             [org.bitcoinj.wallet Wallet]))

;;;
 ; <p>A TransactionOutput message contains a scriptPubKey that controls who is able to spend its value.
 ; It is a sub-part of the Transaction message.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class TransactionOutput extends ChildMessage
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(TransactionOutput.class))

    ;; The output's value is kept as a native type in order to save class instances.
    #_private
    (§ field long value)

    ;; A transaction output has a script used for authenticating that the redeemer is allowed to spend
    ;; this output.
    #_private
    (§ field byte[] scriptBytes)

    ;; The script bytes are parsed and turned into a Script on demand.
    #_private
    (§ field Script scriptPubKey)

    ;; These fields are not Bitcoin serialized.  They are used for tracking purposes in our wallet only.
    ;; If set to true, this output is counted towards our balance.  If false and spentBy is null the tx output
    ;; was owned by us and was sent to somebody else.  If false and spentBy is set it means this output was owned
    ;; by us and used in one of our own transactions (e.g. because it is a change output).
    #_private
    (§ field boolean availableForSpending)
    #_nilable
    #_private
    (§ field TransactionInput spentBy)

    #_private
    (§ field int scriptLen)

    ;;;
     ; Deserializes a transaction output message.  This is usually part of a transaction message.
     ;;
    #_public
    (§ constructor TransactionOutput(NetworkParameters params, #_nilable Transaction parent, byte[] payload, int offset))
        (§ throws ProtocolException)
    (ß
        (§ super (params, payload, offset))

        (§ call setParent(parent))
        (§ ass availableForSpending = true)
    )

    ;;;
     ; Deserializes a transaction output message.  This is usually part of a transaction message.
     ;
     ; @param params NetworkParameters object.
     ; @param payload Bitcoin protocol formatted byte array containing message content.
     ; @param offset The location of the first payload byte within the array.
     ; @param serializer The serializer to use for this message.
     ; @throws ProtocolException
     ;;
    #_public
    (§ constructor TransactionOutput(NetworkParameters params, #_nilable Transaction parent, byte[] payload, int offset, MessageSerializer serializer))
        (§ throws ProtocolException)
    (ß
        (§ super (params, payload, offset, parent, serializer, UNKNOWN_LENGTH))

        (§ ass availableForSpending = true)
    )

    ;;;
     ; Creates an output that sends 'value' to the given address (public key hash).  The amount should be
     ; created with something like {@link Coin#valueOf(int, int)}.  Typically you would use
     ; {@link Transaction#addOutput(Coin, Address)} instead of creating a TransactionOutput directly.
     ;;
    #_public
    (§ constructor TransactionOutput(NetworkParameters params, #_nilable Transaction parent, Coin value, Address to))
    (ß
        (§ this (params, parent, value, ScriptBuilder.createOutputScript(to).getProgram()))
    )

    ;;;
     ; Creates an output that sends 'value' to the given public key using a simple CHECKSIG script (no addresses).
     ; The amount should be created with something like {@link Coin#valueOf(int, int)}.  Typically you would use
     ; {@link Transaction#addOutput(Coin, ECKey)} instead of creating an output directly.
     ;;
    #_public
    (§ constructor TransactionOutput(NetworkParameters params, #_nilable Transaction parent, Coin value, ECKey to))
    (ß
        (§ this (params, parent, value, ScriptBuilder.createOutputScript(to).getProgram()))
    )

    #_public
    (§ constructor TransactionOutput(NetworkParameters params, #_nilable Transaction parent, Coin value, byte[] scriptBytes))
    (ß
        (§ super (params))

        ;; Negative values obviously make no sense, except for -1 which is used as a sentinel value when calculating
        ;; SIGHASH_SINGLE signatures, so unfortunately we have to allow that here.
        (§ call Preconditions.checkArgument(0 <= value.signum() || value.equals(Coin.NEGATIVE_SATOSHI), "Negative values not allowed"))
        (§ call Preconditions.checkArgument(!params.hasMaxMoney() || value.compareTo(params.getMaxMoney()) <= 0, "Values larger than MAX_MONEY not allowed"))

        (§ ass this.value = value.value)
        (§ ass this.scriptBytes = scriptBytes)
        (§ call setParent(parent))
        (§ ass availableForSpending = true)
        (§ ass length = 8 + VarInt.sizeOf(scriptBytes.length) + scriptBytes.length)
    )

    #_public
    (§ method Script getScriptPubKey())
        (§ throws ScriptException)
    (ß
        (§ if (scriptPubKey == nil))
            (§ ass scriptPubKey = new Script(scriptBytes))
        (§ return scriptPubKey)
    )

    ;;;
     ; <p>If the output script pays to an address as in <a href="https://bitcoin.org/en/developer-guide#term-p2pkh">P2PKH</a>,
     ; return the address of the receiver, i.e. a base58 encoded hash of the public key in the script.</p>
     ;
     ; @param networkParameters Needed to specify an address.
     ; @return null, if the output script is not the form <i>OP_DUP OP_HASH160 <PubkeyHash> OP_EQUALVERIFY OP_CHECKSIG</i>,
     ; i.e. not P2PKH.
     ; @return an address made out of the public key hash.
     ;;
    #_nilable
    #_public
    (§ method Address getAddressFromP2PKHScript(NetworkParameters networkParameters))
        (§ throws ScriptException)
    (ß
        (§ return getScriptPubKey().isSentToAddress() ? getScriptPubKey().getToAddress(networkParameters) :else nil)
    )

    ;;;
     ; <p>If the output script pays to a redeem script, return the address of the redeem script as described by,
     ; i.e. a base58 encoding of [one-byte version][20-byte hash][4-byte checksum], where the 20-byte hash refers to
     ; the redeem script.</p>
     ;
     ; <p>P2SH is described by <a href="https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki">BIP 16</a> and
     ; <a href="https://bitcoin.org/en/developer-guide#p2sh-scripts">documented in the Bitcoin Developer Guide</a>.</p>
     ;
     ; @param networkParameters Needed to specify an address.
     ; @return null if the output script does not pay to a script hash.
     ; @return an address that belongs to the redeem script.
     ;;
    #_nilable
    #_public
    (§ method Address getAddressFromP2SH(NetworkParameters networkParameters))
        (§ throws ScriptException)
    (ß
        (§ return getScriptPubKey().isPayToScriptHash() ? getScriptPubKey().getToAddress(networkParameters) :else nil)
    )

    #_override
    #_protected
    (§ method void parse())
        (§ throws ProtocolException)
    (ß
        (§ ass value = readInt64())
        (§ ass scriptLen = (int)readVarInt())
        (§ ass length = cursor - offset + scriptLen)
        (§ ass scriptBytes = readBytes(scriptLen))
    )

    #_override
    #_protected
    (§ method void bitcoinSerializeToStream(OutputStream stream))
        (§ throws IOException)
    (ß
        (§ call Preconditions.checkNotNull(scriptBytes))

        (§ call Utils.int64ToByteStreamLE(value, stream))
        ;; TODO: Move script serialization into the Script class, where it belongs.
        (§ call stream.write(new VarInt(scriptBytes.length).encode()))
        (§ call stream.write(scriptBytes))
    )

    ;;;
     ; Returns the value of this output.
     ; This is the amount of currency that the destination address receives.
     ;;
    #_public
    (§ method Coin getValue())
    (ß
        (§ try)
        (ß
            (§ return Coin.valueOf(value))
        )
        (§ catch (IllegalArgumentException e))
        (ß
            (§ throw new IllegalStateException(e.getMessage(), e))
        )
    )

    ;;;
     ; Sets the value of this output.
     ;;
    #_public
    (§ method void setValue(Coin value))
    (ß
        (§ call Preconditions.checkNotNull(value))

        (§ call unCache())
        (§ ass this.value = value.value)
    )

    ;;;
     ; Gets the index of this output in the parent transaction, or throws if this output is free standing.
     ; Iterates over the parents list to discover this.
     ;;
    #_public
    (§ method int getIndex())
    (ß
        (§ var List<TransactionOutput> outputs = getParentTransaction().getOutputs())
        (§ for (int i = 0 :for i < outputs.size() :for i = i + 1))
            (§ if (outputs.get(i) == this))
                (§ return i)

        (§ throw new IllegalStateException("Output linked to wrong parent transaction?"))
    )

    ;;;
     ; Will this transaction be relayable and mined by default miners?
     ;;
    #_public
    (§ method boolean isDust())
    (ß
        ;; Transactions that are OP_RETURN can't be dust regardless of their value.
        (§ return getScriptPubKey().isOpReturn() ? false :else getValue().isLessThan(getMinNonDustValue()))
    )

    ;;;
     ; <p>Gets the minimum value for a txout of this size to be considered non-dust by Bitcoin Core
     ; (and thus relayed).  See CTxOut::IsDust() in Bitcoin Core.  The assumption is that any output that would
     ; consume more than a third of its value in fees is not something the Bitcoin system wants to deal with right now,
     ; so we call them "dust outputs" and they're made non standard.  The choice of one third is somewhat arbitrary and
     ; may change in future.</p>
     ;
     ; <p>You probably should use {@link org.bitcoinj.core.TransactionOutput#getMinNonDustValue()} which uses
     ; a safe fee-per-kb by default.</p>
     ;
     ; @param feePerKb The fee required per kilobyte.  Note that this is the same as Bitcoin Core's -minrelaytxfee * 3.
     ;;
    #_public
    (§ method Coin getMinNonDustValue(Coin feePerKb))
    (ß
        ;; A typical output is 33 bytes (pubkey hash + opcodes) and requires an input of 148 bytes to spend so we add
        ;; that together to find out the total amount of data used to transfer this amount of value.  Note that this
        ;; formula is wrong for anything that's not a pay-to-address output, unfortunately, we must follow Bitcoin Core's
        ;; wrongness in order to ensure we're considered standard.  A better formula would either estimate the
        ;; size of data needed to satisfy all different script types, or just hard code 33 below.
        #_final
        (§ var long size = this.unsafeBitcoinSerialize().length + 148)
        (§ return feePerKb.multiply(size).divide(1000))
    )

    ;;;
     ; Returns the minimum value for this output to be considered "not dust", i.e. the transaction will be relayable
     ; and mined by default miners.  For normal pay to address outputs, this is 2730 satoshis, the same as
     ; {@link Transaction#MIN_NONDUST_OUTPUT}.
     ;;
    #_public
    (§ method Coin getMinNonDustValue())
    (ß
        (§ return getMinNonDustValue(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.multiply(3)))
    )

    ;;;
     ; Sets this objects availableForSpending flag to false and the spentBy pointer to the given input.
     ; If the input is null, it means this output was signed over to somebody else rather than one of our own keys.
     ; @throws IllegalStateException if the transaction was already marked as spent.
     ;;
    #_public
    (§ method void markAsSpent(TransactionInput input))
    (ß
        (§ call Preconditions.checkState(availableForSpending))

        (§ ass availableForSpending = false)
        (§ ass spentBy = input)

        (§ if (log.isDebugEnabled()))
        (ß
            (§ if (parent != nil))
                (§ call log.debug("Marked {}:{} as spent by {}", getParentTransactionHash(), getIndex(), input))
            (§ else)
                (§ call log.debug("Marked floating output as spent by {}", input))
        )
    )

    ;;;
     ; Resets the spent pointer / availableForSpending flag to null.
     ;;
    #_public
    (§ method void markAsUnspent())
    (ß
        (§ if (log.isDebugEnabled()))
        (ß
            (§ if (parent != nil))
                (§ call log.debug("Un-marked {}:{} as spent by {}", getParentTransactionHash(), getIndex(), spentBy))
            (§ else)
                (§ call log.debug("Un-marked floating output as spent by {}", spentBy))
        )

        (§ ass availableForSpending = true)
        (§ ass spentBy = nil)
    )

    ;;;
     ; Returns whether {@link TransactionOutput#markAsSpent(TransactionInput)} has been called on this class.
     ; A {@link Wallet} will mark a transaction output as spent once it sees a transaction input that is connected to it.
     ; Note that this flag can be false when an output has in fact been spent according to the rest of the network if
     ; the spending transaction wasn't downloaded yet, and it can be marked as spent when in reality the rest of the
     ; network believes it to be unspent if the signature or script connecting to it was not actually valid.
     ;;
    #_public
    (§ method boolean isAvailableForSpending())
    (ß
        (§ return availableForSpending)
    )

    ;;;
     ; The backing script bytes which can be turned into a Script object.
     ; @return the scriptBytes
    ;;
    #_public
    (§ method byte[] getScriptBytes())
    (ß
        (§ return scriptBytes)
    )

    ;;;
     ; Returns true if this output is to a key, or an address we have the keys for, in the wallet.
     ;;
    #_public
    (§ method boolean isMine(TransactionBag transactionBag))
    (ß
        (§ try)
        (ß
            (§ var Script script = getScriptPubKey())
            (§ if (script.isSentToRawPubKey()))
                (§ return transactionBag.isPubKeyMine(script.getPubKey()))
            (§ if (script.isPayToScriptHash()))
                (§ return transactionBag.isPayToScriptHashMine(script.getPubKeyHash()))
            (§ return transactionBag.isPubKeyHashMine(script.getPubKeyHash()))
        )
        (§ catch (ScriptException e))
        (ß
            ;; Just means we didn't understand the output of this transaction: ignore it.
            (§ call log.debug("Could not parse tx {} output script: {}", (parent != nil) ? parent.getHash() :else "(no parent)", e.toString()))
            (§ return false)
        )
    )

    ;;;
     ; Returns a human readable debug string.
     ;;
    #_override
    #_public
    (§ method String toString())
    (ß
        (§ try)
        (ß
            (§ var Script script = getScriptPubKey())
            (§ var StringBuilder sb = new StringBuilder("TxOut of "))
            (§ call sb.append(Coin.valueOf(value).toFriendlyString()))
            (§ if (script.isSentToAddress() || script.isPayToScriptHash()))
                (§ call sb.append(" to ").append(script.getToAddress(params)))
            (§ elseif (script.isSentToRawPubKey()))
                (§ call sb.append(" to pubkey ").append(Utils.HEX.encode(script.getPubKey())))
            (§ elseif (script.isSentToMultiSig()))
                (§ call sb.append(" to multisig"))
            (§ else)
                (§ call sb.append(" (unknown type)"))
            (§ call sb.append(" script:").append(script))
            (§ return sb.toString())
        )
        (§ catch (ScriptException e))
        (ß
            (§ throw new RuntimeException(e))
        )
    )

    ;;;
     ; Returns the connected input.
     ;;
    #_nilable
    #_public
    (§ method TransactionInput getSpentBy())
    (ß
        (§ return spentBy)
    )

    ;;;
     ; Returns the transaction that owns this output.
     ;;
    #_nilable
    #_public
    (§ method Transaction getParentTransaction())
    (ß
        (§ return (Transaction)parent)
    )

    ;;;
     ; Returns the transaction hash that owns this output.
     ;;
    #_nilable
    #_public
    (§ method Sha256Hash getParentTransactionHash())
    (ß
        (§ return (parent != nil) ? parent.getHash() :else nil)
    )

    ;;;
     ; Returns the depth in blocks of the parent tx.
     ;
     ; <p>If the transaction appears in the top block, the depth is one.
     ; If it's anything else (pending, dead, unknown), then -1.</p>
     ; @return the tx depth or -1.
     ;;
    #_public
    (§ method int getParentTransactionDepthInBlocks())
    (ß
        (§ if (getParentTransaction() != nil))
        (ß
            (§ var TransactionConfidence confidence = getParentTransaction().getConfidence())
            (§ if (confidence.getConfidenceType() == TransactionConfidence.ConfidenceType.BUILDING))
                (§ return confidence.getDepthInBlocks())
        )
        (§ return -1)
    )

    ;;;
     ; Returns a new {@link TransactionOutPoint}, which is essentially a structure pointing to this output.
     ; Requires that this output is not detached.
     ;;
    #_public
    (§ method TransactionOutPoint getOutPointFor())
    (ß
        (§ return new TransactionOutPoint(params, getIndex(), getParentTransaction()))
    )

    ;;; Returns a copy of the output detached from its containing transaction, if need be. ;;
    #_public
    (§ method TransactionOutput duplicateDetached())
    (ß
        (§ return new TransactionOutput(params, nil, Coin.valueOf(value), org.spongycastle.util.Arrays.clone(scriptBytes)))
    )

    #_override
    #_public
    (§ method boolean equals(Object o))
    (ß
        (§ if (this == o))
            (§ return true)
        (§ if (o == nil || getClass() != o.getClass()))
            (§ return false)
        (§ var TransactionOutput other = (TransactionOutput)o)
        (§ return (value == other.value && (parent == nil || (parent == other.parent && getIndex() == other.getIndex())) && Arrays.equals(scriptBytes, other.scriptBytes)))
    )

    #_override
    #_public
    (§ method int hashCode())
    (ß
        (§ return Objects.hashCode(value, parent, Arrays.hashCode(scriptBytes)))
    )
)

#_(ns org.bitcoinj.core #_"TransactionOutputChanges"
    (:import [java.io IOException InputStream OutputStream]
             [java.util LinkedList List]))

;;;
 ; <p>TransactionOutputChanges represents a delta to the set of unspent outputs.  It used as a return value for
 ; {@link AbstractBlockChain#connectTransactions(int, Block)}.  It contains the full list of transaction outputs created
 ; and spent in a block.  It DOES contain outputs created that were spent later in the block, as those are needed for
 ; BIP30 (no duplicate txid creation if the previous one was not fully spent prior to this block) verification.</p>
 ;;
#_public
(§ class TransactionOutputChanges
    #_public
    #_final
    (§ field List<UTXO> txOutsCreated)
    #_public
    #_final
    (§ field List<UTXO> txOutsSpent)

    #_public
    (§ constructor TransactionOutputChanges(List<UTXO> txOutsCreated, List<UTXO> txOutsSpent))
    (ß
        (§ ass this.txOutsCreated = txOutsCreated)
        (§ ass this.txOutsSpent = txOutsSpent)
    )

    #_private
    #_static
    #_final
    (§ method int read4x8le(InputStream is))
        (§ throws IOException)
    (ß
        (§ return (is.read() & 0xff) | ((is.read() & 0xff) << 8) | ((is.read() & 0xff) << 16) | ((is.read() & 0xff) << 24))
    )

    #_public
    (§ constructor TransactionOutputChanges(InputStream is))
        (§ throws IOException)
    (ß
        (§ var int nCreated = read4x8le(is))
        (§ ass txOutsCreated = new LinkedList<>())
        (§ for (int i = 0 :for i < nCreated :for i = i + 1))
            (§ call txOutsCreated.add(new UTXO(is)))

        (§ var int nSpent = read4x8le(is))
        (§ ass txOutsSpent = new LinkedList<>())
        (§ for (int i = 0 :for i < nSpent :for i = i + 1))
            (§ call txOutsSpent.add(new UTXO(is)))
    )

    #_private
    #_static
    #_final
    (§ method void write4x8le(OutputStream os, int n))
        (§ throws IOException)
    (ß
        (§ call os.write(0xff & n))
        (§ call os.write(0xff & (n >> 8)))
        (§ call os.write(0xff & (n >> 16)))
        (§ call os.write(0xff & (n >> 24)))
    )

    #_public
    (§ method void serializeToStream(OutputStream os))
        (§ throws IOException)
    (ß
        (§ call write4x8le(os, txOutsCreated.size()))
        (§ for (UTXO output :for txOutsCreated))
            (§ call output.serializeToStream(os))

        (§ call write4x8le(os, txOutsSpent.size()))
        (§ for (UTXO output :for txOutsSpent))
            (§ call output.serializeToStream(os))
    )
)

#_(ns org.bitcoinj.core #_"TxConfidenceTable"
    (:import #_[java.lang.ref *]
             #_[java.util *]
             #_[java.util.concurrent.locks *])
    (:import [com.google.common.base Preconditions])
  #_(:require #_[org.bitcoinj.utils *]))

;;;
 ; <p>Tracks transactions that are being announced across the network.  Typically one is created for you by a
 ; {@link PeerGroup} and then given to each Peer to update.  The current purpose is to let Peers update the confidence
 ; (number of peers broadcasting).  It helps address an attack scenario in which a malicious remote peer (or several)
 ; feeds you invalid transactions, e.g. ones that spend coins which don't exist.  If you don't see most of the peers
 ; announce the transaction within a reasonable time, it may be that the TX is not valid.  Alternatively, an attacker
 ; may control your entire internet connection: in this scenario counting broadcasting peers does not help you.</p>
 ;
 ; <p>It is <b>not</b> at this time directly equivalent to the Bitcoin Core memory pool, which tracks
 ; all transactions not currently included in the best chain - it's simply a cache.</p>
 ;;
#_public
(§ class TxConfidenceTable
    #_protected
    (§ field ReentrantLock lock = Threading.lock("txconfidencetable"))

    #_private
    #_static
    (§ class WeakConfidenceReference extends WeakReference<TransactionConfidence>
        #_public
        (§ field Sha256Hash hash)

        #_public
        (§ constructor WeakConfidenceReference(TransactionConfidence confidence, ReferenceQueue<TransactionConfidence> queue))
        (ß
            (§ super (confidence, queue))

            (§ ass hash = confidence.getTransactionHash())
        )
    )
    #_private
    (§ field LinkedHashMap<Sha256Hash, WeakConfidenceReference> table)

    ;; This ReferenceQueue gets entries added to it when they are only weakly reachable, i.e. the TxConfidenceTable is
    ;; the only thing that is tracking the confidence data anymore.  We check it from time to time and delete table entries
    ;; corresponding to expired transactions.  In this way memory usage of the system is in line with however many
    ;; transactions you actually care to track the confidence of.  We can still end up with lots of hashes being stored
    ;; if our peers flood us with invs but the MAX_SIZE param caps this.
    #_private
    (§ field ReferenceQueue<TransactionConfidence> referenceQueue)

    ;;; The max size of a table created with the no-args constructor. ;;
    #_public
    #_static
    #_final
    (§ field int MAX_SIZE = 1000)

    ;;;
     ; Creates a table that will track at most the given number of transactions (allowing you to bound memory usage).
     ; @param size Max number of transactions to track.  The table will fill up to this size then stop growing.
     ;;
    #_public
    (§ constructor TxConfidenceTable(#_final int size))
    (ß
        (§ ass table = new LinkedHashMap<Sha256Hash, WeakConfidenceReference>()
        (ß
            #_override
            #_protected
            (§ method boolean removeEldestEntry(Map.Entry<Sha256Hash, WeakConfidenceReference> entry))
            (ß
                ;; An arbitrary choice to stop the memory used by tracked transactions getting too huge in the event
                ;; of some kind of DoS attack.
                (§ return (size < size()))
            )
        ))
        (§ ass referenceQueue = new ReferenceQueue<>())
    )

    ;;;
     ; Creates a table that will track at most {@link TxConfidenceTable#MAX_SIZE} entries.
     ; You should normally use this constructor.
     ;;
    #_public
    (§ constructor TxConfidenceTable())
    (ß
        (§ this (MAX_SIZE))
    )

    ;;;
     ; If any transactions have expired due to being only weakly reachable through us, go ahead and delete their
     ; table entries - it means we downloaded the transaction and sent it to various event listeners, none of
     ; which bothered to keep a reference.  Typically, this is because the transaction does not involve any keys
     ; that are relevant to any of our wallets.
     ;;
    #_private
    (§ method void cleanTable())
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ var Reference<? extends TransactionConfidence> ref)
            (§ while ((ref = referenceQueue.poll()) != nil))
            (ß
                ;; Find which transaction got deleted by the GC.
                (§ var WeakConfidenceReference txRef = (WeakConfidenceReference)ref)
                ;; And remove the associated map entry, so the other bits of memory can also be reclaimed.
                (§ call table.remove(txRef.hash))
            )
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Returns the number of peers that have seen the given hash recently.
     ;;
    #_public
    (§ method int numBroadcastPeers(Sha256Hash txHash))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ call cleanTable())
            (§ var WeakConfidenceReference entry = table.get(txHash))
            (§ if (entry == nil))
                (§ return 0) ;; No such TX known.

            (§ var TransactionConfidence confidence = entry.get())
            (§ if (confidence == nil))
            (ß
                ;; Such a TX hash was seen, but nothing seemed to care, so we ended up throwing away the data.
                (§ call table.remove(txHash))
                (§ return 0)
            )

            (§ return confidence.numBroadcastPeers())
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Called by peers when they see a transaction advertised in an "inv" message.  It passes the data on to the relevant
     ; {@link org.bitcoinj.core.TransactionConfidence} object, creating it if needed.
     ;
     ; @return the number of peers that have now announced this hash (including the caller).
     ;;
    #_public
    (§ method TransactionConfidence seen(Sha256Hash hash, PeerAddress byPeer))
    (ß
        (§ var TransactionConfidence confidence)
        (§ var boolean fresh = false)
        (§ call lock.lock())
        (ß
            (§ call cleanTable())
            (§ ass confidence = getOrCreate(hash))
            (§ ass fresh = confidence.markBroadcastBy(byPeer))
        )
        (§ call lock.unlock())
        (§ if (fresh))
            (§ call confidence.queueListeners(TransactionConfidence.Listener.ChangeReason.SEEN_PEERS))
        (§ return confidence)
    )

    ;;;
     ; Returns the {@link TransactionConfidence} for the given hash if we have downloaded it, or null if that tx hash
     ; is unknown to the system at this time.
     ;;
    #_public
    (§ method TransactionConfidence getOrCreate(Sha256Hash hash))
    (ß
        (§ call Preconditions.checkNotNull(hash))

        (§ call lock.lock())
        (§ try)
        (ß
            (§ var WeakConfidenceReference reference = table.get(hash))
            (§ if (reference != nil))
            (ß
                (§ var TransactionConfidence confidence = reference.get())
                (§ if (confidence != nil))
                    (§ return confidence)
            )
            (§ var TransactionConfidence newConfidence = new TransactionConfidence(hash))
            (§ call table.put(hash, new WeakConfidenceReference(newConfidence, referenceQueue)))
            (§ return newConfidence)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Returns the {@link TransactionConfidence} for the given hash if we have downloaded it, or null if that tx hash
     ; is unknown to the system at this time.
     ;;
    #_nilable
    #_public
    (§ method TransactionConfidence get(Sha256Hash hash))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ var WeakConfidenceReference ref = table.get(hash))
            (§ return (ref != nil) ? ref.get() :else nil)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )
)

#_(ns org.bitcoinj.core #_"UTXO"
    (:import #_[java.io *]
             #_[java.math *]
             [java.util Locale])
    (:import [com.google.common.base Objects])
  #_(:require #_[org.bitcoinj.script *]))

;; TODO: Fix this class: should not talk about addresses, height should be optional/support mempool height etc.

;;;
 ; A UTXO message contains the information necessary to check a spending transaction.
 ; It avoids having to store the entire parentTransaction just to get the hash and index.
 ; Useful when working with free standing outputs.
 ;;
#_public
(§ class UTXO implements Serializable
    #_private
    (§ field Coin value)
    #_private
    (§ field Script script)
    #_private
    (§ field Sha256Hash hash)
    #_private
    (§ field long index)
    #_private
    (§ field int height)
    #_private
    (§ field boolean coinbase)
    #_private
    (§ field String address)

    ;;;
     ; Creates a stored transaction output.
     ;
     ; @param hash     The hash of the containing transaction.
     ; @param index    The outpoint.
     ; @param value    The value available.
     ; @param height   The height this output was created in.
     ; @param coinbase The coinbase flag.
     ;;
    #_public
    (§ constructor UTXO(Sha256Hash hash, long index, Coin value, int height, boolean coinbase, Script script))
    (ß
        (§ ass this.hash = hash)
        (§ ass this.index = index)
        (§ ass this.value = value)
        (§ ass this.height = height)
        (§ ass this.script = script)
        (§ ass this.coinbase = coinbase)
        (§ ass this.address = "")
    )

    ;;;
     ; Creates a stored transaction output.
     ;
     ; @param hash     The hash of the containing transaction.
     ; @param index    The outpoint.
     ; @param value    The value available.
     ; @param height   The height this output was created in.
     ; @param coinbase The coinbase flag.
     ; @param address  The address.
     ;;
    #_public
    (§ constructor UTXO(Sha256Hash hash, long index, Coin value, int height, boolean coinbase, Script script, String address))
    (ß
        (§ this (hash, index, value, height, coinbase, script))
        (§ ass this.address = address)
    )

    #_public
    (§ constructor UTXO(InputStream in))
        (§ throws IOException)
    (ß
        (§ call deserializeFromStream(in))
    )

    ;;; The value which this Transaction output holds. ;;
    #_public
    (§ method Coin getValue())
    (ß
        (§ return value)
    )

    ;;; The Script object which you can use to get address, script bytes or script type. ;;
    #_public
    (§ method Script getScript())
    (ß
        (§ return script)
    )

    ;;; The hash of the transaction which holds this output. ;;
    #_public
    (§ method Sha256Hash getHash())
    (ß
        (§ return hash)
    )

    ;;; The index of this output in the transaction which holds it. ;;
    #_public
    (§ method long getIndex())
    (ß
        (§ return index)
    )

    ;;; Gets the height of the block that created this output. ;;
    #_public
    (§ method int getHeight())
    (ß
        (§ return height)
    )

    ;;; Gets the flag of whether this was created by a coinbase tx. ;;
    #_public
    (§ method boolean isCoinbase())
    (ß
        (§ return coinbase)
    )

    ;;; The address of this output, can be the empty string if none was provided at construction time or was deserialized. ;;
    #_public
    (§ method String getAddress())
    (ß
        (§ return address)
    )

    #_override
    #_public
    (§ method String toString())
    (ß
        (§ return String.format(Locale.US, "Stored TxOut of %s (%s:%d)", value.toFriendlyString(), hash, index))
    )

    #_override
    #_public
    (§ method int hashCode())
    (ß
        (§ return Objects.hashCode(getIndex(), getHash()))
    )

    #_override
    #_public
    (§ method boolean equals(Object o))
    (ß
        (§ if (this == o))
            (§ return true)
        (§ if (o == nil || getClass() != o.getClass()))
            (§ return false)
        (§ var UTXO other = (UTXO)o)
        (§ return (getIndex() == other.getIndex() && getHash().equals(other.getHash())))
    )

    #_private
    #_static
    #_final
    (§ method void write4x8le(OutputStream os, int n))
        (§ throws IOException)
    (ß
        (§ call os.write(0xff & n))
        (§ call os.write(0xff & (n >> 8)))
        (§ call os.write(0xff & (n >> 16)))
        (§ call os.write(0xff & (n >> 24)))
    )

    #_public
    (§ method void serializeToStream(OutputStream os))
        (§ throws IOException)
    (ß
        (§ call Utils.uint64ToByteStreamLE(BigInteger.valueOf(value.value), os))

        (§ var byte[] scriptBytes = script.getProgram())
        (§ call write4x8le(os, scriptBytes.length))
        (§ call os.write(scriptBytes))

        (§ call os.write(hash.getBytes()))
        (§ call Utils.uint32ToByteStreamLE(index, os))

        (§ call write4x8le(os, height))
        (§ call os.write(new byte[] (ß (byte)(coinbase ? 1 :else 0) )))
    )

    #_private
    #_static
    #_final
    (§ method int read4x8le(InputStream is))
        (§ throws IOException)
    (ß
        (§ return (is.read() & 0xff) | ((is.read() & 0xff) << 8) | ((is.read() & 0xff) << 16) | ((is.read() & 0xff) << 24))
    )

    #_public
    (§ method void deserializeFromStream(InputStream is))
        (§ throws IOException)
    (ß
        (§ var byte[] valueBytes = new byte[8])
        (§ if (is.read(valueBytes, 0, 8) != 8))
            (§ throw new EOFException())
        (§ ass value = Coin.valueOf(Utils.readInt64(valueBytes, 0)))

        (§ var int scriptBytesLength = read4x8le(is))
        (§ var byte[] scriptBytes = new byte[scriptBytesLength])
        (§ if (is.read(scriptBytes) != scriptBytesLength))
            (§ throw new EOFException())
        (§ ass script = new Script(scriptBytes))

        (§ var byte[] hashBytes = new byte[32])
        (§ if (is.read(hashBytes) != 32))
            (§ throw new EOFException())
        (§ ass hash = Sha256Hash.wrap(hashBytes))

        (§ var byte[] indexBytes = new byte[4])
        (§ if (is.read(indexBytes) != 4))
            (§ throw new EOFException())
        (§ ass index = Utils.readUint32(indexBytes, 0))

        (§ ass height = read4x8le(is))

        (§ var byte[] coinbaseByte = new byte[1])
        (§ call is.read(coinbaseByte))
        (§ ass coinbase = (coinbaseByte[0] == 1))
    )

    #_private
    (§ method void writeObject(ObjectOutputStream o))
        (§ throws IOException)
    (ß
        (§ call serializeToStream(o))
    )

    #_private
    (§ method void readObject(ObjectInputStream o))
        (§ throws IOException, ClassNotFoundException)
    (ß
        (§ call deserializeFromStream(o))
    )
)

#_(ns org.bitcoinj.core #_"UnknownMessage")

;;;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class UnknownMessage extends EmptyMessage
    #_private
    (§ field String name)

    #_public
    (§ constructor UnknownMessage(NetworkParameters params, String name, byte[] payloadBytes))
        (§ throws ProtocolException)
    (ß
        (§ super (params, payloadBytes, 0))

        (§ ass this.name = name)
    )

    #_override
    #_public
    (§ method String toString())
    (ß
        (§ return "Unknown message [" + name + "]: " + (payload != nil ? Utils.HEX.encode(payload) :else ""))
    )
)

#_(ns org.bitcoinj.core #_"UnsafeByteArrayOutputStream"
    (:import [java.io ByteArrayOutputStream IOException OutputStream]))

;;;
 ; An unsynchronized implementation of ByteArrayOutputStream that will return the backing byte array
 ; if its length == size().  This avoids unneeded array copy where the BOS is simply being used to
 ; extract a byte array of known length from a 'serialized to stream' method.
 ;
 ; Unless the final length can be accurately predicted the only performance this will yield is due
 ; to unsynchronized methods.
 ;
 ; @author git
 ;;
#_public
(§ class UnsafeByteArrayOutputStream extends ByteArrayOutputStream
    #_public
    (§ constructor UnsafeByteArrayOutputStream())
    (ß
        (§ super (32))
    )

    #_public
    (§ constructor UnsafeByteArrayOutputStream(int size))
    (ß
        (§ super (size))
    )

    ;;;
     ; Writes the specified byte to this byte array output stream.
     ;
     ; @param b The byte to be written.
     ;;
    #_override
    #_public
    (§ method void write(int b))
    (ß
        (§ var int n = count + 1)
        (§ if (buf.length < n))
            (§ ass buf = Utils.copyOf(buf, Math.max(buf.length << 1, n)))
        (§ ass buf[count] = (byte)b)
        (§ ass count = n)
    )

    ;;;
     ; Writes <code>len</code> bytes from the specified byte array
     ; starting at offset <code>off</code> to this byte array output stream.
     ;
     ; @param b   The data.
     ; @param off The start offset in the data.
     ; @param len The number of bytes to write.
     ;;
    #_override
    #_public
    (§ method void write(byte[] b, int off, int len))
    (ß
        (§ if (off < 0 || b.length < off || len < 0 || b.length < off + len || off + len < 0))
            (§ throw new IndexOutOfBoundsException())

        (§ if (len != 0))
        (ß
            (§ var int n = count + len)
            (§ if (buf.length < n))
                (§ ass buf = Utils.copyOf(buf, Math.max(buf.length << 1, n)))
            (§ call System.arraycopy(b, off, buf, count, len))
            (§ ass count = n)
        )
    )

    ;;;
     ; Writes the complete contents of this byte array output stream to
     ; the specified output stream argument, as if by calling the output
     ; stream's write method using <code>out.write(buf, 0, count)</code>.
     ;
     ; @param out The output stream to which to write the data.
     ; @throws IOException if an I/O error occurs.
     ;;
    #_override
    #_public
    (§ method void writeTo(OutputStream out))
        (§ throws IOException)
    (ß
        (§ call out.write(buf, 0, count))
    )

    ;;;
     ; Resets the <code>count</code> field of this byte array output
     ; stream to zero, so that all currently accumulated output in the
     ; output stream is discarded.  The output stream can be used again,
     ; reusing the already allocated buffer space.
     ;
     ; @see java.io.ByteArrayInputStream#count
     ;;
    #_override
    #_public
    (§ method void reset())
    (ß
        (§ ass count = 0)
    )

    ;;;
     ; Creates a newly allocated byte array.  Its size is the current
     ; size of this output stream and the valid contents of the buffer
     ; have been copied into it.
     ;
     ; @return the current contents of this output stream, as a byte array.
     ; @see java.io.ByteArrayOutputStream#size()
     ;;
    #_override
    #_public
    (§ method byte[] toByteArray())
    (ß
        (§ return (count == buf.length) ? buf :else Utils.copyOf(buf, count))
    )

    ;;;
     ; Returns the current size of the buffer.
     ;
     ; @return the value of the <code>count</code> field, which is the number
     ;         of valid bytes in this output stream.
     ; @see java.io.ByteArrayOutputStream#count
     ;;
    #_override
    #_public
    (§ method int size())
    (ß
        (§ return count)
    )
)

#_(ns org.bitcoinj.core #_"Utils"
    (:import [java.io ByteArrayOutputStream IOException InputStream OutputStream UnsupportedEncodingException]
             [java.math BigInteger]
             [java.net URL]
             [java.text DateFormat SimpleDateFormat]
             #_[java.util *]
             [java.util.concurrent ArrayBlockingQueue BlockingQueue TimeUnit])
    (:import [com.google.common.base Charsets Joiner Preconditions]
             [com.google.common.collect Lists Ordering]
             [com.google.common.io BaseEncoding Resources]
             [com.google.common.primitives Ints UnsignedLongs]
             #_static #_[com.google.common.util.concurrent.Uninterruptibles sleepUninterruptibly]
             [org.spongycastle.crypto.digests RIPEMD160Digest]))

;;;
 ; A collection of various utility methods that are helpful for working with the Bitcoin protocol.
 ; To enable debug logging from the library, run with -Dbitcoinj.logging=true on your command line.
 ;;
#_public
(§ class Utils
    ;;; The string that prefixes all text messages signed using Bitcoin keys. ;;
    #_public
    #_static
    #_final
    (§ field String BITCOIN_SIGNED_MESSAGE_HEADER = "Bitcoin Signed Message:\n")
    #_public
    #_static
    #_final
    (§ field byte[] BITCOIN_SIGNED_MESSAGE_HEADER_BYTES = BITCOIN_SIGNED_MESSAGE_HEADER.getBytes(Charsets.UTF_8))

    #_public
    #_static
    #_final
    (§ field Joiner SPACE_JOINER = Joiner.on(" "))

    #_private
    #_static
    (§ field BlockingQueue<Boolean> mockSleepQueue)

    ;;;
     ; The regular {@link java.math.BigInteger#toByteArray()} includes the sign bit of the number and
     ; might result in an extra byte addition.  This method removes this extra byte.
     ;
     ; Assuming only positive numbers, it's possible to discriminate if an extra byte
     ; is added by checking if the first element of the array is 0 (0000_0000).
     ; Due to the minimal representation provided by BigInteger, it means that the bit sign
     ; is the least significant bit 0000_000<b>0</b>.  Otherwise the representation is not minimal.
     ; For example, if the sign bit is 0000_00<b>0</b>0, then the representation is not minimal due to the rightmost zero.
     ;
     ; @param b The integer to format into a byte array.
     ; @param numBytes The desired size of the resulting byte array.
     ; @return numBytes byte long array.
     ;;
    #_public
    #_static
    (§ method byte[] bigIntegerToBytes(BigInteger b, int numBytes))
    (ß
        (§ call Preconditions.checkArgument(0 <= b.signum(), "b must be positive or zero"))
        (§ call Preconditions.checkArgument(0 < numBytes, "numBytes must be positive"))

        (§ var byte[] src = b.toByteArray())
        (§ var byte[] dest = new byte[numBytes])
        (§ var boolean isFirstByteOnlyForSign = (src[0] == 0))
        (§ var int length = isFirstByteOnlyForSign ? src.length - 1 :else src.length)

        (§ call Preconditions.checkArgument(length <= numBytes, "The given number does not fit in " + numBytes))

        (§ var int srcPos = isFirstByteOnlyForSign ? 1 :else 0)
        (§ var int destPos = numBytes - length)
        (§ call System.arraycopy(src, srcPos, dest, destPos, length))
        (§ return dest)
    )

    #_public
    #_static
    (§ method void uint32ToByteArrayBE(long val, byte[] out, int offset))
    (ß
        (§ ass out[offset] = (byte)(0xff & (val >> 24)))
        (§ ass out[offset + 1] = (byte)(0xff & (val >> 16)))
        (§ ass out[offset + 2] = (byte)(0xff & (val >> 8)))
        (§ ass out[offset + 3] = (byte)(0xff & val))
    )

    #_public
    #_static
    (§ method void uint32ToByteArrayLE(long val, byte[] out, int offset))
    (ß
        (§ ass out[offset] = (byte)(0xff & val))
        (§ ass out[offset + 1] = (byte)(0xff & (val >> 8)))
        (§ ass out[offset + 2] = (byte)(0xff & (val >> 16)))
        (§ ass out[offset + 3] = (byte)(0xff & (val >> 24)))
    )

    #_public
    #_static
    (§ method void uint64ToByteArrayLE(long val, byte[] out, int offset))
    (ß
        (§ ass out[offset] = (byte)(0xff & val))
        (§ ass out[offset + 1] = (byte)(0xff & (val >> 8)))
        (§ ass out[offset + 2] = (byte)(0xff & (val >> 16)))
        (§ ass out[offset + 3] = (byte)(0xff & (val >> 24)))
        (§ ass out[offset + 4] = (byte)(0xff & (val >> 32)))
        (§ ass out[offset + 5] = (byte)(0xff & (val >> 40)))
        (§ ass out[offset + 6] = (byte)(0xff & (val >> 48)))
        (§ ass out[offset + 7] = (byte)(0xff & (val >> 56)))
    )

    #_public
    #_static
    (§ method void uint32ToByteStreamLE(long val, OutputStream stream))
        (§ throws IOException)
    (ß
        (§ call stream.write((int)(0xff & val)))
        (§ call stream.write((int)(0xff & (val >> 8))))
        (§ call stream.write((int)(0xff & (val >> 16))))
        (§ call stream.write((int)(0xff & (val >> 24))))
    )

    #_public
    #_static
    (§ method void int64ToByteStreamLE(long val, OutputStream stream))
        (§ throws IOException)
    (ß
        (§ call stream.write((int)(0xff & val)))
        (§ call stream.write((int)(0xff & (val >> 8))))
        (§ call stream.write((int)(0xff & (val >> 16))))
        (§ call stream.write((int)(0xff & (val >> 24))))
        (§ call stream.write((int)(0xff & (val >> 32))))
        (§ call stream.write((int)(0xff & (val >> 40))))
        (§ call stream.write((int)(0xff & (val >> 48))))
        (§ call stream.write((int)(0xff & (val >> 56))))
    )

    #_public
    #_static
    (§ method void uint64ToByteStreamLE(BigInteger val, OutputStream stream))
        (§ throws IOException)
    (ß
        (§ var byte[] bytes = val.toByteArray())
        (§ if (8 < bytes.length))
            (§ throw new RuntimeException("Input too large to encode into a uint64"))

        (§ ass bytes = reverseBytes(bytes))
        (§ call stream.write(bytes))
        (§ if (bytes.length < 8))
            (§ for (int i = 0 :for i < 8 - bytes.length :for i = i + 1))
                (§ call stream.write(0))
    )

    ;;;
     ; Work around lack of unsigned types in Java.
     ;;
    #_public
    #_static
    (§ method boolean isLessThanUnsigned(long n1, long n2))
    (ß
        (§ return (UnsignedLongs.compare(n1, n2) < 0))
    )

    ;;;
     ; Work around lack of unsigned types in Java.
     ;;
    #_public
    #_static
    (§ method boolean isLessThanOrEqualToUnsigned(long n1, long n2))
    (ß
        (§ return (UnsignedLongs.compare(n1, n2) <= 0))
    )

    ;;;
     ; Hex encoding used throughout the framework.  Use with HEX.encode(byte[]) or HEX.decode(CharSequence).
     ;;
    #_public
    #_static
    #_final
    (§ field BaseEncoding HEX = BaseEncoding.base16().lowerCase())

    ;;;
     ; Returns a copy of the given byte array in reverse order.
     ;;
    #_public
    #_static
    (§ method byte[] reverseBytes(byte[] bytes))
    (ß
        ;; We could use the XOR trick here, but it's easier to understand if we don't.
        ;; If we find this is really a performance issue, the matter can be revisited.
        (§ var byte[] buf = new byte[bytes.length])
        (§ for (int i = 0 :for i < bytes.length :for i = i + 1))
            (§ ass buf[i] = bytes[bytes.length - 1 - i])
        (§ return buf)
    )

    ;;;
     ; Returns a copy of the given byte array with the bytes of each double-word (4 bytes) reversed.
     ;
     ; @param bytes Length must be divisible by 4.
     ; @param trimLength Trim output to this length.  If positive, must be divisible by 4.
     ;;
    #_public
    #_static
    (§ method byte[] reverseDwordBytes(byte[] bytes, int trimLength))
    (ß
        (§ call Preconditions.checkArgument(bytes.length % 4 == 0))
        (§ call Preconditions.checkArgument(trimLength < 0 || trimLength % 4 == 0))

        (§ var byte[] rev = new byte[(0 <= trimLength && trimLength < bytes.length) ? trimLength :else bytes.length])

        (§ for (int i = 0 :for i < rev.length :for i = i + 4))
        (ß
            (§ call System.arraycopy(bytes, i, rev, i , 4))
            (§ for (int j = 0 :for j < 4 :for j = j + 1))
                (§ ass rev[i + j] = bytes[i + 3 - j])
        )
        (§ return rev)
    )

    ;;; Parse 4 bytes from the byte array (starting at the offset) as unsigned 32-bit integer in little endian format. ;;
    #_public
    #_static
    (§ method long readUint32(byte[] bytes, int offset))
    (ß
        (§ return (bytes[offset] & 0xff) | ((bytes[offset + 1] & 0xff) << 8) | ((bytes[offset + 2] & 0xff) << 16) | ((bytes[offset + 3] & 0xff) << 24))
    )

    ;;; Parse 8 bytes from the byte array (starting at the offset) as signed 64-bit integer in little endian format. ;;
    #_public
    #_static
    (§ method long readInt64(byte[] bytes, int offset))
    (ß
        (§ return (bytes[offset] & 0xff) | ((bytes[offset + 1] & 0xff) << 8) | ((bytes[offset + 2] & 0xff) << 16) | ((bytes[offset + 3] & 0xff) << 24) | ((bytes[offset + 4] & 0xff) << 32) | ((bytes[offset + 5] & 0xff) << 40) | ((bytes[offset + 6] & 0xff) << 48) | ((bytes[offset + 7] & 0xff) << 56))
    )

    ;;; Parse 4 bytes from the byte array (starting at the offset) as unsigned 32-bit integer in big endian format. ;;
    #_public
    #_static
    (§ method long readUint32BE(byte[] bytes, int offset))
    (ß
        (§ return ((bytes[offset] & 0xff) << 24) |  ((bytes[offset + 1] & 0xff) << 16) |  ((bytes[offset + 2] & 0xff) << 8) |   (bytes[offset + 3] & 0xff))
    )

    ;;; Parse 2 bytes from the byte array (starting at the offset) as unsigned 16-bit integer in big endian format. ;;
    #_public
    #_static
    (§ method int readUint16BE(byte[] bytes, int offset))
    (ß
        (§ return ((bytes[offset] & 0xff) << 8) |   (bytes[offset + 1] & 0xff))
    )

    ;;;
     ; Calculates RIPEMD160(SHA256(input)).  This is used in Address calculations.
     ;;
    #_public
    #_static
    (§ method byte[] sha256hash160(byte[] input))
    (ß
        (§ var byte[] sha256 = Sha256Hash.hash(input))
        (§ var RIPEMD160Digest digest = new RIPEMD160Digest())
        (§ call digest.update(sha256, 0, sha256.length))
        (§ var byte[] out = new byte[20])
        (§ call digest.doFinal(out, 0))
        (§ return out)
    )

    ;;;
     ; MPI encoded numbers are produced by the OpenSSL BN_bn2mpi function.  They consist of
     ; a 4 byte big endian length field, followed by the stated number of bytes representing
     ; the number in big endian format (with a sign bit).
     ; @param hasLength can be set to false if the given array is missing the 4 byte length field.
     ;;
    #_public
    #_static
    (§ method BigInteger decodeMPI(byte[] mpi, boolean hasLength))
    (ß
        (§ var byte[] buf)
        (§ if (hasLength))
        (ß
            (§ var int length = (int)readUint32BE(mpi, 0))
            (§ ass buf = new byte[length])
            (§ call System.arraycopy(mpi, 4, buf, 0, length))
        )
        (§ else)
            (§ ass buf = mpi)
        (§ if (buf.length == 0))
            (§ return BigInteger.ZERO)

        (§ var boolean isNegative = ((buf[0] & 0x80) == 0x80))
        (§ if (isNegative))
            (§ ass buf[0] = buf[0] & 0x7f)
        (§ var BigInteger result = new BigInteger(buf))
        (§ return isNegative ? result.negate() :else result)
    )

    ;;;
     ; MPI encoded numbers are produced by the OpenSSL BN_bn2mpi function.  They consist of
     ; a 4 byte big endian length field, followed by the stated number of bytes representing
     ; the number in big endian format (with a sign bit).
     ; @param includeLength indicates whether the 4 byte length field should be included.
     ;;
    #_public
    #_static
    (§ method byte[] encodeMPI(BigInteger value, boolean includeLength))
    (ß
        (§ if (value.equals(BigInteger.ZERO)))
            (§ return includeLength ? new byte[] (ß 0x00, 0x00, 0x00, 0x00 ) :else new byte[] (ß ))

        (§ var boolean isNegative = (value.signum() < 0))
        (§ if (isNegative))
            (§ ass value = value.negate())
        (§ var byte[] array = value.toByteArray())
        (§ var int length = array.length)
        (§ if ((array[0] & 0x80) == 0x80))
            (§ ass length = length + 1)

        (§ if (includeLength))
        (ß
            (§ var byte[] result = new byte[length + 4])
            (§ call System.arraycopy(array, 0, result, length - array.length + 3, array.length))
            (§ call uint32ToByteArrayBE(length, result, 0))
            (§ if (isNegative))
                (§ ass result[4] = result[4] | 0x80)
            (§ return result)
        )
        (§ else)
        (ß
            (§ var byte[] result)
            (§ if (length != array.length))
            (ß
                (§ ass result = new byte[length])
                (§ call System.arraycopy(array, 0, result, 1, array.length))
            )
            (§ else)
                (§ ass result = array)
            (§ if (isNegative))
                (§ ass result[0] = result[0] | 0x80)
            (§ return result)
        )
    )

    ;;;
     ; <p>The "compact" format is a representation of a whole number N using an unsigned 32 bit number similar to
     ; a floating point format.  The most significant 8 bits are the unsigned exponent of base 256.  This exponent
     ; can be thought of as "number of bytes of N".  The lower 23 bits are the mantissa.  Bit number 24 (0x800000)
     ; represents the sign of N.  Therefore, N = (-1^sign) * mantissa * 256^(exponent-3).</p>
     ;
     ; <p>Satoshi's original implementation used BN_bn2mpi() and BN_mpi2bn().  MPI uses the most significant bit of
     ; the first byte as sign.  Thus 0x1234560000 is compact 0x05123456 and 0xc0de000000 is compact 0x0600c0de.
     ; Compact 0x05c0de00 would be -0x40de000000.</p>
     ;
     ; <p>Bitcoin only uses this "compact" format for encoding difficulty targets, which are unsigned 256bit quantities.
     ; Thus, all the complexities of the sign bit and using base 256 are probably an implementation accident.</p>
     ;;
    #_public
    #_static
    (§ method BigInteger decodeCompactBits(long compact))
    (ß
        (§ var int size = ((int)(compact >> 24)) & 0xff)
        (§ var byte[] bytes = new byte[4 + size])
        (§ ass bytes[3] = (byte)size)
        (§ if (1 <= size))
            (§ ass bytes[4] = (byte)((compact >> 16) & 0xff))
        (§ if (2 <= size))
            (§ ass bytes[5] = (byte)((compact >> 8) & 0xff))
        (§ if (3 <= size))
            (§ ass bytes[6] = (byte)(compact & 0xff))
        (§ return decodeMPI(bytes, true))
    )

    ;;;
     ; @see Utils#decodeCompactBits(long)
     ;;
    #_public
    #_static
    (§ method long encodeCompactBits(BigInteger value))
    (ß
        (§ var long result)
        (§ var int size = value.toByteArray().length)
        (§ if (size <= 3))
            (§ ass result = value.longValue() << 8 * (3 - size))
        (§ else)
            (§ ass result = value.shiftRight(8 * (size - 3)).longValue())
        ;; The 0x00800000 bit denotes the sign.
        ;; Thus, if it is already set, divide the mantissa by 256 and increase the exponent.
        (§ if ((result & 0x00800000) != 0))
        (ß
            (§ ass result = result >> 8)
            (§ ass size = size + 1)
        )
        (§ ass result = result | (size << 24))
        (§ ass result = result | (value.signum() == -1 ? 0x00800000 :else 0))
        (§ return result)
    )

    ;;;
     ; If non-null, overrides the return value of now().
     ;;
    #_public
    #_static
    #_volatile
    (§ field Date mockTime)

    ;;;
     ; Advances (or rewinds) the mock clock by the given number of seconds.
     ;;
    #_public
    #_static
    (§ method Date rollMockClock(int seconds))
    (ß
        (§ return rollMockClockMillis(seconds * 1000))
    )

    ;;;
     ; Advances (or rewinds) the mock clock by the given number of milliseconds.
     ;;
    #_public
    #_static
    (§ method Date rollMockClockMillis(long millis))
    (ß
        (§ if (mockTime == nil))
            (§ throw new IllegalStateException("You need to use setMockClock() first."))

        (§ ass mockTime = new Date(mockTime.getTime() + millis))
        (§ return mockTime)
    )

    ;;;
     ; Sets the mock clock to the current time.
     ;;
    #_public
    #_static
    (§ method void setMockClock())
    (ß
        (§ ass mockTime = new Date())
    )

    ;;;
     ; Sets the mock clock to the given time (in seconds).
     ;;
    #_public
    #_static
    (§ method void setMockClock(long mockClockSeconds))
    (ß
        (§ ass mockTime = new Date(mockClockSeconds * 1000))
    )

    ;;;
     ; Returns the current time, or a mocked out equivalent.
     ;;
    #_public
    #_static
    (§ method Date now())
    (ß
        (§ return (mockTime != nil) ? mockTime :else new Date())
    )

    ;; TODO: Replace usages of this where the result is / 1000 with currentTimeSeconds.
    ;;; Returns the current time in milliseconds since the epoch, or a mocked out equivalent. ;;
    #_public
    #_static
    (§ method long currentTimeMillis())
    (ß
        (§ return (mockTime != nil) ? mockTime.getTime() :else System.currentTimeMillis())
    )

    #_public
    #_static
    (§ method long currentTimeSeconds())
    (ß
        (§ return currentTimeMillis() / 1000)
    )

    #_private
    #_static
    #_final
    (§ field TimeZone UTC = TimeZone.getTimeZone("UTC"))

    ;;;
     ; Formats a given date+time value to an ISO 8601 string.
     ; @param dateTime value to format, as a Date
     ;;
    #_public
    #_static
    (§ method String dateTimeFormat(Date dateTime))
    (ß
        (§ var DateFormat iso8601 = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.US))
        (§ call iso8601.setTimeZone(UTC))
        (§ return iso8601.format(dateTime))
    )

    ;;;
     ; Formats a given date+time value to an ISO 8601 string.
     ; @param dateTime value to format, unix time (ms)
     ;;
    #_public
    #_static
    (§ method String dateTimeFormat(long dateTime))
    (ß
        (§ var DateFormat iso8601 = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.US))
        (§ call iso8601.setTimeZone(UTC))
        (§ return iso8601.format(dateTime))
    )

    #_public
    #_static
    (§ method byte[] copyOf(byte[] in, int length))
    (ß
        (§ var byte[] out = new byte[length])
        (§ call System.arraycopy(in, 0, out, 0, Math.min(length, in.length)))
        (§ return out)
    )

    ;;;
     ; Creates a copy of bytes and appends b to the end of it.
     ;;
    #_public
    #_static
    (§ method byte[] appendByte(byte[] bytes, byte b))
    (ß
        (§ var byte[] result = Arrays.copyOf(bytes, bytes.length + 1))
        (§ ass result[result.length - 1] = b)
        (§ return result)
    )

    ;;;
     ; Constructs a new String by decoding the given bytes using the specified charset.
     ;
     ; This is a convenience method which wraps the checked exception with a RuntimeException.
     ; The exception can never occur given the charsets
     ; US-ASCII, ISO-8859-1, UTF-8, UTF-16, UTF-16LE or UTF-16BE.
     ;
     ; @param bytes The bytes to be decoded into characters.
     ; @param charsetName The name of a supported {@linkplain java.nio.charset.Charset charset}.
     ; @return the decoded String.
     ;;
    #_public
    #_static
    (§ method String toString(byte[] bytes, String charsetName))
    (ß
        (§ try)
        (ß
            (§ return new String(bytes, charsetName))
        )
        (§ catch (UnsupportedEncodingException e))
        (ß
            (§ throw new RuntimeException(e))
        )
    )

    ;;;
     ; Encodes the given string into a sequence of bytes using the named charset.
     ;
     ; This is a convenience method which wraps the checked exception with a RuntimeException.
     ; The exception can never occur given the charsets
     ; US-ASCII, ISO-8859-1, UTF-8, UTF-16, UTF-16LE or UTF-16BE.
     ;
     ; @param str The string to encode into bytes.
     ; @param charsetName The name of a supported {@linkplain java.nio.charset.Charset charset}.
     ; @return the encoded bytes.
     ;;
    #_public
    #_static
    (§ method byte[] toBytes(CharSequence str, String charsetName))
    (ß
        (§ try)
        (ß
            (§ return str.toString().getBytes(charsetName))
        )
        (§ catch (UnsupportedEncodingException e))
        (ß
            (§ throw new RuntimeException(e))
        )
    )

    ;;;
     ; Attempts to parse the given string as arbitrary-length hex or base58 and then return the results,
     ; or null if neither parse was successful.
     ;;
    #_public
    #_static
    (§ method byte[] parseAsHexOrBase58(String data))
    (ß
        (§ try)
        (ß
            (§ return HEX.decode(data))
        )
        (§ catch (Exception _))
        (ß
            ;; Didn't decode as hex, try base58.
            (§ try)
            (ß
                (§ return Base58.decodeChecked(data))
            )
            (§ catch (AddressFormatException __))
            (ß
                (§ return nil)
            )
        )
    )

    #_public
    #_static
    (§ method boolean isWindows())
    (ß
        (§ return System.getProperty("os.name").toLowerCase().contains("win"))
    )

    ;;;
     ; <p>Given a textual message, returns a byte buffer formatted as follows:</p>
     ;
     ; <p><tt>[24] "Bitcoin Signed Message:\n" [message.length as a varint] message</tt>.</p>
     ;;
    #_public
    #_static
    (§ method byte[] formatMessageForSigning(String message))
    (ß
        (§ try)
        (ß
            (§ var ByteArrayOutputStream bos = new ByteArrayOutputStream())
            (§ call bos.write(BITCOIN_SIGNED_MESSAGE_HEADER_BYTES.length))
            (§ call bos.write(BITCOIN_SIGNED_MESSAGE_HEADER_BYTES))
            (§ var byte[] messageBytes = message.getBytes(Charsets.UTF_8))
            (§ var VarInt size = new VarInt(messageBytes.length))
            (§ call bos.write(size.encode()))
            (§ call bos.write(messageBytes))
            (§ return bos.toByteArray())
        )
        (§ catch (IOException e))
        (ß
            (§ throw new RuntimeException(e)) ;; Cannot happen.
        )
    )

    ;; 00000001, 00000010, 00000100, 00001000, ...
    #_private
    #_static
    #_final
    (§ field int[] bitMask = (ß 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80 ))

    ;;; Checks if the given bit is set in data, using little endian (not the same as Java native big endian). ;;
    #_public
    #_static
    (§ method boolean checkBitLE(byte[] data, int index))
    (ß
        (§ return ((data[index >>> 3] & bitMask[7 & index]) != 0))
    )

    ;;; Sets the given bit in data to one, using little endian (not the same as Java native big endian). ;;
    #_public
    #_static
    (§ method void setBitLE(byte[] data, int index))
    (ß
        (§ ass data[index >>> 3] = data[index >>> 3] | bitMask[7 & index])
    )

    ;;; Sleep for a span of time, or mock sleep if enabled. ;;
    #_public
    #_static
    (§ method void sleep(long millis))
    (ß
        (§ if (mockSleepQueue == nil))
        (ß
            (§ call sleepUninterruptibly(millis, TimeUnit.MILLISECONDS))
        )
        (§ else)
        (ß
            (§ try)
            (ß
                (§ var boolean isMultiPass = mockSleepQueue.take())
                (§ call rollMockClockMillis(millis))
                (§ if (isMultiPass))
                    (§ call mockSleepQueue.offer(true))
            )
            (§ catch (InterruptedException _))
            (ß
                ;; Ignored.
            )
        )
    )

    ;;; Enable or disable mock sleep.  If enabled, set mock time to current time. ;;
    #_public
    #_static
    (§ method void setMockSleep(boolean isEnable))
    (ß
        (§ if (isEnable))
        (ß
            (§ ass mockSleepQueue = new ArrayBlockingQueue<>(1))
            (§ ass mockTime = new Date(System.currentTimeMillis()))
        )
        (§ else)
        (ß
            (§ ass mockSleepQueue = nil)
        )
    )

    ;;; Let sleeping thread pass the synchronization point. ;;
    #_public
    #_static
    (§ method void passMockSleep())
    (ß
        (§ call mockSleepQueue.offer(false))
    )

    ;;; Let the sleeping thread pass the synchronization point any number of times. ;;
    #_public
    #_static
    (§ method void finishMockSleep())
    (ß
        (§ if (mockSleepQueue != nil))
            (§ call mockSleepQueue.offer(true))
    )

    #_private
    #_static
    (§ field int isAndroid = -1)
    #_public
    #_static
    (§ method boolean isAndroidRuntime())
    (ß
        (§ if (isAndroid == -1))
        (ß
            #_final
            (§ var String runtime = System.getProperty("java.runtime.name"))
            (§ ass isAndroid = (runtime != nil && runtime.equals("Android Runtime")) ? 1 :else 0)
        )
        (§ return (isAndroid == 1))
    )

    #_private
    #_static
    (§ class Pair implements Comparable<Pair>
        (§ var int item, count)

        #_public
        (§ constructor Pair(int item, int count))
        (ß
            (§ ass this.count = count)
            (§ ass this.item = item)
        )

        ;; Note that in this implementation compareTo() is not consistent with equals().
        #_override
        #_public
        (§ method int compareTo(Pair o))
        (ß
            (§ return -Ints.compare(count, o.count))
        )
    )

    #_public
    #_static
    (§ method int maxOfMostFreq(int... items))
    (ß
        ;; Java 6 sucks.
        (§ var ArrayList<Integer> list = new ArrayList<>(items.length))
        (§ for (int item :for items))
            (§ call list.add(item))
        (§ return maxOfMostFreq(list))
    )

    #_public
    #_static
    (§ method int maxOfMostFreq(List<Integer> items))
    (ß
        (§ if (items.isEmpty()))
            (§ return 0)

        ;; This would be much easier in a functional language (or in Java 8).
        (§ ass items = Ordering.natural().reverse().sortedCopy(items))
        (§ var LinkedList<Pair> pairs = Lists.newLinkedList())
        (§ call pairs.add(new Pair(items.get(0), 0)))
        (§ for (int item :for items))
        (ß
            (§ var Pair pair = pairs.getLast())
            (§ if (pair.item != item))
                (§ ass pairs.add((pair = new Pair(item, 0))))
            (§ ass pair.count = pair.count + 1)
        )
        ;; pairs now contains a uniqified list of the sorted inputs, with counts for how often that item appeared.
        ;; Now sort by how frequently they occur, and pick the max of the most frequent.
        (§ call Collections.sort(pairs))
        (§ var int maxCount = pairs.getFirst().count)
        (§ var int maxItem = pairs.getFirst().item)
        (§ for (Pair pair :for pairs))
        (ß
            (§ if (pair.count != maxCount))
                (§ break)
            (§ ass maxItem = Math.max(maxItem, pair.item))
        )
        (§ return maxItem)
    )

    ;;;
     ; Reads and joins together with LF char (\n) all the lines from given file.
     ; It's assumed that file is in UTF-8.
     ;;
    #_public
    #_static
    (§ method String getResourceAsString(URL url))
        (§ throws IOException)
    (ß
        (§ var List<String> lines = Resources.readLines(url, Charsets.UTF_8))
        (§ return Joiner.on("\n").join(lines))
    )

    ;; Can't use Closeable here because it's Java 7 only and Android devices only got that with KitKat.
    #_public
    #_static
    (§ method InputStream closeUnchecked(InputStream stream))
    (ß
        (§ try)
        (ß
            (§ call stream.close())
            (§ return stream)
        )
        (§ catch (IOException e))
        (ß
            (§ throw new RuntimeException(e))
        )
    )

    #_public
    #_static
    (§ method OutputStream closeUnchecked(OutputStream stream))
    (ß
        (§ try)
        (ß
            (§ call stream.close())
            (§ return stream)
        )
        (§ catch (IOException e))
        (ß
            (§ throw new RuntimeException(e))
        )
    )
)

#_(ns org.bitcoinj.core #_"VarInt")

;;;
 ; A variable-length encoded unsigned integer using Satoshi's encoding (a.k.a. "CompactSize").
 ;;
#_public
(§ class VarInt
    #_public
    #_final
    (§ field long value)
    #_private
    #_final
    (§ field int originallyEncodedSize)

    ;;;
     ; Constructs a new VarInt with the given unsigned long value.
     ;
     ; @param value the unsigned long value (beware widening conversion of negatives!)
     ;;
    #_public
    (§ constructor VarInt(long value))
    (ß
        (§ ass this.value = value)
        (§ ass originallyEncodedSize = getSizeInBytes())
    )

    ;;;
     ; Constructs a new VarInt with the value parsed from the specified offset of the given buffer.
     ;
     ; @param buf The buffer containing the value.
     ; @param offset The offset of the value.
     ;;
    #_public
    (§ constructor VarInt(byte[] buf, int offset))
    (ß
        (§ var int first = 0xff & buf[offset])
        (§ if (first < 253))
        (ß
            (§ ass value = first)
            (§ ass originallyEncodedSize = 1) ;; 1 data byte (8 bits)
        )
        (§ elseif (first == 253))
        (ß
            (§ ass value = (0xff & buf[offset + 1]) | ((0xff & buf[offset + 2]) << 8))
            (§ ass originallyEncodedSize = 3) ;; 1 marker + 2 data bytes (16 bits)
        )
        (§ elseif (first == 254))
        (ß
            (§ ass value = Utils.readUint32(buf, offset + 1))
            (§ ass originallyEncodedSize = 5) ;; 1 marker + 4 data bytes (32 bits)
        )
        (§ else)
        (ß
            (§ ass value = Utils.readInt64(buf, offset + 1))
            (§ ass originallyEncodedSize = 9) ;; 1 marker + 8 data bytes (64 bits)
        )
    )

    ;;;
     ; Returns the original number of bytes used to encode the value if it was
     ; deserialized from a byte array, or the minimum encoded size if it was not.
     ;;
    #_public
    (§ method int getOriginalSizeInBytes())
    (ß
        (§ return originallyEncodedSize)
    )

    ;;;
     ; Returns the minimum encoded size of the value.
     ;;
    #_public
    #_final
    (§ method int getSizeInBytes())
    (ß
        (§ return sizeOf(value))
    )

    ;;;
     ; Returns the minimum encoded size of the given unsigned long value.
     ;
     ; @param value the unsigned long value (beware widening conversion of negatives!)
     ;;
    #_public
    #_static
    (§ method int sizeOf(long value))
    (ß
        ;; if negative, it's actually a very large unsigned long value
        (§ if (value < 0))
            (§ return 9) ;; 1 marker + 8 data bytes
        (§ if (value < 253))
            (§ return 1) ;; 1 data byte
        (§ if (value <= 0xffff))
            (§ return 3) ;; 1 marker + 2 data bytes
        (§ if (value <= 0xffffffff))
            (§ return 5) ;; 1 marker + 4 data bytes
        (§ return 9) ;; 1 marker + 8 data bytes
    )

    ;;;
     ; Encodes the value into its minimal representation.
     ;
     ; @return the minimal encoded bytes of the value.
     ;;
    #_public
    (§ method byte[] encode())
    (ß
        (§ var byte[] bytes)
        (§ switch (sizeOf(value)))
        (ß
            (§ case 1)
                (§ return new byte[] (ß (byte)value ))
            (§ case 3)
                (§ return new byte[] (ß (byte)253, (byte)value, (byte)(value >> 8) ))
            (§ case 5)
                (§ ass bytes = new byte[5])
                (§ ass bytes[0] = (byte)254)
                (§ call Utils.uint32ToByteArrayLE(value, bytes, 1))
                (§ return bytes)
            (§ default)
                (§ ass bytes = new byte[9])
                (§ ass bytes[0] = (byte)255)
                (§ call Utils.uint64ToByteArrayLE(value, bytes, 1))
                (§ return bytes)
        )
    )
)

#_(ns org.bitcoinj.core #_"VerificationException")

#_public
(§ class VerificationException extends RuntimeException
    #_public
    (§ constructor VerificationException(String msg))
    (ß
        (§ super (msg))
    )

    #_public
    (§ constructor VerificationException(Exception e))
    (ß
        (§ super (e))
    )

    #_public
    (§ constructor VerificationException(String msg, Throwable t))
    (ß
        (§ super (msg, t))
    )

    #_public
    #_static
    (§ class EmptyInputsOrOutputs extends VerificationException
        #_public
        (§ constructor EmptyInputsOrOutputs())
        (ß
            (§ super ("Transaction had no inputs or no outputs."))
        )
    )

    #_public
    #_static
    (§ class LargerThanMaxBlockSize extends VerificationException
        #_public
        (§ constructor LargerThanMaxBlockSize())
        (ß
            (§ super ("Transaction larger than MAX_BLOCK_SIZE"))
        )
    )

    #_public
    #_static
    (§ class DuplicatedOutPoint extends VerificationException
        #_public
        (§ constructor DuplicatedOutPoint())
        (ß
            (§ super ("Duplicated outpoint"))
        )
    )

    #_public
    #_static
    (§ class NegativeValueOutput extends VerificationException
        #_public
        (§ constructor NegativeValueOutput())
        (ß
            (§ super ("Transaction output negative"))
        )
    )

    #_public
    #_static
    (§ class ExcessiveValue extends VerificationException
        #_public
        (§ constructor ExcessiveValue())
        (ß
            (§ super ("Total transaction output value greater than possible"))
        )
    )

    #_public
    #_static
    (§ class CoinbaseScriptSizeOutOfRange extends VerificationException
        #_public
        (§ constructor CoinbaseScriptSizeOutOfRange())
        (ß
            (§ super ("Coinbase script size out of range"))
        )
    )

    #_public
    #_static
    (§ class BlockVersionOutOfDate extends VerificationException
        #_public
        (§ constructor BlockVersionOutOfDate(#_final long version))
        (ß
            (§ super ("Block version #" + version + " is outdated."))
        )
    )

    #_public
    #_static
    (§ class UnexpectedCoinbaseInput extends VerificationException
        #_public
        (§ constructor UnexpectedCoinbaseInput())
        (ß
            (§ super ("Coinbase input as input in non-coinbase transaction"))
        )
    )

    #_public
    #_static
    (§ class CoinbaseHeightMismatch extends VerificationException
        #_public
        (§ constructor CoinbaseHeightMismatch(#_final String message))
        (ß
            (§ super (message))
        )
    )
)

#_(ns org.bitcoinj.core #_"VersionAck")

;;;
 ; <p>The verack message, sent by a client accepting the version message they
 ; received from their peer.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class VersionAck extends EmptyMessage
    #_public
    (§ constructor VersionAck())
    (ß
    )

    ;; this is needed by the BitcoinSerializer
    #_public
    (§ constructor VersionAck(NetworkParameters params, byte[] payload))
    (ß
    )
)

#_(ns org.bitcoinj.core #_"VersionMessage"
    (:import [java.io IOException OutputStream]
             [java.math BigInteger]
             [java.net InetAddress UnknownHostException]
             [java.util Locale])
    (:import [com.google.common.base Objects]
             [com.google.common.net InetAddresses]))

;;;
 ; <p>A VersionMessage holds information exchanged during connection setup with another peer.  Most of the fields are
 ; not particularly interesting.  The subVer field, since BIP 14, acts as a User-Agent string would.  You can and should
 ; append to or change the subVer for your own software so other implementations can identify it, and you can look at
 ; the subVer field received from other nodes to see what they are running.</p>
 ;
 ; <p>After creating yourself a VersionMessage, you can pass it to {@link PeerGroup#setVersionMessage(VersionMessage)}
 ; to ensure it will be used for each new connection.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class VersionMessage extends Message
    ;;; The version of this library release, as a string. ;;
    #_public
    #_static
    #_final
    (§ field String BITCOINJ_VERSION = "0.15-SNAPSHOT")
    ;;; The value that is prepended to the subVer field of this application. ;;
    #_public
    #_static
    #_final
    (§ field String LIBRARY_SUBVER = "/bitcoinj:" + BITCOINJ_VERSION + "/")

    ;;; A services flag that denotes whether the peer has a copy of the block chain or not. ;;
    #_public
    #_static
    #_final
    (§ field int NODE_NETWORK = 1)

    ;;;
     ; The version number of the protocol spoken.
     ;;
    #_public
    (§ field int clientVersion)
    ;;;
     ; Flags defining what optional services are supported.
     ;;
    #_public
    (§ field long localServices)
    ;;;
     ; What the other side believes the current time to be, in seconds.
     ;;
    #_public
    (§ field long time)
    ;;;
     ; What the other side believes the address of this program is.  Not used.
     ;;
    #_public
    (§ field PeerAddress myAddr)
    ;;;
     ; What the other side believes their own address is.  Not used.
     ;;
    #_public
    (§ field PeerAddress theirAddr)
    ;;;
     ; User-Agent as defined in <a href="https://github.com/bitcoin/bips/blob/master/bip-0014.mediawiki">BIP 14</a>.
     ; Bitcoin Core sets it to something like "/Satoshi:0.9.1/".
     ;;
    #_public
    (§ field String subVer)
    ;;;
     ; How many blocks are in the chain, according to the other side.
     ;;
    #_public
    (§ field long bestHeight)
    ;;;
     ; Whether or not to relay tx invs before a filter is received.
     ; See <a href="https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki#extensions-to-existing-messages">BIP 37</a>.
     ;;
    #_public
    (§ field boolean relayTxesBeforeFilter)

    #_public
    (§ constructor VersionMessage(NetworkParameters params, byte[] payload))
        (§ throws ProtocolException)
    (ß
        (§ super (params, payload, 0))
    )

    ;; It doesn't really make sense to ever lazily parse a version message or to retain the backing bytes.
    ;; If you're receiving this on the wire you need to check the protocol version and it will never need
    ;; to be sent back down the wire.

    #_public
    (§ constructor VersionMessage(NetworkParameters params, int newBestHeight))
    (ß
        (§ super (params))

        (§ ass clientVersion = params.getProtocolVersionNum(NetworkParameters.ProtocolVersion.CURRENT))
        (§ ass localServices = 0)
        (§ ass time = System.currentTimeMillis() / 1000)
        ;; Note that the Bitcoin Core doesn't do anything with these, and finding out your own external IP address
        ;; is kind of tricky anyway, so we just put nonsense here for now.
        (§ var InetAddress localhost = InetAddresses.forString("127.0.0.1"))
        (§ ass myAddr = new PeerAddress(params, localhost, params.getPort(), 0, BigInteger.ZERO))
        (§ ass theirAddr = new PeerAddress(params, localhost, params.getPort(), 0, BigInteger.ZERO))
        (§ ass subVer = LIBRARY_SUBVER)
        (§ ass bestHeight = newBestHeight)
        (§ ass relayTxesBeforeFilter = true)

        (§ ass length = 85)
        (§ if (31402 < protocolVersion))
            (§ ass length = length + 8)
        (§ ass length = length + VarInt.sizeOf(subVer.length()) + subVer.length())
    )

    #_override
    #_protected
    (§ method void parse())
        (§ throws ProtocolException)
    (ß
        (§ ass clientVersion = (int)readUint32())
        (§ ass localServices = readUint64().longValue())
        (§ ass time = readUint64().longValue())
        (§ ass myAddr = new PeerAddress(params, payload, cursor, 0))
        (§ ass cursor = cursor + myAddr.getMessageSize())
        (§ ass theirAddr = new PeerAddress(params, payload, cursor, 0))
        (§ ass cursor = cursor + theirAddr.getMessageSize())
        ;; uint64 localHostNonce (random data)
        ;; We don't care about the localhost nonce.  It's used to detect connecting back to yourself in cases where
        ;; there are NATs and proxies in the way.  However we don't listen for inbound connections so it's irrelevant.
        (§ call readUint64())
        (§ try)
        (ß
            ;; Initialize default values for flags which may not be sent by old nodes.
            (§ ass subVer = "")
            (§ ass bestHeight = 0)
            (§ ass relayTxesBeforeFilter = true)
            (§ if (!hasMoreBytes()))
                (§ return)

            ;; string subVer (currently "")
            (§ ass subVer = readStr())
            (§ if (!hasMoreBytes()))
                (§ return)

            ;; int bestHeight (size of known block chain)
            (§ ass bestHeight = readUint32())
            (§ if (!hasMoreBytes()))
                (§ return)

            (§ ass relayTxesBeforeFilter = (readBytes(1)[0] != 0))
        )
        (§ finally)
        (ß
            (§ ass length = cursor - offset)
        )
    )

    #_override
    #_public
    (§ method void bitcoinSerializeToStream(OutputStream buf))
        (§ throws IOException)
    (ß
        (§ call Utils.uint32ToByteStreamLE(clientVersion, buf))
        (§ call Utils.uint32ToByteStreamLE(localServices, buf))
        (§ call Utils.uint32ToByteStreamLE(localServices >> 32, buf))
        (§ call Utils.uint32ToByteStreamLE(time, buf))
        (§ call Utils.uint32ToByteStreamLE(time >> 32, buf))
        (§ try)
        (ß
            ;; My address.
            (§ call myAddr.bitcoinSerialize(buf))
            ;; Their address.
            (§ call theirAddr.bitcoinSerialize(buf))
        )
        (§ catch (UnknownHostException e))
        (ß
            (§ throw new RuntimeException(e)) ;; Can't happen.
        )
        (§ catch (IOException e))
        (ß
            (§ throw new RuntimeException(e)) ;; Can't happen.
        )
        ;; Next up is the "local host nonce", this is to detect the case of connecting back to yourself.
        ;; We don't care about this as we won't be accepting inbound connections.
        (§ call Utils.uint32ToByteStreamLE(0, buf))
        (§ call Utils.uint32ToByteStreamLE(0, buf))
        ;; Now comes subVer.
        (§ var byte[] subVerBytes = subVer.getBytes("UTF-8"))
        (§ call buf.write(new VarInt(subVerBytes.length).encode()))
        (§ call buf.write(subVerBytes))
        ;; Size of known block chain.
        (§ call Utils.uint32ToByteStreamLE(bestHeight, buf))
        (§ call buf.write(relayTxesBeforeFilter ? 1 :else 0))
    )

    ;;;
     ; Returns true if the version message indicates the sender has a full copy of the block chain,
     ; or if it's running in client mode (only has the headers).
     ;;
    #_public
    (§ method boolean hasBlockChain())
    (ß
        (§ return ((localServices & NODE_NETWORK) == NODE_NETWORK))
    )

    #_override
    #_public
    (§ method boolean equals(Object o))
    (ß
        (§ if (this == o))
            (§ return true)
        (§ if (o == nil || getClass() != o.getClass()))
            (§ return false)
        (§ var VersionMessage other = (VersionMessage)o)
        (§ return (other.bestHeight == bestHeight && other.clientVersion == clientVersion && other.localServices == localServices && other.time == time && other.subVer.equals(subVer) && other.myAddr.equals(myAddr) && other.theirAddr.equals(theirAddr) && other.relayTxesBeforeFilter == relayTxesBeforeFilter))
    )

    #_override
    #_public
    (§ method int hashCode())
    (ß
        (§ return Objects.hashCode(bestHeight, clientVersion, localServices, time, subVer, myAddr, theirAddr, relayTxesBeforeFilter))
    )

    #_override
    #_public
    (§ method String toString())
    (ß
        (§ var StringBuilder sb = new StringBuilder())
        (§ call sb.append("\n"))
        (§ call sb.append("client version: ").append(clientVersion).append("\n"))
        (§ call sb.append("local services: ").append(localServices).append("\n"))
        (§ call sb.append("time:           ").append(time).append("\n"))
        (§ call sb.append("my addr:        ").append(myAddr).append("\n"))
        (§ call sb.append("their addr:     ").append(theirAddr).append("\n"))
        (§ call sb.append("sub version:    ").append(subVer).append("\n"))
        (§ call sb.append("best height:    ").append(bestHeight).append("\n"))
        (§ call sb.append("delay tx relay: ").append(!relayTxesBeforeFilter).append("\n"))
        (§ return sb.toString())
    )

    #_public
    (§ method VersionMessage duplicate())
    (ß
        (§ var VersionMessage v = new VersionMessage(params, (int)bestHeight))
        (§ ass v.clientVersion = clientVersion)
        (§ ass v.localServices = localServices)
        (§ ass v.time = time)
        (§ ass v.myAddr = myAddr)
        (§ ass v.theirAddr = theirAddr)
        (§ ass v.subVer = subVer)
        (§ ass v.relayTxesBeforeFilter = relayTxesBeforeFilter)
        (§ return v)
    )

    ;;;
     ; Appends the given user-agent information to the subVer field.  The subVer is composed of a series of
     ; name:version pairs separated by slashes in the form of a path.  For example a typical subVer field for bitcoinj
     ; users might look like "/bitcoinj:0.13/MultiBit:1.2/" where libraries come further to the left.
     ;
     ; There can be as many components as you feel a need for, and the version string can be anything, but it is
     ; recommended to use A.B.C where A = major, B = minor and C = revision for software releases, and dates for
     ; auto-generated source repository snapshots.  A valid subVer begins and ends with a slash, therefore name
     ; and version are not allowed to contain such characters.
     ;
     ; Anything put in the "comments" field will appear in brackets and may be used for platform info, or anything
     ; else.  For example, calling <tt>appendToSubVer("MultiBit", "1.0", "Windows")</tt> will result in a subVer being
     ; set of "/bitcoinj:1.0/MultiBit:1.0(Windows)/".  Therefore the / ( and ) characters are reserved in all these
     ; components.  If you don't want to add a comment (recommended), pass null.
     ;
     ; See <a href="https://github.com/bitcoin/bips/blob/master/bip-0014.mediawiki">BIP 14</a> for more information.
     ;
     ; @param comments Optional (can be null) platform or other node specific information.
     ; @throws IllegalArgumentException if name, version or comments contains invalid characters.
     ;;
    #_public
    (§ method void appendToSubVer(String name, String version, #_nilable String comments))
    (ß
        (§ call checkSubVerComponent(name))
        (§ call checkSubVerComponent(version))

        (§ if (comments != nil))
        (ß
            (§ call checkSubVerComponent(comments))
            (§ ass subVer = subVer.concat(String.format(Locale.US, "%s:%s(%s)/", name, version, comments)))
        )
        (§ else)
        (ß
            (§ ass subVer = subVer.concat(String.format(Locale.US, "%s:%s/", name, version)))
        )
    )

    #_private
    #_static
    (§ method void checkSubVerComponent(String component))
    (ß
        (§ if (component.contains("/") || component.contains("(") || component.contains(")")))
            (§ throw new IllegalArgumentException("name contains invalid characters"))
    )

    ;;;
     ; Returns true if the clientVersion field is >= Pong.MIN_PROTOCOL_VERSION.  If it is then ping() is usable.
     ;;
    #_public
    (§ method boolean isPingPongSupported())
    (ß
        (§ return (params.getProtocolVersionNum(NetworkParameters.ProtocolVersion.PONG) <= clientVersion))
    )

    ;;;
     ; Returns true if the clientVersion field is >= FilteredBlock.MIN_PROTOCOL_VERSION.  If it is then Bloom filtering
     ; is available and the memory pool of the remote peer will be queried when the downloadData property is true.
     ;;
    #_public
    (§ method boolean isBloomFilteringSupported())
    (ß
        (§ return (params.getProtocolVersionNum(NetworkParameters.ProtocolVersion.BLOOM_FILTER) <= clientVersion))
    )
)

#_(ns org.bitcoinj.core #_"VersionedChecksummedBytes"
    (:import [java.io Serializable]
             [java.util Arrays])
    (:import [com.google.common.base Objects Preconditions]
             [com.google.common.primitives Ints UnsignedBytes]))

;;;
 ; <p>In Bitcoin the following format is often used to represent some type of key:</p>
 ;
 ; <pre>[one version byte] [data bytes] [4 checksum bytes]</pre>
 ;
 ; <p>and the result is then Base58 encoded.
 ; This format is used for addresses, and private keys exported using the dumpprivkey command.</p>
 ;;
#_public
(§ class VersionedChecksummedBytes implements Serializable, Cloneable, Comparable<VersionedChecksummedBytes>
    #_protected
    #_final
    (§ field int version)
    #_protected
    (§ field byte[] bytes)

    #_protected
    (§ constructor VersionedChecksummedBytes(String encoded))
        (§ throws AddressFormatException)
    (ß
        (§ var byte[] versionAndDataBytes = Base58.decodeChecked(encoded))
        (§ var byte versionByte = versionAndDataBytes[0])
        (§ ass version = versionByte & 0xff)
        (§ ass bytes = new byte[versionAndDataBytes.length - 1])
        (§ call System.arraycopy(versionAndDataBytes, 1, bytes, 0, versionAndDataBytes.length - 1))
    )

    #_protected
    (§ constructor VersionedChecksummedBytes(int version, byte[] bytes))
    (ß
        (§ call Preconditions.checkArgument(0 <= version && version < 256))

        (§ ass this.version = version)
        (§ ass this.bytes = bytes)
    )

    ;;;
     ; Returns the base-58 encoded String representation of this object,
     ; including version and checksum bytes.
     ;;
    #_public
    #_final
    (§ method String toBase58())
    (ß
        ;; A stringified buffer is: 1 byte version + data bytes + 4 bytes check code (a truncated hash).
        (§ var byte[] addressBytes = new byte[1 + bytes.length + 4])
        (§ ass addressBytes[0] = (byte)version)
        (§ call System.arraycopy(bytes, 0, addressBytes, 1, bytes.length))
        (§ var byte[] checksum = Sha256Hash.hashTwice(addressBytes, 0, bytes.length + 1))
        (§ call System.arraycopy(checksum, 0, addressBytes, bytes.length + 1, 4))
        (§ return Base58.encode(addressBytes))
    )

    #_override
    #_public
    (§ method String toString())
    (ß
        (§ return toBase58())
    )

    #_override
    #_public
    (§ method int hashCode())
    (ß
        (§ return Objects.hashCode(version, Arrays.hashCode(bytes)))
    )

    #_override
    #_public
    (§ method boolean equals(Object o))
    (ß
        (§ if (this == o))
            (§ return true)
        (§ if (o == nil || getClass() != o.getClass()))
            (§ return false)
        (§ var VersionedChecksummedBytes other = (VersionedChecksummedBytes)o)
        (§ return (this.version == other.version && Arrays.equals(this.bytes, other.bytes)))
    )

    ;;;
     ; {@inheritDoc}
     ;
     ; This implementation narrows the return type to <code>VersionedChecksummedBytes</code>
     ; and allows subclasses to throw <code>CloneNotSupportedException</code> even though it
     ; is never thrown by this implementation.
     ;;
    #_override
    #_public
    (§ method VersionedChecksummedBytes clone())
        (§ throws CloneNotSupportedException)
    (ß
        (§ return (VersionedChecksummedBytes)super.clone())
    )

    ;;;
     ; {@inheritDoc}
     ;
     ; This implementation uses an optimized Google Guava method to compare <code>bytes</code>.
     ;;
    #_override
    #_public
    (§ method int compareTo(VersionedChecksummedBytes o))
    (ß
        (§ var int result = Ints.compare(this.version, o.version))
        (§ return (result != 0) ? result :else UnsignedBytes.lexicographicalComparator().compare(this.bytes, o.bytes))
    )

    ;;;
     ; Returns the "version" or "header" byte: the first byte of the data.  This is used to disambiguate what
     ; the contents apply to, for example, which network the key or address is valid on.
     ;
     ; @return a positive number between 0 and 255.
     ;;
    #_public
    (§ method int getVersion())
    (ß
        (§ return version)
    )
)

#_(ns org.bitcoinj.core #_"WrongNetworkException"
    (:import [java.util Arrays]))

;;;
 ; This exception is thrown by the Address class when you try and decode an address with a version code that isn't
 ; used by that network.  You shouldn't allow the user to proceed in this case as they are trying to send money across
 ; different chains, an operation that is guaranteed to destroy the money.
 ;;
#_public
(§ class WrongNetworkException extends AddressFormatException
    ;;; The version code that was provided in the address. ;;
    #_public
    (§ field int verCode)
    ;;; The list of acceptable versions that were expected given the addresses network parameters. ;;
    #_public
    (§ field int[] acceptableVersions)

    #_public
    (§ constructor WrongNetworkException(int verCode, int[] acceptableVersions))
    (ß
        (§ super ("Version code of address did not match acceptable versions for network: " + verCode + " not in " + Arrays.toString(acceptableVersions)))

        (§ ass this.verCode = verCode)
        (§ ass this.acceptableVersions = acceptableVersions)
    )
)

#_(ns org.bitcoinj.core.listeners #_"AbstractPeerDataEventListener"
    (:import #_[java.util *])
  #_(:require #_[org.bitcoinj.core *]))

;;;
 ; Deprecated: implement the more specific event listener interfaces instead to fill out only what you need.
 ;;
#_deprecated
#_public
#_abstract
(§ class AbstractPeerDataEventListener implements PeerDataEventListener
    #_override
    #_public
    (§ method void onBlocksDownloaded(Peer peer, Block block, #_nilable FilteredBlock filteredBlock, int blocksLeft))
    (ß
    )

    #_override
    #_public
    (§ method void onChainDownloadStarted(Peer peer, int blocksLeft))
    (ß
    )

    #_override
    #_public
    (§ method Message onPreMessageReceived(Peer peer, Message m))
    (ß
        ;; Just pass the message right through for further processing.
        (§ return m)
    )

    #_override
    #_public
    (§ method List<Message> getData(Peer peer, GetDataMessage m))
    (ß
        (§ return nil)
    )
)

#_(ns org.bitcoinj.core.listeners #_"BlockChainListener")

;;;
 ; Old interface for backwards compatibility. Implement the more specific interfaces instead.
 ;;
#_deprecated
#_public
(§ interface BlockChainListener extends NewBestBlockListener, TransactionReceivedInBlockListener, ReorganizeListener)

#_(ns org.bitcoinj.core.listeners #_"BlocksDownloadedEventListener"
  #_(:require #_[org.bitcoinj.core *]))

;;;
 ; <p>Implementors can listen to events like blocks being downloaded/transactions being broadcast/connect/disconnects,
 ; they can pre-filter messages before they are procesesed by a {@link Peer} or {@link PeerGroup}, and they can
 ; provide transactions to remote peers when they ask for them.</p>
 ;;
#_public
(§ interface BlocksDownloadedEventListener
    ;; TODO: Fix the Block/FilteredBlock type hierarchy so we can avoid the stupid typeless API here.
    ;;;
     ; <p>Called on a Peer thread when a block is received.</p>
     ;
     ; <p>The block may be a Block object that contains transactions, a Block object that is only a header when
     ; fast catchup is being used.  If set, filteredBlock can be used to retrieve the list of associated transactions.</p>
     ;
     ; @param peer The peer receiving the block.
     ; @param block The downloaded block.
     ; @param filteredBlock If non-null, the object that wraps the block header passed as the block param.
     ; @param blocksLeft The number of blocks left to download.
     ;;
    (§ method void onBlocksDownloaded(Peer peer, Block block, #_nilable FilteredBlock filteredBlock, int blocksLeft))
)

#_(ns org.bitcoinj.core.listeners #_"ChainDownloadStartedEventListener"
  #_(:require #_[org.bitcoinj.core *]))

;;;
 ; <p>Implementors can listen to events like blocks being downloaded/transactions being broadcast/connect/disconnects,
 ; they can pre-filter messages before they are procesesed by a {@link Peer} or {@link PeerGroup}, and they can
 ; provide transactions to remote peers when they ask for them.</p>
 ;;
#_public
(§ interface ChainDownloadStartedEventListener
    ;;;
     ; Called when a download is started with the initial number of blocks to be downloaded.
     ;
     ; @param peer The peer receiving the block.
     ; @param blocksLeft The number of blocks left to download.
     ;;
    (§ method void onChainDownloadStarted(Peer peer, int blocksLeft))
)

#_(ns org.bitcoinj.core.listeners #_"DownloadProgressTracker"
    (:import [java.util Date Locale]
             [java.util.concurrent ExecutionException])
    (:import [com.google.common.util.concurrent ListenableFuture SettableFuture]
             [org.slf4j Logger LoggerFactory])
  #_(:require [org.bitcoinj.core Block FilteredBlock Peer Utils]))

;;;
 ; <p>An implementation of {@link AbstractPeerDataEventListener} that listens to chain download events and tracks
 ; progress as a percentage.  The default implementation prints progress to stdout, but you can subclass it and
 ; override the progress method to update a GUI instead.</p>
 ;;
#_public
(§ class DownloadProgressTracker extends AbstractPeerDataEventListener
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(DownloadProgressTracker.class))

    #_private
    (§ field int originalBlocksLeft = -1)
    #_private
    (§ field int lastPercent = 0)
    #_private
    (§ field SettableFuture<Long> future = SettableFuture.create())
    #_private
    (§ field boolean caughtUp = false)

    #_override
    #_public
    (§ method void onChainDownloadStarted(Peer peer, int blocksLeft))
    (ß
        (§ if (0 < blocksLeft && originalBlocksLeft == -1))
            (§ call startDownload(blocksLeft))
        ;; Only mark this the first time, because this method can be called more than once during a chain download
        ;; if we switch peers during it.
        (§ if (originalBlocksLeft == -1))
            (§ ass originalBlocksLeft = blocksLeft)
        (§ else)
            (§ call log.info("Chain download switched to {}", peer))
        (§ if (blocksLeft == 0))
        (ß
            (§ call doneDownload())
            (§ call future.set(peer.getBestHeight()))
        )
    )

    #_override
    #_public
    (§ method void onBlocksDownloaded(Peer peer, Block block, #_nilable FilteredBlock filteredBlock, int blocksLeft))
    (ß
        (§ if (caughtUp))
            (§ return)

        (§ if (blocksLeft == 0))
        (ß
            (§ ass caughtUp = true)
            (§ call doneDownload())
            (§ call future.set(peer.getBestHeight()))
        )

        (§ if (blocksLeft < 0 || originalBlocksLeft <= 0))
            (§ return)

        (§ var double pct = 100.0 - (100.0 * (blocksLeft / (double)originalBlocksLeft)))
        (§ if ((int)pct != lastPercent))
        (ß
            (§ call progress(pct, blocksLeft, new Date(block.getTimeSeconds() * 1000)))
            (§ ass lastPercent = (int)pct)
        )
    )

    ;;;
     ; Called when download progress is made.
     ;
     ; @param pct The percentage of chain downloaded, estimated.
     ; @param date The date of the last block downloaded.
     ;;
    #_protected
    (§ method void progress(double pct, int blocksSoFar, Date date))
    (ß
        (§ call log.info(String.format(Locale.US, "Chain download %d%% done with %d blocks to go, block date %s", (int)pct, blocksSoFar, Utils.dateTimeFormat(date))))
    )

    ;;;
     ; Called when download is initiated.
     ;
     ; @param blocks The number of blocks to download, estimated.
     ;;
    #_protected
    (§ method void startDownload(int blocks))
    (ß
        (§ call log.info("Downloading block chain of size " + blocks + ". " + (1000 < blocks ? "This may take a while." :else "")))
    )

    ;;;
     ; Called when we are done downloading the block chain.
     ;;
    #_protected
    (§ method void doneDownload())
    (ß
    )

    ;;;
     ; Wait for the chain to be downloaded.
     ;;
    #_public
    (§ method void await())
        (§ throws InterruptedException)
    (ß
        (§ try)
        (ß
            (§ call future.get())
        )
        (§ catch (ExecutionException e))
        (ß
            (§ throw new RuntimeException(e))
        )
    )

    ;;;
     ; Returns a listenable future that completes with the height of the best chain (as reported by the peer) once chain
     ; download seems to be finished.
     ;;
    #_public
    (§ method ListenableFuture<Long> getFuture())
    (ß
        (§ return future)
    )
)

#_(ns org.bitcoinj.core.listeners #_"GetDataEventListener"
    (:import #_[java.util *])
  #_(:require #_[org.bitcoinj.core *]))

;;;
 ; <p>Implementors can listen to events like blocks being downloaded/transactions being broadcast/connect/disconnects,
 ; they can pre-filter messages before they are procesesed by a {@link Peer} or {@link PeerGroup}, and they can
 ; provide transactions to remote peers when they ask for them.</p>
 ;;
#_public
(§ interface GetDataEventListener
    ;;;
     ; <p>Called when a peer receives a getdata message, usually in response to an "inv" being broadcast.  Return as many
     ; items as possible which appear in the {@link GetDataMessage}, or null if you're not interested in responding.</p>
     ;
     ; <p>Note that this will never be called if registered with any executor other than
     ; {@link org.bitcoinj.utils.Threading#SAME_THREAD}</p>
     ;;
    #_nilable
    (§ method List<Message> getData(Peer peer, GetDataMessage m))
)

#_(ns org.bitcoinj.core.listeners #_"NewBestBlockListener"
  #_(:require [org.bitcoinj.core StoredBlock VerificationException]))

;;;
 ; Listener interface for when a new block on the best chain is seen.
 ;;
#_public
(§ interface NewBestBlockListener
    ;;;
     ; Called when a new block on the best chain is seen, after relevant transactions are extracted and sent to us via either
     ; {@link TransactionReceivedInBlockListener#receiveFromBlock(org.bitcoinj.core.Transaction, org.bitcoinj.core.StoredBlock, org.bitcoinj.core.BlockChain.NewBlockType, int relativityOffset)}
     ; or {@link TransactionReceivedInBlockListener#notifyTransactionIsInBlock(org.bitcoinj.core.Sha256Hash, org.bitcoinj.core.StoredBlock, org.bitcoinj.core.BlockChain.NewBlockType, int)}.
     ;
     ; If this block is causing a re-organise to a new chain, this method is NOT
     ; called even though the block may be the new best block: your reorganize
     ; implementation is expected to do whatever would normally be done do for a
     ; new best block in this case.
     ;;
    (§ method void notifyNewBestBlock(#_final StoredBlock block))
        (§ throws VerificationException)
)

#_(ns org.bitcoinj.core.listeners #_"OnTransactionBroadcastListener"
  #_(:require #_[org.bitcoinj.core *]))

;;;
 ; Called when a new transaction is broadcast over the network.
 ;;
#_public
(§ interface OnTransactionBroadcastListener
    ;;;
     ; Called when a new transaction is broadcast over the network.
     ;;
    (§ method void onTransaction(Peer peer, Transaction t))
)

#_(ns org.bitcoinj.core.listeners #_"PeerConnectedEventListener"
  #_(:require [org.bitcoinj.core Peer]))

;;;
 ; <p>Implementors can listen to events indicating a new peer connecting.</p>
 ;;
#_public
(§ interface PeerConnectedEventListener
    ;;;
     ; Called when a peer is connected.  If this listener is registered to a {@link Peer} instead of a {@link PeerGroup},
     ; peerCount will always be 1.
     ;
     ; @param peer
     ; @param peerCount The total number of connected peers.
     ;;
    (§ method void onPeerConnected(Peer peer, int peerCount))
)

#_(ns org.bitcoinj.core.listeners #_"PeerDataEventListener"
  #_(:require #_[org.bitcoinj.core *]))

;;;
 ; <p>Implementors can listen to events like blocks being downloaded/transactions being broadcast/connect/disconnects,
 ; they can pre-filter messages before they are processed by a {@link Peer} or {@link PeerGroup}, and they can
 ; provide transactions to remote peers when they ask for them.</p>
 ;;
#_public
(§ interface PeerDataEventListener extends BlocksDownloadedEventListener, ChainDownloadStartedEventListener, GetDataEventListener, PreMessageReceivedEventListener)

#_(ns org.bitcoinj.core.listeners #_"PeerDisconnectedEventListener"
  #_(:require [org.bitcoinj.core Peer]))

;;;
 ; <p>Implementors can listen to events indicating a peer disconnecting.</p>
 ;;
#_public
(§ interface PeerDisconnectedEventListener
    ;;;
     ; Called when a peer is disconnected.  Note that this won't be called if the listener is registered on
     ; a {@link PeerGroup} and the group is in the process of shutting down.  If this listener is registered to
     ; a {@link Peer} instead of a {@link PeerGroup}, peerCount will always be 0.  This handler can be called
     ; without a corresponding invocation of onPeerConnected if the initial connection is never successful.
     ;
     ; @param peer
     ; @param peerCount The total number of connected peers.
     ;;
    (§ method void onPeerDisconnected(Peer peer, int peerCount))
)

#_(ns org.bitcoinj.core.listeners #_"PeerDiscoveredEventListener"
    (:import [java.util Set])
  #_(:require [org.bitcoinj.core Peer PeerAddress]))

;;;
 ; <p>Implementors can listen to events for peers being discovered.</p>
 ;;
#_public
(§ interface PeerDiscoveredEventListener
    ;;;
     ; <p>Called when peers are discovered, this happens at startup of {@link PeerGroup}
     ; or if we run out of suitable {@link Peer}s to connect to.</p>
     ;
     ; @param peerAddresses The set of discovered {@link PeerAddress}es.
     ;;
    (§ method void onPeersDiscovered(Set<PeerAddress> peerAddresses))
)

#_(ns org.bitcoinj.core.listeners #_"PreMessageReceivedEventListener"
  #_(:require #_[org.bitcoinj.core *]))

;;;
 ; <p>Implementors can listen to events like blocks being downloaded/transactions being broadcast/connect/disconnects,
 ; they can pre-filter messages before they are procesesed by a {@link Peer} or {@link PeerGroup}, and they can
 ; provide transactions to remote peers when they ask for them.</p>
 ;;
#_public
(§ interface PreMessageReceivedEventListener
    ;;;
     ; <p>Called when a message is received by a peer, before the message is processed.  The returned message is
     ; processed instead.  Returning null will cause the message to be ignored by the Peer returning the same message
     ; object allows you to see the messages received but not change them.  The result from one event listeners
     ; callback is passed as "m" to the next, forming a chain.</p>
     ;
     ; <p>Note that this will never be called if registered with any executor other than
     ; {@link org.bitcoinj.utils.Threading#SAME_THREAD}.</p>
     ;;
    (§ method Message onPreMessageReceived(Peer peer, Message m))
)

#_(ns org.bitcoinj.core.listeners #_"ReorganizeListener"
    (:import [java.util List])
  #_(:require [org.bitcoinj.core StoredBlock VerificationException]))

;;;
 ; Listener interface for when the best chain has changed.
 ;;
#_public
(§ interface ReorganizeListener
    ;;;
     ; Called by the {@link org.bitcoinj.core.BlockChain} when the best chain (representing total work done)
     ; has changed.  In this case, we need to go through our transactions and find out if any have become invalid.
     ; It's possible for our balance to go down in this case: money we thought we had can suddenly vanish
     ; if the rest of the network agrees it should be so.
     ;
     ; The oldBlocks/newBlocks lists are ordered height-wise from top first to bottom last (i.e. newest blocks first).
     ;;
    (§ method void reorganize(StoredBlock splitPoint, List<StoredBlock> oldBlocks, List<StoredBlock> newBlocks))
        (§ throws VerificationException)
)

#_(ns org.bitcoinj.core.listeners #_"TransactionConfidenceEventListener"
  #_(:require [org.bitcoinj.core Transaction]
             [org.bitcoinj.wallet Wallet]))

;;;
 ; <p>Implementors are called when confidence of a transaction changes.</p>
 ;;
#_public
(§ interface TransactionConfidenceEventListener
    ;;;
     ; <p>Called when a transaction changes its confidence level.  You can also attach event listeners to
     ; the individual transactions, if you don't care about all of them.  Usually you would save the wallet to disk
     ; after receiving this callback unless you already set up autosaving.</p>
     ;
     ; <p>You should pay attention to this callback in case a transaction becomes <i>dead</i>, that is, a transaction
     ; you believed to be active (send or receive) becomes overridden by the network.  This can happen if</p>
     ;
     ; <ol>
     ;     <li>You are sharing keys between wallets and accidentally create/broadcast a double spend.</li>
     ;     <li>Somebody is attacking the network and reversing transactions, i.e. the user is a victim of fraud.</li>
     ;     <li>A bug: for example you create a transaction, broadcast it but fail to commit it.
     ;     The {@link Wallet} will then re-use the same outputs when creating the next spend.</li>
     ; </ol>
     ;
     ; <p>To find if the transaction is dead, you can use <tt>tx.getConfidence().getConfidenceType() ==
     ; TransactionConfidence.ConfidenceType.DEAD</tt>.  If it is, you should notify the user in some way
     ; so they know the thing they bought may not arrive/the thing they sold should not be dispatched.</p>
     ;
     ; <p>Note that this callback will be invoked for every transaction in the wallet, for every new block that is
     ; received (because the depth has changed).  <b>If you want to update a UI view from the contents of the wallet
     ; it is more efficient to use onWalletChanged instead.</b></p>
     ;;
    (§ method void onTransactionConfidenceChanged(Wallet wallet, Transaction tx))
)

#_(ns org.bitcoinj.core.listeners #_"TransactionReceivedInBlockListener"
  #_(:require [org.bitcoinj.core BlockChain Sha256Hash StoredBlock Transaction VerificationException]))

;;;
 ; Listener interface for when we receive a new block that contains a relevant transaction.
 ;;
#_public
(§ interface TransactionReceivedInBlockListener
    ;;;
     ; <p>Called by the {@link BlockChain} when we receive a new block that contains a relevant transaction.</p>
     ;
     ; <p>A transaction may be received multiple times if is included into blocks in parallel chains.  The blockType
     ; parameter describes whether the containing block is on the main/best chain or whether it's on a presently
     ; inactive side chain.</p>
     ;
     ; <p>The relativityOffset parameter is an arbitrary number used to establish an ordering between transactions
     ; within the same block.  In the case where full blocks are being downloaded, it is simply the index of the
     ; transaction within that block.  When Bloom filtering is in use, we don't find out the exact offset into a block
     ; that a transaction occurred at, so the relativity count is not reflective of anything in an absolute sense but
     ; rather exists only to order the transaction relative to the others.</p>
     ;;
    (§ method void receiveFromBlock(Transaction tx, StoredBlock block, BlockChain.NewBlockType blockType, int relativityOffset))
        (§ throws VerificationException)

    ;;;
     ; <p>Called by the {@link BlockChain} when we receive a new {@link FilteredBlock} that contains the given
     ; transaction hash in its merkle tree.</p>
     ;
     ; <p>A transaction may be received multiple times if is included into blocks in parallel chains.  The blockType
     ; parameter describes whether the containing block is on the main/best chain or whether it's on a presently
     ; inactive side chain.</p>
     ;
     ; <p>The relativityOffset parameter in this case is an arbitrary (meaningless) number, that is useful only when
     ; compared to the relativity count of another transaction received inside the same block.  It is used to establish
     ; an ordering of transactions relative to one another.</p>
     ;
     ; <p>This method should return false if the given tx hash isn't known about, e.g. because the the transaction was
     ; a Bloom false positive.  If it was known about and stored, it should return true.  The caller may need to know
     ; this to calculate the effective FP rate.</p>
     ;
     ; @return whether the transaction is known about i.e. was considered relevant previously.
     ;;
    (§ method boolean notifyTransactionIsInBlock(Sha256Hash txHash, StoredBlock block, BlockChain.NewBlockType blockType, int relativityOffset))
        (§ throws VerificationException)
)

#_(ns org.bitcoinj.crypto #_"ChildNumber"
    (:import [java.util Locale])
    (:import [com.google.common.primitives Ints]))

;;;
 ; <p>This is just a wrapper for the i (child number) as per BIP 32 with a boolean getter for the most significant bit
 ; and a getter for the actual 0-based child number.  A {@link java.util.List} of these forms a <i>path</i> through a
 ; {@link DeterministicHierarchy}.  This class is immutable.
 ;;
#_public
(§ class ChildNumber implements Comparable<ChildNumber>
    ;;;
     ; The bit that's set in the child number to indicate whether this key is "hardened".  Given a hardened key, it is
     ; not possible to derive a child public key if you know only the hardened public key.  With a non-hardened key this
     ; is possible, so you can derive trees of public keys given only a public parent, but the downside is that it's
     ; possible to leak private keys if you disclose a parent public key and a child private key (elliptic curve maths
     ; allows you to work upwards).
     ;;
    #_public
    #_static
    #_final
    (§ field int HARDENED_BIT = 0x80000000)

    #_public
    #_static
    #_final
    (§ field ChildNumber ZERO = new ChildNumber(0))
    #_public
    #_static
    #_final
    (§ field ChildNumber ONE = new ChildNumber(1))
    #_public
    #_static
    #_final
    (§ field ChildNumber ZERO_HARDENED = new ChildNumber(0, true))

    ;;; Integer i as per BIP 32 spec, including the MSB denoting derivation type (0 = public, 1 = private). ;;
    #_private
    #_final
    (§ field int i)

    #_public
    (§ constructor ChildNumber(int childNumber, boolean isHardened))
    (ß
        (§ if (hasHardenedBit(childNumber)))
            (§ throw new IllegalArgumentException("Most significant bit is reserved and shouldn't be set: " + childNumber))

        (§ ass i = isHardened ? (childNumber | HARDENED_BIT) :else childNumber)
    )

    #_public
    (§ constructor ChildNumber(int i))
    (ß
        (§ ass this.i = i)
    )

    ;;; Returns the uint32 encoded form of the path element, including the most significant bit. ;;
    #_public
    (§ method int getI())
    (ß
        (§ return i)
    )

    ;;; Returns the uint32 encoded form of the path element, including the most significant bit. ;;
    #_public
    (§ method int i())
    (ß
        (§ return i)
    )

    #_public
    (§ method boolean isHardened())
    (ß
        (§ return hasHardenedBit(i))
    )

    #_private
    #_static
    (§ method boolean hasHardenedBit(int a))
    (ß
        (§ return ((a & HARDENED_BIT) != 0))
    )

    ;;; Returns the child number without the hardening bit set (i.e. index in that part of the tree). ;;
    #_public
    (§ method int num())
    (ß
        (§ return (i & ~HARDENED_BIT))
    )

    #_override
    #_public
    (§ method String toString())
    (ß
        (§ return String.format(Locale.US, "%d%s", num(), isHardened() ? "H" :else ""))
    )

    #_override
    #_public
    (§ method boolean equals(Object o))
    (ß
        (§ if (this == o))
            (§ return true)
        (§ if (o == nil || getClass() != o.getClass()))
            (§ return false)
        (§ return (i == ((ChildNumber)o).i))
    )

    #_override
    #_public
    (§ method int hashCode())
    (ß
        (§ return i)
    )

    #_override
    #_public
    (§ method int compareTo(ChildNumber other))
    (ß
        ;; Note that in this implementation compareTo() is not consistent with equals().
        (§ return Ints.compare(this.num(), other.num()))
    )
)

#_(ns org.bitcoinj.crypto #_"DeterministicHierarchy"
    (:import [java.util List Locale Map])
    (:import [com.google.common.base Preconditions]
             [com.google.common.collect ImmutableList Maps]))

;; TODO: This whole API feels a bit object heavy.  Do we really need ChildNumber and so many maps, etc?
;; TODO: Should we be representing this using an actual tree arrangement in memory instead of a bunch of hashmaps?

;;;
 ; <p>A DeterministicHierarchy calculates and keeps a whole tree (hierarchy) of keys originating from a single
 ; root key.  This implements part of the BIP 32 specification.  A deterministic key tree is useful because
 ; Bitcoin's privacy system require new keys to be created for each transaction, but managing all these
 ; keys quickly becomes unwieldy.  In particular it becomes hard to back up and distribute them.  By having
 ; a way to derive random-looking but deterministic keys we can make wallet backup simpler and gain the
 ; ability to hand out {@link DeterministicKey}s to other people who can then create new addresses
 ; on the fly, without having to contact us.</p>
 ;
 ; <p>The hierarchy is started from a single root key, and a location in the tree is given by a path which
 ; is a list of {@link ChildNumber}s.</p>
 ;;
#_public
(§ class DeterministicHierarchy
    #_private
    #_final
    (§ field Map<ImmutableList<ChildNumber>, DeterministicKey> keys = Maps.newHashMap())
    #_private
    #_final
    (§ field ImmutableList<ChildNumber> rootPath)
    ;; Keep track of how many child keys each node has.  This is kind of weak.
    #_private
    #_final
    (§ field Map<ImmutableList<ChildNumber>, ChildNumber> lastChildNumbers = Maps.newHashMap())

    #_public
    #_static
    #_final
    (§ field int BIP32_STANDARDISATION_TIME_SECS = 1369267200)

    ;;;
     ; Constructs a new hierarchy rooted at the given key.  Note that this does not have to be the top of the tree.
     ; You can construct a DeterministicHierarchy for a subtree of a larger tree that you may not own.
     ;;
    #_public
    (§ constructor DeterministicHierarchy(DeterministicKey rootKey))
    (ß
        (§ call putKey(rootKey))
        (§ ass rootPath = rootKey.getPath())
    )

    ;;;
     ; Inserts a key into the heirarchy.  Used during deserialization: you normally don't need this.  Keys must be
     ; inserted in order.
     ;;
    #_public
    #_final
    (§ method void putKey(DeterministicKey key))
    (ß
        (§ var ImmutableList<ChildNumber> path = key.getPath())
        ;; Update our tracking of what the next child in each branch of the tree should be.  Just assume that keys
        ;; are inserted in order here.
        #_final
        (§ var DeterministicKey parent = key.getParent())
        (§ if (parent != nil))
            (§ call lastChildNumbers.put(parent.getPath(), key.getChildNumber()))
        (§ call keys.put(path, key))
    )

    ;;;
     ; Returns a key for the given path, optionally creating it.
     ;
     ; @param path The path to the key.
     ; @param relativePath Whether the path is relative to the root path.
     ; @param create Whether the key corresponding to path should be created (with any necessary ancestors) if it doesn't exist already.
     ; @return next newly created key using the child derivation function.
     ; @throws IllegalArgumentException if create is false and the path was not found.
     ;;
    #_public
    (§ method DeterministicKey get(List<ChildNumber> path, boolean relativePath, boolean create))
    (ß
        (§ var ImmutableList<ChildNumber> absolutePath = relativePath ? ImmutableList.<ChildNumber>builder().addAll(rootPath).addAll(path).build() :else ImmutableList.copyOf(path))
        (§ if (!keys.containsKey(absolutePath)))
        (ß
            (§ if (!create))
                (§ throw new IllegalArgumentException(String.format(Locale.US, "No key found for %s path %s.", relativePath ? "relative" :for "absolute", HDUtils.formatPath(path))))
            (§ call Preconditions.checkArgument(0 < absolutePath.size(), "Can't derive the master key: nothing to derive from."))
            (§ var DeterministicKey parent = get(absolutePath.subList(0, absolutePath.size() - 1), false, true))
            (§ call putKey(HDKeyDerivation.deriveChildKey(parent, absolutePath.get(absolutePath.size() - 1))))
        )
        (§ return keys.get(absolutePath))
    )

    ;;;
     ; Extends the tree by calculating the next key that hangs off the given parent path.  For example, if you pass
     ; a path of 1/2 here and there are already keys 1/2/1 and 1/2/2 then it will derive 1/2/3.
     ;
     ; @param parentPath The path to the parent.
     ; @param relative Whether the path is relative to the root path.
     ; @param createParent Whether the parent corresponding to path should be created (with any necessary ancestors) if it doesn't exist already.
     ; @param privateDerivation Whether to use private or public derivation.
     ; @return next newly created key using the child derivation funtcion.
     ; @throws IllegalArgumentException if the parent doesn't exist and createParent is false.
     ;;
    #_public
    (§ method DeterministicKey deriveNextChild(ImmutableList<ChildNumber> parentPath, boolean relative, boolean createParent, boolean privateDerivation))
    (ß
        (§ var DeterministicKey parent = get(parentPath, relative, createParent))
        (§ for (int i = 0 :for i < HDKeyDerivation.MAX_CHILD_DERIVATION_ATTEMPTS :for i = i + 1))
        (ß
            (§ try)
            (ß
                (§ var ChildNumber createChildNumber = getNextChildNumberToDerive(parent.getPath(), privateDerivation))
                (§ return deriveChild(parent, createChildNumber))
            )
            (§ catch (HDDerivationException _))
            (ß
            )
        )
        (§ throw new HDDerivationException("Maximum number of child derivation attempts reached, this is probably an indication of a bug."))
    )

    #_private
    (§ method ChildNumber getNextChildNumberToDerive(ImmutableList<ChildNumber> path, boolean privateDerivation))
    (ß
        (§ var ChildNumber lastChildNumber = lastChildNumbers.get(path))
        (§ var ChildNumber nextChildNumber = new ChildNumber(lastChildNumber != nil ? lastChildNumber.num() + 1 :else 0, privateDerivation))
        (§ call lastChildNumbers.put(path, nextChildNumber))
        (§ return nextChildNumber)
    )

    #_public
    (§ method int getNumChildren(ImmutableList<ChildNumber> path))
    (ß
        #_final
        (§ var ChildNumber cn = lastChildNumbers.get(path))
        ;; Children start with zero based childnumbers.
        (§ return (cn == nil) ? 0 :else 1 + cn.num())
    )

    ;;;
     ; Extends the tree by calculating the requested child for the given path.  For example, to get the key at position
     ; 1/2/3 you would pass 1/2 as the parent path and 3 as the child number.
     ;
     ; @param parentPath The path to the parent.
     ; @param relative Whether the path is relative to the root path.
     ; @param createParent Whether the parent corresponding to path should be created (with any necessary ancestors) if it doesn't exist already.
     ; @return the requested key.
     ; @throws IllegalArgumentException if the parent doesn't exist and createParent is false.
     ;;
    #_public
    (§ method DeterministicKey deriveChild(List<ChildNumber> parentPath, boolean relative, boolean createParent, ChildNumber createChildNumber))
    (ß
        (§ return deriveChild(get(parentPath, relative, createParent), createChildNumber))
    )

    #_private
    (§ method DeterministicKey deriveChild(DeterministicKey parent, ChildNumber createChildNumber))
    (ß
        (§ var DeterministicKey childKey = HDKeyDerivation.deriveChildKey(parent, createChildNumber))
        (§ call putKey(childKey))
        (§ return childKey)
    )

    ;;;
     ; Returns the root key that the {@link DeterministicHierarchy} was created with.
     ;;
    #_public
    (§ method DeterministicKey getRootKey())
    (ß
        (§ return get(rootPath, false, false))
    )
)

#_(ns org.bitcoinj.crypto #_"DeterministicKey"
    (:import [java.math BigInteger]
             [java.nio ByteBuffer]
             [java.util Arrays Comparator])
    (:import [com.google.common.base MoreObjects Objects Preconditions]
             [com.google.common.collect ImmutableList]
             [org.spongycastle.crypto.params KeyParameter]
             [org.spongycastle.math.ec ECPoint])
  #_(:require #_[org.bitcoinj.core *]
             #_static #_[org.bitcoinj.core.Utils HEX]))

;;;
 ; A deterministic key is a node in a {@link DeterministicHierarchy}.  As per
 ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">the BIP 32 specification</a> it is a pair
 ; (key, chaincode).  If you know its path in the tree and its chain code you can derive more keys from this.
 ; To obtain one of these, you can call {@link HDKeyDerivation#createMasterPrivateKey(byte[])}.
 ;;
#_public
(§ class DeterministicKey extends ECKey
    ;;; Sorts deterministic keys in the order of their child number.  That's <i>usually</i> the order used to derive them. ;;
    #_public
    #_static
    #_final
    (§ field Comparator<ECKey> CHILDNUM_ORDER = new Comparator<ECKey>()
        (ß
            #_override
            #_public
            (§ method int compare(ECKey k1, ECKey k2))
            (ß
                (§ var ChildNumber cn1 = ((DeterministicKey)k1).getChildNumber())
                (§ var ChildNumber cn2 = ((DeterministicKey)k2).getChildNumber())
                (§ return cn1.compareTo(cn2))
            )
        ))

    #_private
    #_final
    (§ field DeterministicKey parent)
    #_private
    #_final
    (§ field ImmutableList<ChildNumber> childNumberPath)
    #_private
    #_final
    (§ field int depth)
    #_private
    (§ field int parentFingerprint) ;; 0 if this key is root node of key hierarchy

    ;;; 32 bytes ;;
    #_private
    #_final
    (§ field byte[] chainCode)

    ;;; Constructs a key from its components.  This is not normally something you should use. ;;
    #_public
    (§ constructor DeterministicKey(ImmutableList<ChildNumber> childNumberPath, byte[] chainCode, LazyECPoint publicAsPoint, #_nilable BigInteger priv, #_nilable DeterministicKey parent))
    (ß
        (§ super (priv, compressPoint(Preconditions.checkNotNull(publicAsPoint))))

        (§ call Preconditions.checkArgument(chainCode.length == 32))

        (§ ass this.parent = parent)
        (§ ass this.childNumberPath = Preconditions.checkNotNull(childNumberPath))
        (§ ass this.chainCode = Arrays.copyOf(chainCode, chainCode.length))
        (§ ass this.depth = (parent != nil) ? parent.depth + 1 :else 0)
        (§ ass this.parentFingerprint = (parent != nil) ? parent.getFingerprint() :else 0)
    )

    #_public
    (§ constructor DeterministicKey(ImmutableList<ChildNumber> childNumberPath, byte[] chainCode, ECPoint publicAsPoint, #_nilable BigInteger priv, #_nilable DeterministicKey parent))
    (ß
        (§ this (childNumberPath, chainCode, new LazyECPoint(publicAsPoint), priv, parent))
    )

    ;;; Constructs a key from its components.  This is not normally something you should use. ;;
    #_public
    (§ constructor DeterministicKey(ImmutableList<ChildNumber> childNumberPath, byte[] chainCode, BigInteger priv, #_nilable DeterministicKey parent))
    (ß
        (§ super (priv, compressPoint(ECKey.publicPointFromPrivate(priv))))

        (§ call Preconditions.checkArgument(chainCode.length == 32))

        (§ ass this.parent = parent)
        (§ ass this.childNumberPath = Preconditions.checkNotNull(childNumberPath))
        (§ ass this.chainCode = Arrays.copyOf(chainCode, chainCode.length))
        (§ ass this.depth = (parent != nil) ? parent.depth + 1 :else 0)
        (§ ass this.parentFingerprint = (parent != nil) ? parent.getFingerprint() :else 0)
    )

    ;;; Constructs a key from its components.  This is not normally something you should use. ;;
    #_public
    (§ constructor DeterministicKey(ImmutableList<ChildNumber> childNumberPath, byte[] chainCode, KeyCrypter crypter, LazyECPoint pub, EncryptedData priv, #_nilable DeterministicKey parent))
    (ß
        (§ this (childNumberPath, chainCode, pub, nil, parent))
        (§ ass this.encryptedPrivateKey = Preconditions.checkNotNull(priv))
        (§ ass this.keyCrypter = Preconditions.checkNotNull(crypter))
    )

    ;;;
     ; Return the fingerprint of this key's parent as an int value, or zero if this key is the
     ; root node of the key hierarchy.  Raise an exception if the arguments are inconsistent.
     ; This method exists to avoid code repetition in the constructors.
     ;;
    #_private
    (§ method int ascertainParentFingerprint(DeterministicKey parentKey, int parentFingerprint))
        (§ throws IllegalArgumentException)
    (ß
        (§ if (parentFingerprint != 0))
        (ß
            (§ if (parent != nil))
                (§ call Preconditions.checkArgument(parent.getFingerprint() == parentFingerprint, "parent fingerprint mismatch", Integer.toHexString(parent.getFingerprint()), Integer.toHexString(parentFingerprint)))
            (§ return parentFingerprint)
        )

        (§ return 0)
    )

    ;;;
     ; Constructs a key from its components, including its public key data and possibly-redundant
     ; information about its parent key.  Invoked when deserializing, but otherwise not something
     ; that you normally should use.
     ;;
    #_public
    (§ constructor DeterministicKey(ImmutableList<ChildNumber> childNumberPath, byte[] chainCode, LazyECPoint publicAsPoint, #_nilable DeterministicKey parent, int depth, int parentFingerprint))
    (ß
        (§ super (nil, compressPoint(Preconditions.checkNotNull(publicAsPoint))))

        (§ call Preconditions.checkArgument(chainCode.length == 32))

        (§ ass this.parent = parent)
        (§ ass this.childNumberPath = Preconditions.checkNotNull(childNumberPath))
        (§ ass this.chainCode = Arrays.copyOf(chainCode, chainCode.length))
        (§ ass this.depth = depth)
        (§ ass this.parentFingerprint = ascertainParentFingerprint(parent, parentFingerprint))
    )

    ;;;
     ; Constructs a key from its components, including its private key data and possibly-redundant
     ; information about its parent key.  Invoked when deserializing, but otherwise not something that
     ; you normally should use.
     ;;
    #_public
    (§ constructor DeterministicKey(ImmutableList<ChildNumber> childNumberPath, byte[] chainCode, BigInteger priv, #_nilable DeterministicKey parent, int depth, int parentFingerprint))
    (ß
        (§ super (priv, compressPoint(ECKey.publicPointFromPrivate(priv))))

        (§ call Preconditions.checkArgument(chainCode.length == 32))

        (§ ass this.parent = parent)
        (§ ass this.childNumberPath = Preconditions.checkNotNull(childNumberPath))
        (§ ass this.chainCode = Arrays.copyOf(chainCode, chainCode.length))
        (§ ass this.depth = depth)
        (§ ass this.parentFingerprint = ascertainParentFingerprint(parent, parentFingerprint))
    )

    ;;; Clones the key. ;;
    #_public
    (§ constructor DeterministicKey(DeterministicKey keyToClone, DeterministicKey newParent))
    (ß
        (§ super (keyToClone.priv, keyToClone.pub.get()))

        (§ ass this.parent = newParent)
        (§ ass this.childNumberPath = keyToClone.childNumberPath)
        (§ ass this.chainCode = keyToClone.chainCode)
        (§ ass this.encryptedPrivateKey = keyToClone.encryptedPrivateKey)
        (§ ass this.depth = this.childNumberPath.size())
        (§ ass this.parentFingerprint = this.parent.getFingerprint())
    )

    ;;;
     ; Returns the path through some {@link DeterministicHierarchy} which reaches this keys position in the tree.
     ; A path can be written as 1/2/1 which means the first child of the root, the second child of that node, then
     ; the first child of that node.
     ;;
    #_public
    (§ method ImmutableList<ChildNumber> getPath())
    (ß
        (§ return childNumberPath)
    )

    ;;;
     ; Returns the path of this key as a human readable string starting with M to indicate the master key.
     ;;
    #_public
    (§ method String getPathAsString())
    (ß
        (§ return HDUtils.formatPath(getPath()))
    )

    ;;;
     ; Return this key's depth in the hierarchy, where the root node is at depth zero.
     ; This may be different than the number of segments in the path if this key was
     ; deserialized without access to its parent.
     ;;
    #_public
    (§ method int getDepth())
    (ß
        (§ return depth)
    )

    ;;; Returns the last element of the path returned by {@link DeterministicKey#getPath()}. ;;
    #_public
    (§ method ChildNumber getChildNumber())
    (ß
        (§ return (childNumberPath.size() == 0) ? ChildNumber.ZERO :else childNumberPath.get(childNumberPath.size() - 1))
    )

    ;;;
     ; Returns the chain code associated with this key.  See the specification to learn more about chain codes.
     ;;
    #_public
    (§ method byte[] getChainCode())
    (ß
        (§ return chainCode)
    )

    ;;;
     ; Returns RIPE-MD160(SHA256(pub key bytes)).
     ;;
    #_public
    (§ method byte[] getIdentifier())
    (ß
        (§ return Utils.sha256hash160(getPubKey()))
    )

    ;;; Returns the first 32 bits of the result of {@link #getIdentifier()}. ;;
    #_public
    (§ method int getFingerprint())
    (ß
        ;; TODO: Why is this different than armory's fingerprint?  BIP 32: "The first 32 bits of the identifier are called the fingerprint."
        (§ return ByteBuffer.wrap(Arrays.copyOfRange(getIdentifier(), 0, 4)).getInt())
    )

    #_nilable
    #_public
    (§ method DeterministicKey getParent())
    (ß
        (§ return parent)
    )

    ;;;
     ; Return the fingerprint of the key from which this key was derived, if this is
     ; a child key, or else an array of four zero-value bytes.
     ;;
    #_public
    (§ method int getParentFingerprint())
    (ß
        (§ return parentFingerprint)
    )

    ;;;
     ; Returns private key bytes, padded with zeros to 33 bytes.
     ; @throws java.lang.IllegalStateException if the private key bytes are missing.
     ;;
    #_public
    (§ method byte[] getPrivKeyBytes33())
    (ß
        (§ var byte[] bytes33 = new byte[33])
        (§ var byte[] priv = getPrivKeyBytes())
        (§ call System.arraycopy(priv, 0, bytes33, 33 - priv.length, priv.length))
        (§ return bytes33)
    )

    ;;;
     ; Returns the same key with the private bytes removed.  May return the same instance.  The purpose of this is to
     ; save memory: the private key can always be very efficiently rederived from a parent that a private key, so storing
     ; all the private keys in RAM is a poor tradeoff especially on constrained devices.  This means that the returned
     ; key may still be usable for signing and so on, so don't expect it to be a true pubkey-only object!  If you want
     ; that then you should follow this call with a call to {@link #dropParent()}.
     ;;
    #_public
    (§ method DeterministicKey dropPrivateBytes())
    (ß
        (§ return isPubKeyOnly() ? this :else new DeterministicKey(getPath(), getChainCode(), pub, nil, parent))
    )

    ;;;
     ; <p>Returns the same key with the parent pointer removed (it still knows its own path and the parent fingerprint).</p>
     ;
     ; <p>If this key doesn't have private key bytes stored/cached itself, but could rederive them from the parent, then
     ; the new key returned by this method won't be able to do that.  Thus, using dropPrivateBytes().dropParent() on a
     ; regular DeterministicKey will yield a new DeterministicKey that cannot sign or do other things involving the
     ; private key at all.</p>
     ;;
    #_public
    (§ method DeterministicKey dropParent())
    (ß
        (§ var DeterministicKey key = new DeterministicKey(getPath(), getChainCode(), pub, priv, nil))
        (§ ass key.parentFingerprint = parentFingerprint)
        (§ return key)
    )

    #_static
    (§ method byte[] addChecksum(byte[] input))
    (ß
        (§ var int inputLength = input.length)
        (§ var byte[] checksummed = new byte[inputLength + 4])
        (§ call System.arraycopy(input, 0, checksummed, 0, inputLength))
        (§ var byte[] checksum = Sha256Hash.hashTwice(input))
        (§ call System.arraycopy(checksum, 0, checksummed, inputLength, 4))
        (§ return checksummed)
    )

    #_override
    #_public
    (§ method DeterministicKey encrypt(KeyCrypter keyCrypter, KeyParameter aesKey))
        (§ throws KeyCrypterException)
    (ß
        (§ throw new UnsupportedOperationException("Must supply a new parent for encryption"))
    )

    #_public
    (§ method DeterministicKey encrypt(KeyCrypter keyCrypter, KeyParameter aesKey, #_nilable DeterministicKey newParent))
        (§ throws KeyCrypterException)
    (ß
        ;; Same as the parent code, except we construct a DeterministicKey instead of an ECKey.
        (§ call Preconditions.checkNotNull(keyCrypter))
        (§ if (newParent != nil))
            (§ call Preconditions.checkArgument(newParent.isEncrypted()))

        #_final
        (§ var byte[] privKeyBytes = getPrivKeyBytes())
        (§ call Preconditions.checkState(privKeyBytes != nil, "Private key is not available"))

        (§ var EncryptedData encryptedPrivateKey = keyCrypter.encrypt(privKeyBytes, aesKey))
        (§ var DeterministicKey key = new DeterministicKey(childNumberPath, chainCode, keyCrypter, pub, encryptedPrivateKey, newParent))
        (§ if (newParent == nil))
            (§ call key.setCreationTimeSeconds(getCreationTimeSeconds()))
        (§ return key)
    )

    ;;;
     ; A deterministic key is considered to be 'public key only' if it hasn't got a private key part and it cannot be
     ; rederived.  If the hierarchy is encrypted this returns true.
     ;;
    #_override
    #_public
    (§ method boolean isPubKeyOnly())
    (ß
        (§ return (super.isPubKeyOnly() && (parent == nil || parent.isPubKeyOnly())))
    )

    ;;; {@inheritDoc} ;;
    #_override
    #_public
    (§ method boolean hasPrivKey())
    (ß
        (§ return (findParentWithPrivKey() != nil))
    )

    #_nilable
    #_override
    #_public
    (§ method byte[] getSecretBytes())
    (ß
        (§ return (priv != nil) ? getPrivKeyBytes() :else nil)
    )

    ;;;
     ; A deterministic key is considered to be encrypted if it has access to encrypted private key bytes, OR if its
     ; parent does.  The reason is because the parent would be encrypted under the same key and this key knows how to
     ; rederive its own private key bytes from the parent, if needed.
     ;;
    #_override
    #_public
    (§ method boolean isEncrypted())
    (ß
        (§ return (priv == nil && (super.isEncrypted() || (parent != nil && parent.isEncrypted()))))
    )

    ;;;
     ; Returns this keys {@link org.bitcoinj.crypto.KeyCrypter} <b>or</b> the keycrypter of its parent key.
     ;;
    #_override
    #_nilable
    #_public
    (§ method KeyCrypter getKeyCrypter())
    (ß
        (§ if (keyCrypter != nil))
            (§ return keyCrypter)
        (§ if (parent != nil))
            (§ return parent.getKeyCrypter())

        (§ return nil)
    )

    #_override
    #_public
    (§ method ECDSASignature sign(Sha256Hash input, #_nilable KeyParameter aesKey))
        (§ throws KeyCrypterException)
    (ß
        (§ if (isEncrypted()))
        (ß
            ;; If the key is encrypted, ECKey.sign will decrypt it first before rerunning sign.  Decryption walks
            ;; the key heirarchy to find the private key (see below), so, we can just run the inherited method.
            (§ return super.sign(input, aesKey))
        )
        (§ else)
        (ß
            ;; If it's not encrypted, derive the private via the parents.
            #_final
            (§ var BigInteger privateKey = findOrDerivePrivateKey())
            ;; This key is a part of a public-key only heirarchy and cannot be used for signing.
            (§ if (privateKey == nil))
                (§ throw new MissingPrivateKeyException())

            (§ return super.doSign(input, privateKey))
        )
    )

    #_override
    #_public
    (§ method DeterministicKey decrypt(KeyCrypter keyCrypter, KeyParameter aesKey))
        (§ throws KeyCrypterException)
    (ß
        (§ call Preconditions.checkNotNull(keyCrypter))
        ;; Check that the keyCrypter matches the one used to encrypt the keys, if set.
        (§ if (this.keyCrypter != nil && !this.keyCrypter.equals(keyCrypter)))
            (§ throw new KeyCrypterException("The keyCrypter being used to decrypt the key is different to the one that was used to encrypt it"))

        (§ var BigInteger privKey = findOrDeriveEncryptedPrivateKey(keyCrypter, aesKey))
        (§ var DeterministicKey key = new DeterministicKey(childNumberPath, chainCode, privKey, parent))
        (§ if (!Arrays.equals(key.getPubKey(), getPubKey())))
            (§ throw new KeyCrypterException("Provided AES key is wrong"))

        (§ if (parent == nil))
            (§ call key.setCreationTimeSeconds(getCreationTimeSeconds()))
        (§ return key)
    )

    #_override
    #_public
    (§ method DeterministicKey decrypt(KeyParameter aesKey))
        (§ throws KeyCrypterException)
    (ß
        (§ return (DeterministicKey)super.decrypt(aesKey))
    )

    ;; For when a key is encrypted, either decrypt our encrypted private key bytes, or work up the tree asking parents
    ;; to decrypt and re-derive.
    #_private
    (§ method BigInteger findOrDeriveEncryptedPrivateKey(KeyCrypter keyCrypter, KeyParameter aesKey))
    (ß
        (§ if (encryptedPrivateKey != nil))
            (§ return new BigInteger(1, keyCrypter.decrypt(encryptedPrivateKey, aesKey)))

        ;; Otherwise we don't have it, but maybe we can figure it out from our parents.  Walk up the tree looking for
        ;; the first key that has some encrypted private key data.
        (§ var DeterministicKey cursor = parent)
        (§ while (cursor != nil))
        (ß
            (§ if (cursor.encryptedPrivateKey != nil))
                (§ break)
            (§ ass cursor = cursor.parent)
        )
        (§ if (cursor == nil))
            (§ throw new KeyCrypterException("Neither this key nor its parents have an encrypted private key"))

        (§ var byte[] parentalPrivateKeyBytes = keyCrypter.decrypt(cursor.encryptedPrivateKey, aesKey))
        (§ return derivePrivateKeyDownwards(cursor, parentalPrivateKeyBytes))
    )

    #_private
    (§ method DeterministicKey findParentWithPrivKey())
    (ß
        (§ var DeterministicKey cursor = this)
        (§ while (cursor != nil))
        (ß
            (§ if (cursor.priv != nil))
                (§ break)
            (§ ass cursor = cursor.parent)
        )
        (§ return cursor)
    )

    #_nilable
    #_private
    (§ method BigInteger findOrDerivePrivateKey())
    (ß
        (§ var DeterministicKey cursor = findParentWithPrivKey())
        (§ if (cursor == nil))
            (§ return nil)

        (§ return derivePrivateKeyDownwards(cursor, cursor.priv.toByteArray()))
    )

    #_private
    (§ method BigInteger derivePrivateKeyDownwards(DeterministicKey cursor, byte[] parentalPrivateKeyBytes))
    (ß
        (§ var DeterministicKey downCursor = new DeterministicKey(cursor.childNumberPath, cursor.chainCode, cursor.pub, new BigInteger(1, parentalPrivateKeyBytes), cursor.parent))
        ;; Now we have to rederive the keys along the path back to ourselves.  That path can be found by just truncating
        ;; our path with the length of the parents path.
        (§ var ImmutableList<ChildNumber> path = childNumberPath.subList(cursor.getPath().size(), childNumberPath.size()))
        (§ for (ChildNumber num :for path))
            (§ ass downCursor = HDKeyDerivation.deriveChildKey(downCursor, num))
        ;; downCursor is now the same key as us, but with private key bytes.
        ;; If it's not, it means we tried decrypting with an invalid password and earlier checks e.g. for padding didn't
        ;; catch it.
        (§ if (!downCursor.pub.equals(pub)))
            (§ throw new KeyCrypterException("Could not decrypt bytes"))

        (§ return Preconditions.checkNotNull(downCursor.priv))
    )

    ;;;
     ; Derives a child at the given index using hardened derivation.  Note: <code>index</code>
     ; is not the "i" value.  If you want the softened derivation, then use instead
     ; <code>HDKeyDerivation.deriveChildKey(this, new ChildNumber(child, false))</code>.
     ;;
    #_public
    (§ method DeterministicKey derive(int child))
    (ß
        (§ return HDKeyDerivation.deriveChildKey(this, new ChildNumber(child, true)))
    )

    ;;;
     ; Returns the private key of this deterministic key.  Even if this object isn't storing the private key,
     ; it can be re-derived by walking up to the parents if necessary and this is what will happen.
     ; @throws java.lang.IllegalStateException if the parents are encrypted or a watching chain.
     ;;
    #_override
    #_public
    (§ method BigInteger getPrivKey())
    (ß
        #_final
        (§ var BigInteger key = findOrDerivePrivateKey())
        (§ call Preconditions.checkState(key != nil, "Private key bytes not available"))
        (§ return key)
    )

    #_public
    (§ method byte[] serializePublic(NetworkParameters params))
    (ß
        (§ return serialize(params, true))
    )

    #_public
    (§ method byte[] serializePrivate(NetworkParameters params))
    (ß
        (§ return serialize(params, false))
    )

    #_private
    (§ method byte[] serialize(NetworkParameters params, boolean pub))
    (ß
        (§ var ByteBuffer ser = ByteBuffer.allocate(78))
        (§ call ser.putInt(pub ? params.getBip32HeaderPub() :else params.getBip32HeaderPriv()))
        (§ call ser.put((byte)getDepth()))
        (§ call ser.putInt(getParentFingerprint()))
        (§ call ser.putInt(getChildNumber().i()))
        (§ call ser.put(getChainCode()))
        (§ call ser.put(pub ? getPubKey() :else getPrivKeyBytes33()))
        (§ call Preconditions.checkState(ser.position() == 78))
        (§ return ser.array())
    )

    #_public
    (§ method String serializePubB58(NetworkParameters params))
    (ß
        (§ return toBase58(serialize(params, true)))
    )

    #_public
    (§ method String serializePrivB58(NetworkParameters params))
    (ß
        (§ return toBase58(serialize(params, false)))
    )

    #_static
    (§ method String toBase58(byte[] ser))
    (ß
        (§ return Base58.encode(addChecksum(ser)))
    )

    ;;; Deserialize a base-58-encoded HD Key with no parent. ;;
    #_public
    #_static
    (§ method DeterministicKey deserializeB58(String base58, NetworkParameters params))
    (ß
        (§ return deserializeB58(nil, base58, params))
    )

    ;;;
     ; Deserialize a base-58-encoded HD Key.
     ; @param parent The parent node in the given key's deterministic hierarchy.
     ; @throws IllegalArgumentException if the base58 encoded key could not be parsed.
     ;;
    #_public
    #_static
    (§ method DeterministicKey deserializeB58(#_nilable DeterministicKey parent, String base58, NetworkParameters params))
    (ß
        (§ return deserialize(params, Base58.decodeChecked(base58), parent))
    )

    ;;;
     ; Deserialize an HD Key with no parent.
     ;;
    #_public
    #_static
    (§ method DeterministicKey deserialize(NetworkParameters params, byte[] serializedKey))
    (ß
        (§ return deserialize(params, serializedKey, nil))
    )

    ;;;
     ; Deserialize an HD Key.
     ; @param parent The parent node in the given key's deterministic hierarchy.
     ;;
    #_public
    #_static
    (§ method DeterministicKey deserialize(NetworkParameters params, byte[] serializedKey, #_nilable DeterministicKey parent))
    (ß
        (§ var ByteBuffer buffer = ByteBuffer.wrap(serializedKey))
        (§ var int header = buffer.getInt())
        (§ if (header != params.getBip32HeaderPriv() && header != params.getBip32HeaderPub()))
            (§ throw new IllegalArgumentException("Unknown header bytes: " + toBase58(serializedKey).substring(0, 4)))

        (§ var boolean pub = (header == params.getBip32HeaderPub()))
        (§ var int depth = buffer.get() & 0xff) ;; convert signed byte to positive int since depth cannot be negative
        #_final
        (§ var int parentFingerprint = buffer.getInt())
        #_final
        (§ var int i = buffer.getInt())
        #_final
        (§ var ChildNumber childNumber = new ChildNumber(i))
        (§ var ImmutableList<ChildNumber> path)
        (§ if (parent != nil))
        (ß
            (§ if (parentFingerprint == 0))
                (§ throw new IllegalArgumentException("Parent was provided but this key doesn't have one"))
            (§ if (parent.getFingerprint() != parentFingerprint))
                (§ throw new IllegalArgumentException("Parent fingerprints don't match"))
            (§ ass path = HDUtils.append(parent.getPath(), childNumber))
            (§ if (path.size() != depth))
                (§ throw new IllegalArgumentException("Depth does not match"))
        )
        (§ else)
        (ß
            ;; We have been given a key that is not a root key, yet we lack the object representing the parent.
            ;; This can happen when deserializing an account key for a watching wallet.  In this case, we assume that
            ;; the client wants to conceal the key's position in the hierarchy.  The path is truncated at the
            ;; parent's node.
            (§ if (1 <= depth))
                (§ ass path = ImmutableList.of(childNumber))
            (§ else)
                (§ ass path = ImmutableList.of())
        )
        (§ var byte[] chainCode = new byte[32])
        (§ call buffer.get(chainCode))
        (§ var byte[] data = new byte[33])
        (§ call buffer.get(data))
        (§ call Preconditions.checkArgument(!buffer.hasRemaining(), "Found unexpected data in key"))
        (§ if (pub))
            (§ return new DeterministicKey(path, chainCode, new LazyECPoint(ECKey.CURVE.getCurve(), data), parent, depth, parentFingerprint))
        (§ else)
            (§ return new DeterministicKey(path, chainCode, new BigInteger(1, data), parent, depth, parentFingerprint))
    )

    ;;;
     ; The creation time of a deterministic key is equal to that of its parent, unless this key is the root of a tree
     ; in which case the time is stored alongside the key as per normal, see {@link org.bitcoinj.core.ECKey#getCreationTimeSeconds()}.
     ;;
    #_override
    #_public
    (§ method long getCreationTimeSeconds())
    (ß
        (§ if (parent != nil))
            (§ return parent.getCreationTimeSeconds())
        (§ else)
            (§ return super.getCreationTimeSeconds())
    )

    ;;;
     ; The creation time of a deterministic key is equal to that of its parent, unless this key is the root of a tree.
     ; Thus, setting the creation time on a leaf is forbidden.
     ;;
    #_override
    #_public
    (§ method void setCreationTimeSeconds(long newCreationTimeSeconds))
    (ß
        (§ if (parent != nil))
            (§ throw new IllegalStateException("Creation time can only be set on root keys."))
        (§ else)
            (§ call super.setCreationTimeSeconds(newCreationTimeSeconds))
    )

    ;;;
     ; Verifies equality of all fields but NOT the parent pointer (thus the same key derived in two separate heirarchy
     ; objects will equal each other.
     ;;
    #_override
    #_public
    (§ method boolean equals(Object o))
    (ß
        (§ if (this == o))
            (§ return true)
        (§ if (o == nil || getClass() != o.getClass()))
            (§ return false)
        (§ var DeterministicKey other = (DeterministicKey)o)
        (§ return (super.equals(other) && Arrays.equals(this.chainCode, other.chainCode) && Objects.equal(this.childNumberPath, other.childNumberPath)))
    )

    #_override
    #_public
    (§ method int hashCode())
    (ß
        (§ return Objects.hashCode(super.hashCode(), Arrays.hashCode(chainCode), childNumberPath))
    )

    #_override
    #_public
    (§ method String toString())
    (ß
        #_final
        (§ var MoreObjects.ToStringHelper helper = MoreObjects.toStringHelper(this).omitNullValues())
        (§ call helper.add("pub", Utils.HEX.encode(pub.getEncoded())))
        (§ call helper.add("chainCode", HEX.encode(chainCode)))
        (§ call helper.add("path", getPathAsString()))
        (§ if (0 < creationTimeSeconds))
            (§ call helper.add("creationTimeSeconds", creationTimeSeconds))
        (§ call helper.add("isEncrypted", isEncrypted()))
        (§ call helper.add("isPubKeyOnly", isPubKeyOnly()))
        (§ return helper.toString())
    )

    #_override
    #_public
    (§ method void formatKeyWithAddress(boolean includePrivateKeys, StringBuilder sb, NetworkParameters params))
    (ß
        #_final
        (§ var Address address = toAddress(params))
        (§ call sb.append("  addr:").append(address))
        (§ call sb.append("  hash160:").append(Utils.HEX.encode(getPubKeyHash())))
        (§ call sb.append("  (").append(getPathAsString()).append(")\n"))
        (§ if (includePrivateKeys))
            (§ call sb.append("  ").append(toStringWithPrivate(params)).append("\n"))
    )
)

#_(ns org.bitcoinj.crypto #_"EncryptableItem"
  #_(:require [org.bitcoinj.wallet Protos]))

;;;
 ; Provides a uniform way to access something that can be optionally encrypted with a
 ; {@link org.bitcoinj.crypto.KeyCrypter}, yielding an {@link org.bitcoinj.crypto.EncryptedData},
 ; and which can have a creation time associated with it.
 ;;
#_public
(§ interface EncryptableItem
    ;;; Returns whether the item is encrypted or not.  If it is, then {@link #getSecretBytes()} will return null. ;;
    (§ method boolean isEncrypted())

    ;;; Returns the raw bytes of the item, if not encrypted, or null if encrypted or the secret is missing. ;;
    #_nilable
    (§ method byte[] getSecretBytes())

    ;;; Returns the initialization vector and encrypted secret bytes, or null if not encrypted. ;;
    #_nilable
    (§ method EncryptedData getEncryptedData())

    ;;; Returns an enum constant describing what algorithm was used to encrypt the key or UNENCRYPTED. ;;
    (§ method Protos.Wallet.EncryptionType getEncryptionType())

    ;;; Returns the time in seconds since the UNIX epoch at which this encryptable item was first created/derived. ;;
    (§ method long getCreationTimeSeconds())
)

#_(ns org.bitcoinj.crypto #_"EncryptedData"
    (:import [java.util Arrays])
    (:import [com.google.common.base Objects]))

;;;
 ; <p>An instance of EncryptedData is a holder for an initialization vector and encrypted bytes.
 ; It is typically used to hold encrypted private key bytes.</p>
 ;
 ; <p>The initialisation vector is random data that is used to initialise the AES block cipher when
 ; the private key bytes were encrypted.  You need these for decryption.</p>
 ;;
#_public
#_final
(§ class EncryptedData
    #_public
    #_final
    (§ field byte[] initialisationVector)
    #_public
    #_final
    (§ field byte[] encryptedBytes)

    #_public
    (§ constructor EncryptedData(byte[] initialisationVector, byte[] encryptedBytes))
    (ß
        (§ ass this.initialisationVector = Arrays.copyOf(initialisationVector, initialisationVector.length))
        (§ ass this.encryptedBytes = Arrays.copyOf(encryptedBytes, encryptedBytes.length))
    )

    #_override
    #_public
    (§ method boolean equals(Object o))
    (ß
        (§ if (this == o))
            (§ return true)
        (§ if (o == nil || getClass() != o.getClass()))
            (§ return false)
        (§ var EncryptedData other = (EncryptedData)o)
        (§ return (Arrays.equals(encryptedBytes, other.encryptedBytes) && Arrays.equals(initialisationVector, other.initialisationVector)))
    )

    #_override
    #_public
    (§ method int hashCode())
    (ß
        (§ return Objects.hashCode(Arrays.hashCode(encryptedBytes), Arrays.hashCode(initialisationVector)))
    )

    #_override
    #_public
    (§ method String toString())
    (ß
        (§ return "EncryptedData [initialisationVector=" + Arrays.toString(initialisationVector) + ", encryptedPrivateKey=" + Arrays.toString(encryptedBytes) + "]")
    )
)

#_(ns org.bitcoinj.crypto #_"HDDerivationException")

#_public
(§ class HDDerivationException extends RuntimeException
    #_public
    (§ constructor HDDerivationException(String message))
    (ß
        (§ super (message))
    )
)

#_(ns org.bitcoinj.crypto #_"HDKeyDerivation"
    (:import #_[java.math *]
             #_[java.nio *]
             #_[java.security *]
             #_[java.util *])
    (:import [com.google.common.base Preconditions]
             #_[com.google.common.collect *]
             #_[org.spongycastle.math.ec *])
  #_(:require #_[org.bitcoinj.core *]))

;;;
 ; Implementation of the <a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">BIP 32</a>
 ; deterministic wallet child key generation algorithm.
 ;;
#_public
#_final
(§ class HDKeyDerivation
    #_static
    (ß
        ;; Init proper random number generator, as some old Android installations have bugs that make it unsecure.
        (§ if (Utils.isAndroidRuntime()))
            (§ call new LinuxSecureRandom())

        (§ ass RAND_INT = new BigInteger(256, new SecureRandom()))
    )

    ;; Some arbitrary random number.  Doesn't matter what it is.
    #_private
    #_static
    #_final
    (§ field BigInteger RAND_INT)

    #_private
    (§ constructor HDKeyDerivation())
    (ß
    )

    ;;;
     ; Child derivation may fail (although with extremely low probability); in such case it is re-attempted.
     ; This is the maximum number of re-attempts (to avoid an infinite loop in case of bugs etc.)
     ;;
    #_public
    #_static
    #_final
    (§ field int MAX_CHILD_DERIVATION_ATTEMPTS = 100)

    ;;;
     ; Generates a new deterministic key from the given seed, which can be any arbitrary byte array.
     ; However resist the temptation to use a string as the seed - any key derived from a password
     ; is likely to be weak and easily broken by attackers (this is not theoretical, people have had
     ; money stolen that way).  This method checks that the given seed is at least 64 bits long.
     ;
     ; @throws HDDerivationException if generated master key is invalid (private key 0 or >= n).
     ; @throws IllegalArgumentException if the seed is less than 8 bytes and could be brute forced.
     ;;
    #_public
    #_static
    (§ method DeterministicKey createMasterPrivateKey(byte[] seed))
        (§ throws HDDerivationException)
    (ß
        (§ call Preconditions.checkArgument(8 < seed.length, "Seed is too short and could be brute forced"))

        ;; Calculate I = HMAC-SHA512(key="Bitcoin seed", msg=S).
        (§ var byte[] i = HDUtils.hmacSha512(HDUtils.createHmacSha512Digest("Bitcoin seed".getBytes()), seed))
        ;; Split I into two 32-byte sequences, Il and Ir.
        ;; Use Il as master secret key, and Ir as master chain code.
        (§ call Preconditions.checkState(i.length == 64, i.length))

        (§ var byte[] il = Arrays.copyOfRange(i, 0, 32))
        (§ var byte[] ir = Arrays.copyOfRange(i, 32, 64))
        (§ call Arrays.fill(i, (byte)0))
        (§ var DeterministicKey masterPrivKey = createMasterPrivKeyFromBytes(il, ir))
        (§ call Arrays.fill(il, (byte)0))
        (§ call Arrays.fill(ir, (byte)0))

        ;; Child deterministic keys will chain up to their parents to find the keys.
        (§ call masterPrivKey.setCreationTimeSeconds(Utils.currentTimeSeconds()))
        (§ return masterPrivKey)
    )

    ;;;
     ; @throws HDDerivationException if privKeyBytes is invalid (0 or >= n).
     ;;
    #_public
    #_static
    (§ method DeterministicKey createMasterPrivKeyFromBytes(byte[] privKeyBytes, byte[] chainCode))
        (§ throws HDDerivationException)
    (ß
        (§ var BigInteger priv = new BigInteger(1, privKeyBytes))
        (§ call assertNonZero(priv, "Generated master key is invalid."))
        (§ call assertLessThanN(priv, "Generated master key is invalid."))
        (§ return new DeterministicKey(ImmutableList.<ChildNumber>of(), chainCode, priv, nil))
    )

    #_public
    #_static
    (§ method DeterministicKey createMasterPubKeyFromBytes(byte[] pubKeyBytes, byte[] chainCode))
    (ß
        (§ return new DeterministicKey(ImmutableList.<ChildNumber>of(), chainCode, new LazyECPoint(ECKey.CURVE.getCurve(), pubKeyBytes), nil, nil))
    )

    ;;;
     ; Derives a key given the "extended" child number, i.e. the 0x80000000 bit of the value that you
     ; pass for <code>childNumber</code> will determine whether to use hardened derivation or not.
     ; Consider whether your code would benefit from the clarity of the equivalent, but explicit, form
     ; of this method that takes a <code>ChildNumber</code> rather than an <code>int</code>, for example:
     ; <code>deriveChildKey(parent, new ChildNumber(childNumber, true))</code>
     ; where the value of the hardened bit of <code>childNumber</code> is zero.
     ;;
    #_public
    #_static
    (§ method DeterministicKey deriveChildKey(DeterministicKey parent, int childNumber))
    (ß
        (§ return deriveChildKey(parent, new ChildNumber(childNumber)))
    )

    ;;;
     ; Derives a key of the "extended" child number, i.e. with the 0x80000000 bit specifying whether
     ; to use hardened derivation or not.  If derivation fails, tries a next child.
     ;;
    #_public
    #_static
    (§ method DeterministicKey deriveThisOrNextChildKey(DeterministicKey parent, int childNumber))
    (ß
        (§ var ChildNumber child = new ChildNumber(childNumber))
        (§ var boolean isHardened = child.isHardened())
        (§ for (int i = 0 :for i < MAX_CHILD_DERIVATION_ATTEMPTS :for i = i + 1))
        (ß
            (§ try)
            (ß
                (§ ass child = new ChildNumber(child.num() + i, isHardened))
                (§ return deriveChildKey(parent, child))
            )
            (§ catch (HDDerivationException _))
            (ß
            )
        )
        (§ throw new HDDerivationException("Maximum number of child derivation attempts reached, this is probably an indication of a bug."))
    )

    ;;;
     ; @throws HDDerivationException if private derivation is attempted for a public-only parent key, or
     ; if the resulting derived key is invalid (e.g. private key == 0).
     ;;
    #_public
    #_static
    (§ method DeterministicKey deriveChildKey(DeterministicKey parent, ChildNumber childNumber))
        (§ throws HDDerivationException)
    (ß
        (§ if (!parent.hasPrivKey()))
        (ß
            (§ var RawKeyBytes rawKey = deriveChildKeyBytesFromPublic(parent, childNumber, PublicDeriveMode.NORMAL))
            (§ return new DeterministicKey(HDUtils.append(parent.getPath(), childNumber), rawKey.chainCode, new LazyECPoint(ECKey.CURVE.getCurve(), rawKey.keyBytes), nil, parent))
        )
        (§ else)
        (ß
            (§ var RawKeyBytes rawKey = deriveChildKeyBytesFromPrivate(parent, childNumber))
            (§ return new DeterministicKey(HDUtils.append(parent.getPath(), childNumber), rawKey.chainCode, new BigInteger(1, rawKey.keyBytes), parent))
        )
    )

    #_public
    #_static
    (§ method RawKeyBytes deriveChildKeyBytesFromPrivate(DeterministicKey parent, ChildNumber childNumber))
        (§ throws HDDerivationException)
    (ß
        (§ call Preconditions.checkArgument(parent.hasPrivKey(), "Parent key must have private key bytes for this method."))

        (§ var byte[] parentPublicKey = parent.getPubKeyPoint().getEncoded(true))
        (§ call Preconditions.checkState(parentPublicKey.length == 33, "Parent pubkey must be 33 bytes, but is " + parentPublicKey.length))

        (§ var ByteBuffer data = ByteBuffer.allocate(37))
        (§ call data.put(childNumber.isHardened() ? parent.getPrivKeyBytes33() :else parentPublicKey))
        (§ call data.putInt(childNumber.i()))

        (§ var byte[] i = HDUtils.hmacSha512(parent.getChainCode(), data.array()))
        (§ call Preconditions.checkState(i.length == 64, i.length))

        (§ var byte[] il = Arrays.copyOfRange(i, 0, 32))
        (§ var byte[] chainCode = Arrays.copyOfRange(i, 32, 64))
        (§ var BigInteger ilInt = new BigInteger(1, il))
        (§ call assertLessThanN(ilInt, "Illegal derived key: I_L >= n"))

        #_final
        (§ var BigInteger priv = parent.getPrivKey())
        (§ var BigInteger ki = priv.add(ilInt).mod(ECKey.CURVE.getN()))
        (§ call assertNonZero(ki, "Illegal derived key: derived private key equals 0."))

        (§ return new RawKeyBytes(ki.toByteArray(), chainCode))
    )

    #_public
    (§ enum PublicDeriveMode
        (§ item NORMAL)
        (§ item WITH_INVERSION)
    )

    #_public
    #_static
    (§ method RawKeyBytes deriveChildKeyBytesFromPublic(DeterministicKey parent, ChildNumber childNumber, PublicDeriveMode mode))
        (§ throws HDDerivationException)
    (ß
        (§ call Preconditions.checkArgument(!childNumber.isHardened(), "Can't use private derivation with public keys only."))

        (§ var byte[] parentPublicKey = parent.getPubKeyPoint().getEncoded(true))
        (§ call Preconditions.checkState(parentPublicKey.length == 33, "Parent pubkey must be 33 bytes, but is " + parentPublicKey.length))

        (§ var ByteBuffer data = ByteBuffer.allocate(37))
        (§ call data.put(parentPublicKey))
        (§ call data.putInt(childNumber.i()))

        (§ var byte[] i = HDUtils.hmacSha512(parent.getChainCode(), data.array()))
        (§ call Preconditions.checkState(i.length == 64, i.length))

        (§ var byte[] il = Arrays.copyOfRange(i, 0, 32))
        (§ var byte[] chainCode = Arrays.copyOfRange(i, 32, 64))
        (§ var BigInteger ilInt = new BigInteger(1, il))
        (§ call assertLessThanN(ilInt, "Illegal derived key: I_L >= n"))

        #_final
        (§ var BigInteger N = ECKey.CURVE.getN())
        (§ var ECPoint Ki)
        (§ switch (mode))
        (ß
            (§ case NORMAL)
                (§ ass Ki = ECKey.publicPointFromPrivate(ilInt).add(parent.getPubKeyPoint()))
                (§ break)
            (§ case WITH_INVERSION)
                ;; This trick comes from Gregory Maxwell.  Check the homomorphic properties of our curve hold.  The
                ;; below calculations should be redundant and give the same result as NORMAL but if the precalculated
                ;; tables have taken a bit flip will yield a different answer.  This mode is used when vending a key
                ;; to perform a last-ditch sanity check trying to catch bad RAM.
                (§ ass Ki = ECKey.publicPointFromPrivate(ilInt.add(RAND_INT).mod(N)))
                (§ var BigInteger additiveInverse = RAND_INT.negate().mod(N))
                (§ ass Ki = Ki.add(ECKey.publicPointFromPrivate(additiveInverse)))
                (§ ass Ki = Ki.add(parent.getPubKeyPoint()))
                (§ break)
            (§ default)
                (§ throw new AssertionError())
        )

        (§ call assertNonInfinity(Ki, "Illegal derived key: derived public key equals infinity."))
        (§ return new RawKeyBytes(Ki.getEncoded(true), chainCode))
    )

    #_private
    #_static
    (§ method void assertNonZero(BigInteger integer, String errorMessage))
    (ß
        (§ if (integer.equals(BigInteger.ZERO)))
            (§ throw new HDDerivationException(errorMessage))
    )

    #_private
    #_static
    (§ method void assertNonInfinity(ECPoint point, String errorMessage))
    (ß
        (§ if (point.equals(ECKey.CURVE.getCurve().getInfinity())))
            (§ throw new HDDerivationException(errorMessage))
    )

    #_private
    #_static
    (§ method void assertLessThanN(BigInteger integer, String errorMessage))
    (ß
        (§ if (integer.compareTo(ECKey.CURVE.getN()) > 0))
            (§ throw new HDDerivationException(errorMessage))
    )

    #_public
    #_static
    (§ class RawKeyBytes
        #_public
        #_final
        (§ field byte[] keyBytes, chainCode)

        #_public
        (§ constructor RawKeyBytes(byte[] keyBytes, byte[] chainCode))
        (ß
            (§ ass this.keyBytes = keyBytes)
            (§ ass this.chainCode = chainCode)
        )
    )
)

#_(ns org.bitcoinj.crypto #_"HDUtils"
    (:import [java.nio ByteBuffer]
             [java.util ArrayList Arrays Collections List])
    (:import [com.google.common.base Joiner]
             [com.google.common.collect ImmutableList Iterables]
             [org.spongycastle.crypto.digests SHA512Digest]
             [org.spongycastle.crypto.macs HMac]
             [org.spongycastle.crypto.params KeyParameter])
  #_(:require [org.bitcoinj.core ECKey]))

;;;
 ; Static utilities used in BIP 32 Hierarchical Deterministic Wallets (HDW).
 ;;
#_public
#_final
(§ class HDUtils
    #_private
    #_static
    #_final
    (§ field Joiner PATH_JOINER = Joiner.on("/"))

    #_static
    (§ method HMac createHmacSha512Digest(byte[] key))
    (ß
        (§ var SHA512Digest digest = new SHA512Digest())
        (§ var HMac hMac = new HMac(digest))
        (§ call hMac.init(new KeyParameter(key)))
        (§ return hMac)
    )

    #_static
    (§ method byte[] hmacSha512(HMac hmacSha512, byte[] input))
    (ß
        (§ call hmacSha512.reset())
        (§ call hmacSha512.update(input, 0, input.length))
        (§ var byte[] out = new byte[64])
        (§ call hmacSha512.doFinal(out, 0))
        (§ return out)
    )

    #_public
    #_static
    (§ method byte[] hmacSha512(byte[] key, byte[] data))
    (ß
        (§ return hmacSha512(createHmacSha512Digest(key), data))
    )

    #_static
    (§ method byte[] toCompressed(byte[] uncompressedPoint))
    (ß
        (§ return ECKey.CURVE.getCurve().decodePoint(uncompressedPoint).getEncoded(true))
    )

    #_static
    (§ method byte[] longTo4ByteArray(long n))
    (ß
        (§ var byte[] bytes = Arrays.copyOfRange(ByteBuffer.allocate(8).putLong(n).array(), 4, 8))
        (§ assert (bytes.length == 4) :assert bytes.length)
        (§ return bytes)
    )

    ;;; Append a derivation level to an existing path. ;;
    #_public
    #_static
    (§ method ImmutableList<ChildNumber> append(List<ChildNumber> path, ChildNumber childNumber))
    (ß
        (§ return ImmutableList.<ChildNumber>builder().addAll(path).add(childNumber).build())
    )

    ;;; Concatenate two derivation paths. ;;
    #_public
    #_static
    (§ method ImmutableList<ChildNumber> concat(List<ChildNumber> path, List<ChildNumber> path2))
    (ß
        (§ return ImmutableList.<ChildNumber>builder().addAll(path).addAll(path2).build())
    )

    ;;; Convert to a string path, starting with "M/". ;;
    #_public
    #_static
    (§ method String formatPath(List<ChildNumber> path))
    (ß
        (§ return PATH_JOINER.join(Iterables.concat(Collections.singleton("M"), path)))
    )

    ;;;
     ; The path is a human-friendly representation of the deterministic path.  For example:
     ;
     ; "44H / 0H / 0H / 1 / 1"
     ;
     ; Where a letter "H" means hardened key.  Spaces are ignored.
     ;;
    #_public
    #_static
    (§ method List<ChildNumber> parsePath(#_non-nil String path))
    (ß
        (§ var String[] parsedNodes = path.replace("M", "").split("/"))
        (§ var List<ChildNumber> nodes = new ArrayList<>())

        (§ for (String n :for parsedNodes))
        (ß
            (§ ass n = n.replaceAll(" ", ""))
            (§ if (n.length() != 0))
            (ß
                (§ var boolean isHard = n.endsWith("H"))
                (§ if (isHard))
                    (§ ass n = n.substring(0, n.length() - 1))
                (§ var int nodeNumber = Integer.parseInt(n))
                (§ call nodes.add(new ChildNumber(nodeNumber, isHard)))
            )
        )

        (§ return nodes)
    )
)

#_(ns org.bitcoinj.crypto #_"KeyCrypter"
    (:import [java.io Serializable])
    (:import [org.spongycastle.crypto.params KeyParameter])
  #_(:require [org.bitcoinj.wallet.Protos.Wallet EncryptionType]))

;;;
 ; <p>A KeyCrypter can be used to encrypt and decrypt a message.  The sequence of events to encrypt and then decrypt
 ; a message are as follows:</p>
 ;
 ; <p>(1) Ask the user for a password.  deriveKey() is then called to create an KeyParameter.  This contains the AES
 ; key that will be used for encryption.</p>
 ; <p>(2) Encrypt the message using encrypt(), providing the message bytes and the KeyParameter from (1).  This returns
 ; an EncryptedData which contains the encryptedPrivateKey bytes and an initialisation vector.</p>
 ; <p>(3) To decrypt an EncryptedData, repeat step (1) to get a KeyParameter, then call decrypt().</p>
 ;
 ; <p>There can be different algorithms used for encryption/ decryption so the getUnderstoodEncryptionType is used
 ; to determine whether any given KeyCrypter can understand the type of encrypted data you have.</p>
 ;;
#_public
(§ interface KeyCrypter extends Serializable
    ;;;
     ; Return the EncryptionType enum value which denotes the type of encryption/ decryption that this KeyCrypter
     ; can understand.
     ;;
    (§ method EncryptionType getUnderstoodEncryptionType())

    ;;;
     ; Create a KeyParameter (which typically contains an AES key).
     ; @param password
     ; @return the KeyParameter which typically contains the AES key to use for encrypting and decrypting.
     ; @throws KeyCrypterException
     ;;
    (§ method KeyParameter deriveKey(CharSequence password))
        (§ throws KeyCrypterException)

    ;;;
     ; Decrypt the provided encrypted bytes, converting them into unencrypted bytes.
     ;
     ; @throws KeyCrypterException if decryption was unsuccessful.
     ;;
    (§ method byte[] decrypt(EncryptedData encryptedBytesToDecode, KeyParameter aesKey))
        (§ throws KeyCrypterException)

    ;;;
     ; Encrypt the supplied bytes, converting them into ciphertext.
     ;
     ; @return an encryptedPrivateKey containing the encrypted bytes and an initialisation vector.
     ; @throws KeyCrypterException if encryption was unsuccessful.
     ;;
    (§ method EncryptedData encrypt(byte[] plainBytes, KeyParameter aesKey))
        (§ throws KeyCrypterException)
)

#_(ns org.bitcoinj.crypto #_"KeyCrypterException")

;;;
 ; <p>Exception to provide the following:</p>
 ; <ul>
 ; <li>Provision of encryption / decryption exception.</li>
 ; </ul>
 ; <p>This base exception acts as a general failure mode not attributable to a specific cause (other than
 ; that reported in the exception message).  Since this is in English, it may not be worth reporting directly
 ; to the user other than as part of a "general failure to parse" response.</p>
 ;;
#_public
(§ class KeyCrypterException extends RuntimeException
    #_public
    (§ constructor KeyCrypterException(String s))
    (ß
        (§ super (s))
    )

    #_public
    (§ constructor KeyCrypterException(String s, Throwable throwable))
    (ß
        (§ super (s, throwable))
    )
)

#_(ns org.bitcoinj.crypto #_"KeyCrypterScrypt"
    (:import [java.security SecureRandom]
             [java.util Arrays])
    (:import [com.google.common.base Objects Preconditions Stopwatch]
             [com.google.protobuf ByteString]
             [com.lambdaworks.crypto SCrypt]
             [org.slf4j Logger LoggerFactory]
             [org.spongycastle.crypto BufferedBlockCipher]
             [org.spongycastle.crypto.engines AESFastEngine]
             [org.spongycastle.crypto.modes CBCBlockCipher]
             [org.spongycastle.crypto.paddings PaddedBufferedBlockCipher]
             [org.spongycastle.crypto.params KeyParameter ParametersWithIV])
  #_(:require [org.bitcoinj.core Utils]
             [org.bitcoinj.wallet Protos]
             [org.bitcoinj.wallet.Protos ScryptParameters]
             [org.bitcoinj.wallet.Protos.Wallet EncryptionType]))

;;;
 ; <p>This class encrypts and decrypts byte arrays and strings using scrypt as the
 ; key derivation function and AES for the encryption.</p>
 ;
 ; <p>You can use this class to:</p>
 ;
 ; <p>1. Using a user password, create an AES key that can encrypt and decrypt your private keys.
 ; To convert the password to the AES key, scrypt is used.  This is an algorithm resistant
 ; to brute force attacks.  You can use the ScryptParameters to tune how difficult you
 ; want this to be generation to be.</p>
 ;
 ; <p>2. Using the AES Key generated above, you then can encrypt and decrypt any bytes using
 ; the AES symmetric cipher.  Eight bytes of salt is used to prevent dictionary attacks.</p>
 ;;
#_public
(§ class KeyCrypterScrypt implements KeyCrypter
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(KeyCrypterScrypt.class))

    ;;;
     ; Key length in bytes.
     ;;
    #_public
    #_static
    #_final
    (§ field int KEY_LENGTH = 32) ;; = 256 bits.

    ;;;
     ; The size of an AES block in bytes.
     ; This is also the length of the initialisation vector.
     ;;
    #_public
    #_static
    #_final
    (§ field int BLOCK_LENGTH = 16) ;; = 128 bits.

    ;;;
     ; The length of the salt used.
     ;;
    #_public
    #_static
    #_final
    (§ field int SALT_LENGTH = 8)

    #_static
    (ß
        ;; Init proper random number generator, as some old Android installations have bugs that make it unsecure.
        (§ if (Utils.isAndroidRuntime()))
            (§ call new LinuxSecureRandom())

        (§ ass secureRandom = new SecureRandom())
    )

    #_private
    #_static
    #_final
    (§ field SecureRandom secureRandom)

    ;;; Returns SALT_LENGTH (8) bytes of random data. ;;
    #_public
    #_static
    (§ method byte[] randomSalt())
    (ß
        (§ var byte[] salt = new byte[SALT_LENGTH])
        (§ call secureRandom.nextBytes(salt))
        (§ return salt)
    )

    ;; Scrypt parameters.
    #_private
    #_final
    (§ field ScryptParameters scryptParameters)

    ;;;
     ; Encryption/Decryption using default parameters and a random salt.
     ;;
    #_public
    (§ constructor KeyCrypterScrypt())
    (ß
        (§ var Protos.ScryptParameters.Builder builder = Protos.ScryptParameters.newBuilder().setSalt(ByteString.copyFrom(randomSalt())))
        (§ ass this.scryptParameters = builder.build())
    )

    ;;;
     ; Encryption/Decryption using custom number of iterations parameters and a random salt.
     ; As of August 2016, a useful value for mobile devices is 4096 (derivation takes about 1 second).
     ;
     ; @param iterations Number of scrypt iterations.
     ;;
    #_public
    (§ constructor KeyCrypterScrypt(int iterations))
    (ß
        (§ var Protos.ScryptParameters.Builder builder = Protos.ScryptParameters.newBuilder().setSalt(ByteString.copyFrom(randomSalt())).setN(iterations))
        (§ ass this.scryptParameters = builder.build())
    )

    ;;;
     ; Encryption/ Decryption using specified Scrypt parameters.
     ;
     ; @param scryptParameters ScryptParameters to use.
     ; @throws NullPointerException if the scryptParameters or any of its N, R or P is null.
     ;;
    #_public
    (§ constructor KeyCrypterScrypt(ScryptParameters scryptParameters))
    (ß
        (§ ass this.scryptParameters = Preconditions.checkNotNull(scryptParameters))

        ;; Check there is a non-empty salt.  Some early MultiBit wallets has a missing salt, so it is not a hard fail.
        (§ if (scryptParameters.getSalt() == nil || scryptParameters.getSalt().toByteArray() == nil || scryptParameters.getSalt().toByteArray().length == 0))
            (§ call log.warn("You are using a ScryptParameters with no salt. Your encryption may be vulnerable to a dictionary attack."))
    )

    ;;;
     ; Generate AES key.
     ;
     ; This is a very slow operation compared to encrypt/ decrypt so it is normally worth caching the result.
     ;
     ; @param password The password to use in key generation.
     ; @return the KeyParameter containing the created AES key.
     ; @throws KeyCrypterException
     ;;
    #_override
    #_public
    (§ method KeyParameter deriveKey(CharSequence password))
        (§ throws KeyCrypterException)
    (ß
        (§ var byte[] passwordBytes = nil)
        (§ try)
        (ß
            (§ ass passwordBytes = convertToByteArray(password))
            (§ var byte[] salt = new byte[0])
            (§ if (scryptParameters.getSalt() != nil))
            (ß
                (§ ass salt = scryptParameters.getSalt().toByteArray())
            )
            (§ else)
            (ß
                ;; Warn the user that they are not using a salt.  Some early MultiBit wallets had a blank salt.
                (§ call log.warn("You are using a ScryptParameters with no salt. Your encryption may be vulnerable to a dictionary attack."))
            )

            #_final
            (§ var Stopwatch watch = Stopwatch.createStarted())
            (§ var byte[] keyBytes = SCrypt.scrypt(passwordBytes, salt, (int)scryptParameters.getN(), scryptParameters.getR(), scryptParameters.getP(), KEY_LENGTH))
            (§ call watch.stop())
            (§ call log.info("Deriving key took {} for {} scrypt iterations.", watch, scryptParameters.getN()))
            (§ return new KeyParameter(keyBytes))
        )
        (§ catch (Exception e))
        (ß
            (§ throw new KeyCrypterException("Could not generate key from password and salt.", e))
        )
        (§ finally)
        (ß
            ;; Zero the password bytes.
            (§ if (passwordBytes != nil))
                (§ call java.util.Arrays.fill(passwordBytes, (byte)0))
        )
    )

    ;;;
     ; Password based encryption using AES - CBC 256 bits.
     ;;
    #_override
    #_public
    (§ method EncryptedData encrypt(byte[] plainBytes, KeyParameter aesKey))
        (§ throws KeyCrypterException)
    (ß
        (§ call Preconditions.checkNotNull(plainBytes))
        (§ call Preconditions.checkNotNull(aesKey))

        (§ try)
        (ß
            ;; Generate iv - each encryption call has a different iv.
            (§ var byte[] iv = new byte[BLOCK_LENGTH])
            (§ call secureRandom.nextBytes(iv))

            (§ var ParametersWithIV keyWithIv = new ParametersWithIV(aesKey, iv))

            ;; Encrypt using AES.
            (§ var BufferedBlockCipher cipher = new PaddedBufferedBlockCipher(new CBCBlockCipher(new AESFastEngine())))
            (§ call cipher.init(true, keyWithIv))
            (§ var byte[] encryptedBytes = new byte[cipher.getOutputSize(plainBytes.length)])
            #_final
            (§ var int length1 = cipher.processBytes(plainBytes, 0, plainBytes.length, encryptedBytes, 0))
            #_final
            (§ var int length2 = cipher.doFinal(encryptedBytes, length1))

            (§ return new EncryptedData(iv, Arrays.copyOf(encryptedBytes, length1 + length2)))
        )
        (§ catch (Exception e))
        (ß
            (§ throw new KeyCrypterException("Could not encrypt bytes.", e))
        )
    )

    ;;;
     ; Decrypt bytes previously encrypted with this class.
     ;
     ; @param dataToDecrypt The data to decrypt.
     ; @param aesKey The AES key to use for decryption.
     ; @return the decrypted bytes.
     ; @throws KeyCrypterException if bytes could not be decrypted.
     ;;
    #_override
    #_public
    (§ method byte[] decrypt(EncryptedData dataToDecrypt, KeyParameter aesKey))
        (§ throws KeyCrypterException)
    (ß
        (§ call Preconditions.checkNotNull(dataToDecrypt))
        (§ call Preconditions.checkNotNull(aesKey))

        (§ try)
        (ß
            (§ var ParametersWithIV keyWithIv = new ParametersWithIV(new KeyParameter(aesKey.getKey()), dataToDecrypt.initialisationVector))

            ;; Decrypt the message.
            (§ var BufferedBlockCipher cipher = new PaddedBufferedBlockCipher(new CBCBlockCipher(new AESFastEngine())))
            (§ call cipher.init(false, keyWithIv))

            (§ var byte[] cipherBytes = dataToDecrypt.encryptedBytes)
            (§ var byte[] decryptedBytes = new byte[cipher.getOutputSize(cipherBytes.length)])
            #_final
            (§ var int length1 = cipher.processBytes(cipherBytes, 0, cipherBytes.length, decryptedBytes, 0))
            #_final
            (§ var int length2 = cipher.doFinal(decryptedBytes, length1))

            (§ return Arrays.copyOf(decryptedBytes, length1 + length2))
        )
        (§ catch (Exception e))
        (ß
            (§ throw new KeyCrypterException("Could not decrypt bytes", e))
        )
    )

    ;;;
     ; Convert a CharSequence (which are UTF16) into a byte array.
     ;
     ; Note: a String.getBytes() is not used to avoid creating a String of the password in the JVM.
     ;;
    #_private
    #_static
    (§ method byte[] convertToByteArray(CharSequence charSequence))
    (ß
        (§ call Preconditions.checkNotNull(charSequence))

        (§ var byte[] byteArray = new byte[charSequence.length() << 1])
        (§ for (int i = 0 :for i < charSequence.length() :for i = i + 1))
        (ß
            (§ var int bytePosition = i << 1)
            (§ ass byteArray[bytePosition] = (byte)((charSequence.charAt(i) & 0xff00) >> 8))
            (§ ass byteArray[bytePosition + 1] = (byte)(charSequence.charAt(i) & 0x00ff))
        )
        (§ return byteArray)
    )

    #_public
    (§ method ScryptParameters getScryptParameters())
    (ß
        (§ return scryptParameters)
    )

    ;;;
     ; Return the EncryptionType enum value which denotes the type of encryption/ decryption that this KeyCrypter
     ; can understand.
     ;;
    #_override
    #_public
    (§ method EncryptionType getUnderstoodEncryptionType())
    (ß
        (§ return EncryptionType.ENCRYPTED_SCRYPT_AES)
    )

    #_override
    #_public
    (§ method String toString())
    (ß
        (§ return "AES-" + KEY_LENGTH * 8 + "-CBC, Scrypt (N: " + scryptParameters.getN() + ")")
    )

    #_override
    #_public
    (§ method int hashCode())
    (ß
        (§ return Objects.hashCode(scryptParameters))
    )

    #_override
    #_public
    (§ method boolean equals(Object o))
    (ß
        (§ if (this == o))
            (§ return true)
        (§ if (o == nil || getClass() != o.getClass()))
            (§ return false)
        (§ return Objects.equal(scryptParameters, ((KeyCrypterScrypt)o).scryptParameters))
    )
)

#_(ns org.bitcoinj.crypto #_"LazyECPoint"
    (:import [java.math BigInteger]
             [java.util Arrays])
    (:import [com.google.common.base Preconditions]
             [org.spongycastle.math.ec ECCurve ECFieldElement ECPoint]))

;;;
 ; A wrapper around ECPoint that delays decoding of the point for as long as possible.  This is useful because point
 ; encode/decode in Bouncy Castle is quite slow especially on Dalvik, as it often involves decompression/recompression.
 ;;
#_public
(§ class LazyECPoint
    ;; If curve is set, bits is also set.  If curve is unset, point is set and bits is unset.  Point can be set along
    ;; with curve and bits when the cached form has been accessed and thus must have been converted.
    #_private
    #_final
    (§ field ECCurve curve)
    #_private
    #_final
    (§ field byte[] bits)

    ;; This field is effectively final - once set it won't change again.  However it can be set after construction.
    #_nilable
    #_private
    (§ field ECPoint point)

    #_public
    (§ constructor LazyECPoint(ECCurve curve, byte[] bits))
    (ß
        (§ ass this.curve = curve)
        (§ ass this.bits = bits)
    )

    #_public
    (§ constructor LazyECPoint(ECPoint point))
    (ß
        (§ ass this.point = Preconditions.checkNotNull(point))
        (§ ass this.curve = nil)
        (§ ass this.bits = nil)
    )

    #_public
    (§ method ECPoint get())
    (ß
        (§ if (point == nil))
            (§ ass point = curve.decodePoint(bits))
        (§ return point)
    )

    ;; Delegated methods.

    #_public
    (§ method ECPoint getDetachedPoint())
    (ß
        (§ return get().getDetachedPoint())
    )

    #_public
    (§ method byte[] getEncoded())
    (ß
        (§ if (bits != nil))
            (§ return Arrays.copyOf(bits, bits.length))
        (§ else)
            (§ return get().getEncoded())
    )

    #_public
    (§ method boolean isInfinity())
    (ß
        (§ return get().isInfinity())
    )

    #_public
    (§ method ECPoint timesPow2(int e))
    (ß
        (§ return get().timesPow2(e))
    )

    #_public
    (§ method ECFieldElement getYCoord())
    (ß
        (§ return get().getYCoord())
    )

    #_public
    (§ method ECFieldElement[] getZCoords())
    (ß
        (§ return get().getZCoords())
    )

    #_public
    (§ method boolean isNormalized())
    (ß
        (§ return get().isNormalized())
    )

    #_public
    (§ method boolean isCompressed())
    (ß
        (§ if (bits != nil))
            (§ return (bits[0] == 2 || bits[0] == 3))
        (§ else)
            (§ return get().isCompressed())
    )

    #_public
    (§ method ECPoint multiply(BigInteger k))
    (ß
        (§ return get().multiply(k))
    )

    #_public
    (§ method ECPoint subtract(ECPoint b))
    (ß
        (§ return get().subtract(b))
    )

    #_public
    (§ method boolean isValid())
    (ß
        (§ return get().isValid())
    )

    #_public
    (§ method ECPoint scaleY(ECFieldElement scale))
    (ß
        (§ return get().scaleY(scale))
    )

    #_public
    (§ method ECFieldElement getXCoord())
    (ß
        (§ return get().getXCoord())
    )

    #_public
    (§ method ECPoint scaleX(ECFieldElement scale))
    (ß
        (§ return get().scaleX(scale))
    )

    #_public
    (§ method boolean equals(ECPoint other))
    (ß
        (§ return get().equals(other))
    )

    #_public
    (§ method ECPoint negate())
    (ß
        (§ return get().negate())
    )

    #_public
    (§ method ECPoint threeTimes())
    (ß
        (§ return get().threeTimes())
    )

    #_public
    (§ method ECFieldElement getZCoord(int index))
    (ß
        (§ return get().getZCoord(index))
    )

    #_public
    (§ method byte[] getEncoded(boolean compressed))
    (ß
        (§ if (compressed == isCompressed() && bits != nil))
            (§ return Arrays.copyOf(bits, bits.length))
        (§ else)
            (§ return get().getEncoded(compressed))
    )

    #_public
    (§ method ECPoint add(ECPoint b))
    (ß
        (§ return get().add(b))
    )

    #_public
    (§ method ECPoint twicePlus(ECPoint b))
    (ß
        (§ return get().twicePlus(b))
    )

    #_public
    (§ method ECCurve getCurve())
    (ß
        (§ return get().getCurve())
    )

    #_public
    (§ method ECPoint normalize())
    (ß
        (§ return get().normalize())
    )

    #_public
    (§ method ECFieldElement getY())
    (ß
        (§ return this.normalize().getYCoord())
    )

    #_public
    (§ method ECPoint twice())
    (ß
        (§ return get().twice())
    )

    #_public
    (§ method ECFieldElement getAffineYCoord())
    (ß
        (§ return get().getAffineYCoord())
    )

    #_public
    (§ method ECFieldElement getAffineXCoord())
    (ß
        (§ return get().getAffineXCoord())
    )

    #_public
    (§ method ECFieldElement getX())
    (ß
        (§ return this.normalize().getXCoord())
    )

    #_override
    #_public
    (§ method boolean equals(Object o))
    (ß
        (§ if (this == o))
            (§ return true)
        (§ if (o == nil || getClass() != o.getClass()))
            (§ return false)
        (§ return Arrays.equals(getCanonicalEncoding(), ((LazyECPoint)o).getCanonicalEncoding()))
    )

    #_override
    #_public
    (§ method int hashCode())
    (ß
        (§ return Arrays.hashCode(getCanonicalEncoding()))
    )

    #_private
    (§ method byte[] getCanonicalEncoding())
    (ß
        (§ return getEncoded(true))
    )
)

#_(ns org.bitcoinj.crypto #_"LinuxSecureRandom"
    (:import #_[java.io *]
             #_[java.security *])
    (:import #_[org.slf4j *]))

;;;
 ; A SecureRandom implementation that is able to override the standard JVM provided implementation, and which simply
 ; serves random numbers by reading /dev/urandom.  That is, it delegates to the kernel on UNIX systems and is unusable
 ; on other platforms.  Attempts to manually set the seed are ignored.  There is no difference between seed bytes and
 ; non-seed bytes, they are all from the same source.
 ;;
#_public
(§ class LinuxSecureRandom extends SecureRandomSpi
    #_private
    #_static
    #_final
    (§ field FileInputStream urandom)

    #_private
    #_static
    (§ class LinuxSecureRandomProvider extends Provider
        #_public
        (§ constructor LinuxSecureRandomProvider())
        (ß
            (§ super ("LinuxSecureRandom", 1.0, "A Linux specific random number provider that uses /dev/urandom"))

            (§ call put("SecureRandom.LinuxSecureRandom", LinuxSecureRandom.class.getName()))
        )
    )

    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(LinuxSecureRandom.class))

    #_static
    (ß
        (§ try)
        (ß
            (§ var File file = new File("/dev/urandom"))
            ;; This stream is deliberately leaked.
            (§ ass urandom = new FileInputStream(file))
            (§ if (urandom.read() == -1))
                (§ throw new RuntimeException("/dev/urandom not readable?"))

            ;; Now override the default SecureRandom implementation with this one.
            (§ var int position = Security.insertProviderAt(new LinuxSecureRandomProvider(), 1))

            (§ if (position != -1))
                (§ call log.info("Secure randomness will be read from {} only.", file))
            (§ else)
                (§ call log.info("Randomness is already secure."))
        )
        (§ catch (FileNotFoundException e))
        (ß
            ;; Should never happen.
            (§ call log.error("/dev/urandom does not appear to exist or is not openable"))
            (§ throw new RuntimeException(e))
        )
        (§ catch (IOException e))
        (ß
            (§ call log.error("/dev/urandom does not appear to be readable"))
            (§ throw new RuntimeException(e))
        )
    )

    #_private
    #_final
    (§ field DataInputStream dis)

    #_public
    (§ constructor LinuxSecureRandom())
    (ß
        ;; DataInputStream is not thread safe, so each random object has its own.
        (§ ass dis = new DataInputStream(urandom))
    )

    #_override
    #_protected
    (§ method void engineSetSeed(byte[] bytes))
    (ß
        ;; Ignore.
    )

    #_override
    #_protected
    (§ method void engineNextBytes(byte[] bytes))
    (ß
        (§ try)
        (ß
            (§ call dis.readFully(bytes)) ;; This will block until all the bytes can be read.
        )
        (§ catch (IOException e))
        (ß
            (§ throw new RuntimeException(e)) ;; Fatal error.  Do not attempt to recover from this.
        )
    )

    #_override
    #_protected
    (§ method byte[] engineGenerateSeed(int i))
    (ß
        (§ var byte[] bits = new byte[i])
        (§ call engineNextBytes(bits))
        (§ return bits)
    )
)

#_(ns org.bitcoinj.crypto #_"MnemonicCode"
    (:import [java.io BufferedReader FileNotFoundException IOException InputStream InputStreamReader]
             [java.security MessageDigest]
             [java.util ArrayList Collections List])
    (:import [com.google.common.base Stopwatch]
             [org.slf4j Logger LoggerFactory])
  #_(:require [org.bitcoinj.core Sha256Hash Utils]
             #_static #_[org.bitcoinj.core.Utils HEX]))

;;;
 ; A MnemonicCode object may be used to convert between binary seed values and lists of words per
 ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki">the BIP 39 specification</a>.
 ;;

#_public
(§ class MnemonicCode
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(MnemonicCode.class))

    #_private
    (§ field ArrayList<String> wordList)

    #_private
    #_static
    #_final
    (§ field String BIP39_ENGLISH_RESOURCE_NAME = "mnemonic/wordlist/english.txt")
    #_private
    #_static
    #_final
    (§ field String BIP39_ENGLISH_SHA256 = "ad90bf3beb7b0eb7e5acd74727dc0da96e0a280a258354e7293fb7e211ac03db")

    ;;; UNIX time for when the BIP39 standard was finalised.  This can be used as a default seed birthday. ;;
    #_public
    #_static
    (§ field long BIP39_STANDARDISATION_TIME_SECS = 1381276800)

    #_private
    #_static
    #_final
    (§ field int PBKDF2_ROUNDS = 2048)

    #_public
    #_static
    (§ field MnemonicCode INSTANCE)

    #_static
    (ß
        (§ try)
        (ß
            (§ ass INSTANCE = new MnemonicCode())
        )
        (§ catch (FileNotFoundException e))
        (ß
            ;; We expect failure on Android.  The developer has to set INSTANCE themselves.
            (§ if (!Utils.isAndroidRuntime()))
                (§ call log.error("Could not find word list", e))
        )
        (§ catch (IOException e))
        (ß
            (§ call log.error("Failed to load word list", e))
        )
    )

    ;;; Initialise from the included word list.  Won't work on Android. ;;
    #_public
    (§ constructor MnemonicCode())
        (§ throws IOException)
    (ß
        (§ this (openDefaultWords(), BIP39_ENGLISH_SHA256))
    )

    #_private
    #_static
    (§ method InputStream openDefaultWords())
        (§ throws IOException)
    (ß
        (§ var InputStream stream = MnemonicCode.class.getResourceAsStream(BIP39_ENGLISH_RESOURCE_NAME))
        (§ if (stream == nil))
            (§ throw new FileNotFoundException(BIP39_ENGLISH_RESOURCE_NAME))
        (§ return stream)
    )

    ;;;
     ; Creates an MnemonicCode object, initializing with words read from the supplied input stream.
     ; If a wordListDigest is supplied, the digest of the words will be checked.
     ;;
    #_public
    (§ constructor MnemonicCode(InputStream wordstream, String wordListDigest))
        (§ throws IOException, IllegalArgumentException)
    (ß
        (§ var BufferedReader br = new BufferedReader(new InputStreamReader(wordstream, "UTF-8")))
        (§ ass this.wordList = new ArrayList<>(2048))
        (§ var MessageDigest md = Sha256Hash.newDigest())
        (§ var String word)
        (§ while ((word = br.readLine()) != nil))
        (ß
            (§ call md.update(word.getBytes()))
            (§ call this.wordList.add(word))
        )
        (§ call br.close())

        (§ if (this.wordList.size() != 2048))
            (§ throw new IllegalArgumentException("input stream did not contain 2048 words"))

        ;; If a wordListDigest is supplied, check to make sure it matches.
        (§ if (wordListDigest != nil))
        (ß
            (§ var byte[] digest = md.digest())
            (§ var String hexdigest = HEX.encode(digest))
            (§ if (!hexdigest.equals(wordListDigest)))
                (§ throw new IllegalArgumentException("wordlist digest mismatch"))
        )
    )

    ;;;
     ; Gets the word list this code uses.
     ;;
    #_public
    (§ method List<String> getWordList())
    (ß
        (§ return wordList)
    )

    ;;;
     ; Convert mnemonic word list to seed.
     ;;
    #_public
    #_static
    (§ method byte[] toSeed(List<String> words, String passphrase))
    (ß
        ;; To create binary seed from mnemonic, we use PBKDF2 function with mnemonic sentence (in UTF-8) used as a password
        ;; and string "mnemonic" + passphrase (again in UTF-8) used as a salt.  Iteration count is set to 4096 and HMAC-SHA512
        ;; is used as a pseudo-random function.  Desired length of the derived key is 512 bits (= 64 bytes).

        (§ var String pass = Utils.SPACE_JOINER.join(words))
        (§ var String salt = "mnemonic" + passphrase)

        #_final
        (§ var Stopwatch watch = Stopwatch.createStarted())
        (§ var byte[] seed = PBKDF2SHA512.derive(pass, salt, PBKDF2_ROUNDS, 64))
        (§ call watch.stop())
        (§ call log.info("PBKDF2 took {}", watch))
        (§ return seed)
    )

    ;;;
     ; Convert mnemonic word list to original entropy value.
     ;;
    #_public
    (§ method byte[] toEntropy(List<String> words))
        (§ throws MnemonicException.MnemonicLengthException, MnemonicException.MnemonicWordException, MnemonicException.MnemonicChecksumException)
    (ß
        (§ if (0 < words.size() % 3))
            (§ throw new MnemonicException.MnemonicLengthException("Word list size must be multiple of three words."))

        (§ if (words.size() == 0))
            (§ throw new MnemonicException.MnemonicLengthException("Word list is empty."))

        ;; Look up all the words in the list and construct the concatenation of the original entropy and the checksum.

        (§ var int concatLenBits = words.size() * 11)
        (§ var boolean[] concatBits = new boolean[concatLenBits])
        (§ var int wordindex = 0)
        (§ for (String word :for words))
        (ß
            ;; Find the words index in the wordlist.
            (§ var int ndx = Collections.binarySearch(this.wordList, word))
            (§ if (ndx < 0))
                (§ throw new MnemonicException.MnemonicWordException(word))

            ;; Set the next 11 bits to the value of the index.
            (§ for (int i = 0 :for i < 11 :for i = i + 1))
                (§ ass concatBits[(wordindex * 11) + i] = ((ndx & (1 << (10 - i))) != 0))
            (§ ass wordindex = wordindex + 1)
        )

        (§ var int checksumLengthBits = concatLenBits / 33)
        (§ var int entropyLengthBits = concatLenBits - checksumLengthBits)

        ;; Extract original entropy as bytes.
        (§ var byte[] entropy = new byte[entropyLengthBits / 8])
        (§ for (int i = 0 :for i < entropy.length :for i = i + 1))
            (§ for (int j = 0 :for j < 8 :for j = j + 1))
                (§ if (concatBits[(i * 8) + j]))
                    (§ ass entropy[i] = entropy[i] | (1 << (7 - j)))

        ;; Take the digest of the entropy.
        (§ var byte[] hash = Sha256Hash.hash(entropy))
        (§ var boolean[] hashBits = bytesToBits(hash))

        ;; Check all the checksum bits.
        (§ for (int i = 0 :for i < checksumLengthBits :for i = i + 1))
            (§ if (concatBits[entropyLengthBits + i] != hashBits[i]))
                (§ throw new MnemonicException.MnemonicChecksumException())

        (§ return entropy)
    )

    ;;;
     ; Convert entropy data to mnemonic word list.
     ;;
    #_public
    (§ method List<String> toMnemonic(byte[] entropy))
        (§ throws MnemonicException.MnemonicLengthException)
    (ß
        (§ if (0 < entropy.length % 4))
            (§ throw new MnemonicException.MnemonicLengthException("Entropy length not multiple of 32 bits."))

        (§ if (entropy.length == 0))
            (§ throw new MnemonicException.MnemonicLengthException("Entropy is empty."))

        ;; We take initial entropy of ENT bits and compute its checksum by taking first ENT / 32 bits of its SHA256 hash.

        (§ var byte[] hash = Sha256Hash.hash(entropy))
        (§ var boolean[] hashBits = bytesToBits(hash))

        (§ var boolean[] entropyBits = bytesToBits(entropy))
        (§ var int checksumLengthBits = entropyBits.length / 32)

        ;; We append these bits to the end of the initial entropy.
        (§ var boolean[] concatBits = new boolean[entropyBits.length + checksumLengthBits])
        (§ call System.arraycopy(entropyBits, 0, concatBits, 0, entropyBits.length))
        (§ call System.arraycopy(hashBits, 0, concatBits, entropyBits.length, checksumLengthBits))

        ;; Next we take these concatenated bits and split them into groups of 11 bits.  Each group encodes number from 0-2047
        ;; which is a position in a wordlist.  We convert numbers into words and use joined words as mnemonic sentence.

        (§ var ArrayList<String> words = new ArrayList<>())
        (§ var int nwords = concatBits.length / 11)
        (§ for (int i = 0 :for i < nwords :for i = i + 1))
        (ß
            (§ var int index = 0)
            (§ for (int j = 0 :for j < 11 :for j = j + 1))
            (ß
                (§ ass index = index << 1)
                (§ if (concatBits[(i * 11) + j]))
                    (§ ass index = index | 0x1)
            )
            (§ call words.add(this.wordList.get(index)))
        )

        (§ return words)
    )

    ;;;
     ; Check to see if a mnemonic word list is valid.
     ;;
    #_public
    (§ method void check(List<String> words))
        (§ throws MnemonicException)
    (ß
        (§ call toEntropy(words))
    )

    #_private
    #_static
    (§ method boolean[] bytesToBits(byte[] data))
    (ß
        (§ var boolean[] bits = new boolean[data.length * 8])
        (§ for (int i = 0 :for i < data.length :for i = i + 1))
            (§ for (int j = 0 :for j < 8 :for j = j + 1))
                (§ ass bits[(i * 8) + j] = ((data[i] & (1 << (7 - j))) != 0))
        (§ return bits)
    )
)

#_(ns org.bitcoinj.crypto #_"MnemonicException")

;;;
 ; Exceptions thrown by the MnemonicCode module.
 ;;
#_public
(§ class MnemonicException extends Exception
    #_public
    (§ constructor MnemonicException())
    (ß
        (§ super ())
    )

    #_public
    (§ constructor MnemonicException(String msg))
    (ß
        (§ super (msg))
    )

    ;;;
     ; Thrown when an argument to MnemonicCode is the wrong length.
     ;;
    #_public
    #_static
    (§ class MnemonicLengthException extends MnemonicException
        #_public
        (§ constructor MnemonicLengthException(String msg))
        (ß
            (§ super (msg))
        )
    )

    ;;;
     ; Thrown when a list of MnemonicCode words fails the checksum check.
     ;;
    #_public
    #_static
    (§ class MnemonicChecksumException extends MnemonicException
        #_public
        (§ constructor MnemonicChecksumException())
        (ß
            (§ super ())
        )
    )

    ;;;
     ; Thrown when a word is encountered which is not in the MnemonicCode's word list.
     ;;
    #_public
    #_static
    (§ class MnemonicWordException extends MnemonicException
        ;;; Contains the word that was not found in the word list. ;;
        #_public
        #_final
        (§ field String badWord)

        #_public
        (§ constructor MnemonicWordException(String badWord))
        (ß
            (§ super ())
            (§ ass this.badWord = badWord)
        )
    )
)

#_(ns org.bitcoinj.crypto #_"PBKDF2SHA512"
    (:import [java.io ByteArrayOutputStream]
             [java.nio ByteBuffer ByteOrder]
             [javax.crypto Mac]
             [javax.crypto.spec SecretKeySpec]))

;;;
 ; <p>This is a clean-room implementation of PBKDF2 using RFC 2898 as a reference.</p>
 ;
 ; <p>RFC 2898: http://tools.ietf.org/html/rfc2898#section-5.2</p>
 ;
 ; <p>This code passes all RFC 6070 test vectors: http://tools.ietf.org/html/rfc6070</p>
 ;
 ; <p>http://cryptofreek.org/2012/11/29/pbkdf2-pure-java-implementation/<br>
 ; Modified to use SHA-512 - Ken Sedgwick ken@bonsai.com</p>
 ;;
#_public
(§ class PBKDF2SHA512
    #_public
    #_static
    (§ method byte[] derive(String P, String S, int c, int dkLen))
    (ß
        (§ var ByteArrayOutputStream baos = new ByteArrayOutputStream())

        (§ try)
        (ß
            (§ var int hLen = 20)

            (§ if (((Math.pow(2, 32)) - 1) * hLen < dkLen))
                (§ throw new IllegalArgumentException("derived key too long"))

            (§ var int l = (int)Math.ceil((double)dkLen / (double)hLen))
         ;; int r = dkLen - (l - 1) * hLen;

            (§ for (int i = 1 :for i <= l :for i = i + 1))
            (ß
                (§ var byte[] T = F(P, S, c, i))
                (§ call baos.write(T))
            )
        )
        (§ catch (Exception e))
        (ß
            (§ throw new RuntimeException(e))
        )

        (§ var byte[] baDerived = new byte[dkLen])
        (§ call System.arraycopy(baos.toByteArray(), 0, baDerived, 0, baDerived.length))

        (§ return baDerived)
    )

    #_private
    #_static
    (§ method byte[] F(String P, String S, int c, int i))
        (§ throws Exception)
    (ß
        (§ var byte[] U_LAST = nil)
        (§ var byte[] U_XOR = nil)

        (§ var SecretKeySpec key = new SecretKeySpec(P.getBytes("UTF-8"), "HmacSHA512"))
        (§ var Mac mac = Mac.getInstance(key.getAlgorithm()))
        (§ call mac.init(key))

        (§ for (int j = 0 :for j < c :for j = j + 1))
        (ß
            (§ if (j == 0))
            (ß
                (§ var byte[] baS = S.getBytes("UTF-8"))
                (§ var byte[] baI = INT(i))
                (§ var byte[] baU = new byte[baS.length + baI.length])

                (§ call System.arraycopy(baS, 0, baU, 0, baS.length))
                (§ call System.arraycopy(baI, 0, baU, baS.length, baI.length))

                (§ ass U_XOR = mac.doFinal(baU))
                (§ ass U_LAST = U_XOR)
                (§ call mac.reset())
            )
            (§ else)
            (ß
                (§ var byte[] baU = mac.doFinal(U_LAST))
                (§ call mac.reset())

                (§ for (int k = 0 :for k < U_XOR.length :for k = k + 1))
                (ß
                    (§ ass U_XOR[k] = (byte)(U_XOR[k] :xor baU[k]))
                )

                (§ ass U_LAST = baU)
            )
        )

        (§ return U_XOR)
    )

    #_private
    #_static
    (§ method byte[] INT(int i))
    (ß
        (§ var ByteBuffer bb = ByteBuffer.allocate(4))
        (§ call bb.order(ByteOrder.BIG_ENDIAN))
        (§ call bb.putInt(i))

        (§ return bb.array())
    )
)

#_(ns org.bitcoinj.crypto #_"TransactionSignature"
    (:import [java.io ByteArrayOutputStream IOException]
             [java.math BigInteger])
    (:import [com.google.common.base Preconditions])
  #_(:require [org.bitcoinj.core ECKey Transaction VerificationException]
             [org.bitcoinj.core.Transaction SigHash]))

;;;
 ; A TransactionSignature wraps an {@link org.bitcoinj.core.ECKey.ECDSASignature} and adds methods for handling
 ; the additional SIGHASH mode byte that is used.
 ;;
#_public
(§ class TransactionSignature extends ECKey.ECDSASignature
    ;;;
     ; A byte that controls which parts of a transaction are signed.  This is exposed because signatures
     ; parsed off the wire may have sighash flags that aren't "normal" serializations of the enum values.
     ; Because Bitcoin Core works via bit testing, we must not lose the exact value when round-tripping
     ; otherwise we'll fail to verify signature hashes.
     ;;
    #_public
    #_final
    (§ field int sighashFlags)

    ;;; Constructs a signature with the given components and SIGHASH_ALL. ;;
    #_public
    (§ constructor TransactionSignature(BigInteger r, BigInteger s))
    (ß
        (§ this (r, s, Transaction.SigHash.ALL.value))
    )

    ;;; Constructs a signature with the given components and raw sighash flag bytes (needed for rule compatibility). ;;
    #_public
    (§ constructor TransactionSignature(BigInteger r, BigInteger s, int sighashFlags))
    (ß
        (§ super (r, s))
        (§ ass this.sighashFlags = sighashFlags)
    )

    ;;; Constructs a transaction signature based on the ECDSA signature. ;;
    #_public
    (§ constructor TransactionSignature(ECKey.ECDSASignature signature, Transaction.SigHash mode, boolean anyoneCanPay))
    (ß
        (§ super (signature.r, signature.s))
        (§ ass sighashFlags = calcSigHashValue(mode, anyoneCanPay))
    )

    ;;;
     ; Returns a dummy invalid signature whose R/S values are set such that they will take up the same number of
     ; encoded bytes as a real signature.  This can be useful when you want to fill out a transaction to be of
     ; the right size (e.g. for fee calculations) but don't have the requisite signing key yet and will fill out
     ; the real signature later.
     ;;
    #_public
    #_static
    (§ method TransactionSignature dummy())
    (ß
        (§ var BigInteger val = ECKey.HALF_CURVE_ORDER)
        (§ return new TransactionSignature(val, val))
    )

    ;;; Calculates the byte used in the protocol to represent the combination of mode and anyoneCanPay. ;;
    #_public
    #_static
    (§ method int calcSigHashValue(Transaction.SigHash mode, boolean anyoneCanPay))
    (ß
        ;; Enforce compatibility since this code was made before the SigHash enum was updated.
        (§ call Preconditions.checkArgument(SigHash.ALL == mode || SigHash.NONE == mode || SigHash.SINGLE == mode))

        (§ var int sighashFlags = mode.value)
        (§ if (anyoneCanPay))
            (§ ass sighashFlags = sighashFlags | Transaction.SigHash.ANYONECANPAY.value)
        (§ return sighashFlags)
    )

    ;;;
     ; Returns true if the given signature is has canonical encoding, and will thus be accepted as standard by
     ; Bitcoin Core.  DER and the SIGHASH encoding allow for quite some flexibility in how the same structures
     ; are encoded, and this can open up novel attacks in which a man in the middle takes a transaction and then
     ; changes its signature such that the transaction hash is different but it's still valid.  This can confuse
     ; wallets and generally violates people's mental model of how Bitcoin should work, thus non-canonical
     ; signatures are now not relayed by default.
     ;;
    #_public
    #_static
    (§ method boolean isEncodingCanonical(byte[] signature))
    (ß
        ;; See Bitcoin Core's IsCanonicalSignature, https://bitcointalk.org/index.php?topic=8392.msg127623#msg127623
        ;; A canonical signature exists of: <30> <total len> <02> <len R> <R> <02> <len S> <S> <hashtype>
        ;; Where R and S are not negative (their first byte has its highest bit not set), and not
        ;; excessively padded (do not start with a 0 byte, unless an otherwise negative number follows,
        ;; in which case a single 0 byte is necessary and even required).
        (§ if (signature.length < 9 || 73 < signature.length))
            (§ return false)

        (§ var int hashType = (signature[signature.length-1] & 0xff) & ~Transaction.SigHash.ANYONECANPAY.value) ;; mask the byte to prevent sign-extension hurting us
        (§ if (hashType < Transaction.SigHash.ALL.value || Transaction.SigHash.SINGLE.value < hashType))
            (§ return false)

        ;;                   "wrong type"                  "wrong length marker"
        (§ if ((signature[0] & 0xff) != 0x30 || (signature[1] & 0xff) != signature.length - 3))
            (§ return false)

        (§ var int lenR = signature[3] & 0xff)
        (§ if (signature.length <= 5 + lenR || lenR == 0))
            (§ return false)
        (§ var int lenS = signature[5 + lenR] & 0xff)
        (§ if (lenR + lenS + 7 != signature.length || lenS == 0))
            (§ return false)

        ;;    R value type mismatch          R value negative
        (§ if (signature[4 - 2] != 0x02 || (signature[4] & 0x80) == 0x80))
            (§ return false)
        (§ if (1 < lenR && signature[4] == 0x00 && (signature[4 + 1] & 0x80) != 0x80))
            (§ return false) ;; R value excessively padded

        ;;       S value type mismatch                    S value negative
        (§ if (signature[6 + lenR - 2] != 0x02 || (signature[6 + lenR] & 0x80) == 0x80))
            (§ return false)
        (§ if (1 < lenS && signature[6 + lenR] == 0x00 && (signature[6 + lenR + 1] & 0x80) != 0x80))
            (§ return false) ;; S value excessively padded

        (§ return true)
    )

    #_public
    (§ method boolean anyoneCanPay())
    (ß
        (§ return ((sighashFlags & Transaction.SigHash.ANYONECANPAY.value) != 0))
    )

    #_public
    (§ method Transaction.SigHash sigHashMode())
    (ß
        #_final
        (§ var int mode = sighashFlags & 0x1f)

        (§ if (mode == Transaction.SigHash.NONE.value))
            (§ return Transaction.SigHash.NONE)
        (§ if (mode == Transaction.SigHash.SINGLE.value))
            (§ return Transaction.SigHash.SINGLE)

        (§ return Transaction.SigHash.ALL)
    )

    ;;;
     ; What we get back from the signer are the two components of a signature, r and s.  To get a flat byte stream
     ; of the type used by Bitcoin we have to encode them using DER encoding, which is just a way to pack the two
     ; components into a structure, and then we append a byte to the end for the sighash flags.
     ;;
    #_public
    (§ method byte[] encodeToBitcoin())
    (ß
        (§ try)
        (ß
            (§ var ByteArrayOutputStream bos = derByteStream())
            (§ call bos.write(sighashFlags))
            (§ return bos.toByteArray())
        )
        (§ catch (IOException e))
        (ß
            (§ throw new RuntimeException(e)) ;; Cannot happen.
        )
    )

    #_override
    #_public
    (§ method ECKey.ECDSASignature toCanonicalised())
    (ß
        (§ return new TransactionSignature(super.toCanonicalised(), sigHashMode(), anyoneCanPay()))
    )

    ;;;
     ; Returns a decoded signature.
     ;
     ; @param requireCanonicalEncoding if the encoding of the signature must be canonical.
     ; @throws RuntimeException if the signature is invalid or unparseable in some way.
     ; @deprecated use {@link #decodeFromBitcoin(byte[], boolean, boolean)} instead.
     ;;
    #_deprecated
    #_public
    #_static
    (§ method TransactionSignature decodeFromBitcoin(byte[] bytes, boolean requireCanonicalEncoding))
        (§ throws VerificationException)
    (ß
        (§ return decodeFromBitcoin(bytes, requireCanonicalEncoding, false))
    )

    ;;;
     ; Returns a decoded signature.
     ;
     ; @param requireCanonicalEncoding if the encoding of the signature must be canonical.
     ; @param requireCanonicalSValue if the S-value must be canonical (below half the order of the curve).
     ; @throws RuntimeException if the signature is invalid or unparseable in some way.
     ;;
    #_public
    #_static
    (§ method TransactionSignature decodeFromBitcoin(byte[] bytes, boolean requireCanonicalEncoding, boolean requireCanonicalSValue))
        (§ throws VerificationException)
    (ß
        ;; Bitcoin encoding is DER signature + sighash byte.
        (§ if (requireCanonicalEncoding && !isEncodingCanonical(bytes)))
            (§ throw new VerificationException("Signature encoding is not canonical."))

        (§ var ECKey.ECDSASignature sig)
        (§ try)
        (ß
            (§ ass sig = ECKey.ECDSASignature.decodeFromDER(bytes))
        )
        (§ catch (IllegalArgumentException e))
        (ß
            (§ throw new VerificationException("Could not decode DER", e))
        )
        (§ if (requireCanonicalSValue && !sig.isCanonical()))
            (§ throw new VerificationException("S-value is not canonical."))

        ;; In Bitcoin, any value of the final byte is valid, but not necessarily canonical.  See javadocs
        ;; for isEncodingCanonical to learn more about this.  So we must store the exact byte found.
        (§ return new TransactionSignature(sig.r, sig.s, bytes[bytes.length - 1]))
    )
)

#_(ns org.bitcoinj.kits #_"WalletAppKit"
    (:import #_[java.io *]
             #_[java.net *]
             #_[java.nio.channels *]
             #_[java.util *]
             #_[java.util.concurrent *])
    (:import [com.google.common.base Preconditions]
             #_[com.google.common.collect *]
             #_[com.google.common.util.concurrent *]
             #_[org.slf4j *])
  #_(:require #_[org.bitcoinj.core.listeners *]
             #_[org.bitcoinj.core *]
             #_[org.bitcoinj.net.discovery *]
             #_[org.bitcoinj.store *]
             #_[org.bitcoinj.wallet *]))

;;;
 ; <p>Utility class that wraps the boilerplate needed to set up a new SPV bitcoinj app.  Instantiate it with a directory
 ; and file prefix, optionally configure a few things, then use startAsync and optionally awaitRunning.  The object will
 ; construct and configure a {@link BlockChain}, {@link SPVBlockStore}, {@link Wallet} and {@link PeerGroup}.  Depending
 ; on the value of the blockingStartup property, startup will be considered complete once the block chain has fully
 ; synchronized, so it can take a while.</p>
 ;
 ; <p>To add listeners and modify the objects that are constructed, you can either do that by overriding the
 ; {@link #onSetupCompleted()} method (which will run on a background thread) and make your changes there,
 ; or by waiting for the service to start and then accessing the objects from wherever you want.  However, you cannot
 ; access the objects this class creates until startup is complete.</p>
 ;
 ; <p>The asynchronous design of this class may seem puzzling (just use {@link #awaitRunning()} if you don't want that).
 ; It is to make it easier to fit bitcoinj into GUI apps, which require a high degree of responsiveness on their main
 ; thread which handles all the animation and user interaction.  Even when blockingStart is false, initializing bitcoinj
 ; means doing potentially blocking file IO, generating keys and other potentially intensive operations.  By running it
 ; on a background thread, there's no risk of accidentally causing UI lag.</p>
 ;
 ; <p>Note that {@link #awaitRunning()} can throw an unchecked {@link java.lang.IllegalStateException}
 ; if anything goes wrong during startup - you should probably handle it and use {@link Exception#getCause()} to figure
 ; out what went wrong more precisely.  Same thing if you just use the {@link #startAsync()} method.</p>
 ;;
#_public
(§ class WalletAppKit extends AbstractIdleService
    #_protected
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(WalletAppKit.class))

    #_protected
    #_final
    (§ field String filePrefix)
    #_protected
    #_final
    (§ field NetworkParameters params)
    #_protected
    #_volatile
    (§ field BlockChain vChain)
    #_protected
    #_volatile
    (§ field BlockStore vStore)
    #_protected
    #_volatile
    (§ field Wallet vWallet)
    #_protected
    #_volatile
    (§ field PeerGroup vPeerGroup)

    #_protected
    #_final
    (§ field File directory)
    #_protected
    #_volatile
    (§ field File vWalletFile)

    #_protected
    (§ field boolean useAutoSave = true)
    #_protected
    (§ field PeerAddress[] peerAddresses)
    #_protected
    (§ field DownloadProgressTracker downloadListener)
    #_protected
    (§ field boolean autoStop = true)
    #_protected
    (§ field InputStream checkpoints)
    #_protected
    (§ field boolean blockingStartup = true)
    #_protected
    (§ field String userAgent, version)
    #_protected
    (§ field WalletProtobufSerializer.WalletFactory walletFactory)
    #_nilable
    #_protected
    (§ field DeterministicSeed restoreFromSeed)
    #_nilable
    #_protected
    (§ field PeerDiscovery discovery)

    #_protected
    #_volatile
    (§ field Context context)

    ;;;
     ; Creates a new WalletAppKit, with a newly created {@link Context}.  Files will be stored in the given directory.
     ;;
    #_public
    (§ constructor WalletAppKit(NetworkParameters params, File directory, String filePrefix))
    (ß
        (§ this (new Context(params), directory, filePrefix))
    )

    ;;;
     ; Creates a new WalletAppKit, with the given {@link Context}.  Files will be stored in the given directory.
     ;;
    #_public
    (§ constructor WalletAppKit(Context context, File directory, String filePrefix))
    (ß
        (§ ass this.context = context)
        (§ ass this.params = Preconditions.checkNotNull(context.getParams()))
        (§ ass this.directory = Preconditions.checkNotNull(directory))
        (§ ass this.filePrefix = Preconditions.checkNotNull(filePrefix))
    )

    ;;; Will only connect to the given addresses.  Cannot be called after startup. ;;
    #_public
    (§ method WalletAppKit setPeerNodes(PeerAddress... addresses))
    (ß
        (§ call Preconditions.checkState(state() == State.NEW, "Cannot call after startup"))
        (§ ass this.peerAddresses = addresses)
        (§ return this)
    )

    ;;; Will only connect to localhost.  Cannot be called after startup. ;;
    #_public
    (§ method WalletAppKit connectToLocalHost())
    (ß
        (§ try)
        (ß
            #_final
            (§ var InetAddress localHost = InetAddress.getLocalHost())
            (§ return setPeerNodes(new PeerAddress(params, localHost, params.getPort())))
        )
        (§ catch (UnknownHostException e))
        (ß
            ;; Borked machine with no loopback adapter configured properly.
            (§ throw new RuntimeException(e))
        )
    )

    ;;; If true, the wallet will save itself to disk automatically whenever it changes. ;;
    #_public
    (§ method WalletAppKit setAutoSave(boolean value))
    (ß
        (§ call Preconditions.checkState(state() == State.NEW, "Cannot call after startup"))
        (§ ass useAutoSave = value)
        (§ return this)
    )

    ;;;
     ; If you want to learn about the sync process, you can provide a listener here.  For instance,
     ; a {@link org.bitcoinj.core.DownloadProgressTracker} is a good choice.  This has no effect unless
     ; setBlockingStartup(false) has been called too, due to some missing implementation code.
     ;;
    #_public
    (§ method WalletAppKit setDownloadListener(DownloadProgressTracker listener))
    (ß
        (§ ass this.downloadListener = listener)
        (§ return this)
    )

    ;;; If true, will register a shutdown hook to stop the library.  Defaults to true. ;;
    #_public
    (§ method WalletAppKit setAutoStop(boolean autoStop))
    (ß
        (§ ass this.autoStop = autoStop)
        (§ return this)
    )

    ;;;
     ; If set, the file is expected to contain a checkpoints file calculated with BuildCheckpoints.
     ; It makes initial block sync faster for new users - please refer to the documentation on the
     ; bitcoinj website (https://bitcoinj.github.io/speeding-up-chain-sync) for further details.
     ;;
    #_public
    (§ method WalletAppKit setCheckpoints(InputStream checkpoints))
    (ß
        (§ if (this.checkpoints != nil))
            (§ call Utils.closeUnchecked(this.checkpoints))
        (§ ass this.checkpoints = Preconditions.checkNotNull(checkpoints))
        (§ return this)
    )

    ;;;
     ; If true (the default) then the startup of this service won't be considered complete until the network has been
     ; brought up, peer connections established and the block chain synchronised.  Therefore {@link #awaitRunning()} can
     ; potentially take a very long time.  If false, then startup is considered complete once the network activity
     ; begins and peer connections/block chain sync will continue in the background.
     ;;
    #_public
    (§ method WalletAppKit setBlockingStartup(boolean blockingStartup))
    (ß
        (§ ass this.blockingStartup = blockingStartup)
        (§ return this)
    )

    ;;;
     ; Sets the string that will appear in the subver field of the version message.
     ; @param userAgent A short string that should be the name of your app, e.g. "My Wallet".
     ; @param version A short string that contains the version number, e.g. "1.0-BETA".
     ;;
    #_public
    (§ method WalletAppKit setUserAgent(String userAgent, String version))
    (ß
        (§ ass this.userAgent = Preconditions.checkNotNull(userAgent))
        (§ ass this.version = Preconditions.checkNotNull(version))
        (§ return this)
    )

    ;;;
     ; Sets a wallet factory which will be used when the kit creates a new wallet.
     ;;
    #_public
    (§ method WalletAppKit setWalletFactory(WalletProtobufSerializer.WalletFactory walletFactory))
    (ß
        (§ ass this.walletFactory = walletFactory)
        (§ return this)
    )

    ;;;
     ; If a seed is set here then any existing wallet that matches the file name will be renamed to a backup name,
     ; the chain file will be deleted, and the wallet object will be instantiated with the given seed instead of
     ; a fresh one being created.  This is intended for restoring a wallet from the original seed.  To implement
     ; restore, you would shut down the existing appkit, if any, then recreate it with the seed given by the user,
     ; then start up the new kit.  The next time your app starts it should work as normal (that is, don't keep
     ; calling this each time).
     ;;
    #_public
    (§ method WalletAppKit restoreWalletFromSeed(DeterministicSeed seed))
    (ß
        (§ ass this.restoreFromSeed = seed)
        (§ return this)
    )

    ;;;
     ; Sets the peer discovery class to use.  If none is provided then DNS is used, which is a reasonable default.
     ;;
    #_public
    (§ method WalletAppKit setDiscovery(#_nilable PeerDiscovery discovery))
    (ß
        (§ ass this.discovery = discovery)
        (§ return this)
    )

    ;;;
     ; Override this to use a {@link BlockStore} that isn't the default of {@link SPVBlockStore}.
     ;;
    #_protected
    (§ method BlockStore provideBlockStore(File file))
        (§ throws BlockStoreException)
    (ß
        (§ return new SPVBlockStore(params, file))
    )

    ;;;
     ; This method is invoked on a background thread after all objects are initialised, but before the peer group
     ; or block chain download is started.  You can tweak the objects configuration here.
     ;;
    #_protected
    (§ method void onSetupCompleted())
    (ß
    )

    ;;;
     ; Tests to see if the spvchain file has an operating system file lock on it.  Useful for checking if your app
     ; is already running.  If another copy of your app is running and you start the appkit anyway, an exception will
     ; be thrown during the startup process.  Returns false if the chain file does not exist or is a directory.
     ;;
    #_public
    (§ method boolean isChainFileLocked())
        (§ throws IOException)
    (ß
        (§ var RandomAccessFile file2 = nil)
        (§ try)
        (ß
            (§ var File file = new File(directory, filePrefix + ".spvchain"))
            (§ if (!file.exists()))
                (§ return false)
            (§ if (file.isDirectory()))
                (§ return false)
            (§ ass file2 = new RandomAccessFile(file, "rw"))
            (§ var FileLock lock = file2.getChannel().tryLock())
            (§ if (lock == nil))
                (§ return true)
            (§ call lock.release())
            (§ return false)
        )
        (§ finally)
        (ß
            (§ if (file2 != nil))
                (§ call file2.close())
        )
    )

    #_override
    #_protected
    (§ method void startUp())
        (§ throws Exception)
    (ß
        ;; Runs in a separate thread.
        (§ call Context.propagate(context))
        (§ if (!directory.exists() && !directory.mkdirs()))
            (§ throw new IOException("Could not create directory " + directory.getAbsolutePath()))

        (§ ass log.info("Starting up with directory = {}", directory))
        (§ try)
        (ß
            (§ var File chainFile = new File(directory, filePrefix + ".spvchain"))
            (§ var boolean chainFileExists = chainFile.exists())
            (§ ass vWalletFile = new File(directory, filePrefix + ".wallet"))
            (§ var boolean shouldReplayWallet = ((vWalletFile.exists() && !chainFileExists) || restoreFromSeed != nil))
            (§ ass vWallet = createOrLoadWallet(shouldReplayWallet))

            ;; Initiate Bitcoin network objects (block store, blockchain and peer group).
            (§ ass vStore = provideBlockStore(chainFile))
            (§ if (!chainFileExists || restoreFromSeed != nil))
            (ß
                (§ if (checkpoints == nil && !Utils.isAndroidRuntime()))
                    (§ ass checkpoints = CheckpointManager.openStream(params))

                (§ if (checkpoints != nil))
                (ß
                    ;; Initialize the chain file with a checkpoint to speed up first-run sync.
                    (§ var long time)
                    (§ if (restoreFromSeed != nil))
                    (ß
                        (§ ass time = restoreFromSeed.getCreationTimeSeconds())
                        (§ if (chainFileExists))
                        (ß
                            (§ call log.info("Deleting the chain file in preparation from restore."))
                            (§ call vStore.close())
                            (§ if (!chainFile.delete()))
                                (§ throw new IOException("Failed to delete chain file in preparation for restore."))

                            (§ ass vStore = new SPVBlockStore(params, chainFile))
                        )
                    )
                    (§ else)
                    (ß
                        (§ ass time = vWallet.getEarliestKeyCreationTime())
                    )
                    (§ if (0 < time))
                        (§ call CheckpointManager.checkpoint(params, checkpoints, vStore, time))
                    (§ else)
                        (§ call log.warn("Creating a new uncheckpointed block store due to a wallet with a creation time of zero: this will result in a very slow chain sync"))
                )
                (§ elseif (chainFileExists))
                (ß
                    (§ call log.info("Deleting the chain file in preparation from restore."))
                    (§ call vStore.close())
                    (§ if (!chainFile.delete()))
                        (§ throw new IOException("Failed to delete chain file in preparation for restore."))

                    (§ ass vStore = new SPVBlockStore(params, chainFile))
                )
            )
            (§ ass vChain = new BlockChain(params, vStore))
            (§ ass vPeerGroup = createPeerGroup())
            (§ if (this.userAgent != nil))
                (§ call vPeerGroup.setUserAgent(userAgent, version))

            ;; Set up peer addresses or discovery first, so if wallet extensions try to broadcast a transaction
            ;; before we're actually connected the broadcast waits for an appropriate number of connections.
            (§ if (peerAddresses != nil))
            (ß
                (§ for (PeerAddress addr :for peerAddresses))
                    (§ call vPeerGroup.addAddress(addr))
                (§ call vPeerGroup.setMaxConnections(peerAddresses.length))
                (§ ass peerAddresses = nil)
            )
            (§ else)
            (ß
                (§ call vPeerGroup.addPeerDiscovery((discovery != nil) ? discovery :else new DnsDiscovery(params)))
            )
            (§ call vChain.addWallet(vWallet))
            (§ call vPeerGroup.addWallet(vWallet))
            (§ call onSetupCompleted())

            (§ if (blockingStartup))
            (ß
                (§ call vPeerGroup.start())
                ;; Make sure we shut down cleanly.
                (§ call installShutdownHook())

                ;; TODO: Be able to use the provided download listener when doing a blocking startup.
                #_final
                (§ var DownloadProgressTracker listener = new DownloadProgressTracker())
                (§ call vPeerGroup.startBlockChainDownload(listener))
                (§ call listener.await())
            )
            (§ else)
            (ß
                (§ call Futures.addCallback(vPeerGroup.startAsync(), new FutureCallback()
                (ß
                    #_override
                    #_public
                    (§ method void onSuccess(#_nilable Object result))
                    (ß
                        #_final
                        (§ var DownloadProgressTracker l = (downloadListener != nil) ? downloadListener :else new DownloadProgressTracker())
                        (§ call vPeerGroup.startBlockChainDownload(l))
                    )

                    #_override
                    #_public
                    (§ method void onFailure(Throwable t))
                    (ß
                        (§ throw new RuntimeException(t))
                    )
                )))
            )
        )
        (§ catch (BlockStoreException e))
        (ß
            (§ throw new IOException(e))
        )
    )

    #_private
    (§ method Wallet createOrLoadWallet(boolean shouldReplayWallet))
        (§ throws Exception)
    (ß
        (§ var Wallet wallet)

        (§ call maybeMoveOldWalletOutOfTheWay())

        (§ if (vWalletFile.exists()))
        (ß
            (§ ass wallet = loadWallet(shouldReplayWallet))
        )
        (§ else)
        (ß
            (§ ass wallet = createWallet())
            (§ call wallet.freshReceiveKey())

            ;; Currently the only way we can be sure that an extension is aware of its containing wallet is
            ;; by deserializing the extension.
            ;; Hence, we first save and then load wallet to ensure any extensions are correctly initialized.
            (§ call wallet.saveToFile(vWalletFile))
            (§ ass wallet = loadWallet(false))
        )

        (§ if (useAutoSave))
            (§ call this.setupAutoSave(wallet))

        (§ return wallet)
    )

    #_protected
    (§ method void setupAutoSave(Wallet wallet))
    (ß
        (§ call wallet.autosaveToFile(vWalletFile, 5, TimeUnit.SECONDS, nil))
    )

    #_private
    (§ method Wallet loadWallet(boolean shouldReplayWallet))
        (§ throws Exception)
    (ß
        (§ var Wallet wallet)
        (§ var FileInputStream walletStream = new FileInputStream(vWalletFile))
        (§ try)
        (ß
            (§ var Protos.Wallet proto = WalletProtobufSerializer.parseToProto(walletStream))
            #_final
            (§ var WalletProtobufSerializer serializer)
            (§ if (walletFactory != nil))
                (§ ass serializer = new WalletProtobufSerializer(walletFactory))
            (§ else)
                (§ ass serializer = new WalletProtobufSerializer())
            (§ ass wallet = serializer.readWallet(params, proto))
            (§ if (shouldReplayWallet))
                (§ call wallet.reset())
        )
        (§ finally)
        (ß
            (§ call walletStream.close())
        )
        (§ return wallet)
    )

    #_protected
    (§ method Wallet createWallet())
    (ß
        (§ var KeyChainGroup kcg)
        (§ if (restoreFromSeed != nil))
            (§ ass kcg = new KeyChainGroup(params, restoreFromSeed))
        (§ else)
            (§ ass kcg = new KeyChainGroup(params))
        (§ return (walletFactory != nil) ? walletFactory.create(params, kcg) :else new Wallet(params, kcg)) ;; default
    )

    #_private
    (§ method void maybeMoveOldWalletOutOfTheWay())
    (ß
        (§ if (restoreFromSeed == nil))
            (§ return)
        (§ if (!vWalletFile.exists()))
            (§ return)

        (§ var int counter = 1)
        (§ var File newName)
        (§ do)
        (ß
            (§ ass newName = new File(vWalletFile.getParent(), "Backup " + counter + " for " + vWalletFile.getName()))
            (§ ass counter = counter + 1)
        )
        (§ again (newName.exists()))

        (§ call log.info("Renaming old wallet file {} to {}", vWalletFile, newName))

        ;; This should not happen unless something is really messed up.
        (§ if (!vWalletFile.renameTo(newName)))
            (§ throw new RuntimeException("Failed to rename wallet for restore"))
    )

    #_protected
    (§ method PeerGroup createPeerGroup())
        (§ throws TimeoutException)
    (ß
        (§ return new PeerGroup(params, vChain))
    )

    #_private
    (§ method void installShutdownHook())
    (ß
        (§ if (autoStop))
            (§ call Runtime.getRuntime().addShutdownHook(new Thread()
            (ß
                #_override
                #_public
                (§ method void run())
                (ß
                    (§ try)
                    (ß
                        (§ call WalletAppKit.this.stopAsync())
                        (§ call WalletAppKit.this.awaitTerminated())
                    )
                    (§ catch (Exception e))
                    (ß
                        (§ throw new RuntimeException(e))
                    )
                )
            )))
    )

    #_override
    #_protected
    (§ method void shutDown())
        (§ throws Exception)
    (ß
        ;; Runs in a separate thread.
        (§ try)
        (ß
            (§ call Context.propagate(context))
            (§ call vPeerGroup.stop())
            (§ call vWallet.saveToFile(vWalletFile))
            (§ call vStore.close())

            (§ ass vPeerGroup = nil)
            (§ ass vWallet = nil)
            (§ ass vStore = nil)
            (§ ass vChain = nil)
        )
        (§ catch (BlockStoreException e))
        (ß
            (§ throw new IOException(e))
        )
    )

    #_public
    (§ method NetworkParameters params())
    (ß
        (§ return params)
    )

    #_public
    (§ method BlockChain chain())
    (ß
        (§ call Preconditions.checkState(state() == State.STARTING || state() == State.RUNNING, "Cannot call until startup is complete"))
        (§ return vChain)
    )

    #_public
    (§ method BlockStore store())
    (ß
        (§ call Preconditions.checkState(state() == State.STARTING || state() == State.RUNNING, "Cannot call until startup is complete"))
        (§ return vStore)
    )

    #_public
    (§ method Wallet wallet())
    (ß
        (§ call Preconditions.checkState(state() == State.STARTING || state() == State.RUNNING, "Cannot call until startup is complete"))
        (§ return vWallet)
    )

    #_public
    (§ method PeerGroup peerGroup())
    (ß
        (§ call Preconditions.checkState(state() == State.STARTING || state() == State.RUNNING, "Cannot call until startup is complete"))
        (§ return vPeerGroup)
    )

    #_public
    (§ method File directory())
    (ß
        (§ return directory)
    )
)

#_(ns org.bitcoinj.net #_"AbstractTimeoutHandler"
    (:import [java.util Timer TimerTask]))

;;;
 ; <p>A base class which provides basic support for socket timeouts.  It is used instead of integrating timeouts into the
 ; NIO select thread both for simplicity and to keep code shared between NIO and blocking sockets as much as possible.
 ; </p>
 ;;
#_public
#_abstract
(§ class AbstractTimeoutHandler
    ;; TimerTask and timeout value which are added to a timer to kill the connection on timeout.
    #_private
    (§ field TimerTask timeoutTask)
    #_private
    (§ field long timeoutMillis = 0)
    #_private
    (§ field boolean timeoutEnabled = true)

    ;; A timer which manages expiring channels as their timeouts occur (if configured).
    #_private
    #_static
    #_final
    (§ field Timer timeoutTimer = new Timer("AbstractTimeoutHandler timeouts", true))

    ;;;
     ; <p>Enables or disables the timeout entirely.  This may be useful if you want to store the timeout value
     ; but wish to temporarily disable/enable timeouts.</p>
     ;
     ; <p>The default is for timeoutEnabled to be true but timeoutMillis to be set to 0 (i.e. disabled).</p>
     ;
     ; <p>This call will reset the current progress towards the timeout.</p>
     ;;
    #_public
    #_synchronized
    #_final
    (§ method void setTimeoutEnabled(boolean timeoutEnabled))
    (ß
        (§ ass this.timeoutEnabled = timeoutEnabled)
        (§ call resetTimeout())
    )

    ;;;
     ; <p>Sets the receive timeout to the given number of milliseconds, automatically killing the connection
     ; if no messages are received for this long.</p>
     ;
     ; <p>A timeout of 0 is interpreted as no timeout.</p>
     ;
     ; <p>The default is for timeoutEnabled to be true but timeoutMillis to be set to 0 (i.e. disabled).</p>
     ;
     ; <p>This call will reset the current progress towards the timeout.</p>
     ;;
    #_public
    #_synchronized
    #_final
    (§ method void setSocketTimeout(int timeoutMillis))
    (ß
        (§ ass this.timeoutMillis = timeoutMillis)
        (§ call resetTimeout())
    )

    ;;;
     ; Resets the current progress towards timeout to 0.
     ;;
    #_protected
    #_synchronized
    (§ method void resetTimeout())
    (ß
        (§ if (timeoutTask != nil))
            (§ call timeoutTask.cancel())
        (§ if (timeoutMillis == 0 || !timeoutEnabled))
            (§ return)

        (§ ass timeoutTask = new TimerTask()
        (ß
            #_override
            #_public
            (§ method void run())
            (ß
                (§ call timeoutOccurred())
            )
        ))
        (§ call timeoutTimer.schedule(timeoutTask, timeoutMillis))
    )

    #_protected
    #_abstract
    (§ method void timeoutOccurred())
)

#_(ns org.bitcoinj.net #_"BlockingClient"
    (:import #_[java.io *]
             #_[java.net *]
             #_[java.nio *]
             #_[java.util *]
             #_[javax.net *])
    (:import [com.google.common.base Preconditions]
             #_[com.google.common.util.concurrent *]
             [org.slf4j Logger LoggerFactory])
  #_(:require #_[org.bitcoinj.core *]))

;;;
 ; <p>Creates a simple connection to a server using a {@link StreamConnection} to process data.</p>
 ;
 ; <p>Generally, using {@link NioClient} and {@link NioClientManager} should be preferred over {@link BlockingClient}
 ; and {@link BlockingClientManager}, unless you wish to connect over a proxy or use some other network settings that
 ; cannot be set using NIO.</p>
 ;;
#_public
(§ class BlockingClient implements MessageWriteTarget
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(BlockingClient.class))

    #_private
    #_static
    #_final
    (§ field int BUFFER_SIZE_LOWER_BOUND = 4096)
    #_private
    #_static
    #_final
    (§ field int BUFFER_SIZE_UPPER_BOUND = 65536)

    #_private
    (§ field Socket socket)
    #_private
    #_volatile
    (§ field boolean vCloseRequested = false)
    #_private
    (§ field SettableFuture<SocketAddress> connectFuture)

    ;;;
     ; <p>Creates a new client to the given server address using the given {@link StreamConnection} to decode the data.
     ; The given connection <b>MUST</b> be unique to this object.  This does not block while waiting for the connection
     ; to open, but will call either the {@link StreamConnection#connectionOpened()} or
     ; {@link StreamConnection#connectionClosed()} callback on the created network event processing thread.</p>
     ;
     ; @param connectTimeoutMillis The connect timeout set on the connection (in milliseconds).
     ;                             0 is interpreted as no timeout.
     ; @param socketFactory An object that creates {@link Socket} objects on demand, which may be customised to control
     ;                      how this client connects to the internet.  If not sure, use SocketFactory.getDefault().
     ; @param clientSet A set which this object will add itself to after initialization, and then remove itself from.
     ;;
    #_public
    (§ constructor BlockingClient(#_final SocketAddress serverAddress, #_final StreamConnection connection, #_final int connectTimeoutMillis, #_final SocketFactory socketFactory, #_nilable #_final Set<BlockingClient> clientSet))
        (§ throws IOException)
    (ß
        (§ ass connectFuture = SettableFuture.create())
        ;; Try to fit at least one message in the network buffer, but place an upper and lower limit on its size to make
        ;; sure it doesnt get too large or have to call read too often.
        (§ call connection.setWriteTarget(this))
        (§ ass socket = socketFactory.createSocket())
        #_final
        (§ var Context context = Context.get())
        (§ var Thread t = new Thread()
        (ß
            #_override
            #_public
            (§ method void run())
            (ß
                (§ call Context.propagate(context))
                (§ if (clientSet != nil))
                    (§ call clientSet.add(BlockingClient.this))
                (§ try)
                (ß
                    (§ call socket.connect(serverAddress, connectTimeoutMillis))
                    (§ call connection.connectionOpened())
                    (§ call connectFuture.set(serverAddress))
                    (§ var InputStream stream = socket.getInputStream())
                    (§ call runReadLoop(stream, connection))
                )
                (§ catch (Exception e))
                (ß
                    (§ if (!vCloseRequested))
                    (ß
                        (§ call log.error("Error trying to open/read from connection: {}: {}", serverAddress, e.getMessage()))
                        (§ call connectFuture.setException(e))
                    )
                )
                (§ finally)
                (ß
                    (§ try)
                    (ß
                        (§ call socket.close())
                    )
                    (§ catch (IOException e1))
                    (ß
                        ;; At this point there isn't much we can do, and we can probably assume the channel is closed.
                    )
                    (§ if (clientSet != nil))
                        (§ call clientSet.remove(BlockingClient.this))
                    (§ call connection.connectionClosed())
                )
            )
        ))
        (§ call t.setName("BlockingClient network thread for " + serverAddress))
        (§ call t.setDaemon(true))
        (§ call t.start())
    )

    ;;;
     ; A blocking call that never returns, except by throwing an exception.  It reads bytes from the input stream
     ; and feeds them to the provided {@link StreamConnection}, for example, a {@link Peer}.
     ;;
    #_public
    #_static
    (§ method void runReadLoop(InputStream stream, StreamConnection connection))
        (§ throws Exception)
    (ß
        (§ var ByteBuffer dbuf = ByteBuffer.allocateDirect(Math.min(Math.max(connection.getMaxMessageSize(), BUFFER_SIZE_LOWER_BOUND), BUFFER_SIZE_UPPER_BOUND)))
        (§ var byte[] readBuff = new byte[dbuf.capacity()])
        (§ while (true))
        (ß
            ;; TODO: Kill the message duplication here.
            (§ call Preconditions.checkState(0 < dbuf.remaining() && dbuf.remaining() <= readBuff.length))
            (§ var int read = stream.read(readBuff, 0, Math.max(1, Math.min(dbuf.remaining(), stream.available()))))
            (§ if (read == -1))
                (§ return)

            (§ call dbuf.put(readBuff, 0, read))
            ;; "flip" the buffer - setting the limit to the current position and setting position to 0
            (§ call dbuf.flip())
            ;; Use connection.receiveBytes's return value as a double-check that it stopped reading at the right location.
            (§ var int bytesConsumed = connection.receiveBytes(dbuf))
            (§ call Preconditions.checkState(dbuf.position() == bytesConsumed))
            ;; Now drop the bytes which were read by compacting dbuf (resetting limit and keeping relative position).
            (§ call dbuf.compact())
        )
    )

    ;;;
     ; Closes the connection to the server, triggering the {@link StreamConnection#connectionClosed()}
     ; event on the network-handling thread where all callbacks occur.
     ;;
    #_override
    #_public
    (§ method void closeConnection())
    (ß
        ;; Closes the channel, triggering an exception in the network-handling thread triggering connectionClosed().
        (§ try)
        (ß
            (§ ass vCloseRequested = true)
            (§ call socket.close())
        )
        (§ catch (IOException e))
        (ß
            (§ throw new RuntimeException(e))
        )
    )

    #_override
    #_public
    #_synchronized
    (§ method void writeBytes(byte[] message))
        (§ throws IOException)
    (ß
        (§ try)
        (ß
            (§ var OutputStream stream = socket.getOutputStream())
            (§ call stream.write(message))
            (§ call stream.flush())
        )
        (§ catch (IOException e))
        (ß
            (§ call log.error("Error writing message to connection, closing connection", e))
            (§ call closeConnection())
            (§ throw e)
        )
    )

    ;;; Returns a future that completes once connection has occurred at the socket level or with an exception if failed to connect. ;;
    #_public
    (§ method ListenableFuture<SocketAddress> getConnectFuture())
    (ß
        (§ return connectFuture)
    )
)

#_(ns org.bitcoinj.net #_"BlockingClientManager"
    (:import [java.io IOException]
             [java.net SocketAddress]
             [java.util Collections HashSet Iterator Set]
             [javax.net SocketFactory])
    (:import [com.google.common.base Preconditions]
             [com.google.common.util.concurrent AbstractIdleService ListenableFuture]))

;;;
 ; <p>A thin wrapper around a set of {@link BlockingClient}s.</p>
 ;
 ; <p>Generally, using {@link NioClient} and {@link NioClientManager} should be preferred over {@link BlockingClient}
 ; and {@link BlockingClientManager} as they scale significantly better, unless you wish to connect over a proxy or use
 ; some other network settings that cannot be set using NIO.</p>
 ;;
#_public
(§ class BlockingClientManager extends AbstractIdleService implements ClientConnectionManager
    #_private
    #_final
    (§ field SocketFactory socketFactory)
    #_private
    #_final
    (§ field Set<BlockingClient> clients = Collections.synchronizedSet(new HashSet<BlockingClient>()))

    #_private
    (§ field int connectTimeoutMillis = 1000)

    #_public
    (§ constructor BlockingClientManager())
    (ß
        (§ ass socketFactory = SocketFactory.getDefault())
    )

    ;;;
     ; Creates a blocking client manager that will obtain sockets from the given factory.
     ; Useful for customising how bitcoinj connects to the P2P network.
     ;;
    #_public
    (§ constructor BlockingClientManager(SocketFactory socketFactory))
    (ß
        (§ ass this.socketFactory = Preconditions.checkNotNull(socketFactory))
    )

    #_override
    #_public
    (§ method ListenableFuture<SocketAddress> openConnection(SocketAddress serverAddress, StreamConnection connection))
    (ß
        (§ try)
        (ß
            (§ if (!isRunning()))
                (§ throw new IllegalStateException())

            (§ return new BlockingClient(serverAddress, connection, connectTimeoutMillis, socketFactory, clients).getConnectFuture())
        )
        (§ catch (IOException e))
        (ß
            (§ throw new RuntimeException(e)) ;; This should only happen if we are, e.g. out of system resources.
        )
    )

    ;;; Sets the number of milliseconds to wait before giving up on a connect attempt. ;;
    #_public
    (§ method void setConnectTimeoutMillis(int connectTimeoutMillis))
    (ß
        (§ ass this.connectTimeoutMillis = connectTimeoutMillis)
    )

    #_override
    #_protected
    (§ method void startUp())
        (§ throws Exception)
    (ß
    )

    #_override
    #_protected
    (§ method void shutDown())
        (§ throws Exception)
    (ß
        (§ sync clients)
        (ß
            (§ for (BlockingClient client :for clients))
                (§ call client.closeConnection())
        )
    )

    #_override
    #_public
    (§ method int getConnectedClientCount())
    (ß
        (§ return clients.size())
    )

    #_override
    #_public
    (§ method void closeConnections(int n))
    (ß
        (§ if (!isRunning()))
            (§ throw new IllegalStateException())

        (§ sync clients)
        (ß
            (§ for (Iterator<BlockingClient> it = clients.iterator() :for 0 < n && it.hasNext() :for n = n - 1))
                (§ call it.next().closeConnection())
        )
    )
)

#_(ns org.bitcoinj.net #_"ClientConnectionManager"
    (:import [java.net SocketAddress])
    (:import [com.google.common.util.concurrent ListenableFuture Service]))

;;;
 ; <p>A generic interface for an object which keeps track of a set of open client connections, creates new ones and
 ; ensures they are serviced properly.</p>
 ;
 ; <p>When the service is {@link com.google.common.util.concurrent.Service#stop()}ed, all connections will be closed
 ; and the appropriate connectionClosed() calls must be made.</p>
 ;;
#_public
(§ interface ClientConnectionManager extends Service
    ;;;
     ; Creates a new connection to the given address, with the given connection used to handle incoming data.  Any errors
     ; that occur during connection will be returned in the given future, including errors that can occur immediately.
     ;;
    (§ method ListenableFuture<SocketAddress> openConnection(SocketAddress serverAddress, StreamConnection connection))

    ;;; Gets the number of connected peers. ;;
    (§ method int getConnectedClientCount())

    ;;; Closes n peer connections. ;;
    (§ method void closeConnections(int n))
)

#_(ns org.bitcoinj.net #_"ConnectionHandler"
    (:import [java.io IOException]
             [java.nio ByteBuffer]
             [java.nio.channels CancelledKeyException SelectionKey SocketChannel]
             [java.util Arrays Iterator LinkedList Set]
             [java.util.concurrent.locks ReentrantLock]
             [javax.annotation.concurrent GuardedBy])
    (:import [com.google.common.base Preconditions Throwables]
             [org.slf4j Logger LoggerFactory])
  #_(:require [org.bitcoinj.core Message]
             [org.bitcoinj.utils Threading]))

;; TODO: The locking in all this class is horrible and not really necessary.  We should just run all network stuff on one thread.

;;;
 ; A simple NIO MessageWriteTarget which handles all the business logic of a connection (reading+writing bytes).
 ; Used only by the NioClient and NioServer classes.
 ;;
(§ class ConnectionHandler implements MessageWriteTarget
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(ConnectionHandler.class))

    #_private
    #_static
    #_final
    (§ field int BUFFER_SIZE_LOWER_BOUND = 4096)
    #_private
    #_static
    #_final
    (§ field int BUFFER_SIZE_UPPER_BOUND = 65536)

    #_private
    #_static
    #_final
    (§ field int OUTBOUND_BUFFER_BYTE_COUNT = Message.MAX_SIZE + 24) ;; 24 byte message header

    ;; We lock when touching local flags and when writing data, but NEVER when calling any methods which leave
    ;; this class into non-Java classes.
    #_private
    #_final
    (§ field ReentrantLock lock = Threading.lock("nioConnectionHandler"))
    #_guarded-by(ß "lock")
    #_private
    #_final
    (§ field ByteBuffer readBuff)
    #_guarded-by(ß "lock")
    #_private
    #_final
    (§ field SocketChannel channel)
    #_guarded-by(ß "lock")
    #_private
    #_final
    (§ field SelectionKey key)
    #_guarded-by(ß "lock")
    (§ field StreamConnection connection)
    #_guarded-by(ß "lock")
    #_private
    (§ field boolean closeCalled = false)

    #_guarded-by(ß "lock")
    #_private
    (§ field long bytesToWriteRemaining = 0)
    #_guarded-by(ß "lock")
    #_private
    #_final
    (§ field LinkedList<ByteBuffer> bytesToWrite = new LinkedList<>())

    #_private
    (§ field Set<ConnectionHandler> connectedHandlers)

    #_public
    (§ constructor ConnectionHandler(StreamConnectionFactory connectionFactory, SelectionKey key))
        (§ throws IOException)
    (ß
        (§ this (connectionFactory.getNewConnection(((SocketChannel)key.channel()).socket().getInetAddress(), ((SocketChannel)key.channel()).socket().getPort()), key))
        (§ if (connection == nil))
            (§ throw new IOException("Parser factory.getNewConnection returned nil"))
    )

    #_private
    (§ constructor ConnectionHandler(#_nilable StreamConnection connection, SelectionKey key))
    (ß
        (§ ass this.key = key)
        (§ ass this.channel = Preconditions.checkNotNull(((SocketChannel)key.channel())))
        (§ if (connection == nil))
        (ß
            (§ ass readBuff = nil)
            (§ return)
        )

        (§ ass this.connection = connection)
        (§ ass readBuff = ByteBuffer.allocateDirect(Math.min(Math.max(connection.getMaxMessageSize(), BUFFER_SIZE_LOWER_BOUND), BUFFER_SIZE_UPPER_BOUND)))
        (§ call connection.setWriteTarget(this)) ;; May callback into us (e.g. closeConnection() now).
        (§ ass connectedHandlers = nil)
    )

    #_public
    (§ constructor ConnectionHandler(StreamConnection connection, SelectionKey key, Set<ConnectionHandler> connectedHandlers))
    (ß
        (§ this (Preconditions.checkNotNull(connection), key))

        ;; closeConnection() may have already happened because we invoked the other c'tor above, which called
        ;; connection.setWriteTarget which might have re-entered already.  In this case we shouldn't add ourselves
        ;; to the connectedHandlers set.
        (§ call lock.lock())
        (§ try)
        (ß
            (§ ass this.connectedHandlers = connectedHandlers)
            (§ if (!closeCalled))
                (§ call Preconditions.checkState(this.connectedHandlers.add(this)))
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    #_guarded-by(ß "lock")
    #_private
    (§ method void setWriteOps())
    (ß
        ;; Make sure we are registered to get updated when writing is available again.
        (§ call key.interestOps(key.interestOps() | SelectionKey.OP_WRITE))
        ;; Refresh the selector to make sure it gets the new interestOps.
        (§ call key.selector().wakeup())
    )

    ;; Tries to write any outstanding write bytes, runs in any thread (possibly unlocked).
    #_private
    (§ method void tryWriteBytes())
        (§ throws IOException)
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            ;; Iterate through the outbound ByteBuff queue, pushing as much as possible into the OS' network buffer.
            (§ var Iterator<ByteBuffer> bytesIterator = bytesToWrite.iterator())
            (§ while (bytesIterator.hasNext()))
            (ß
                (§ var ByteBuffer buff = bytesIterator.next())
                (§ ass bytesToWriteRemaining = bytesToWriteRemaining - channel.write(buff))
                (§ if (!buff.hasRemaining()))
                    (§ call bytesIterator.remove())
                (§ else)
                (ß
                    (§ call setWriteOps())
                    (§ break)
                )
            )
            ;; If we are done writing, clear the OP_WRITE interestOps.
            (§ if (bytesToWrite.isEmpty()))
                (§ call key.interestOps(key.interestOps() & ~SelectionKey.OP_WRITE))
            ;; Don't bother waking up the selector here, since we're just removing an op, not adding.
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    #_override
    #_public
    (§ method void writeBytes(byte[] message))
        (§ throws IOException)
    (ß
        (§ var boolean andUnlock = true)
        (§ call lock.lock())
        (§ try)
        (ß
            ;; Network buffers are not unlimited (and are often smaller than some messages we may wish to send), and
            ;; thus we have to buffer outbound messages sometimes.  To do this, we use a queue of ByteBuffers and just
            ;; append to it when we want to send a message.  We then let tryWriteBytes() either send the message or
            ;; register our SelectionKey to wakeup when we have free outbound buffer space available.
            (§ if (OUTBOUND_BUFFER_BYTE_COUNT < bytesToWriteRemaining + message.length))
                (§ throw new IOException("Outbound buffer overflowed"))

            ;; Just dump the message onto the write buffer and call tryWriteBytes.
            ;; TODO: Kill the needless message duplication when the write completes right away.
            (§ call bytesToWrite.offer(ByteBuffer.wrap(Arrays.copyOf(message, message.length))))
            (§ ass bytesToWriteRemaining = bytesToWriteRemaining + message.length)
            (§ call setWriteOps())
        )
        (§ catch (IOException e))
        (ß
            (§ call lock.unlock())
            (§ ass andUnlock = false)
            (§ call log.warn("Error writing message to connection, closing connection", e))
            (§ call closeConnection())
            (§ throw e)
        )
        (§ catch (CancelledKeyException e))
        (ß
            (§ call lock.unlock())
            (§ ass andUnlock = false)
            (§ call log.warn("Error writing message to connection, closing connection", e))
            (§ call closeConnection())
            (§ throw new IOException(e))
        )
        (§ finally)
        (ß
            (§ if (andUnlock))
                (§ call lock.unlock())
        )
    )

    ;; May NOT be called with lock held.
    #_override
    #_public
    (§ method void closeConnection())
    (ß
        (§ call Preconditions.checkState(!lock.isHeldByCurrentThread()))
        (§ try)
        (ß
            (§ call channel.close())
        )
        (§ catch (IOException e))
        (ß
            (§ throw new RuntimeException(e))
        )
        (§ call connectionClosed())
    )

    #_private
    (§ method void connectionClosed())
    (ß
        (§ var boolean callClosed = false)
        (§ call lock.lock())
        (§ try)
        (ß
            (§ ass callClosed = !closeCalled)
            (§ ass closeCalled = true)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
        (§ if (callClosed))
        (ß
            (§ call Preconditions.checkState(connectedHandlers == nil || connectedHandlers.remove(this)))
            (§ call connection.connectionClosed())
        )
    )

    ;; Handle a SelectionKey which was selected.
    ;; Runs unlocked as the caller is single-threaded (or if not, should enforce that handleKey is only called
    ;; atomically for a given ConnectionHandler).
    #_public
    #_static
    (§ method void handleKey(SelectionKey key))
    (ß
        (§ var ConnectionHandler handler = (ConnectionHandler)key.attachment())
        (§ try)
        (ß
            (§ if (handler == nil))
                (§ return)
            (§ if (!key.isValid()))
            (ß
                (§ call handler.closeConnection()) ;; Key has been cancelled, make sure the socket gets closed.
                (§ return)
            )
            (§ if (key.isReadable()))
            (ß
                ;; Do a socket read and invoke the connection's receiveBytes message.
                (§ var int read = handler.channel.read(handler.readBuff))
                (§ if (read == 0))
                    (§ return) ;; Was probably waiting on a write.
                (§ elseif (read == -1)) ;; Socket was closed.
                (ß
                    (§ call key.cancel())
                    (§ call handler.closeConnection())
                    (§ return)
                )
                ;; "flip" the buffer - setting the limit to the current position and setting position to 0
                (§ call handler.readBuff.flip())
                ;; Use connection.receiveBytes's return value as a check that it stopped reading at the right location.
                (§ var int bytesConsumed = Preconditions.checkNotNull(handler.connection).receiveBytes(handler.readBuff))
                (§ call Preconditions.checkState(handler.readBuff.position() == bytesConsumed))
                ;; Now drop the bytes which were read by compacting readBuff (resetting limit and keeping relative position).
                (§ call handler.readBuff.compact())
            )
            (§ if (key.isWritable()))
                (§ call handler.tryWriteBytes())
        )
        (§ catch (Exception e))
        (ß
            ;; This can happen e.g. if the channel closes while the thread is about to get killed
            ;; (ClosedByInterruptException), or if handler.connection.receiveBytes throws something.
            (§ var Throwable t = Throwables.getRootCause(e))
            (§ call log.warn("Error handling SelectionKey: {} {}", t.getClass().getName(), (t.getMessage() != nil) ? t.getMessage() :else "", e))
            (§ call handler.closeConnection())
        )
    )
)

#_(ns org.bitcoinj.net #_"FilterMerger"
    (:import [java.util LinkedList])
    (:import [com.google.common.collect ImmutableList Lists])
  #_(:require [org.bitcoinj.core BloomFilter PeerFilterProvider]))

;;;
 ; <p>A reusable object that will calculate, given a list of {@link org.bitcoinj.core.PeerFilterProvider}s, a merged
 ; {@link org.bitcoinj.core.BloomFilter} and earliest key time for all of them.
 ; Used by the {@link org.bitcoinj.core.PeerGroup} class internally.</p>
 ;
 ; <p>Thread safety: threading here can be complicated.  Each filter provider is given a begin event, which may acquire
 ; a lock (and is guaranteed to receive an end event).  This class is mostly thread unsafe and is meant to be used from
 ; a single thread only, PeerGroup ensures this by only accessing it from the dedicated PeerGroup thread.  PeerGroup
 ; does not hold any locks whilst this object is used, relying on the single thread to prevent multiple filters being
 ; calculated in parallel, thus a filter provider can do things like make blocking calls into PeerGroup from a separate
 ; thread.  However the bloomFilterFPRate property IS thread safe, for convenience.</p>
 ;;
#_public
(§ class FilterMerger
    ;; We use a constant tweak to avoid giving up privacy when we regenerate our filter with new keys.
    #_private
    #_final
    (§ field long bloomFilterTweak = (long)(Math.random() * Long.MAX_VALUE))

    #_private
    #_volatile
    (§ field double vBloomFilterFPRate)
    #_private
    (§ field int lastBloomFilterElementCount)
    #_private
    (§ field BloomFilter lastFilter)

    #_public
    (§ constructor FilterMerger(double bloomFilterFPRate))
    (ß
        (§ ass this.vBloomFilterFPRate = bloomFilterFPRate)
    )

    #_public
    #_static
    (§ class Result
        #_public
        (§ field BloomFilter filter)
        #_public
        (§ field long earliestKeyTimeSecs)
        #_public
        (§ field boolean changed)
    )

    #_public
    (§ method Result calculate(ImmutableList<PeerFilterProvider> providers))
    (ß
        (§ var LinkedList<PeerFilterProvider> begunProviders = Lists.newLinkedList())
        (§ try)
        (ß
            ;; All providers must be in a consistent, unchanging state because the filter is a merged one that's
            ;; large enough for all providers elements: if a provider were to get more elements in the middle of the
            ;; calculation, we might assert or calculate the filter wrongly.  Most providers use a lock here but
            ;; snapshotting required state is also a legitimate strategy.
            (§ for (PeerFilterProvider provider :for providers))
            (ß
                (§ call provider.beginBloomFilterCalculation())
                (§ call begunProviders.add(provider))
            )
            (§ var Result result = new Result())
            (§ ass result.earliestKeyTimeSecs = Long.MAX_VALUE)
            (§ var int elements = 0)
            (§ var boolean requiresUpdateAll = false)
            (§ for (PeerFilterProvider p :for providers))
            (ß
                (§ ass result.earliestKeyTimeSecs = Math.min(result.earliestKeyTimeSecs, p.getEarliestKeyCreationTime()))
                (§ ass elements = elements + p.getBloomFilterElementCount())
            )

            (§ if (0 < elements))
            (ß
                ;; We stair-step our element count so that we avoid creating a filter with different parameters
                ;; as much as possible as that results in a loss of privacy.
                ;; The constant 100 here is somewhat arbitrary, but makes sense for small to medium wallets -
                ;; it will likely mean we never need to create a filter with different parameters.
                (§ ass lastBloomFilterElementCount = (lastBloomFilterElementCount < elements) ? elements + 100 :else lastBloomFilterElementCount)
                (§ var BloomFilter.BloomUpdate bloomFlags = requiresUpdateAll ? BloomFilter.BloomUpdate.UPDATE_ALL :else BloomFilter.BloomUpdate.UPDATE_P2PUBKEY_ONLY)
                (§ var double fpRate = vBloomFilterFPRate)
                (§ var BloomFilter filter = new BloomFilter(lastBloomFilterElementCount, fpRate, bloomFilterTweak, bloomFlags))
                (§ for (PeerFilterProvider p :for providers))
                    (§ call filter.merge(p.getBloomFilter(lastBloomFilterElementCount, fpRate, bloomFilterTweak)))

                (§ ass result.changed = !filter.equals(lastFilter))
                (§ ass result.filter = lastFilter = filter)
            )
            ;; Now adjust the earliest key time backwards by a week to handle the case of clock drift.  This can occur
            ;; both in block header timestamps and if the users clock was out of sync when the key was first created
            ;; (to within a small amount of tolerance).
            (§ ass result.earliestKeyTimeSecs = earliestKeyTimeSecs - (86400 * 7))
            (§ return result)
        )
        (§ finally)
        (ß
            (§ for (PeerFilterProvider provider :for begunProviders))
                (§ call provider.endBloomFilterCalculation())
        )
    )

    #_public
    (§ method void setBloomFilterFPRate(double bloomFilterFPRate))
    (ß
        (§ ass this.vBloomFilterFPRate = bloomFilterFPRate)
    )

    #_public
    (§ method double getBloomFilterFPRate())
    (ß
        (§ return vBloomFilterFPRate)
    )

    #_public
    (§ method BloomFilter getLastFilter())
    (ß
        (§ return lastFilter)
    )
)

#_(ns org.bitcoinj.net #_"MessageWriteTarget"
    (:import [java.io IOException]))

;;;
 ; A target to which messages can be written/connection can be closed.
 ;;
#_public
(§ interface MessageWriteTarget
    ;;;
     ; Writes the given bytes to the remote server.
     ;;
    (§ method void writeBytes(byte[] message))
        (§ throws IOException)
    ;;;
     ; Closes the connection to the server, triggering the {@link StreamConnection#connectionClosed()}
     ; event on the network-handling thread where all callbacks occur.
     ;;
    (§ method void closeConnection())
)

#_(ns org.bitcoinj.net #_"NioClient"
    (:import #_[java.io *]
             #_[java.net *]
             #_[java.nio *])
    (:import #_[com.google.common.base *]
             #_[com.google.common.util.concurrent *]
             #_[org.slf4j *]))

;;;
 ; Creates a simple connection to a server using a {@link StreamConnection} to process data.
 ;;
#_public
(§ class NioClient implements MessageWriteTarget
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(NioClient.class))

    #_private
    #_final
    (§ field Handler handler)
    #_private
    #_final
    (§ field NioClientManager manager = new NioClientManager())

    (§ class Handler extends AbstractTimeoutHandler implements StreamConnection
        #_private
        #_final
        (§ field StreamConnection upstreamConnection)
        #_private
        (§ field MessageWriteTarget writeTarget)
        #_private
        (§ field boolean closeOnOpen)
        #_private
        (§ field boolean closeCalled)

        (§ constructor Handler(StreamConnection upstreamConnection, int connectTimeoutMillis))
        (ß
            (§ ass this.upstreamConnection = upstreamConnection)
            (§ call setSocketTimeout(connectTimeoutMillis))
            (§ call setTimeoutEnabled(true))
        )

        #_override
        #_protected
        #_synchronized
        (§ method void timeoutOccurred())
        (ß
            (§ ass closeOnOpen = true)
            (§ call connectionClosed())
        )

        #_override
        #_public
        #_synchronized
        (§ method void connectionClosed())
        (ß
            (§ call manager.stopAsync())
            (§ if (!closeCalled))
            (ß
                (§ ass closeCalled = true)
                (§ call upstreamConnection.connectionClosed())
            )
        )

        #_override
        #_public
        #_synchronized
        (§ method void connectionOpened())
        (ß
            (§ if (!closeOnOpen))
                (§ call upstreamConnection.connectionOpened())
        )

        #_override
        #_public
        (§ method int receiveBytes(ByteBuffer buff))
            (§ throws Exception)
        (ß
            (§ return upstreamConnection.receiveBytes(buff))
        )

        #_override
        #_public
        #_synchronized
        (§ method void setWriteTarget(MessageWriteTarget writeTarget))
        (ß
            (§ if (closeOnOpen))
                (§ call writeTarget.closeConnection())
            (§ else)
            (ß
                (§ call setTimeoutEnabled(false))
                (§ ass this.writeTarget = writeTarget)
                (§ call upstreamConnection.setWriteTarget(writeTarget))
            )
        )

        #_override
        #_public
        (§ method int getMaxMessageSize())
        (ß
            (§ return upstreamConnection.getMaxMessageSize())
        )
    )

    ;;;
     ; <p>Creates a new client to the given server address using the given {@link StreamConnection} to decode the data.
     ; The given connection <b>MUST</b> be unique to this object.  This does not block while waiting for the connection
     ; to open, but will call either the {@link StreamConnection#connectionOpened()} or
     ; {@link StreamConnection#connectionClosed()} callback on the created network event processing thread.</p>
     ;
     ; @param connectTimeoutMillis The connect timeout set on the connection (in milliseconds).
     ;                             0 is interpreted as no timeout.
     ;;
    #_public
    (§ constructor NioClient(#_final SocketAddress serverAddress, #_final StreamConnection parser, #_final int connectTimeoutMillis))
        (§ throws IOException)
    (ß
        (§ call manager.startAsync())
        (§ call manager.awaitRunning())
        (§ ass handler = new Handler(parser, connectTimeoutMillis))
        (§ call Futures.addCallback(manager.openConnection(serverAddress, handler), new FutureCallback<SocketAddress>()
        (ß
            #_override
            #_public
            (§ method void onSuccess(SocketAddress result))
            (ß
            )

            #_override
            #_public
            (§ method void onFailure(Throwable t))
            (ß
                (§ call log.error("Connect to {} failed: {}", serverAddress, Throwables.getRootCause(t)))
            )
        )))
    )

    #_override
    #_public
    (§ method void closeConnection())
    (ß
        (§ call handler.writeTarget.closeConnection())
    )

    #_override
    #_public
    #_synchronized
    (§ method void writeBytes(byte[] message))
        (§ throws IOException)
    (ß
        (§ call handler.writeTarget.writeBytes(message))
    )
)

#_(ns org.bitcoinj.net #_"NioClientManager"
    (:import [java.io IOException]
             [java.net ConnectException SocketAddress]
             #_[java.nio.channels *]
             [java.nio.channels.spi SelectorProvider]
             #_[java.util *]
             #_[java.util.concurrent *])
    (:import [com.google.common.base Throwables]
             #_[com.google.common.util.concurrent *]
             [org.slf4j Logger LoggerFactory])
  #_(:require #_[org.bitcoinj.utils *]))

;;;
 ; A class which manages a set of client connections.  Uses Java NIO to select network events and processes them
 ; in a single network processing thread.
 ;;
#_public
(§ class NioClientManager extends AbstractExecutionThreadService implements ClientConnectionManager
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(NioClientManager.class))

    #_private
    #_final
    (§ field Selector selector)

    (§ class PendingConnect
        (§ var SocketChannel sc)
        (§ var StreamConnection connection)
        (§ var SocketAddress address)
        (§ var SettableFuture<SocketAddress> future = SettableFuture.create())

        (§ constructor PendingConnect(SocketChannel sc, StreamConnection connection, SocketAddress address))
        (ß
            (§ ass this.sc = sc)
            (§ ass this.connection = connection)
            (§ ass this.address = address)
        )
    )
    #_final
    (§ field Queue<PendingConnect> newConnectionChannels = new LinkedBlockingQueue<>())

    ;; Added to/removed from by the individual ConnectionHandler's, thus must by synchronized on its own.
    #_private
    #_final
    (§ field Set<ConnectionHandler> connectedHandlers = Collections.synchronizedSet(new HashSet<ConnectionHandler>()))

    ;; Handle a SelectionKey which was selected.
    #_private
    (§ method void handleKey(SelectionKey key))
        (§ throws IOException)
    (ß
        ;; We could have a !isValid() key here if the connection is already closed at this point,
        ;; i.e. a client connection which has finished the initial connect process.
        (§ if (key.isValid() && key.isConnectable()))
        (ß
            ;; Create a ConnectionHandler and hook everything together.
            (§ var PendingConnect data = (PendingConnect)key.attachment())
            (§ var StreamConnection connection = data.connection)
            (§ var SocketChannel sc = (SocketChannel)key.channel())
            (§ var ConnectionHandler handler = new ConnectionHandler(connection, key, connectedHandlers))
            (§ try)
            (ß
                (§ if (sc.finishConnect()))
                (ß
                    (§ call log.info("Connected to {}", sc.socket().getRemoteSocketAddress()))
                    (§ call key.interestOps((key.interestOps() | SelectionKey.OP_READ) & ~SelectionKey.OP_CONNECT).attach(handler))
                    (§ call connection.connectionOpened())
                    (§ call data.future.set(data.address))
                )
                (§ else)
                (ß
                    (§ call log.warn("Failed to connect to {}", sc.socket().getRemoteSocketAddress()))
                    (§ call handler.closeConnection()) ;; Failed to connect for some reason.
                    (§ call data.future.setException(new ConnectException("Unknown reason")))
                    (§ ass data.future = nil)
                )
            )
            (§ catch (Exception e))
            (ß
                ;; If e is a CancelledKeyException, there is a race to get to interestOps after finishConnect() which
                ;; may cause this.  Otherwise it may be any arbitrary kind of connection failure.
                ;; Calling sc.socket().getRemoteSocketAddress() here throws an exception, so we can only log the error itself.
                (§ var Throwable cause = Throwables.getRootCause(e))
                (§ call log.warn("Failed to connect with exception: {}: {}", cause.getClass().getName(), cause.getMessage(), e))
                (§ call handler.closeConnection())
                (§ call data.future.setException(cause))
                (§ ass data.future = nil)
            )
        )
        (§ else) ;; Process bytes read.
            (§ call ConnectionHandler.handleKey(key))
    )

    ;;;
     ; Creates a new client manager which uses Java NIO for socket management.
     ; Uses a single thread to handle all select calls.
     ;;
    #_public
    (§ constructor NioClientManager())
    (ß
        (§ try)
        (ß
            (§ ass selector = SelectorProvider.provider().openSelector())
        )
        (§ catch (IOException e))
        (ß
            (§ throw new RuntimeException(e)) ;; Shouldn't ever happen.
        )
    )

    #_override
    #_public
    (§ method void run())
    (ß
        (§ try)
        (ß
            (§ call Thread.currentThread().setPriority(Thread.MIN_PRIORITY))
            (§ while (isRunning()))
            (ß
                (§ var PendingConnect conn)
                (§ while ((conn = newConnectionChannels.poll()) != nil))
                (ß
                    (§ try)
                    (ß
                        (§ var SelectionKey key = conn.sc.register(selector, SelectionKey.OP_CONNECT))
                        (§ call key.attach(conn))
                    )
                    (§ catch (ClosedChannelException _))
                    (ß
                        (§ call log.warn("SocketChannel was closed before it could be registered"))
                    )
                )

                (§ call selector.select())

                (§ var Iterator<SelectionKey> keyIterator = selector.selectedKeys().iterator())
                (§ while (keyIterator.hasNext()))
                (ß
                    (§ var SelectionKey key = keyIterator.next())
                    (§ call keyIterator.remove())
                    (§ call handleKey(key))
                )
            )
        )
        (§ catch (Exception e))
        (ß
            (§ call log.warn("Error trying to open/read from connection: ", e))
        )
        (§ finally)
        (ß
            ;; Go through and close everything, without letting IOExceptions get in our way.
            (§ for (SelectionKey key :for selector.keys()))
            (ß
                (§ try)
                (ß
                    (§ call key.channel().close())
                )
                (§ catch (IOException e))
                (ß
                    (§ call log.warn("Error closing channel", e))
                )
                (§ call key.cancel())
                (§ if (key.attachment() instanceof ConnectionHandler))
                    (§ call ConnectionHandler.handleKey(key)) ;; Close connection if relevant.
            )
            (§ try)
            (ß
                (§ call selector.close())
            )
            (§ catch (IOException e))
            (ß
                (§ call log.warn("Error closing client manager selector", e))
            )
        )
    )

    #_override
    #_public
    (§ method ListenableFuture<SocketAddress> openConnection(SocketAddress serverAddress, StreamConnection connection))
    (ß
        (§ if (!isRunning()))
            (§ throw new IllegalStateException())

        ;; Create a new connection, give it a connection as an attachment.
        (§ try)
        (ß
            (§ var SocketChannel sc = SocketChannel.open())
            (§ call sc.configureBlocking(false))
            (§ call sc.connect(serverAddress))
            (§ var PendingConnect data = new PendingConnect(sc, connection, serverAddress))
            (§ call newConnectionChannels.offer(data))
            (§ call selector.wakeup())
            (§ return data.future)
        )
        (§ catch (Throwable e))
        (ß
            (§ return Futures.immediateFailedFuture(e))
        )
    )

    #_override
    #_public
    (§ method void triggerShutdown())
    (ß
        (§ call selector.wakeup())
    )

    #_override
    #_public
    (§ method int getConnectedClientCount())
    (ß
        (§ return connectedHandlers.size())
    )

    #_override
    #_public
    (§ method void closeConnections(int n))
    (ß
        (§ for ( :for 0 < n :for n = n - 1))
        (ß
            (§ var ConnectionHandler handler)
            (§ sync connectedHandlers)
            (ß
                (§ ass handler = connectedHandlers.iterator().next())
            )
            (§ if (handler != nil))
                (§ call handler.closeConnection()) ;; Removes handler from connectedHandlers before returning.
        )
    )

    #_override
    #_protected
    (§ method Executor executor())
    (ß
        (§ return new Executor()
        (ß
            #_override
            #_public
            (§ method void execute(Runnable command))
            (ß
                (§ call new ContextPropagatingThreadFactory("NioClientManager").newThread(command).start())
            )
        ))
    )
)

#_(ns org.bitcoinj.net #_"NioServer"
    (:import [java.io IOException]
             [java.net InetSocketAddress]
             #_[java.nio.channels *]
             [java.nio.channels.spi SelectorProvider]
             [java.util Iterator])
    (:import [com.google.common.annotations VisibleForTesting]
             [com.google.common.base Throwables]
             [com.google.common.util.concurrent AbstractExecutionThreadService]
             [org.slf4j Logger LoggerFactory]))

;;;
 ; Creates a simple server listener which listens for incoming client connections and uses a {@link StreamConnection}
 ; to process data.
 ;;
#_public
(§ class NioServer extends AbstractExecutionThreadService
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(NioServer.class))

    #_private
    #_final
    (§ field StreamConnectionFactory connectionFactory)

    #_private
    #_final
    (§ field ServerSocketChannel sc)
    #_testing
    #_final
    (§ field Selector selector)

    ;; Handle a SelectionKey which was selected.
    #_private
    (§ method void handleKey(Selector selector, SelectionKey key))
        (§ throws IOException)
    (ß
        (§ if (key.isValid() && key.isAcceptable()))
        (ß
            ;; Accept a new connection, give it a stream connection as an attachment.
            (§ var SocketChannel newChannel = sc.accept())
            (§ call newChannel.configureBlocking(false))
            (§ var SelectionKey newKey = newChannel.register(selector, SelectionKey.OP_READ))
            (§ try)
            (ß
                (§ var ConnectionHandler handler = new ConnectionHandler(connectionFactory, newKey))
                (§ call newKey.attach(handler))
                (§ call handler.connection.connectionOpened())
            )
            (§ catch (IOException e))
            (ß
                ;; This can happen if ConnectionHandler's call to get a new handler returned null.
                (§ call log.error("Error handling new connection", Throwables.getRootCause(e).getMessage()))
                (§ call newKey.channel().close())
            )
        )
        (§ else) ;; Got a closing channel or a channel to a client connection.
        (ß
            (§ call ConnectionHandler.handleKey(key))
        )
    )

    ;;;
     ; Creates a new server which is capable of listening for incoming connections and processing client provided data
     ; using {@link StreamConnection}s created by the given {@link StreamConnectionFactory}.
     ;
     ; @throws IOException if there is an issue opening the server socket or binding fails for some reason.
     ;;
    #_public
    (§ constructor NioServer(#_final StreamConnectionFactory connectionFactory, InetSocketAddress bindAddress))
        (§ throws IOException)
    (ß
        (§ ass this.connectionFactory = connectionFactory)

        (§ ass sc = ServerSocketChannel.open())
        (§ call sc.configureBlocking(false))
        (§ call sc.socket().bind(bindAddress))
        (§ ass selector = SelectorProvider.provider().openSelector())
        (§ call sc.register(selector, SelectionKey.OP_ACCEPT))
    )

    #_override
    #_protected
    (§ method void run())
        (§ throws Exception)
    (ß
        (§ try)
        (ß
            (§ while (isRunning()))
            (ß
                (§ call selector.select())

                (§ var Iterator<SelectionKey> keyIterator = selector.selectedKeys().iterator())
                (§ while (keyIterator.hasNext()))
                (ß
                    (§ var SelectionKey key = keyIterator.next())
                    (§ call keyIterator.remove())

                    (§ call handleKey(selector, key))
                )
            )
        )
        (§ catch (Exception e))
        (ß
            (§ call log.error("Error trying to open/read from connection: {}", e))
        )
        (§ finally)
        (ß
            ;; Go through and close everything, without letting IOExceptions get in our way.
            (§ for (SelectionKey key :for selector.keys()))
            (ß
                (§ try)
                (ß
                    (§ call key.channel().close())
                )
                (§ catch (IOException e))
                (ß
                    (§ call log.error("Error closing channel", e))
                )
                (§ try)
                (ß
                    (§ call key.cancel())
                    (§ call handleKey(selector, key))
                )
                (§ catch (IOException e))
                (ß
                    (§ call log.error("Error closing selection key", e))
                )
            )
            (§ try)
            (ß
                (§ call selector.close())
            )
            (§ catch (IOException e))
            (ß
                (§ call log.error("Error closing server selector", e))
            )
            (§ try)
            (ß
                (§ call sc.close())
            )
            (§ catch (IOException e))
            (ß
                (§ call log.error("Error closing server channel", e))
            )
        )
    )

    ;;;
     ; Invoked by the Execution service when it's time to stop.
     ; Calling this method directly will NOT stop the service, call
     ; {@link com.google.common.util.concurrent.AbstractExecutionThreadService#stop()} instead.
     ;;
    #_override
    #_public
    (§ method void triggerShutdown())
    (ß
        ;; Wake up the selector and let the selection thread break its loop as the ExecutionService !isRunning().
        (§ call selector.wakeup())
    )
)

#_(ns org.bitcoinj.net #_"ProtobufConnection"
    (:import [java.io IOException]
             [java.nio ByteBuffer ByteOrder]
             [java.util.concurrent.atomic AtomicReference]
             [java.util.concurrent.locks ReentrantLock]
             [javax.annotation.concurrent GuardedBy])
    (:import [com.google.common.annotations VisibleForTesting]
             [com.google.common.base Preconditions]
             [com.google.protobuf ByteString MessageLite]
             [org.slf4j Logger LoggerFactory])
  #_(:require [org.bitcoinj.core Utils]
             [org.bitcoinj.utils Threading]))

;;;
 ; <p>A handler which is used in {@link NioServer} and {@link NioClient} to split up incoming data streams
 ; into protobufs and provide an interface for writing protobufs to the connections.</p>
 ;
 ; <p>Messages are encoded with a 4-byte signed integer (big endian) prefix to indicate their length followed
 ; by the serialized protobuf.</p>
 ;;
#_public
(§ class ProtobufConnection<MessageType extends MessageLite> extends AbstractTimeoutHandler implements StreamConnection
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(ProtobufConnection.class))

    ;;;
     ; An interface which can be implemented to handle callbacks as new messages are generated and socket events occur.
     ; @param <MessageType> The protobuf type which is used on this socket.
     ;                      This <b>MUST</b> match the MessageType used in the parent {@link ProtobufConnection}.
     ;;
    #_public
    (§ interface Listener<MessageType extends MessageLite>
        ;;; Called when a new protobuf is received from the remote side. ;;
        (§ method void messageReceived(ProtobufConnection<MessageType> handler, MessageType msg))
        ;;; Called when the connection is opened and available for writing data to. ;;
        (§ method void connectionOpen(ProtobufConnection<MessageType> handler))
        ;;; Called when the connection is closed and no more data should be provided. ;;
        (§ method void connectionClosed(ProtobufConnection<MessageType> handler))
    )

    ;; The callback listener.
    #_private
    #_final
    (§ field Listener<MessageType> handler)
    ;; The prototype which is used to deserialize messages.
    #_private
    #_final
    (§ field MessageLite prototype)

    ;; The maximum message size (NOT INCLUDING LENGTH PREFIX).
    #_final
    (§ field int maxMessageSize)

    ;; A temporary buffer used when the message size is larger than the buffer being used by the network code.
    ;; Because the networking code uses a constant size buffer and we want to allow for very large message sizes, we use
    ;; a smaller network buffer per client and only allocate more memory when we need it to deserialize large messages.
    ;; Though this is not in of itself a DoS protection, it allows for handling more legitimate clients per server and
    ;; attacking clients can be made to timeout/get blocked if they are sending crap to fill buffers.
    #_guarded-by(ß "lock")
    #_private
    (§ field int messageBytesOffset = 0)
    #_guarded-by(ß "lock")
    #_private
    (§ field byte[] messageBytes)
    #_private
    #_final
    (§ field ReentrantLock lock = Threading.lock("ProtobufConnection"))

    #_testing
    #_final
    (§ field AtomicReference<MessageWriteTarget> writeTarget = new AtomicReference<>())

    ;;;
     ; Creates a new protobuf handler.
     ;
     ; @param handler The callback listener.
     ; @param prototype The default instance of the message type used in both directions of this channel.
     ;                  This should be the return value from {@link MessageType#getDefaultInstanceForType()}.
     ; @param maxMessageSize The maximum message size (not including the 4-byte length prefix).
     ;                       Note that this has an upper bound of {@link Integer#MAX_VALUE} - 4.
     ; @param timeoutMillis The timeout between messages before the connection is automatically closed.
     ;                      Only enabled after the connection is established.
     ;;
    #_public
    (§ constructor ProtobufConnection(Listener<MessageType> handler, MessageType prototype, int maxMessageSize, int timeoutMillis))
    (ß
        (§ ass this.handler = handler)
        (§ ass this.prototype = prototype)
        (§ ass this.maxMessageSize = Math.min(maxMessageSize, Integer.MAX_VALUE - 4))
        (§ call setTimeoutEnabled(false))
        (§ call setSocketTimeout(timeoutMillis))
    )

    #_override
    #_public
    (§ method void setWriteTarget(MessageWriteTarget writeTarget))
    (ß
        ;; Only allow it to be set once.
        (§ call Preconditions.checkState(this.writeTarget.getAndSet(Preconditions.checkNotNull(writeTarget)) == nil))
    )

    #_override
    #_public
    (§ method int getMaxMessageSize())
    (ß
        (§ return maxMessageSize)
    )

    ;;;
     ; Closes this connection, eventually triggering a {@link ProtobufConnection.Listener#connectionClosed()} event.
     ;;
    #_public
    (§ method void closeConnection())
    (ß
        (§ call this.writeTarget.get().closeConnection())
    )

    #_override
    #_protected
    (§ method void timeoutOccurred())
    (ß
        (§ call log.warn("Timeout occurred for " + handler))
        (§ call closeConnection())
    )

    ;; Deserializes and provides a listener event (buff must not have the length prefix in it).
    ;; Does set the buffers's position to its limit.
    #_suppress(ß "unchecked")
    ;; The warning 'unchecked cast' being suppressed here comes from the build() formally returning
    ;; a MessageLite-derived class that cannot be statically guaranteed to be the MessageType.
    #_private
    (§ method void deserializeMessage(ByteBuffer buff))
        (§ throws Exception)
    (ß
        (§ var MessageType msg = (MessageType)prototype.newBuilderForType().mergeFrom(ByteString.copyFrom(buff)).build())
        (§ call resetTimeout())
        (§ call handler.messageReceived(this, msg))
    )

    #_override
    #_public
    (§ method int receiveBytes(ByteBuffer buff))
        (§ throws Exception)
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ if (messageBytes != nil))
            (ß
                ;; Just keep filling up the currently being worked on message.
                (§ var int bytesToGet = Math.min(messageBytes.length - messageBytesOffset, buff.remaining()))
                (§ call buff.get(messageBytes, messageBytesOffset, bytesToGet))
                (§ ass messageBytesOffset = messageBytesOffset + bytesToGet)
                (§ if (messageBytesOffset == messageBytes.length))
                (ß
                    ;; Filled up our buffer, decode the message.
                    (§ call deserializeMessage(ByteBuffer.wrap(messageBytes)))
                    (§ ass messageBytes = nil)
                    (§ if (buff.hasRemaining()))
                        (§ return bytesToGet + receiveBytes(buff))
                )
                (§ return bytesToGet)
            )

            ;; If we cant read the length prefix yet, give up.
            (§ if (buff.remaining() < 4))
                (§ return 0)

            ;; Read one integer in big endian.
            (§ call buff.order(ByteOrder.BIG_ENDIAN))
            #_final
            (§ var int len = buff.getInt())

            ;; If length is larger than the maximum message size (or is negative/overflows) throw an exception and close
            ;; the connection.
            (§ if (maxMessageSize < len || len + 4 < 4))
                (§ throw new IllegalStateException("Message too large or length underflowed"))

            ;; If the buffer's capacity is less than the next messages length + 4 (length prefix), we must use messageBytes
            ;; as a temporary buffer to store the message.
            (§ if (buff.capacity() < len + 4))
            (ß
                (§ ass messageBytes = new byte[len])
                ;; Now copy all remaining bytes into the new buffer, set messageBytesOffset and tell the caller how many
                ;; bytes we consumed.
                (§ var int bytesToRead = buff.remaining())
                (§ call buff.get(messageBytes, 0, bytesToRead))
                (§ ass messageBytesOffset = bytesToRead)
                (§ return bytesToRead + 4)
            )

            ;; Wait until the whole message is available in the buffer.
            (§ if (buff.remaining() < len))
            (ß
                ;; Make sure the buffer's position is right at the end.
                (§ call buff.position(buff.position() - 4))
                (§ return 0)
            )

            ;; Temporarily limit the buffer to the size of the message, so that the protobuf decode doesn't get messed up.
            (§ var int limit = buff.limit())
            (§ call buff.limit(buff.position() + len))
            (§ call deserializeMessage(buff))
            (§ call Preconditions.checkState(buff.remaining() == 0))
            ;; Reset the limit in case we have to recurse.
            (§ call buff.limit(limit))

            ;; If there are still bytes remaining, see if we can pull out another message since we won't get called again.
            (§ if (buff.hasRemaining()))
                (§ return len + 4 + receiveBytes(buff))
            (§ else)
                (§ return len + 4)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    #_override
    #_public
    (§ method void connectionClosed())
    (ß
        (§ call handler.connectionClosed(this))
    )

    #_override
    #_public
    (§ method void connectionOpened())
    (ß
        (§ call setTimeoutEnabled(true))
        (§ call handler.connectionOpen(this))
    )

    ;;;
     ; <p>Writes the given message to the other side of the connection, prefixing it with the proper 4-byte prefix.</p>
     ;
     ; <p>Provides a write-order guarantee.</p>
     ;
     ; @throws IllegalStateException if the encoded message is larger than the maximum message size.
     ;;
    #_public
    (§ method void write(MessageType msg))
        (§ throws IllegalStateException)
    (ß
        (§ var byte[] messageBytes = msg.toByteArray())
        (§ call Preconditions.checkState(messageBytes.length <= maxMessageSize))

        (§ var byte[] messageLength = new byte[4])
        (§ call Utils.uint32ToByteArrayBE(messageBytes.length, messageLength, 0))
        (§ try)
        (ß
            (§ var MessageWriteTarget target = writeTarget.get())
            (§ call target.writeBytes(messageLength))
            (§ call target.writeBytes(messageBytes))
        )
        (§ catch (IOException e))
        (ß
            (§ call closeConnection())
        )
    )
)

#_(ns org.bitcoinj.net #_"StreamConnection"
    (:import [java.nio ByteBuffer]))

;;;
 ; A generic handler which is used in {@link NioServer}, {@link NioClient} and {@link BlockingClient} to handle incoming
 ; data streams.
 ;;
#_public
(§ interface StreamConnection
    ;;; Called when the connection socket is closed. ;;
    (§ method void connectionClosed())

    ;;; Called when the connection socket is first opened. ;;
    (§ method void connectionOpened())

    ;;;
     ; <p>Called when new bytes are available from the remote end.  This should only ever be called by the single
     ; writeTarget associated with any given StreamConnection, multiple callers will likely confuse implementations.</p>
     ;
     ; Implementers/callers must follow the following conventions exactly:
     ; <ul>
     ; <li>buff will start with its limit set to the position we can read to and its position set to the location we
     ;     will start reading at (always 0).</li>
     ; <li>May read more than one message (recursively) if there are enough bytes available.</li>
     ; <li>Uses some internal buffering to store message which are larger (incl. their length prefix) than buff's
     ;     capacity(), i.e. it is up to this method to ensure we dont run out of buffer space to decode the next message.</li>
     ; <li>buff will end with its limit the same as it was previously, and its position set to the position up to which
     ;     bytes have been read (the same as its return value).</li>
     ; <li>buff must be at least the size of a Bitcoin header (incl. magic bytes).</li>
     ; </ul>
     ;
     ; @return the amount of bytes consumed which should not be provided again.
     ;;
    (§ method int receiveBytes(ByteBuffer buff))
        (§ throws Exception)

    ;;;
     ; Called when this connection is attached to an upstream write target (i.e. a low-level connection handler).
     ; This writeTarget should be stored and used to close the connection or write data to the socket.
     ;;
    (§ method void setWriteTarget(MessageWriteTarget writeTarget))

    ;;;
     ; Returns the maximum message size of a message on the socket. This is used in calculating size of buffers
     ; to allocate.
     ;;
    (§ method int getMaxMessageSize())
)

#_(ns org.bitcoinj.net #_"StreamConnectionFactory"
    (:import [java.net InetAddress]))

;;;
 ; A factory which generates new {@link StreamConnection}s when a new connection is opened.
 ;;
#_public
(§ interface StreamConnectionFactory
    ;;;
     ; Returns a new handler or null to have the connection close.
     ; @param inetAddress The client's (IP) address.
     ; @param port The remote port on the client side.
     ;;
    #_nilable
    (§ method StreamConnection getNewConnection(InetAddress inetAddress, int port))
)

#_(ns org.bitcoinj.net.discovery #_"DnsDiscovery"
    (:import #_[java.net *]
             #_[java.util *]
             #_[java.util.concurrent *])
  #_(:require #_[org.bitcoinj.core *]
             #_[org.bitcoinj.utils *]))

;;;
 ; <p>Supports peer discovery through DNS.</p>
 ;
 ; <p>Failure to resolve individual host names will not cause an Exception to be thrown.
 ; However, if all hosts passed fail to resolve a PeerDiscoveryException will be thrown during getPeers().</p>
 ;
 ; <p>DNS seeds do not attempt to enumerate every peer on the network.
 ; {@link DnsDiscovery#getPeers(long, java.util.concurrent.TimeUnit)} will return up to 30 random peers
 ; from the set of those returned within the timeout period.  If you want more peers to connect to,
 ; you need to discover them via other means (like addr broadcasts).</p>
 ;;
#_public
(§ class DnsDiscovery extends MultiplexingDiscovery
    ;;;
     ; Supports finding peers through DNS A records.  Community run DNS entry points will be used.
     ;
     ; @param netParams Network parameters to be used for port information.
     ;;
    #_public
    (§ constructor DnsDiscovery(NetworkParameters netParams))
    (ß
        (§ this (netParams.getDnsSeeds(), netParams))
    )

    ;;;
     ; Supports finding peers through DNS A records.
     ;
     ; @param dnsSeeds Host names to be examined for seed addresses.
     ; @param params Network parameters to be used for port information.
     ;;
    #_public
    (§ constructor DnsDiscovery(String[] dnsSeeds, NetworkParameters params))
    (ß
        (§ super (params, buildDiscoveries(params, dnsSeeds)))
    )

    #_private
    #_static
    (§ method List<PeerDiscovery> buildDiscoveries(NetworkParameters params, String[] seeds))
    (ß
        (§ var List<PeerDiscovery> discoveries = new ArrayList<>())
        (§ if (seeds != nil))
            (§ for (String seed :for seeds))
                (§ call discoveries.add(new DnsSeedDiscovery(params, seed)))
        (§ return discoveries)
    )

    #_override
    #_protected
    (§ method ExecutorService createExecutor())
    (ß
        ;; Attempted workaround for reported bugs on Linux in which gethostbyname does not appear to be properly
        ;; thread safe and can cause segfaults on some libc versions.
        (§ if (System.getProperty("os.name").toLowerCase().contains("linux")))
            (§ return Executors.newSingleThreadExecutor(new ContextPropagatingThreadFactory("DNS seed lookups")))
        (§ else)
            (§ return Executors.newFixedThreadPool(seeds.size(), new DaemonThreadFactory("DNS seed lookups")))
    )

    ;;; Implements discovery from a single DNS host. ;;
    #_public
    #_static
    (§ class DnsSeedDiscovery implements PeerDiscovery
        #_private
        #_final
        (§ field String hostname)
        #_private
        #_final
        (§ field NetworkParameters params)

        #_public
        (§ constructor DnsSeedDiscovery(NetworkParameters params, String hostname))
        (ß
            (§ ass this.hostname = hostname)
            (§ ass this.params = params)
        )

        #_override
        #_public
        (§ method InetSocketAddress[] getPeers(long services, long timeoutValue, TimeUnit timeoutUnit))
            (§ throws PeerDiscoveryException)
        (ß
            (§ if (services != 0))
                (§ throw new PeerDiscoveryException("DNS seeds cannot filter by services: " + services))

            (§ try)
            (ß
                (§ var InetAddress[] response = InetAddress.getAllByName(hostname))
                (§ var InetSocketAddress[] result = new InetSocketAddress[response.length])
                (§ for (int i = 0 :for i < response.length :for i = i + 1))
                    (§ ass result[i] = new InetSocketAddress(response[i], params.getPort()))
                (§ return result)
            )
            (§ catch (UnknownHostException e))
            (ß
                (§ throw new PeerDiscoveryException(e))
            )
        )

        #_override
        #_public
        (§ method void shutdown())
        (ß
        )

        #_override
        #_public
        (§ method String toString())
        (ß
            (§ return hostname)
        )
    )
)

#_(ns org.bitcoinj.net.discovery #_"MultiplexingDiscovery"
    (:import [java.net InetSocketAddress]
             [java.util ArrayList Collections List]
             #_[java.util.concurrent *])
    (:import [com.google.common.base Preconditions]
             [com.google.common.collect Lists]
             [org.slf4j Logger LoggerFactory])
  #_(:require [org.bitcoinj.core NetworkParameters VersionMessage]
             [org.bitcoinj.net.discovery.DnsDiscovery DnsSeedDiscovery]
             #_[org.bitcoinj.utils *]))

;;;
 ; MultiplexingDiscovery queries multiple PeerDiscovery objects, shuffles their responses and then returns the results,
 ; thus selecting randomly between them and reducing the influence of any particular seed.  Any that don't respond
 ; within the timeout are ignored.  Backends are queried in parallel.  Backends may block.
 ;;
#_public
(§ class MultiplexingDiscovery implements PeerDiscovery
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(MultiplexingDiscovery.class))

    #_protected
    #_final
    (§ field List<PeerDiscovery> seeds)
    #_protected
    #_final
    (§ field NetworkParameters netParams)
    #_private
    #_volatile
    (§ field ExecutorService vThreadPool)

    ;;;
     ; Builds a suitable set of peer discoveries.  Will query them in parallel before producing a merged response.
     ; If specific services are required, DNS is not used as the protocol can't handle it.
     ; @param params Network to use.
     ; @param services Required services as a bitmask, e.g. {@link VersionMessage#NODE_NETWORK}.
     ;;
    #_public
    #_static
    (§ method MultiplexingDiscovery forServices(NetworkParameters params, long services))
    (ß
        (§ var List<PeerDiscovery> discoveries = Lists.newArrayList())
        ;; Also use DNS seeds if there is no specific service requirement.
        (§ if (services == 0))
        (ß
            (§ var String[] dnsSeeds = params.getDnsSeeds())
            (§ if (dnsSeeds != nil))
                (§ for (String dnsSeed :for dnsSeeds))
                    (§ call discoveries.add(new DnsSeedDiscovery(params, dnsSeed)))
        )
        (§ return new MultiplexingDiscovery(params, discoveries))
    )

    ;;;
     ; Will query the given seeds in parallel before producing a merged response.
     ;;
    #_public
    (§ constructor MultiplexingDiscovery(NetworkParameters params, List<PeerDiscovery> seeds))
    (ß
        (§ call Preconditions.checkArgument(!seeds.isEmpty()))

        (§ ass this.netParams = params)
        (§ ass this.seeds = seeds)
    )

    #_override
    #_public
    (§ method InetSocketAddress[] getPeers(#_final long services, #_final long timeoutValue, #_final TimeUnit timeoutUnit))
        (§ throws PeerDiscoveryException)
    (ß
        (§ ass vThreadPool = createExecutor())
        (§ try)
        (ß
            (§ var List<Callable<InetSocketAddress[]>> tasks = Lists.newArrayList())
            (§ for (#_final PeerDiscovery seed :for seeds))
            (ß
                (§ call tasks.add(new Callable<InetSocketAddress[]>()
                (ß
                    #_override
                    #_public
                    (§ method InetSocketAddress[] call())
                        (§ throws Exception)
                    (ß
                        (§ return seed.getPeers(services, timeoutValue,  timeoutUnit))
                    )
                )))
            )
            #_final
            (§ var List<Future<InetSocketAddress[]>> futures = vThreadPool.invokeAll(tasks, timeoutValue, timeoutUnit))
            (§ var ArrayList<InetSocketAddress> addrs = Lists.newArrayList())
            (§ for (int i = 0 :for i < futures.size() :for i = i + 1))
            (ß
                (§ var Future<InetSocketAddress[]> future = futures.get(i))
                (§ if (future.isCancelled()))
                (ß
                    (§ call log.warn("Seed {}: timed out", seeds.get(i)))
                    (§ continue) ;; Timed out.
                )
                #_final
                (§ var InetSocketAddress[] inetAddresses)
                (§ try)
                (ß
                    (§ ass inetAddresses = future.get())
                )
                (§ catch (ExecutionException e))
                (ß
                    (§ call log.warn("Seed {}: failed to look up: {}", seeds.get(i), e.getMessage()))
                    (§ continue)
                )
                (§ call Collections.addAll(addrs, inetAddresses))
            )
            (§ if (addrs.size() == 0))
                (§ throw new PeerDiscoveryException("No peer discovery returned any results in " + timeoutUnit.toMillis(timeoutValue) + "ms. Check internet connection?"))

            (§ call Collections.shuffle(addrs))
            (§ call vThreadPool.shutdownNow())
            (§ return addrs.toArray(new InetSocketAddress[addrs.size()]))
        )
        (§ catch (InterruptedException e))
        (ß
            (§ throw new PeerDiscoveryException(e))
        )
        (§ finally)
        (ß
            (§ call vThreadPool.shutdown())
        )
    )

    #_protected
    (§ method ExecutorService createExecutor())
    (ß
        (§ return Executors.newFixedThreadPool(seeds.size(), new ContextPropagatingThreadFactory("Multiplexing discovery")))
    )

    #_override
    #_public
    (§ method void shutdown())
    (ß
        (§ var ExecutorService tp = vThreadPool)
        (§ if (tp != nil))
            (§ call tp.shutdown())
    )
)

#_(ns org.bitcoinj.net.discovery #_"PeerDiscovery"
    (:import [java.net InetSocketAddress]
             [java.util.concurrent TimeUnit]))

;;;
 ; A PeerDiscovery object is responsible for finding addresses of other nodes in the Bitcoin P2P network.
 ; Note that the addresses returned may or may not be accepting connections.
 ;;
#_public
(§ interface PeerDiscovery
    ;; TODO: Flesh out this interface a lot more.

    ;;;
     ; Returns an array of addresses.  This method may block.
     ; @param services Required services as a bitmask, e.g. {@link VersionMessage#NODE_NETWORK}.
     ;;
    (§ method InetSocketAddress[] getPeers(long services, long timeoutValue, TimeUnit timeoutUnit))
        (§ throws PeerDiscoveryException)

    ;;; Stops any discovery in progress when we want to shut down quickly. ;;
    (§ method void shutdown())
)

#_(ns org.bitcoinj.net.discovery #_"PeerDiscoveryException")

#_public
(§ class PeerDiscoveryException extends Exception
    #_public
    (§ constructor PeerDiscoveryException())
    (ß
        (§ super ())
    )

    #_public
    (§ constructor PeerDiscoveryException(String message))
    (ß
        (§ super (message))
    )

    #_public
    (§ constructor PeerDiscoveryException(Throwable arg0))
    (ß
        (§ super (arg0))
    )

    #_public
    (§ constructor PeerDiscoveryException(String message, Throwable arg0))
    (ß
        (§ super (message, arg0))
    )
)

#_(ns org.bitcoinj.net.discovery #_"SeedPeers"
    (:import [java.net InetAddress InetSocketAddress UnknownHostException]
             [java.util.concurrent TimeUnit])
  #_(:require [org.bitcoinj.core NetworkParameters]))

;;;
 ; SeedPeers stores a pre-determined list of Bitcoin node addresses.  These nodes are selected based on
 ; being active on the network for a long period of time.  The intention is to be a last resort way of finding
 ; a connection to the network, in case IRC and DNS fail.  The list comes from the Bitcoin C++ source code.
 ;;
#_public
(§ class SeedPeers implements PeerDiscovery
    #_private
    (§ field NetworkParameters params)
    #_private
    (§ field int[] seedAddrs)
    #_private
    (§ field int pnseedIndex)

    ;;;
     ; Supports finding peers by IP addresses.
     ;
     ; @param params Network parameters to be used for port information.
     ;;
    #_public
    (§ constructor SeedPeers(NetworkParameters params))
    (ß
        (§ this (params.getAddrSeeds(), params))
    )

    ;;;
     ; Supports finding peers by IP addresses.
     ;
     ; @param seedAddrs IP addresses for seed addresses.
     ; @param params Network parameters to be used for port information.
     ;;
    #_public
    (§ constructor SeedPeers(int[] seedAddrs, NetworkParameters params))
    (ß
        (§ ass this.seedAddrs = seedAddrs)
        (§ ass this.params = params)
    )

    ;;;
     ; Acts as an iterator, returning the address of each node in the list sequentially.
     ; Once all the list has been iterated, null will be returned for each subsequent query.
     ;
     ; @return InetSocketAddress - the address/port of the next node.
     ; @throws PeerDiscoveryException
     ;;
    #_nilable
    #_public
    (§ method InetSocketAddress getPeer())
        (§ throws PeerDiscoveryException)
    (ß
        (§ try)
        (ß
            (§ return nextPeer())
        )
        (§ catch (UnknownHostException e))
        (ß
            (§ throw new PeerDiscoveryException(e))
        )
    )

    #_nilable
    #_private
    (§ method InetSocketAddress nextPeer())
        (§ throws UnknownHostException, PeerDiscoveryException)
    (ß
        (§ if (seedAddrs == nil || seedAddrs.length == 0))
            (§ throw new PeerDiscoveryException("No IP address seeds configured; unable to find any peers"))

        (§ if (seedAddrs.length <= pnseedIndex))
            (§ return nil)

        (§ var int i = pnseedIndex)
        (§ ass pnseedIndex = pnseedIndex + 1)
        (§ return new InetSocketAddress(convertAddress(seedAddrs[i]), params.getPort()))
    )

    ;;;
     ; Returns an array containing all the Bitcoin nodes within the list.
     ;;
    #_override
    #_public
    (§ method InetSocketAddress[] getPeers(long services, long timeoutValue, TimeUnit timeoutUnit))
        (§ throws PeerDiscoveryException)
    (ß
        (§ if (services != 0))
            (§ throw new PeerDiscoveryException("Pre-determined peers cannot be filtered by services: " + services))

        (§ try)
        (ß
            (§ return allPeers())
        )
        (§ catch (UnknownHostException e))
        (ß
            (§ throw new PeerDiscoveryException(e))
        )
    )

    #_private
    (§ method InetSocketAddress[] allPeers())
        (§ throws UnknownHostException)
    (ß
        (§ var InetSocketAddress[] addresses = new InetSocketAddress[seedAddrs.length])
        (§ for (int i = 0 :for i < seedAddrs.length :for i = i + 1))
            (§ ass addresses[i] = new InetSocketAddress(convertAddress(seedAddrs[i]), params.getPort()))
        (§ return addresses)
    )

    #_private
    (§ method InetAddress convertAddress(int seed))
        (§ throws UnknownHostException)
    (ß
        (§ var byte[] v4addr = new byte[4])
        (§ ass v4addr[0] = (byte)(0xff & seed))
        (§ ass v4addr[1] = (byte)(0xff & (seed >> 8)))
        (§ ass v4addr[2] = (byte)(0xff & (seed >> 16)))
        (§ ass v4addr[3] = (byte)(0xff & (seed >> 24)))
        (§ return InetAddress.getByAddress(v4addr))
    )

    #_override
    #_public
    (§ method void shutdown())
    (ß
    )
)

#_(ns org.bitcoinj.params #_"AbstractBitcoinNetParams"
    (:import [java.math BigInteger]
             [java.util.concurrent TimeUnit])
    (:import [com.google.common.base Preconditions Stopwatch]
             [org.slf4j Logger LoggerFactory])
  #_(:require [org.bitcoinj.core BitcoinSerializer Block Coin NetworkParameters Sha256Hash StoredBlock Transaction Utils VerificationException]
             [org.bitcoinj.utils MonetaryFormat]
             [org.bitcoinj.store BlockStore BlockStoreException]))

;;;
 ; Parameters for Bitcoin-like networks.
 ;;
#_public
#_abstract
(§ class AbstractBitcoinNetParams extends NetworkParameters
    ;;;
     ; Scheme part for Bitcoin URIs.
     ;;
    #_public
    #_static
    #_final
    (§ field String BITCOIN_SCHEME = "bitcoin")
    #_public
    #_static
    #_final
    (§ field int REWARD_HALVING_INTERVAL = 210000)

    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(AbstractBitcoinNetParams.class))

    #_public
    (§ constructor AbstractBitcoinNetParams())
    (ß
        (§ super ())
    )

    ;;;
     ; Checks if we are at a reward halving point.
     ; @param height The height of the previous stored block.
     ; @return if this is a reward halving point.
     ;;
    #_public
    #_final
    (§ method boolean isRewardHalvingPoint(#_final int height))
    (ß
        (§ return (((height + 1) % REWARD_HALVING_INTERVAL) == 0))
    )

    ;;;
     ; Checks if we are at a difficulty transition point.
     ; @param height The height of the previous stored block.
     ; @return if this is a difficulty transition point.
     ;;
    #_public
    #_final
    (§ method boolean isDifficultyTransitionPoint(#_final int height))
    (ß
        (§ return (((height + 1) % this.getInterval()) == 0))
    )

    #_override
    #_public
    (§ method void checkDifficultyTransitions(#_final StoredBlock storedPrev, #_final Block nextBlock, #_final BlockStore blockStore))
        (§ throws VerificationException, BlockStoreException)
    (ß
        #_final
        (§ var Block prev = storedPrev.getHeader())

        ;; Is this supposed to be a difficulty transition point?
        (§ if (!isDifficultyTransitionPoint(storedPrev.getHeight())))
        (ß
            ;; No ... so check the difficulty didn't actually change.
            (§ if (nextBlock.getDifficultyTarget() != prev.getDifficultyTarget()))
                (§ throw new VerificationException("Unexpected change in difficulty at height " + storedPrev.getHeight() + ": " + Long.toHexString(nextBlock.getDifficultyTarget()) + " vs " + Long.toHexString(prev.getDifficultyTarget())))
            (§ return)
        )

        ;; We need to find a block far back in the chain.  It's OK that this is expensive because it only occurs every
        ;; two weeks after the initial block chain download.
        #_final
        (§ var Stopwatch watch = Stopwatch.createStarted())

        (§ var Sha256Hash hash = prev.getHash())
        (§ var StoredBlock cursor = nil)
        #_final
        (§ var int interval = this.getInterval())
        (§ for (int i = 0 :for i < interval :for i = i + 1))
        (ß
            (§ ass cursor = blockStore.get(hash))
            (§ if (cursor == nil))
            (ß
                ;; This should never happen.  If it does, it means we are following an incorrect or busted chain.
                (§ throw new VerificationException("Difficulty transition point but we did not find a way back to the last transition point. Not found: " + hash))
            )
            (§ ass hash = cursor.getHeader().getPrevBlockHash())
        )
        (§ call Preconditions.checkState(cursor != nil && isDifficultyTransitionPoint(cursor.getHeight() - 1), "Didn't arrive at a transition point."))

        (§ call watch.stop())
        (§ if (50 < watch.elapsed(TimeUnit.MILLISECONDS)))
            (§ call log.info("Difficulty transition traversal took {}", watch))

        (§ var Block blockIntervalAgo = cursor.getHeader())
        (§ var int timespan = (int)(prev.getTimeSeconds() - blockIntervalAgo.getTimeSeconds()))
        ;; Limit the adjustment step.
        #_final
        (§ var int targetTimespan = this.getTargetTimespan())
        (§ if (timespan < targetTimespan / 4))
            (§ ass timespan = targetTimespan / 4)
        (§ if (timespan > targetTimespan * 4))
            (§ ass timespan = targetTimespan * 4)

        (§ var BigInteger newTarget = Utils.decodeCompactBits(prev.getDifficultyTarget()))
        (§ ass newTarget = newTarget.multiply(BigInteger.valueOf(timespan)))
        (§ ass newTarget = newTarget.divide(BigInteger.valueOf(targetTimespan)))

        (§ if (0 < newTarget.compareTo(this.getMaxTarget())))
        (ß
            (§ call log.info("Difficulty hit proof of work limit: {}", newTarget.toString(16)))
            (§ ass newTarget = this.getMaxTarget())
        )

        (§ var int accuracyBytes = (int)(nextBlock.getDifficultyTarget() >>> 24) - 3)
        (§ var long receivedTargetCompact = nextBlock.getDifficultyTarget())

        ;; The calculated difficulty is to a higher precision than received, so reduce here.
        (§ var BigInteger mask = BigInteger.valueOf(0xffffff).shiftLeft(accuracyBytes * 8))
        (§ ass newTarget = newTarget.and(mask))
        (§ var long newTargetCompact = Utils.encodeCompactBits(newTarget))

        (§ if (newTargetCompact != receivedTargetCompact))
            (§ throw new VerificationException("Network provided difficulty bits do not match what was calculated: " + Long.toHexString(newTargetCompact) + " vs " + Long.toHexString(receivedTargetCompact)))
    )

    #_override
    #_public
    (§ method Coin getMaxMoney())
    (ß
        (§ return MAX_MONEY)
    )

    #_override
    #_public
    (§ method Coin getMinNonDustOutput())
    (ß
        (§ return Transaction.MIN_NONDUST_OUTPUT)
    )

    #_override
    #_public
    (§ method MonetaryFormat getMonetaryFormat())
    (ß
        (§ return new MonetaryFormat())
    )

    #_override
    #_public
    (§ method int getProtocolVersionNum(#_final ProtocolVersion version))
    (ß
        (§ return version.getBitcoinProtocolVersion())
    )

    #_override
    #_public
    (§ method BitcoinSerializer getSerializer(boolean parseRetain))
    (ß
        (§ return new BitcoinSerializer(this, parseRetain))
    )

    #_override
    #_public
    (§ method String getUriScheme())
    (ß
        (§ return BITCOIN_SCHEME)
    )

    #_override
    #_public
    (§ method boolean hasMaxMoney())
    (ß
        (§ return true)
    )
)

#_(ns org.bitcoinj.params #_"MainNetParams"
    (:import #_[java.net *])
    (:import [com.google.common.base Preconditions])
  #_(:require #_[org.bitcoinj.core *]
             #_[org.bitcoinj.net.discovery *]))

;;;
 ; Parameters for the main production network on which people trade goods and services.
 ;;
#_public
(§ class MainNetParams extends AbstractBitcoinNetParams
    #_public
    #_static
    #_final
    (§ field int MAINNET_MAJORITY_WINDOW = 1000)
    #_public
    #_static
    #_final
    (§ field int MAINNET_MAJORITY_REJECT_BLOCK_OUTDATED = 950)
    #_public
    #_static
    #_final
    (§ field int MAINNET_MAJORITY_ENFORCE_BLOCK_UPGRADE = 750)

    #_public
    (§ constructor MainNetParams())
    (ß
        (§ super ())

        (§ ass interval = INTERVAL)
        (§ ass targetTimespan = TARGET_TIMESPAN)
        (§ ass maxTarget = Utils.decodeCompactBits(0x1d00ffff))
        (§ ass addressHeader = 0)
        (§ ass p2shHeader = 5)
        (§ ass acceptableAddressCodes = new int[] (ß addressHeader, p2shHeader ))
        (§ ass port = 8333)
        (§ ass packetMagic = 0xf9beb4d9)
        (§ ass bip32HeaderPub = 0x0488b21e) ;; 4 byte header that serializes in base58 to "xpub"
        (§ ass bip32HeaderPriv = 0x0488ade4) ;; 4 byte header that serializes in base58 to "xprv"

        (§ ass majorityEnforceBlockUpgrade = MAINNET_MAJORITY_ENFORCE_BLOCK_UPGRADE)
        (§ ass majorityRejectBlockOutdated = MAINNET_MAJORITY_REJECT_BLOCK_OUTDATED)
        (§ ass majorityWindow = MAINNET_MAJORITY_WINDOW)

        (§ call genesisBlock.setDifficultyTarget(0x1d00ffff))
        (§ call genesisBlock.setTime(1231006505))
        (§ call genesisBlock.setNonce(2083236893))
        (§ ass id = ID_MAINNET)
        (§ ass subsidyDecreaseBlockCount = 210000)
        (§ ass spendableCoinbaseDepth = 100)
        (§ var String genesisHash = genesisBlock.getHashAsString())
        (§ call Preconditions.checkState(genesisHash.equals("000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f"), genesisHash))

        ;; This contains (at a minimum) the blocks which are not BIP30 compliant.  BIP30 changed how duplicate
        ;; transactions are handled.  Duplicated transactions could occur in the case where a coinbase had the same
        ;; extraNonce and the same outputs but appeared at different heights, and greatly complicated re-org handling.
        ;; Having these here simplifies block connection logic considerably.
        (§ call checkpoints.put(91722, Sha256Hash.wrap("00000000000271a2dc26e7667f8419f2e15416dc6955e5a6c6cdf3f2574dd08e")))
        (§ call checkpoints.put(91812, Sha256Hash.wrap("00000000000af0aed4792b1acee3d966af36cf5def14935db8de83d6f9306f2f")))
        (§ call checkpoints.put(91842, Sha256Hash.wrap("00000000000a4d0a398161ffc163c503763b1f4360639393e0e4c8e300e0caec")))
        (§ call checkpoints.put(91880, Sha256Hash.wrap("00000000000743f190a18c5577a3c2d2a1f610ae9601ac046a38084ccb7cd721")))
        (§ call checkpoints.put(200000, Sha256Hash.wrap("000000000000034a7dedef4a161fa058a2d67a173a90155f3a2fe6fc132e0ebf")))

        (§ ass dnsSeeds = new String[]
        (ß
            "seed.bitcoin.sipa.be",          ;; Pieter Wuille
            "dnsseed.bluematt.me",           ;; Matt Corallo
            "dnsseed.bitcoin.dashjr.org",    ;; Luke Dashjr
            "seed.bitcoinstats.com",         ;; Chris Decker
            "seed.bitnodes.io",              ;; Addy Yeow
            "bitseed.xf2.org",               ;; Jeff Garzik
            "seed.bitcoin.jonasschnelli.ch", ;; Jonas Schnelli
        ))

        (§ ass addrSeeds = new int[]
        (ß
                0x1ddb1032, 0x6242ce40, 0x52d6a445, 0x2dd7a445, 0x8a53cd47, 0x73263750, 0xda23c257, 0xecd4ed57,
                0x0a40ec59, 0x75dce160, 0x7df76791, 0x89370bad, 0xa4f214ad, 0x767700ae, 0x638b0418, 0x868a1018,
                0xcd9f332e, 0x0129653e, 0xcc92dc3e, 0x96671640, 0x56487e40, 0x5b66f440, 0xb1d01f41, 0xf1dc6041,
                0xc1d12b42, 0x86ba1243, 0x6be4df43, 0x6d4cef43, 0xd18e0644, 0x1ab0b344, 0x6584a345, 0xe7c1a445,
                0x58cea445, 0xc5daa445, 0x21dda445, 0x3d3b5346, 0x13e55347, 0x1080d24a, 0x8e611e4b, 0x81518e4b,
                0x6c839e4b, 0xe2ad0a4c, 0xfbbc0a4c, 0x7f5b6e4c, 0x7244224e, 0x1300554e, 0x20690652, 0x5a48b652,
                0x75c5c752, 0x4335cc54, 0x340fd154, 0x87c07455, 0x087b2b56, 0x8a133a57, 0xac23c257, 0x70374959,
                0xfb63d45b, 0xb9a1685c, 0x180d765c, 0x674f645d, 0x04d3495e, 0x1de44b5e, 0x4ee8a362, 0x0ded1b63,
                0xc1b04b6d, 0x8d921581, 0x97b7ea82, 0x1cf83a8e, 0x91490bad, 0x09dc75ae, 0x9a6d79ae, 0xa26d79ae,
                0x0fd08fae, 0x0f3e3fb2, 0x4f944fb2, 0xcca448b8, 0x3ecd6ab8, 0xa9d5a5bc, 0x8d0119c1, 0x045997d5,
                0xca019dd9, 0x0d526c4d, 0xabf1ba44, 0x66b1ab55, 0x1165f462, 0x3ed7cbad, 0xa38fae6e, 0x3bd2cbad,
                0xd36f0547, 0x20df7840, 0x7a337742, 0x549f8e4b, 0x9062365c, 0xd399f562, 0x2b5274a1, 0x8edfa153,
                0x3bffb347, 0x7074bf58, 0xb74fcbad, 0x5b5a795b, 0x02fa29ce, 0x5a6738d4, 0xe8a1d23e, 0xef98c445,
                0x4b0f494c, 0xa2bc1e56, 0x7694ad63, 0xa4a800c3, 0x05fda6cd, 0x9f22175e, 0x364a795b, 0x536285d5,
                0xac44c9d4, 0x0b06254d, 0x150c2fd4, 0x32a50dcc, 0xfd79ce48, 0xf15cfa53, 0x66c01e60, 0x6bc26661,
                0xc03b47ae, 0x4dda1b81, 0x3285a4c1, 0x883ca96d, 0x35d60a4c, 0xdae09744, 0x2e314d61, 0x84e247cf,
                0x6c814552, 0x3a1cc658, 0x98d8f382, 0xe584cb5b, 0x15e86057, 0x7b01504e, 0xd852dd48, 0x56382f56,
                0x0a5df454, 0xa0d18d18, 0x2e89b148, 0xa79c114c, 0xcbdcd054, 0x5523bc43, 0xa9832640, 0x8a066144,
                0x3894c3bc, 0xab76bf58, 0x6a018ac1, 0xfebf4f43, 0x2f26c658, 0x31102f4e, 0x85e929d5, 0x2a1c175e,
                0xfc6c2cd1, 0x27b04b6d, 0xdf024650, 0x161748b8, 0x28be6580, 0x57be6580, 0x1cee677a, 0xaa6bb742,
                0x9a53964b, 0x0a5a2d4d, 0x2434c658, 0x9a494f57, 0x1ebb0e48, 0xf610b85d, 0x077ecf44, 0x085128bc,
                0x5ba17a18, 0x27ca1b42, 0xf8a00b56, 0xfcd4c257, 0xcf2fc15e, 0xd897e052, 0x4cada04f, 0x2f35f6d5,
                0x382ce8c9, 0xe523984b, 0x3f946846, 0x60c8be43, 0x41da6257, 0xde0be142, 0xae8a544b, 0xeff0c254,
                0x1e0f795b, 0xaeb28890, 0xca16acd9, 0x1e47ddd8, 0x8c8c4829, 0xd27dc747, 0xd53b1663, 0x4096b163,
                0x9c8dd958, 0xcb12f860, 0x9e79305c, 0x40c1a445, 0x4a90c2bc, 0x2c3a464d, 0x2727f23c, 0x30b04b6d,
                0x59024cb8, 0xa091e6ad, 0x31b04b6d, 0xc29d46a6, 0x63934fb2, 0xd9224dbe, 0x9f5910d8, 0x7f530a6b,
                0x752e9c95, 0x65453548, 0xa484be46, 0xce5a1b59, 0x710e0718, 0x46a13d18, 0xdaaf5318, 0xc4a8ff53,
                0x87abaa52, 0xb764cf51, 0xb2025d4a, 0x6d351e41, 0xc035c33e, 0xa432c162, 0x61ef34ae, 0xd16fddbc,
                0x0870e8c1, 0x3070e8c1, 0x9c71e8c1, 0xa4992363, 0x85a1f663, 0x4184e559, 0x18d96ed8, 0x17b8dbd5,
                0x60e7cd18, 0xe5ee104c, 0xab17ac62, 0x1e786e1b, 0x5d23b762, 0xf2388fae, 0x88270360, 0x9e5b3d80,
                0x7da518b2, 0xb5613b45, 0x1ad41f3e, 0xd550854a, 0x8617e9a9, 0x925b229c, 0xf2e92542, 0x47af0544,
                0x73b5a843, 0xb9b7a0ad, 0x03a748d0, 0x0a6ff862, 0x6694df62, 0x3bfac948, 0x8e098f4f, 0x746916c3,
                0x02f38e4f, 0x40bb1243, 0x6a54d162, 0x6008414b, 0xa513794c, 0x514aa343, 0x63781747, 0xdbb6795b,
                0xed065058, 0x42d24b46, 0x1518794c, 0x9b271681, 0x73e4ffad, 0x0654784f, 0x438dc945, 0x641846a6,
                0x2d1b0944, 0x94b59148, 0x8d369558, 0xa5a97662, 0x8b705b42, 0xce9204ae, 0x8d584450, 0x2df61555,
                0xeebff943, 0x2e75fb4d, 0x3ef8fc57, 0x9921135e, 0x8e31042e, 0xb5afad43, 0x89ecedd1, 0x9cfcc047,
                0x8fcd0f4c, 0xbe49f5ad, 0x146a8d45, 0x98669ab8, 0x98d9175e, 0xd1a8e46d, 0x839a3ab8, 0x40a0016c,
                0x6d27c257, 0x977fffad, 0x7baa5d5d, 0x1213be43, 0xb167e5a9, 0x640fe8ca, 0xbc9ea655, 0x0f820a4c,
                0x0f097059, 0x69ac957c, 0x366d8453, 0xb1ba2844, 0x8857f081, 0x70b5be63, 0xc545454b, 0xaf36ded1,
                0xb5a4b052, 0x21f062d1, 0x72ab89b2, 0x74a45318, 0x8312e6bc, 0xb916965f, 0x8aa7c858, 0xfe7effad,
        ))
    )

    #_private
    #_static
    (§ field MainNetParams instance)

    #_public
    #_static
    #_synchronized
    (§ method MainNetParams get())
    (ß
        (§ if (instance == nil))
            (§ ass instance = new MainNetParams())
        (§ return instance)
    )

    #_override
    #_public
    (§ method String getPaymentProtocolId())
    (ß
        (§ return PAYMENT_PROTOCOL_ID_MAINNET)
    )
)

#_(ns org.bitcoinj.params #_"Networks"
    (:import [java.util Collection Set])
    (:import [com.google.common.collect ImmutableSet Lists])
  #_(:require [org.bitcoinj.core NetworkParameters]))

;;;
 ; Utility class that holds all the registered NetworkParameters types used for Address auto discovery.
 ; By default only MainNetParams and TestNet3Params are used.  If you want to use UnitTestParams, use
 ; the register and unregister the TestNet3Params as they don't have their own address version/type code.
 ;;
#_public
(§ class Networks
    ;;; Registered networks. ;;
    #_private
    #_static
    (§ field Set<? extends NetworkParameters> networks = ImmutableSet.of(TestNet3Params.get(), MainNetParams.get()))

    #_public
    #_static
    (§ method Set<? extends NetworkParameters> get())
    (ß
        (§ return networks)
    )

    #_public
    #_static
    (§ method void register(NetworkParameters network))
    (ß
        (§ call register(Lists.newArrayList(network)))
    )

    #_public
    #_static
    (§ method void register(Collection<? extends NetworkParameters> networks))
    (ß
        (§ var ImmutableSet.Builder<NetworkParameters> builder = ImmutableSet.builder())
        (§ call builder.addAll(Networks.networks))
        (§ call builder.addAll(networks))
        (§ ass Networks.networks = builder.build())
    )

    #_public
    #_static
    (§ method void unregister(NetworkParameters network))
    (ß
        (§ if (networks.contains(network)))
        (ß
            (§ var ImmutableSet.Builder<NetworkParameters> builder = ImmutableSet.builder())

            (§ for (NetworkParameters parameters :for networks))
                (§ if (!parameters.equals(network)))
                    (§ call builder.add(parameters))

            (§ ass networks = builder.build())
        )
    )
)

#_(ns org.bitcoinj.params #_"TestNet3Params"
    (:import [java.math BigInteger]
             [java.util Date])
    (:import [com.google.common.base Preconditions])
  #_(:require [org.bitcoinj.core Block NetworkParameters StoredBlock Utils VerificationException]
             [org.bitcoinj.store BlockStore BlockStoreException]))

;;;
 ; Parameters for the testnet, a separate public instance of Bitcoin that has relaxed rules suitable for development
 ; and testing of applications and new Bitcoin versions.
 ;;
#_public
(§ class TestNet3Params extends AbstractBitcoinNetParams
    #_public
    #_static
    #_final
    (§ field int TESTNET_MAJORITY_WINDOW = 100)
    #_public
    #_static
    #_final
    (§ field int TESTNET_MAJORITY_REJECT_BLOCK_OUTDATED = 75)
    #_public
    #_static
    #_final
    (§ field int TESTNET_MAJORITY_ENFORCE_BLOCK_UPGRADE = 51)

    #_public
    (§ constructor TestNet3Params())
    (ß
        (§ super ())

        (§ ass id = ID_TESTNET)
        (§ ass packetMagic = 0x0b110907)
        (§ ass interval = INTERVAL)
        (§ ass targetTimespan = TARGET_TIMESPAN)
        (§ ass maxTarget = Utils.decodeCompactBits(0x1d00ffff))
        (§ ass port = 18333)
        (§ ass addressHeader = 111)
        (§ ass p2shHeader = 196)
        (§ ass acceptableAddressCodes = new int[] (ß addressHeader, p2shHeader ))
        (§ call genesisBlock.setTime(1296688602))
        (§ call genesisBlock.setDifficultyTarget(0x1d00ffff))
        (§ call genesisBlock.setNonce(414098458))
        (§ ass spendableCoinbaseDepth = 100)
        (§ ass subsidyDecreaseBlockCount = 210000)
        (§ var String genesisHash = genesisBlock.getHashAsString())
        (§ call Preconditions.checkState(genesisHash.equals("000000000933ea01ad0ee984209779baaec3ced90fa3f408719526f8d77f4943")))
        (§ ass alertSigningKey = Utils.HEX.decode("04302390343f91cc401d56d68b123028bf52e5fca1939df127f63c6467cdf9c8e2c14b61104cf817d0b780da337893ecc4aaff1309e536162dabbdb45200ca2b0a"))

        (§ ass dnsSeeds = new String[]
        (ß
            "testnet-seed.bitcoin.jonasschnelli.ch", ;; Jonas Schnelli
            "testnet-seed.bluematt.me",              ;; Matt Corallo
            "testnet-seed.bitcoin.petertodd.org",    ;; Peter Todd
            "testnet-seed.bitcoin.schildbach.de",    ;; Andreas Schildbach
        ))
        (§ ass addrSeeds = nil)
        (§ ass bip32HeaderPub = 0x043587cf)
        (§ ass bip32HeaderPriv = 0x04358394)

        (§ ass majorityEnforceBlockUpgrade = TESTNET_MAJORITY_ENFORCE_BLOCK_UPGRADE)
        (§ ass majorityRejectBlockOutdated = TESTNET_MAJORITY_REJECT_BLOCK_OUTDATED)
        (§ ass majorityWindow = TESTNET_MAJORITY_WINDOW)
    )

    #_private
    #_static
    (§ field TestNet3Params instance)

    #_public
    #_static
    #_synchronized
    (§ method TestNet3Params get())
    (ß
        (§ if (instance == nil))
            (§ ass instance = new TestNet3Params())
        (§ return instance)
    )

    #_override
    #_public
    (§ method String getPaymentProtocolId())
    (ß
        (§ return PAYMENT_PROTOCOL_ID_TESTNET)
    )

    ;; February 16th 2012
    #_private
    #_static
    #_final
    (§ field Date testnetDiffDate = new Date(1329264000000))

    #_override
    #_public
    (§ method void checkDifficultyTransitions(#_final StoredBlock storedPrev, #_final Block nextBlock, #_final BlockStore blockStore))
        (§ throws VerificationException, BlockStoreException)
    (ß
        (§ if (!isDifficultyTransitionPoint(storedPrev.getHeight()) && nextBlock.getTime().after(testnetDiffDate)))
        (ß
            (§ var Block prev = storedPrev.getHeader())

            ;; After 15th February 2012 the rules on the testnet change to avoid people running up the difficulty
            ;; and then leaving, making it too hard to mine a block.  On non-difficulty transition points, easy
            ;; blocks are allowed if there has been a span of 20 minutes without one.
            #_final
            (§ var long timeDelta = nextBlock.getTimeSeconds() - prev.getTimeSeconds())
            ;; There is an integer underflow bug in bitcoin-qt that means mindiff blocks are accepted when time
            ;; goes backwards.
            (§ if (0 <= timeDelta && timeDelta <= NetworkParameters.TARGET_SPACING * 2))
            (ß
                ;; Walk backwards until we find a block that doesn't have the easiest proof of work, then check
                ;; that difficulty is equal to that one.
                (§ var StoredBlock cursor = storedPrev)
                (§ while (!cursor.getHeader().equals(getGenesisBlock()) && cursor.getHeight() % getInterval() != 0 && cursor.getHeader().getDifficultyTargetAsInteger().equals(getMaxTarget())))
                    (§ ass cursor = cursor.getPrev(blockStore))
                (§ var BigInteger cursorTarget = cursor.getHeader().getDifficultyTargetAsInteger())
                (§ var BigInteger newTarget = nextBlock.getDifficultyTargetAsInteger())
                (§ if (!cursorTarget.equals(newTarget)))
                    (§ throw new VerificationException("Testnet block transition that is not allowed: " + Long.toHexString(cursor.getHeader().getDifficultyTarget()) + " vs " + Long.toHexString(nextBlock.getDifficultyTarget())))
            )
        )
        (§ else)
        (ß
            (§ call super.checkDifficultyTransitions(storedPrev, nextBlock, blockStore))
        )
    )
)

#_(ns org.bitcoinj.params #_"UnitTestParams"
    (:import [java.math BigInteger])
  #_(:require #_[org.bitcoinj.core *]))

;;;
 ; Network parameters used by the bitcoinj unit tests (and potentially your own).  This lets you solve a block using
 ; {@link org.bitcoinj.core.Block#solve()} by setting difficulty to the easiest possible.
 ;;
#_public
(§ class UnitTestParams extends AbstractBitcoinNetParams
    #_public
    #_static
    #_final
    (§ field int UNITNET_MAJORITY_WINDOW = 8)
    #_public
    #_static
    #_final
    (§ field int TESTNET_MAJORITY_REJECT_BLOCK_OUTDATED = 6)
    #_public
    #_static
    #_final
    (§ field int TESTNET_MAJORITY_ENFORCE_BLOCK_UPGRADE = 4)

    #_public
    (§ constructor UnitTestParams())
    (ß
        (§ super ())

        (§ ass id = ID_UNITTESTNET)
        (§ ass packetMagic = 0x0b110907)
        (§ ass addressHeader = 111)
        (§ ass p2shHeader = 196)
        (§ ass acceptableAddressCodes = new int[] (ß addressHeader, p2shHeader ))
        (§ ass maxTarget = new BigInteger("00ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff", 16))
        (§ call genesisBlock.setTime(System.currentTimeMillis() / 1000))
        (§ call genesisBlock.setDifficultyTarget(Block.EASIEST_DIFFICULTY_TARGET))
        (§ call genesisBlock.solve())
        (§ ass port = 18333)
        (§ ass interval = 10)
        (§ ass targetTimespan = 200000000) ;; 6 years.  Just a very big number.
        (§ ass spendableCoinbaseDepth = 5)
        (§ ass subsidyDecreaseBlockCount = 100)
        (§ ass dnsSeeds = nil)
        (§ ass addrSeeds = nil)
        (§ ass bip32HeaderPub = 0x043587cf)
        (§ ass bip32HeaderPriv = 0x04358394)

        (§ ass majorityEnforceBlockUpgrade = 3)
        (§ ass majorityRejectBlockOutdated = 4)
        (§ ass majorityWindow = 7)
    )

    #_private
    #_static
    (§ field UnitTestParams instance)

    #_public
    #_static
    #_synchronized
    (§ method UnitTestParams get())
    (ß
        (§ if (instance == nil))
            (§ ass instance = new UnitTestParams())
        (§ return instance)
    )

    #_override
    #_public
    (§ method String getPaymentProtocolId())
    (ß
        (§ return "unittest")
    )
)

#_(ns org.bitcoinj.script #_"Script"
    (:import [java.io ByteArrayInputStream ByteArrayOutputStream IOException OutputStream]
             [java.math BigInteger]
             [java.security MessageDigest NoSuchAlgorithmException]
             #_[java.util *])
    (:import [com.google.common.base Preconditions]
             [com.google.common.collect Lists]
             [org.slf4j Logger LoggerFactory]
             [org.spongycastle.crypto.digests RIPEMD160Digest])
  #_(:require #_[org.bitcoinj.core *]
             [org.bitcoinj.crypto TransactionSignature]
             #_static #_[org.bitcoinj.script.ScriptOpCodes *]))

;; TODO: Redesign this entire API to be more type safe and organised.

;;;
 ; <p>Programs embedded inside transactions that control redemption of payments.</p>
 ;
 ; <p>Bitcoin transactions don't specify what they do directly.  Instead
 ; <a href="https://en.bitcoin.it/wiki/Script">a small binary stack language</a> is used to define programs that
 ; when evaluated, return whether the transaction "accepts" or rejects the other transactions connected to it.</p>
 ;
 ; <p>In SPV mode, scripts are not run, because that would require all transactions to be available and lightweight
 ; clients don't have that data.  In full mode, this class is used to run the interpreted language.  It also has
 ; static methods for building scripts.</p>
 ;;
#_public
(§ class Script
    ;;; Enumeration to encapsulate the type of this script. ;;
    #_public
    (§ enum ScriptType
        ;; Do NOT change the ordering of the following definitions because their ordinals are stored in databases.
        (§ item NO_TYPE)
        (§ item P2PKH)
        (§ item PUB_KEY)
        (§ item P2SH)
    )

    ;;; Flags to pass to {@link Script#correctlySpends(Transaction, long, Script, Set)}.
     ; Note currently only P2SH, DERSIG and NULLDUMMY are actually supported.
     ;;
    #_public
    (§ enum VerifyFlag
        (§ item P2SH) ;; Enable BIP16-style subscript evaluation.
        (§ item STRICTENC) ;; Passing a non-strict-DER signature or one with undefined hashtype to a checksig operation causes script failure.
        (§ item DERSIG) ;; Passing a non-strict-DER signature to a checksig operation causes script failure (softfork safe, BIP66 rule 1).
        (§ item LOW_S) ;; Passing a non-strict-DER signature or one with S > order/2 to a checksig operation causes script failure.
        (§ item NULLDUMMY) ;; Verify dummy stack item consumed by CHECKMULTISIG is of zero-length.
        (§ item SIGPUSHONLY) ;; Using a non-push operator in the scriptSig causes script failure (softfork safe, BIP62 rule 2).
        (§ item MINIMALDATA) ;; Require minimal encodings for all push operations.
        (§ item DISCOURAGE_UPGRADABLE_NOPS) ;; Discourage use of NOPs reserved for upgrades (NOP1-10).
        (§ item CLEANSTACK) ;; Require that only a single stack element remains after evaluation.
        (§ item CHECKLOCKTIMEVERIFY) ;; Enable CHECKLOCKTIMEVERIFY operation.
        (§ item CHECKSEQUENCEVERIFY) ;; Enable CHECKSEQUENCEVERIFY operation.
    )
    #_public
    #_static
    #_final
    (§ field EnumSet<VerifyFlag> ALL_VERIFY_FLAGS = EnumSet.allOf(VerifyFlag.class))

    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(Script.class))

    #_public
    #_static
    #_final
    (§ field long MAX_SCRIPT_ELEMENT_SIZE = 520) ;; bytes
    #_private
    #_static
    #_final
    (§ field int MAX_OPS_PER_SCRIPT = 201)
    #_private
    #_static
    #_final
    (§ field int MAX_STACK_SIZE = 1000)
    #_private
    #_static
    #_final
    (§ field int MAX_PUBKEYS_PER_MULTISIG = 20)
    #_private
    #_static
    #_final
    (§ field int MAX_SCRIPT_SIZE = 10000)
    #_public
    #_static
    #_final
    (§ field int SIG_SIZE = 75)
    ;;; Max number of sigops allowed in a standard p2sh redeem script. ;;
    #_public
    #_static
    #_final
    (§ field int MAX_P2SH_SIGOPS = 15)

    ;; The program is a set of chunks where each element is either [opcode] or [data, data, data ...].
    #_protected
    (§ field List<ScriptChunk> chunks)
    ;; Unfortunately, scripts are not ever re-serialized or canonicalized when used in signature hashing.
    ;; Thus we must preserve the exact bytes that we read off the wire, along with the parsed form.
    #_protected
    (§ field byte[] program)

    ;; Creation time of the associated keys in seconds since the epoch.
    #_private
    (§ field long creationTimeSeconds)

    ;;; Creates an empty script that serializes to nothing. ;;
    #_private
    (§ constructor Script())
    (ß
        (§ ass chunks = Lists.newArrayList())
    )

    ;; Used from ScriptBuilder.
    (§ constructor Script(List<ScriptChunk> chunks))
    (ß
        (§ ass this.chunks = Collections.unmodifiableList(new ArrayList<>(chunks)))
        (§ ass creationTimeSeconds = Utils.currentTimeSeconds())
    )

    ;;;
     ; Construct a Script that copies and wraps the programBytes array.
     ; The array is parsed and checked for syntactic validity.
     ; @param programBytes Array of program bytes from a transaction.
     ;;
    #_public
    (§ constructor Script(byte[] programBytes))
        (§ throws ScriptException)
    (ß
        (§ ass program = programBytes)
        (§ call parse(programBytes))
        (§ ass creationTimeSeconds = 0)
    )

    #_public
    (§ constructor Script(byte[] programBytes, long creationTimeSeconds))
        (§ throws ScriptException)
    (ß
        (§ ass program = programBytes)
        (§ call parse(programBytes))
        (§ ass this.creationTimeSeconds = creationTimeSeconds)
    )

    #_public
    (§ method long getCreationTimeSeconds())
    (ß
        (§ return creationTimeSeconds)
    )

    #_public
    (§ method void setCreationTimeSeconds(long creationTimeSeconds))
    (ß
        (§ ass this.creationTimeSeconds = creationTimeSeconds)
    )

    ;;;
     ; Returns the program opcodes as a string, for example "[1234] DUP HASH160".
     ;;
    #_override
    #_public
    (§ method String toString())
    (ß
        (§ return Utils.SPACE_JOINER.join(chunks))
    )

    ;;; Returns the serialized program as a newly created byte array. ;;
    #_public
    (§ method byte[] getProgram())
    (ß
        (§ try)
        (ß
            ;; Don't round-trip as Bitcoin Core doesn't and it would introduce a mismatch.
            (§ if (program != nil))
                (§ return Arrays.copyOf(program, program.length))

            (§ var ByteArrayOutputStream bos = new ByteArrayOutputStream())
            (§ for (ScriptChunk chunk :for chunks))
                (§ call chunk.write(bos))
            (§ ass program = bos.toByteArray())
            (§ return program)
        )
        (§ catch (IOException e))
        (ß
            (§ throw new RuntimeException(e)) ;; Cannot happen.
        )
    )

    ;;; Returns an immutable list of the scripts parsed form.  Each chunk is either an opcode or data element. ;;
    #_public
    (§ method List<ScriptChunk> getChunks())
    (ß
        (§ return Collections.unmodifiableList(chunks))
    )

    #_private
    #_static
    #_final
    (§ var ScriptChunk[] STANDARD_TRANSACTION_SCRIPT_CHUNKS =
    (ß
        (ß new ScriptChunk(ScriptOpCodes.OP_DUP, nil, 0))
        (ß new ScriptChunk(ScriptOpCodes.OP_HASH160, nil, 1))
        (ß new ScriptChunk(ScriptOpCodes.OP_EQUALVERIFY, nil, 23))
        (ß new ScriptChunk(ScriptOpCodes.OP_CHECKSIG, nil, 24))
    ))

    ;;;
     ; <p>To run a script, first we parse it which breaks it up into chunks representing pushes of data
     ; or logical opcodes.  Then we can run the parsed chunks.</p>
     ;
     ; <p>The reason for this split, instead of just interpreting directly, is to make it easier
     ; to reach into a programs structure and pull out bits of data without having to run it.
     ; This is necessary to render the to/from addresses of transactions in a user interface.
     ; Bitcoin Core does something similar.</p>
     ;;
    #_private
    (§ method void parse(byte[] program))
        (§ throws ScriptException)
    (ß
        (§ ass chunks = new ArrayList<>(5)) ;; Common size.
        (§ var ByteArrayInputStream bis = new ByteArrayInputStream(program))
        (§ var int initialSize = bis.available())
        (§ while (0 < bis.available()))
        (ß
            (§ var int startLocationInProgram = initialSize - bis.available())
            (§ var int opcode = bis.read())

            (§ var long dataToRead = -1)
            (§ if (0 <= opcode && opcode < OP_PUSHDATA1))
            (ß
                ;; Read some bytes of data, where how many is the opcode value itself.
                (§ ass dataToRead = opcode)
            )
            (§ elseif (opcode == OP_PUSHDATA1))
            (ß
                (§ if (bis.available() < 1))
                    (§ throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "Unexpected end of script"))
                (§ ass dataToRead = bis.read())
            )
            (§ elseif (opcode == OP_PUSHDATA2))
            (ß
                ;; Read a short, then read that many bytes of data.
                (§ if (bis.available() < 2))
                    (§ throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "Unexpected end of script"))
                (§ ass dataToRead = bis.read() | (bis.read() << 8))
            )
            (§ elseif (opcode == OP_PUSHDATA4))
            (ß
                ;; Read a uint32, then read that many bytes of data.
                ;; Though this is allowed, because its value cannot be > 520, it should never actually be used.
                (§ if (bis.available() < 4))
                    (§ throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "Unexpected end of script"))
                (§ ass dataToRead = ((long)bis.read()) | (((long)bis.read()) << 8) | (((long)bis.read()) << 16) | (((long)bis.read()) << 24))
            )

            (§ var ScriptChunk chunk)
            (§ if (dataToRead == -1))
            (ß
                (§ ass chunk = new ScriptChunk(opcode, nil, startLocationInProgram))
            )
            (§ else)
            (ß
                (§ if (bis.available() < dataToRead))
                    (§ throw new ScriptException(ScriptError.SCRIPT_ERR_BAD_OPCODE, "Push of data element that is larger than remaining data"))

                (§ var byte[] data = new byte[(int)dataToRead])
                (§ call Preconditions.checkState(dataToRead == 0 || bis.read(data, 0, (int)dataToRead) == dataToRead))
                (§ ass chunk = new ScriptChunk(opcode, data, startLocationInProgram))
            )
            ;; Save some memory by eliminating redundant copies of the same chunk objects.
            (§ for (ScriptChunk c :for STANDARD_TRANSACTION_SCRIPT_CHUNKS))
                (§ if (c.equals(chunk)))
                    (§ ass chunk = c)
            (§ call chunks.add(chunk))
        )
    )

    ;;;
     ; Returns true if this script is of the form <pubkey> OP_CHECKSIG.  This form was originally intended for
     ; transactions where the peers talked to each other directly via TCP/IP, but has fallen out of favor with time
     ; due to that mode of operation being susceptible to man-in-the-middle attacks.  It is still used in coinbase
     ; outputs and can be useful more exotic types of transaction, but today most payments are to addresses.
     ;;
    #_public
    (§ method boolean isSentToRawPubKey())
    (ß
        (§ return (chunks.size() == 2 && chunks.get(1).equalsOpCode(OP_CHECKSIG) && !chunks.get(0).isOpCode() && 1 < chunks.get(0).data.length))
    )

    ;;;
     ; Returns true if this script is of the form DUP HASH160 <pubkey hash> EQUALVERIFY CHECKSIG, i.e. payment to an
     ; address like 1VayNert3x1KzbpzMGt2qdqrAThiRovi8.  This form was originally intended for the case where you wish
     ; to send somebody money with a written code because their node is offline, but over time has become the standard
     ; way to make payments due to the short and recognizable base58 form addresses come in.
     ;;
    #_public
    (§ method boolean isSentToAddress())
    (ß
        (§ return (chunks.size() == 5 && chunks.get(0).equalsOpCode(OP_DUP) && chunks.get(1).equalsOpCode(OP_HASH160) && chunks.get(2).data.length == Address.LENGTH && chunks.get(3).equalsOpCode(OP_EQUALVERIFY) && chunks.get(4).equalsOpCode(OP_CHECKSIG)))
    )

    ;;;
     ; <p>If a program matches the standard template DUP HASH160 &lt;pubkey hash&gt; EQUALVERIFY CHECKSIG,
     ; then this function retrieves the third element.
     ; In this case, this is useful for fetching the destination address of a transaction.</p>
     ;
     ; <p>If a program matches the standard template HASH160 &lt;script hash&gt; EQUAL,
     ; then this function retrieves the second element.
     ; In this case, this is useful for fetching the hash of the redeem script of a transaction.</p>
     ;
     ; <p>Otherwise it throws a ScriptException.</p>
     ;
     ;;
    #_public
    (§ method byte[] getPubKeyHash())
        (§ throws ScriptException)
    (ß
        (§ if (isSentToAddress()))
            (§ return chunks.get(2).data)
        (§ if (isPayToScriptHash()))
            (§ return chunks.get(1).data)

        (§ throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "Script not in the standard scriptPubKey form"))
    )

    ;;;
     ; Returns the public key in this script.  If a script contains two constants and nothing else, it is assumed
     ; to be a scriptSig (input) for a pay-to-address output and the second constant is returned (the first is the
     ; signature).  If a script contains a constant and an OP_CHECKSIG opcode, the constant is returned as it is
     ; assumed to be a direct pay-to-key scriptPubKey (output) and the first constant is the public key.
     ;
     ; @throws ScriptException if the script is none of the named forms.
     ;;
    #_public
    (§ method byte[] getPubKey())
        (§ throws ScriptException)
    (ß
        (§ if (chunks.size() != 2))
            (§ throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "Script not of right size, expecting 2 but got " + chunks.size()))

        #_final
        (§ var ScriptChunk chunk0 = chunks.get(0))
        #_final
        (§ var byte[] chunk0data = chunk0.data)
        #_final
        (§ var ScriptChunk chunk1 = chunks.get(1))
        #_final
        (§ var byte[] chunk1data = chunk1.data)

        ;; If we have two large constants assume the input to a pay-to-address output.
        (§ if (chunk0data != nil && 2 < chunk0data.length && chunk1data != nil && 2 < chunk1data.length))
            (§ return chunk1data)

        ;; A large constant followed by an OP_CHECKSIG is the key.
        (§ if (chunk1.equalsOpCode(OP_CHECKSIG) && chunk0data != nil && 2 < chunk0data.length))
            (§ return chunk0data)

        (§ throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "Script did not match expected form: " + this))
    )

    ;;;
     ; Retrieves the sender public key from a LOCKTIMEVERIFY transaction.
     ;
     ; @throws ScriptException
     ;;
    #_public
    (§ method byte[] getCLTVPaymentChannelSenderPubKey())
        (§ throws ScriptException)
    (ß
        (§ if (isSentToCLTVPaymentChannel()))
            (§ return chunks.get(8).data)

        (§ throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "Script not a standard CHECKLOCKTIMVERIFY transaction: " + this))
    )

    ;;;
     ; Retrieves the recipient public key from a LOCKTIMEVERIFY transaction.
     ;
     ; @throws ScriptException
     ;;
    #_public
    (§ method byte[] getCLTVPaymentChannelRecipientPubKey())
        (§ throws ScriptException)
    (ß
        (§ if (isSentToCLTVPaymentChannel()))
            (§ return chunks.get(1).data)

        (§ throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "Script not a standard CHECKLOCKTIMVERIFY transaction: " + this))
    )

    #_public
    (§ method BigInteger getCLTVPaymentChannelExpiry())
    (ß
        (§ if (isSentToCLTVPaymentChannel()))
            (§ return castToBigInteger(chunks.get(4).data, 5, false))

        (§ throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "Script not a standard CHECKLOCKTIMEVERIFY transaction: " + this))
    )

    ;;;
     ; For 2-element [input] scripts assumes that the paid-to-address can be derived from the public key.
     ; The concept of a "from address" isn't well defined in Bitcoin and you should not assume the sender
     ; of a transaction can actually receive coins on it. This method may be removed in future.
     ;;
    #_deprecated
    #_public
    (§ method Address getFromAddress(NetworkParameters params))
        (§ throws ScriptException)
    (ß
        (§ return new Address(params, Utils.sha256hash160(getPubKey())))
    )

    ;;;
     ; Gets the destination address from this script, if it's in the required form (see getPubKey).
     ;;
    #_public
    (§ method Address getToAddress(NetworkParameters params))
        (§ throws ScriptException)
    (ß
        (§ return getToAddress(params, false))
    )

    ;;;
     ; Gets the destination address from this script, if it's in the required form (see getPubKey).
     ;
     ; @param forcePayToPubKey If true, allow payToPubKey to be casted to the corresponding address.
     ;                         This is useful if you prefer showing addresses rather than pubkeys.
     ;;
    #_public
    (§ method Address getToAddress(NetworkParameters params, boolean forcePayToPubKey))
        (§ throws ScriptException)
    (ß
        (§ if (isSentToAddress()))
            (§ return new Address(params, getPubKeyHash()))
        (§ if (isPayToScriptHash()))
            (§ return Address.fromP2SHScript(params, this))
        (§ if (forcePayToPubKey && isSentToRawPubKey()))
            (§ return ECKey.fromPublicOnly(getPubKey()).toAddress(params))

        (§ throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "Cannot cast this script to a pay-to-address type"))
    )

    ;;;
     ; Writes out the given byte buffer to the output stream with the correct opcode prefix.
     ; To write an integer call writeBytes(out, Utils.reverseBytes(Utils.encodeMPI(val, false))).
     ;;
    #_public
    #_static
    (§ method void writeBytes(OutputStream os, byte[] buf))
        (§ throws IOException)
    (ß
        (§ if (buf.length < OP_PUSHDATA1))
        (ß
            (§ call os.write(buf.length))
            (§ call os.write(buf))
        )
        (§ elseif (buf.length < 256))
        (ß
            (§ call os.write(OP_PUSHDATA1))
            (§ call os.write(buf.length))
            (§ call os.write(buf))
        )
        (§ elseif (buf.length < 65536))
        (ß
            (§ call os.write(OP_PUSHDATA2))
            (§ call os.write(0xff & buf.length))
            (§ call os.write(0xff & (buf.length >> 8)))
            (§ call os.write(buf))
        )
        (§ else)
        (ß
            (§ throw new RuntimeException("Unimplemented"))
        )
    )

    ;;; Creates a program that requires at least N of the given keys to sign, using OP_CHECKMULTISIG. ;;
    #_public
    #_static
    (§ method byte[] createMultiSigOutputScript(int threshold, List<ECKey> pubkeys))
    (ß
        (§ call Preconditions.checkArgument(0 < threshold))
        (§ call Preconditions.checkArgument(threshold <= pubkeys.size()))
        (§ call Preconditions.checkArgument(pubkeys.size() <= 16)) ;; That's the max we can represent with a single opcode.

        (§ if (3 < pubkeys.size()))
            (§ call log.warn("Creating a multi-signature output that is non-standard: {} pubkeys, should be <= 3", pubkeys.size()))

        (§ try)
        (ß
            (§ var ByteArrayOutputStream bits = new ByteArrayOutputStream())
            (§ call bits.write(encodeToOpN(threshold)))
            (§ for (ECKey key :for pubkeys))
                (§ call writeBytes(bits, key.getPubKey()))
            (§ call bits.write(encodeToOpN(pubkeys.size())))
            (§ call bits.write(OP_CHECKMULTISIG))
            (§ return bits.toByteArray())
        )
        (§ catch (IOException e))
        (ß
            (§ throw new RuntimeException(e)) ;; Cannot happen.
        )
    )

    #_public
    #_static
    (§ method byte[] createInputScript(byte[] signature, byte[] pubkey))
    (ß
        (§ try)
        (ß
            ;; TODO: Do this by creating a Script *first* then having the script reassemble itself into bytes.
            (§ var ByteArrayOutputStream bits = new UnsafeByteArrayOutputStream(signature.length + pubkey.length + 2))
            (§ call writeBytes(bits, signature))
            (§ call writeBytes(bits, pubkey))
            (§ return bits.toByteArray())
        )
        (§ catch (IOException e))
        (ß
            (§ throw new RuntimeException(e))
        )
    )

    #_public
    #_static
    (§ method byte[] createInputScript(byte[] signature))
    (ß
        (§ try)
        (ß
            ;; TODO: Do this by creating a Script *first* then having the script reassemble itself into bytes.
            (§ var ByteArrayOutputStream bits = new UnsafeByteArrayOutputStream(signature.length + 2))
            (§ call writeBytes(bits, signature))
            (§ return bits.toByteArray())
        )
        (§ catch (IOException e))
        (ß
            (§ throw new RuntimeException(e))
        )
    )

    ;;;
     ; Creates an incomplete scriptSig that, once filled with signatures, can redeem output containing this scriptPubKey.
     ; Instead of the signatures resulting script has OP_0.
     ; Having incomplete input script allows to pass around partially signed tx.
     ; It is expected that this program later on will be updated with proper signatures.
     ;;
    #_public
    (§ method Script createEmptyInputScript(#_nilable ECKey key, #_nilable Script redeemScript))
    (ß
        (§ if (isSentToAddress()))
        (ß
            (§ call Preconditions.checkArgument(key != nil, "Key required to create pay-to-address input script"))
            (§ return ScriptBuilder.createInputScript(nil, key))
        )

        (§ if (isSentToRawPubKey()))
            (§ return ScriptBuilder.createInputScript(nil))

        (§ if (isPayToScriptHash()))
        (ß
            (§ call Preconditions.checkArgument(redeemScript != nil, "Redeem script required to create P2SH input script"))
            (§ return ScriptBuilder.createP2SHMultiSigInputScript(nil, redeemScript))
        )

        (§ throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "Do not understand script type: " + this))
    )

    ;;;
     ; Returns a copy of the given scriptSig with the signature inserted in the given position.
     ;;
    #_public
    (§ method Script getScriptSigWithSignature(Script scriptSig, byte[] sigBytes, int index))
    (ß
        (§ var int sigsPrefixCount = 0)
        (§ var int sigsSuffixCount = 0)
        (§ if (isPayToScriptHash()))
        (ß
            (§ ass sigsPrefixCount = 1) ;; OP_0 <sig>* <redeemScript>
            (§ ass sigsSuffixCount = 1)
        )
        (§ elseif (isSentToMultiSig()))
        (ß
            (§ ass sigsPrefixCount = 1) ;; OP_0 <sig>*
        )
        (§ elseif (isSentToAddress()))
        (ß
            (§ ass sigsSuffixCount = 1) ;; <sig> <pubkey>
        )
        (§ return ScriptBuilder.updateScriptWithSignature(scriptSig, sigBytes, index, sigsPrefixCount, sigsSuffixCount))
    )

    ;;;
     ; Returns the index where a signature by the key should be inserted.
     ; Only applicable to a P2SH scriptSig.
     ;;
    #_public
    (§ method int getSigInsertionIndex(Sha256Hash hash, ECKey signingKey))
    (ß
        ;; Iterate over existing signatures, skipping the initial OP_0, the final redeem script
        ;; and any placeholder OP_0 sigs.
        (§ var List<ScriptChunk> existingChunks = chunks.subList(1, chunks.size() - 1))
        (§ var ScriptChunk redeemScriptChunk = chunks.get(chunks.size() - 1))
        (§ call Preconditions.checkNotNull(redeemScriptChunk.data))
        (§ var Script redeemScript = new Script(redeemScriptChunk.data))

        (§ var int sigCount = 0)
        (§ var int myIndex = redeemScript.findKeyInRedeem(signingKey))
        (§ for (ScriptChunk chunk :for existingChunks))
        (ß
            (§ if (chunk.opcode == OP_0))
            (ß
                ;; OP_0, skip
            )
            (§ else)
            (ß
                (§ call Preconditions.checkNotNull(chunk.data))
                (§ if (myIndex < redeemScript.findSigInRedeem(chunk.data, hash)))
                    (§ return sigCount)
                (§ ass sigCount = sigCount + 1)
            )
        )
        (§ return sigCount)
    )

    #_private
    (§ method int findKeyInRedeem(ECKey key))
    (ß
        (§ call Preconditions.checkArgument(chunks.get(0).isOpCode())) ;; P2SH scriptSig

        (§ var int numKeys = Script.decodeFromOpN(chunks.get(chunks.size() - 2).opcode))
        (§ for (int i = 0 :for i < numKeys :for i = i + 1))
            (§ if (Arrays.equals(chunks.get(1 + i).data, key.getPubKey())))
                (§ return i)

        (§ throw new IllegalStateException("Could not find matching key " + key + " in script " + this))
    )

    ;;;
     ; Returns a list of the keys required by this script, assuming a multi-sig script.
     ;
     ; @throws ScriptException if the script type is not understood or is pay to address or is P2SH (run this method on the "Redeem script" instead).
     ;;
    #_public
    (§ method List<ECKey> getPubKeys())
    (ß
        (§ if (!isSentToMultiSig()))
            (§ throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "Only usable for multisig scripts."))

        (§ var ArrayList<ECKey> result = Lists.newArrayList())
        (§ var int numKeys = Script.decodeFromOpN(chunks.get(chunks.size() - 2).opcode))
        (§ for (int i = 0 :for i < numKeys :for i = i + 1))
            (§ call result.add(ECKey.fromPublicOnly(chunks.get(1 + i).data)))
        (§ return result)
    )

    #_private
    (§ method int findSigInRedeem(byte[] signatureBytes, Sha256Hash hash))
    (ß
        (§ call Preconditions.checkArgument(chunks.get(0).isOpCode())) ;; P2SH scriptSig

        (§ var int numKeys = Script.decodeFromOpN(chunks.get(chunks.size() - 2).opcode))
        (§ var TransactionSignature signature = TransactionSignature.decodeFromBitcoin(signatureBytes, true))
        (§ for (int i = 0 :for i < numKeys :for i = i + 1))
            (§ if (ECKey.fromPublicOnly(chunks.get(i + 1).data).verify(hash, signature)))
                (§ return i)

        (§ throw new IllegalStateException("Could not find matching key for signature on " + hash + " sig " + Utils.HEX.encode(signatureBytes)))
    )

    #_private
    #_static
    (§ method int getSigOpCount(List<ScriptChunk> chunks, boolean accurate))
        (§ throws ScriptException)
    (ß
        (§ var int sigOps = 0)
        (§ var int lastOpCode = OP_INVALIDOPCODE)
        (§ for (ScriptChunk chunk :for chunks))
        (ß
            (§ if (chunk.isOpCode()))
            (ß
                (§ switch (chunk.opcode))
                (ß
                (§ case OP_CHECKSIG)
                (§ case OP_CHECKSIGVERIFY)
                    (§ ass sigOps = sigOps + 1)
                    (§ break)
                (§ case OP_CHECKMULTISIG)
                (§ case OP_CHECKMULTISIGVERIFY)
                    (§ if (accurate && OP_1 <= lastOpCode && lastOpCode <= OP_16))
                        (§ ass sigOps = sigOps + decodeFromOpN(lastOpCode))
                    (§ else)
                        (§ ass sigOps = sigOps + 20)
                    (§ break)
                (§ default)
                    (§ break)
                )
                (§ ass lastOpCode = chunk.opcode)
            )
        )
        (§ return sigOps)
    )

    #_static
    (§ method int decodeFromOpN(int opcode))
    (ß
        (§ call Preconditions.checkArgument((opcode == OP_0 || opcode == OP_1NEGATE) || (OP_1 <= opcode && opcode <= OP_16), "decodeFromOpN called on non OP_N opcode"))

        (§ if (opcode == OP_0))
            (§ return 0)
        (§ if (opcode == OP_1NEGATE))
            (§ return -1)

        (§ return opcode + 1 - OP_1)
    )

    #_static
    (§ method int encodeToOpN(int value))
    (ß
        (§ call Preconditions.checkArgument(-1 <= value && value <= 16, "encodeToOpN called for " + value + " which we cannot encode in an opcode."))

        (§ if (value == 0))
            (§ return OP_0)
        (§ if (value == -1))
            (§ return OP_1NEGATE)

        (§ return value - 1 + OP_1)
    )

    ;;;
     ; Gets the count of regular SigOps in the script program (counting multisig ops as 20).
     ;;
    #_public
    #_static
    (§ method int getSigOpCount(byte[] program))
        (§ throws ScriptException)
    (ß
        (§ var Script script = new Script())
        (§ try)
        (ß
            (§ call script.parse(program))
        )
        (§ catch (ScriptException _))
        (ß
            ;; Ignore errors and count up to the parse-able length.
        )
        (§ return getSigOpCount(script.chunks, false))
    )

    ;;;
     ; Gets the count of P2SH Sig Ops in the Script scriptSig.
     ;;
    #_public
    #_static
    (§ method long getP2SHSigOpCount(byte[] scriptSig))
        (§ throws ScriptException)
    (ß
        (§ var Script script = new Script())
        (§ try)
        (ß
            (§ call script.parse(scriptSig))
        )
        (§ catch (ScriptException _))
        (ß
            ;; Ignore errors and count up to the parse-able length.
        )
        (§ for (int i = script.chunks.size() - 1 :for 0 <= i :for i = i - 1))
            (§ if (!script.chunks.get(i).isOpCode()))
            (ß
                (§ var Script subScript = new Script())
                (§ call subScript.parse(script.chunks.get(i).data))
                (§ return getSigOpCount(subScript.chunks, true))
            )
        (§ return 0)
    )

    ;;;
     ; Returns number of signatures required to satisfy this script.
     ;;
    #_public
    (§ method int getNumberOfSignaturesRequiredToSpend())
    (ß
        ;; For N of M CHECKMULTISIG script we will need N signatures to spend.
        (§ if (isSentToMultiSig()))
            (§ return Script.decodeFromOpN(chunks.get(0).opcode))

        ;; pay-to-address and pay-to-pubkey require single sig
        (§ if (isSentToAddress() || isSentToRawPubKey()))
            (§ return 1)

        (§ if (isPayToScriptHash()))
            (§ throw new IllegalStateException("For P2SH number of signatures depends on redeem script"))

        (§ throw new IllegalStateException("Unsupported script type"))
    )

    ;;;
     ; Returns number of bytes required to spend this script.  It accepts optional ECKey and redeemScript
     ; that may be required for certain types of script to estimate target size.
     ;;
    #_public
    (§ method int getNumberOfBytesRequiredToSpend(#_nilable ECKey pubKey, #_nilable Script redeemScript))
    (ß
        (§ if (isPayToScriptHash()))
        (ß
            ;; scriptSig: <sig> [sig] [sig...] <redeemscript>
            (§ call Preconditions.checkArgument(redeemScript != nil, "P2SH script requires redeemScript to be spent"))
            (§ return redeemScript.getNumberOfSignaturesRequiredToSpend() * SIG_SIZE + redeemScript.getProgram().length)
        )
        (§ elseif (isSentToMultiSig()))
        (ß
            ;; scriptSig: OP_0 <sig> [sig] [sig...]
            (§ return getNumberOfSignaturesRequiredToSpend() * SIG_SIZE + 1)
        )
        (§ elseif (isSentToRawPubKey()))
        (ß
            ;; scriptSig: <sig>
            (§ return SIG_SIZE)
        )
        (§ elseif (isSentToAddress()))
        (ß
            ;; scriptSig: <sig> <pubkey>
            (§ var int uncompressedPubKeySize = 65)
            (§ return SIG_SIZE + (pubKey != nil ? pubKey.getPubKey().length :else uncompressedPubKeySize))
        )
        (§ else)
        (ß
            (§ throw new IllegalStateException("Unsupported script type"))
        )
    )

    ;;;
     ; <p>Whether or not this is a scriptPubKey representing a pay-to-script-hash output.  In such outputs, the logic
     ; that controls reclamation is not actually in the output at all.  Instead there's just a hash, and it's up to the
     ; spending input to provide a program matching that hash.  This rule is "soft enforced" by the network as it does
     ; not exist in Bitcoin Core.  It means blocks containing P2SH transactions that don't match
     ; correctly are considered valid, but won't be mined upon, so they'll be rapidly re-orgd out of the chain.  This
     ; logic is defined by <a href="https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki">BIP 16</a>.</p>
     ;
     ; <p>bitcoinj does not support creation of P2SH transactions today.  The goal of P2SH is to allow short addresses
     ; even for complex scripts (e.g. multi-sig outputs) so they are convenient to work with in things like QRcodes or
     ; with copy/paste, and also to minimize the size of the unspent output set (which improves performance of the
     ; Bitcoin system).</p>
     ;;
    #_public
    (§ method boolean isPayToScriptHash())
    (ß
        ;; We have to check against the serialized form because BIP16 defines a P2SH output using an exact byte
        ;; template, not the logical program structure.  Thus you can have two programs that look identical when
        ;; printed out but one is a P2SH script and the other isn't! :( ;; )
        (§ var byte[] program = getProgram())
        (§ return program.length == 23 && (program[0] & 0xff) == OP_HASH160 && (program[1] & 0xff) == 0x14 && (program[22] & 0xff) == OP_EQUAL)
    )

    ;;;
     ; Returns whether this script matches the format used for multisig outputs: [n] [keys...] [m] CHECKMULTISIG.
     ;;
    #_public
    (§ method boolean isSentToMultiSig())
    (ß
        (§ if (chunks.size() < 4))
            (§ return false)

        (§ var ScriptChunk chunk = chunks.get(chunks.size() - 1))
        ;; Must end in OP_CHECKMULTISIG[VERIFY].
        (§ if (!chunk.isOpCode()))
            (§ return false)
        (§ if (!(chunk.equalsOpCode(OP_CHECKMULTISIG) || chunk.equalsOpCode(OP_CHECKMULTISIGVERIFY))))
            (§ return false)

        (§ try)
        (ß
            ;; Second to last chunk must be an OP_N opcode and there should be that many data chunks (keys).
            (§ var ScriptChunk m = chunks.get(chunks.size() - 2))
            (§ if (!m.isOpCode()))
                (§ return false)

            (§ var int numKeys = decodeFromOpN(m.opcode))
            (§ if (numKeys < 1 || chunks.size() != 3 + numKeys))
                (§ return false)

            (§ for (int i = 1 :for i < chunks.size() - 2 :for i = i + 1))
                (§ if (chunks.get(i).isOpCode()))
                    (§ return false)

            ;; First chunk must be an OP_N opcode too.
            (§ if (decodeFromOpN(chunks.get(0).opcode) < 1))
                (§ return false)
        )
        (§ catch (IllegalStateException e))
        (ß
            (§ return false) ;; Not an OP_N opcode.
        )
        (§ return true)
    )

    #_public
    (§ method boolean isSentToCLTVPaymentChannel())
    (ß
        ;; Check that opcodes match the pre-determined format.
        ;; chunk[1] = recipient pubkey
        ;; chunk[4] = locktime
        ;; chunk[8] = sender pubkey
        (§ return (chunks.size() == 10) && chunks.get(0).equalsOpCode(OP_IF) && chunks.get(2).equalsOpCode(OP_CHECKSIGVERIFY) && chunks.get(3).equalsOpCode(OP_ELSE) && chunks.get(5).equalsOpCode(OP_CHECKLOCKTIMEVERIFY) && chunks.get(6).equalsOpCode(OP_DROP) && chunks.get(7).equalsOpCode(OP_ENDIF) && chunks.get(9).equalsOpCode(OP_CHECKSIG))
    )

    #_private
    #_static
    (§ method boolean equalsRange(byte[] a, int start, byte[] b))
    (ß
        (§ if (a.length < start + b.length))
            (§ return false)

        (§ for (int i = 0 :for i < b.length :for i = i + 1))
            (§ if (a[i + start] != b[i]))
                (§ return false)

        (§ return true)
    )

    ;;;
     ; Returns the script bytes of inputScript with all instances of the specified script object removed.
     ;;
    #_public
    #_static
    (§ method byte[] removeAllInstancesOf(byte[] inputScript, byte[] chunkToRemove))
    (ß
        ;; We usually don't end up removing anything.
        (§ var UnsafeByteArrayOutputStream bos = new UnsafeByteArrayOutputStream(inputScript.length))

        (§ var int cursor = 0)
        (§ while (cursor < inputScript.length))
        (ß
            (§ var boolean skip = equalsRange(inputScript, cursor, chunkToRemove))

            (§ var int opcode = inputScript[cursor] & 0xff)
            (§ ass cursor = cursor + 1)
            (§ var int additionalBytes = 0)
            (§ if (0 <= opcode && opcode < OP_PUSHDATA1))
            (ß
                (§ ass additionalBytes = opcode)
            )
            (§ elseif (opcode == OP_PUSHDATA1))
            (ß
                (§ ass additionalBytes = (0xff & inputScript[cursor]) + 1)
            )
            (§ elseif (opcode == OP_PUSHDATA2))
            (ß
                (§ ass additionalBytes = ((0xff & inputScript[cursor]) | ((0xff & inputScript[cursor + 1]) << 8)) + 2)
            )
            (§ elseif (opcode == OP_PUSHDATA4))
            (ß
                (§ ass additionalBytes = ((0xff & inputScript[cursor]) | ((0xff & inputScript[cursor + 1]) << 8) | ((0xff & inputScript[cursor + 1]) << 16) | ((0xff & inputScript[cursor + 1]) << 24)) + 4)
            )
            (§ if (!skip))
            (ß
                (§ try)
                (ß
                    (§ call bos.write(opcode))
                    (§ call bos.write(Arrays.copyOfRange(inputScript, cursor, cursor + additionalBytes)))
                )
                (§ catch (IOException e))
                (ß
                    (§ throw new RuntimeException(e))
                )
            )
            (§ ass cursor = cursor + additionalBytes)
        )
        (§ return bos.toByteArray())
    )

    ;;;
     ; Returns the script bytes of inputScript with all instances of the given op code removed.
     ;;
    #_public
    #_static
    (§ method byte[] removeAllInstancesOfOp(byte[] inputScript, int opCode))
    (ß
        (§ return removeAllInstancesOf(inputScript, new byte[] {(byte)opCode}))
    )

    #_private
    #_static
    (§ method boolean castToBool(byte[] data))
    (ß
        (§ for (int i = 0 :for i < data.length :for i = i + 1))
        (ß
            ;; "Can be negative zero" - Bitcoin Core (see OpenSSL's BN_bn2mpi)
            (§ if (data[i] != 0))
                (§ return (i != data.length - 1 || (data[i] & 0xff) != 0x80))
        )
        (§ return false)
    )

    ;;;
     ; Cast a script chunk to a BigInteger.
     ;
     ; @see #castToBigInteger(byte[], int) for values with different maximum sizes.
     ; @throws ScriptException if the chunk is longer than 4 bytes.
     ;;
    #_private
    #_static
    (§ method BigInteger castToBigInteger(byte[] chunk, #_final boolean requireMinimal))
        (§ throws ScriptException)
    (ß
        (§ return castToBigInteger(chunk, 4, requireMinimal))
    )

    ;;;
     ; Cast a script chunk to a BigInteger.  Normally you would want {@link #castToBigInteger(byte[])} instead, this
     ; is only for cases where the normal maximum length does not apply (i.e. CHECKLOCKTIMEVERIFY, CHECKSEQUENCEVERIFY).
     ;
     ; @param maxLength The maximum length in bytes.
     ; @param requireMinimal Check if the number is encoded with the minimum possible number of bytes.
     ; @throws ScriptException if the chunk is longer than the specified maximum.
     ;;
    #_private
    #_static
    (§ method BigInteger castToBigInteger(#_final byte[] chunk, #_final int maxLength, #_final boolean requireMinimal))
        (§ throws ScriptException)
    (ß
        (§ if (maxLength < chunk.length))
            (§ throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "Script attempted to use an integer larger than " + maxLength + " bytes"))

        (§ if (requireMinimal && 0 < chunk.length))
        (ß
            ;; Check that the number is encoded with the minimum possible number of bytes.
            ;;
            ;; If the most-significant-byte - excluding the sign bit - is zero, then we're not minimal.
            ;; Note how this test also rejects the negative-zero encoding, 0x80.
            (§ if ((chunk[chunk.length - 1] & 0x7f) == 0))
            (ß
                ;; One exception: if there's more than one byte and the most significant bit
                ;; of the second-most-significant-byte is set, it would conflict with the sign bit.
                ;; An example of this case is +-255, which encode to 0xff00 and 0xff80 respectively.
                ;; (big-endian)
                (§ if (chunk.length <= 1 || (chunk[chunk.length - 2] & 0x80) == 0))
                    (§ throw  new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "non-minimally encoded script number"))
            )
        )

        (§ return Utils.decodeMPI(Utils.reverseBytes(chunk), false))
    )

    #_public
    (§ method boolean isOpReturn())
    (ß
        (§ return (0 < chunks.size() && chunks.get(0).equalsOpCode(OP_RETURN)))
    )

    ;;;
     ; Exposes the script interpreter.  Normally you should not use this directly, instead use
     ; {@link org.bitcoinj.core.TransactionInput#verify(org.bitcoinj.core.TransactionOutput)} or
     ; {@link org.bitcoinj.script.Script#correctlySpends(org.bitcoinj.core.Transaction, long, Script)}.
     ; This method is useful if you need more precise control or access to the final state of the stack.
     ; This interface is very likely to change in future.
     ;
     ; @deprecated Use {@link #executeScript(org.bitcoinj.core.Transaction, long, org.bitcoinj.script.Script, java.util.LinkedList, java.util.Set)}
     ; instead.
     ;;
    #_deprecated
    #_public
    #_static
    (§ method void executeScript(#_nilable Transaction txContainingThis, long index, Script script, LinkedList<byte[]> stack, boolean enforceNullDummy))
        (§ throws ScriptException)
    (ß
        #_final
        (§ var EnumSet<VerifyFlag> flags = enforceNullDummy ? EnumSet.of(VerifyFlag.NULLDUMMY) :else EnumSet.noneOf(VerifyFlag.class))

        (§ call executeScript(txContainingThis, index, script, stack, flags))
    )

    ;;;
     ; Exposes the script interpreter.  Normally you should not use this directly, instead use
     ; {@link org.bitcoinj.core.TransactionInput#verify(org.bitcoinj.core.TransactionOutput)} or
     ; {@link org.bitcoinj.script.Script#correctlySpends(org.bitcoinj.core.Transaction, long, Script)}.
     ; This method is useful if you need more precise control or access to the final state of the stack.
     ; This interface is very likely to change in future.
     ;;
    #_public
    #_static
    (§ method void executeScript(#_nilable Transaction txContainingThis, long index, Script script, LinkedList<byte[]> stack, Set<VerifyFlag> verifyFlags))
        (§ throws ScriptException)
    (ß
        (§ var int opCount = 0)
        (§ var int lastCodeSepLocation = 0)

        (§ var LinkedList<byte[]> altstack = new LinkedList<>())
        (§ var LinkedList<Boolean> ifStack = new LinkedList<>())

        (§ for (ScriptChunk chunk :for script.chunks))
        (ß
            (§ var boolean shouldExecute = !ifStack.contains(false))
            (§ var int opcode = chunk.opcode)

            ;; Check stack element size.
            (§ if (chunk.data != nil && MAX_SCRIPT_ELEMENT_SIZE < chunk.data.length))
                (§ throw new ScriptException(ScriptError.SCRIPT_ERR_PUSH_SIZE, "Attempted to push a data string larger than 520 bytes"))

            ;; Note how OP_RESERVED does not count towards the opcode limit.
            (§ if (OP_16 < opcode))
            (ß
                (§ ass opCount = opCount + 1)
                (§ if (MAX_OPS_PER_SCRIPT < opCount))
                    (§ throw new ScriptException(ScriptError.SCRIPT_ERR_OP_COUNT, "More script operations than is allowed"))
            )

            ;; Disabled opcodes.
            (§ if (opcode == OP_CAT || opcode == OP_SUBSTR || opcode == OP_LEFT || opcode == OP_RIGHT || opcode == OP_INVERT || opcode == OP_AND || opcode == OP_OR || opcode == OP_XOR || opcode == OP_2MUL || opcode == OP_2DIV || opcode == OP_MUL || opcode == OP_DIV || opcode == OP_MOD || opcode == OP_LSHIFT || opcode == OP_RSHIFT))
                (§ throw new ScriptException(ScriptError.SCRIPT_ERR_DISABLED_OPCODE, "Script included a disabled Script Op."))

            (§ if (shouldExecute && OP_0 <= opcode && opcode <= OP_PUSHDATA4))
            (ß
                ;; Check minimal push.
                (§ if (verifyFlags.contains(VerifyFlag.MINIMALDATA) && !chunk.isShortestPossiblePushData()))
                    (§ throw new ScriptException(ScriptError.SCRIPT_ERR_MINIMALDATA, "Script included a not minimal push operation."))

                (§ if (opcode == OP_0))
                    (§ call stack.add(new byte[] (ß )))
                (§ else)
                    (§ call stack.add(chunk.data))
            )
            (§ elseif (shouldExecute || (OP_IF <= opcode && opcode <= OP_ENDIF)))
            (ß
                (§ switch (opcode))
                (ß
                (§ case OP_IF)
                    (§ if (!shouldExecute))
                    (ß
                        (§ call ifStack.add(false))
                        (§ continue)
                    )
                    (§ if (stack.size() < 1))
                        (§ throw new ScriptException(ScriptError.SCRIPT_ERR_UNBALANCED_CONDITIONAL, "Attempted OP_IF on an empty stack"))
                    (§ call ifStack.add(castToBool(stack.pollLast())))
                    (§ continue)
                (§ case OP_NOTIF)
                    (§ if (!shouldExecute))
                    (ß
                        (§ call ifStack.add(false))
                        (§ continue)
                    )
                    (§ if (stack.size() < 1))
                        (§ throw new ScriptException(ScriptError.SCRIPT_ERR_UNBALANCED_CONDITIONAL, "Attempted OP_NOTIF on an empty stack"))
                    (§ call ifStack.add(!castToBool(stack.pollLast())))
                    (§ continue)
                (§ case OP_ELSE)
                    (§ if (ifStack.isEmpty()))
                        (§ throw new ScriptException(ScriptError.SCRIPT_ERR_UNBALANCED_CONDITIONAL, "Attempted OP_ELSE without OP_IF/NOTIF"))
                    (§ call ifStack.add(!ifStack.pollLast()))
                    (§ continue)
                (§ case OP_ENDIF)
                    (§ if (ifStack.isEmpty()))
                        (§ throw new ScriptException(ScriptError.SCRIPT_ERR_UNBALANCED_CONDITIONAL, "Attempted OP_ENDIF without OP_IF/NOTIF"))
                    (§ call ifStack.pollLast())
                    (§ continue)

                ;; OP_0 is no opcode
                (§ case OP_1NEGATE)
                    (§ call stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.ONE.negate(), false))))
                    (§ break)
                (§ case OP_1)
                (§ case OP_2)
                (§ case OP_3)
                (§ case OP_4)
                (§ case OP_5)
                (§ case OP_6)
                (§ case OP_7)
                (§ case OP_8)
                (§ case OP_9)
                (§ case OP_10)
                (§ case OP_11)
                (§ case OP_12)
                (§ case OP_13)
                (§ case OP_14)
                (§ case OP_15)
                (§ case OP_16)
                    (§ call stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.valueOf(decodeFromOpN(opcode)), false))))
                    (§ break)
                (§ case OP_NOP)
                    (§ break)
                (§ case OP_VERIFY)
                    (§ if (stack.size() < 1))
                        (§ throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_VERIFY on an empty stack"))
                    (§ if (!castToBool(stack.pollLast())))
                        (§ throw new ScriptException(ScriptError.SCRIPT_ERR_VERIFY, "OP_VERIFY failed"))
                    (§ break)
                (§ case OP_RETURN)
                    (§ throw new ScriptException(ScriptError.SCRIPT_ERR_OP_RETURN, "Script called OP_RETURN"))
                (§ case OP_TOALTSTACK)
                    (§ if (stack.size() < 1))
                        (§ throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_TOALTSTACK on an empty stack"))
                    (§ call altstack.add(stack.pollLast()))
                    (§ break)
                (§ case OP_FROMALTSTACK)
                    (§ if (altstack.size() < 1))
                        (§ throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_ALTSTACK_OPERATION, "Attempted OP_FROMALTSTACK on an empty altstack"))
                    (§ call stack.add(altstack.pollLast()))
                    (§ break)
                (§ case OP_2DROP)
                    (§ if (stack.size() < 2))
                        (§ throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_2DROP on a stack with size < 2"))
                    (§ call stack.pollLast())
                    (§ call stack.pollLast())
                    (§ break)
                (§ case OP_2DUP)
                    (§ if (stack.size() < 2))
                        (§ throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_2DUP on a stack with size < 2"))
                    (§ var Iterator<byte[]> it2DUP = stack.descendingIterator())
                    (§ var byte[] OP2DUPtmpChunk2 = it2DUP.next())
                    (§ call stack.add(it2DUP.next()))
                    (§ call stack.add(OP2DUPtmpChunk2))
                    (§ break)
                (§ case OP_3DUP)
                    (§ if (stack.size() < 3))
                        (§ throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_3DUP on a stack with size < 3"))
                    (§ var Iterator<byte[]> it3DUP = stack.descendingIterator())
                    (§ var byte[] OP3DUPtmpChunk3 = it3DUP.next())
                    (§ var byte[] OP3DUPtmpChunk2 = it3DUP.next())
                    (§ call stack.add(it3DUP.next()))
                    (§ call stack.add(OP3DUPtmpChunk2))
                    (§ call stack.add(OP3DUPtmpChunk3))
                    (§ break)
                (§ case OP_2OVER)
                    (§ if (stack.size() < 4))
                        (§ throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_2OVER on a stack with size < 4"))
                    (§ var Iterator<byte[]> it2OVER = stack.descendingIterator())
                    (§ call it2OVER.next())
                    (§ call it2OVER.next())
                    (§ var byte[] OP2OVERtmpChunk2 = it2OVER.next())
                    (§ call stack.add(it2OVER.next()))
                    (§ call stack.add(OP2OVERtmpChunk2))
                    (§ break)
                (§ case OP_2ROT)
                    (§ if (stack.size() < 6))
                        (§ throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_2ROT on a stack with size < 6"))
                    (§ var byte[] OP2ROTtmpChunk6 = stack.pollLast())
                    (§ var byte[] OP2ROTtmpChunk5 = stack.pollLast())
                    (§ var byte[] OP2ROTtmpChunk4 = stack.pollLast())
                    (§ var byte[] OP2ROTtmpChunk3 = stack.pollLast())
                    (§ var byte[] OP2ROTtmpChunk2 = stack.pollLast())
                    (§ var byte[] OP2ROTtmpChunk1 = stack.pollLast())
                    (§ call stack.add(OP2ROTtmpChunk3))
                    (§ call stack.add(OP2ROTtmpChunk4))
                    (§ call stack.add(OP2ROTtmpChunk5))
                    (§ call stack.add(OP2ROTtmpChunk6))
                    (§ call stack.add(OP2ROTtmpChunk1))
                    (§ call stack.add(OP2ROTtmpChunk2))
                    (§ break)
                (§ case OP_2SWAP)
                    (§ if (stack.size() < 4))
                        (§ throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_2SWAP on a stack with size < 4"))
                    (§ var byte[] OP2SWAPtmpChunk4 = stack.pollLast())
                    (§ var byte[] OP2SWAPtmpChunk3 = stack.pollLast())
                    (§ var byte[] OP2SWAPtmpChunk2 = stack.pollLast())
                    (§ var byte[] OP2SWAPtmpChunk1 = stack.pollLast())
                    (§ call stack.add(OP2SWAPtmpChunk3))
                    (§ call stack.add(OP2SWAPtmpChunk4))
                    (§ call stack.add(OP2SWAPtmpChunk1))
                    (§ call stack.add(OP2SWAPtmpChunk2))
                    (§ break)
                (§ case OP_IFDUP)
                    (§ if (stack.size() < 1))
                        (§ throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_IFDUP on an empty stack"))
                    (§ if (castToBool(stack.getLast())))
                        (§ call stack.add(stack.getLast()))
                    (§ break)
                (§ case OP_DEPTH)
                    (§ call stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.valueOf(stack.size()), false))))
                    (§ break)
                (§ case OP_DROP)
                    (§ if (stack.size() < 1))
                        (§ throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_DROP on an empty stack"))
                    (§ call stack.pollLast())
                    (§ break)
                (§ case OP_DUP)
                    (§ if (stack.size() < 1))
                        (§ throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_DUP on an empty stack"))
                    (§ call stack.add(stack.getLast()))
                    (§ break)
                (§ case OP_NIP)
                    (§ if (stack.size() < 2))
                        (§ throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_NIP on a stack with size < 2"))
                    (§ var byte[] OPNIPtmpChunk = stack.pollLast())
                    (§ call stack.pollLast())
                    (§ call stack.add(OPNIPtmpChunk))
                    (§ break)
                (§ case OP_OVER)
                    (§ if (stack.size() < 2))
                        (§ throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_OVER on a stack with size < 2"))
                    (§ var Iterator<byte[]> itOVER = stack.descendingIterator())
                    (§ call itOVER.next())
                    (§ call stack.add(itOVER.next()))
                    (§ break)
                (§ case OP_PICK)
                (§ case OP_ROLL)
                    (§ if (stack.size() < 1))
                        (§ throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_PICK/OP_ROLL on an empty stack"))
                    (§ var long val = castToBigInteger(stack.pollLast(), verifyFlags.contains(VerifyFlag.MINIMALDATA)).longValue())
                    (§ if (val < 0 || stack.size() <= val))
                        (§ throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "OP_PICK/OP_ROLL attempted to get data deeper than stack size"))
                    (§ var Iterator<byte[]> itPICK = stack.descendingIterator())
                    (§ for (long i = 0 :for i < val :for i = i + 1))
                        (§ call itPICK.next())
                    (§ var byte[] OPROLLtmpChunk = itPICK.next())
                    (§ if (opcode == OP_ROLL))
                        (§ call itPICK.remove())
                    (§ call stack.add(OPROLLtmpChunk))
                    (§ break)
                (§ case OP_ROT)
                    (§ if (stack.size() < 3))
                        (§ throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_ROT on a stack with size < 3"))
                    (§ var byte[] OPROTtmpChunk3 = stack.pollLast())
                    (§ var byte[] OPROTtmpChunk2 = stack.pollLast())
                    (§ var byte[] OPROTtmpChunk1 = stack.pollLast())
                    (§ call stack.add(OPROTtmpChunk2))
                    (§ call stack.add(OPROTtmpChunk3))
                    (§ call stack.add(OPROTtmpChunk1))
                    (§ break)
                (§ case OP_SWAP)
                (§ case OP_TUCK)
                    (§ if (stack.size() < 2))
                        (§ throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_SWAP on a stack with size < 2"))
                    (§ var byte[] OPSWAPtmpChunk2 = stack.pollLast())
                    (§ var byte[] OPSWAPtmpChunk1 = stack.pollLast())
                    (§ call stack.add(OPSWAPtmpChunk2))
                    (§ call stack.add(OPSWAPtmpChunk1))
                    (§ if (opcode == OP_TUCK))
                        (§ call stack.add(OPSWAPtmpChunk2))
                    (§ break)
                (§ case OP_SIZE)
                    (§ if (stack.size() < 1))
                        (§ throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_SIZE on an empty stack"))
                    (§ call stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.valueOf(stack.getLast().length), false))))
                    (§ break)
                (§ case OP_EQUAL)
                    (§ if (stack.size() < 2))
                        (§ throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_EQUAL on a stack with size < 2"))
                    (§ call stack.add(Arrays.equals(stack.pollLast(), stack.pollLast()) ? new byte[] (ß 1 ) :else new byte[] (ß )))
                    (§ break)
                (§ case OP_EQUALVERIFY)
                    (§ if (stack.size() < 2))
                        (§ throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_EQUALVERIFY on a stack with size < 2"))
                    (§ if (!Arrays.equals(stack.pollLast(), stack.pollLast())))
                        (§ throw new ScriptException(ScriptError.SCRIPT_ERR_EQUALVERIFY, "OP_EQUALVERIFY: non-equal data"))
                    (§ break)
                (§ case OP_1ADD)
                (§ case OP_1SUB)
                (§ case OP_NEGATE)
                (§ case OP_ABS)
                (§ case OP_NOT)
                (§ case OP_0NOTEQUAL)
                    (§ if (stack.size() < 1))
                        (§ throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted a numeric op on an empty stack"))
                    (§ var BigInteger numericOPnum = castToBigInteger(stack.pollLast(), verifyFlags.contains(VerifyFlag.MINIMALDATA)))

                    (§ switch (opcode))
                    (ß
                    (§ case OP_1ADD)
                        (§ ass numericOPnum = numericOPnum.add(BigInteger.ONE))
                        (§ break)
                    (§ case OP_1SUB)
                        (§ ass numericOPnum = numericOPnum.subtract(BigInteger.ONE))
                        (§ break)
                    (§ case OP_NEGATE)
                        (§ ass numericOPnum = numericOPnum.negate())
                        (§ break)
                    (§ case OP_ABS)
                        (§ if (numericOPnum.signum() < 0))
                            (§ ass numericOPnum = numericOPnum.negate())
                        (§ break)
                    (§ case OP_NOT)
                        (§ if (numericOPnum.equals(BigInteger.ZERO)))
                            (§ ass numericOPnum = BigInteger.ONE)
                        (§ else)
                            (§ ass numericOPnum = BigInteger.ZERO)
                        (§ break)
                    (§ case OP_0NOTEQUAL)
                        (§ if (numericOPnum.equals(BigInteger.ZERO)))
                            (§ ass numericOPnum = BigInteger.ZERO)
                        (§ else)
                            (§ ass numericOPnum = BigInteger.ONE)
                        (§ break)
                    (§ default)
                        (§ throw new AssertionError("Unreachable"))
                    )

                    (§ call stack.add(Utils.reverseBytes(Utils.encodeMPI(numericOPnum, false))))
                    (§ break)
                (§ case OP_ADD)
                (§ case OP_SUB)
                (§ case OP_BOOLAND)
                (§ case OP_BOOLOR)
                (§ case OP_NUMEQUAL)
                (§ case OP_NUMNOTEQUAL)
                (§ case OP_LESSTHAN)
                (§ case OP_GREATERTHAN)
                (§ case OP_LESSTHANOREQUAL)
                (§ case OP_GREATERTHANOREQUAL)
                (§ case OP_MIN)
                (§ case OP_MAX)
                    (§ if (stack.size() < 2))
                        (§ throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted a numeric op on a stack with size < 2"))
                    (§ var BigInteger numericOPnum2 = castToBigInteger(stack.pollLast(), verifyFlags.contains(VerifyFlag.MINIMALDATA)))
                    (§ var BigInteger numericOPnum1 = castToBigInteger(stack.pollLast(), verifyFlags.contains(VerifyFlag.MINIMALDATA)))

                    (§ var BigInteger numericOPresult)
                    (§ switch (opcode))
                    (ß
                    (§ case OP_ADD)
                        (§ ass numericOPresult = numericOPnum1.add(numericOPnum2))
                        (§ break)
                    (§ case OP_SUB)
                        (§ ass numericOPresult = numericOPnum1.subtract(numericOPnum2))
                        (§ break)
                    (§ case OP_BOOLAND)
                        (§ if (!numericOPnum1.equals(BigInteger.ZERO) && !numericOPnum2.equals(BigInteger.ZERO)))
                            (§ ass numericOPresult = BigInteger.ONE)
                        (§ else)
                            (§ ass numericOPresult = BigInteger.ZERO)
                        (§ break)
                    (§ case OP_BOOLOR)
                        (§ if (!numericOPnum1.equals(BigInteger.ZERO) || !numericOPnum2.equals(BigInteger.ZERO)))
                            (§ ass numericOPresult = BigInteger.ONE)
                        (§ else)
                            (§ ass numericOPresult = BigInteger.ZERO)
                        (§ break)
                    (§ case OP_NUMEQUAL)
                        (§ if (numericOPnum1.equals(numericOPnum2)))
                            (§ ass numericOPresult = BigInteger.ONE)
                        (§ else)
                            (§ ass numericOPresult = BigInteger.ZERO)
                        (§ break)
                    (§ case OP_NUMNOTEQUAL)
                        (§ if (!numericOPnum1.equals(numericOPnum2)))
                            (§ ass numericOPresult = BigInteger.ONE)
                        (§ else)
                            (§ ass numericOPresult = BigInteger.ZERO)
                        (§ break)
                    (§ case OP_LESSTHAN)
                        (§ if (numericOPnum1.compareTo(numericOPnum2) < 0))
                            (§ ass numericOPresult = BigInteger.ONE)
                        (§ else)
                            (§ ass numericOPresult = BigInteger.ZERO)
                        (§ break)
                    (§ case OP_GREATERTHAN)
                        (§ if (numericOPnum1.compareTo(numericOPnum2) > 0))
                            (§ ass numericOPresult = BigInteger.ONE)
                        (§ else)
                            (§ ass numericOPresult = BigInteger.ZERO)
                        (§ break)
                    (§ case OP_LESSTHANOREQUAL)
                        (§ if (numericOPnum1.compareTo(numericOPnum2) <= 0))
                            (§ ass numericOPresult = BigInteger.ONE)
                        (§ else)
                            (§ ass numericOPresult = BigInteger.ZERO)
                        (§ break)
                    (§ case OP_GREATERTHANOREQUAL)
                        (§ if (numericOPnum1.compareTo(numericOPnum2) >= 0))
                            (§ ass numericOPresult = BigInteger.ONE)
                        (§ else)
                            (§ ass numericOPresult = BigInteger.ZERO)
                        (§ break)
                    (§ case OP_MIN)
                        (§ if (numericOPnum1.compareTo(numericOPnum2) < 0))
                            (§ ass numericOPresult = numericOPnum1)
                        (§ else)
                            (§ ass numericOPresult = numericOPnum2)
                        (§ break)
                    (§ case OP_MAX)
                        (§ if (numericOPnum1.compareTo(numericOPnum2) > 0))
                            (§ ass numericOPresult = numericOPnum1)
                        (§ else)
                            (§ ass numericOPresult = numericOPnum2)
                        (§ break)
                    (§ default)
                        (§ throw new RuntimeException("Opcode switched at runtime?"))
                    )

                    (§ call stack.add(Utils.reverseBytes(Utils.encodeMPI(numericOPresult, false))))
                    (§ break)
                (§ case OP_NUMEQUALVERIFY)
                    (§ if (stack.size() < 2))
                        (§ throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_NUMEQUALVERIFY on a stack with size < 2"))
                    (§ var BigInteger OPNUMEQUALVERIFYnum2 = castToBigInteger(stack.pollLast(), verifyFlags.contains(VerifyFlag.MINIMALDATA)))
                    (§ var BigInteger OPNUMEQUALVERIFYnum1 = castToBigInteger(stack.pollLast(), verifyFlags.contains(VerifyFlag.MINIMALDATA)))

                    (§ if (!OPNUMEQUALVERIFYnum1.equals(OPNUMEQUALVERIFYnum2)))
                        (§ throw new ScriptException(ScriptError.SCRIPT_ERR_NUMEQUALVERIFY, "OP_NUMEQUALVERIFY failed"))
                    (§ break)
                (§ case OP_WITHIN)
                    (§ if (stack.size() < 3))
                        (§ throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_WITHIN on a stack with size < 3"))
                    (§ var BigInteger OPWITHINnum3 = castToBigInteger(stack.pollLast(), verifyFlags.contains(VerifyFlag.MINIMALDATA)))
                    (§ var BigInteger OPWITHINnum2 = castToBigInteger(stack.pollLast(), verifyFlags.contains(VerifyFlag.MINIMALDATA)))
                    (§ var BigInteger OPWITHINnum1 = castToBigInteger(stack.pollLast(), verifyFlags.contains(VerifyFlag.MINIMALDATA)))
                    (§ if (OPWITHINnum2.compareTo(OPWITHINnum1) <= 0 && OPWITHINnum1.compareTo(OPWITHINnum3) < 0))
                        (§ call stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.ONE, false))))
                    (§ else)
                        (§ call stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.ZERO, false))))
                    (§ break)
                (§ case OP_RIPEMD160)
                    (§ if (stack.size() < 1))
                        (§ throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_RIPEMD160 on an empty stack"))
                    (§ var RIPEMD160Digest digest = new RIPEMD160Digest())
                    (§ var byte[] dataToHash = stack.pollLast())
                    (§ call digest.update(dataToHash, 0, dataToHash.length))
                    (§ var byte[] ripmemdHash = new byte[20])
                    (§ call digest.doFinal(ripmemdHash, 0))
                    (§ call stack.add(ripmemdHash))
                    (§ break)
                (§ case OP_SHA1)
                    (§ if (stack.size() < 1))
                        (§ throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_SHA1 on an empty stack"))
                    (§ try)
                    (ß
                        (§ call stack.add(MessageDigest.getInstance("SHA-1").digest(stack.pollLast())))
                    )
                    (§ catch (NoSuchAlgorithmException e))
                    (ß
                        (§ throw new RuntimeException(e)) ;; Cannot happen.
                    )
                    (§ break)
                (§ case OP_SHA256)
                    (§ if (stack.size() < 1))
                        (§ throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_SHA256 on an empty stack"))
                    (§ call stack.add(Sha256Hash.hash(stack.pollLast())))
                    (§ break)
                (§ case OP_HASH160)
                    (§ if (stack.size() < 1))
                        (§ throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_HASH160 on an empty stack"))
                    (§ call stack.add(Utils.sha256hash160(stack.pollLast())))
                    (§ break)
                (§ case OP_HASH256)
                    (§ if (stack.size() < 1))
                        (§ throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_SHA256 on an empty stack"))
                    (§ call stack.add(Sha256Hash.hashTwice(stack.pollLast())))
                    (§ break)
                (§ case OP_CODESEPARATOR)
                    (§ ass lastCodeSepLocation = chunk.getStartLocationInProgram() + 1)
                    (§ break)
                (§ case OP_CHECKSIG)
                (§ case OP_CHECKSIGVERIFY)
                    (§ if (txContainingThis == nil))
                        (§ throw new IllegalStateException("Script attempted signature check but no tx was provided"))
                    (§ call executeCheckSig(txContainingThis, (int)index, script, stack, lastCodeSepLocation, opcode, verifyFlags))
                    (§ break)
                (§ case OP_CHECKMULTISIG)
                (§ case OP_CHECKMULTISIGVERIFY)
                    (§ if (txContainingThis == nil))
                        (§ throw new IllegalStateException("Script attempted signature check but no tx was provided"))
                    (§ ass opCount = executeMultiSig(txContainingThis, (int)index, script, stack, opCount, lastCodeSepLocation, opcode, verifyFlags))
                    (§ break)
                (§ case OP_CHECKLOCKTIMEVERIFY)
                    (§ if (!verifyFlags.contains(VerifyFlag.CHECKLOCKTIMEVERIFY)))
                    (ß
                        ;; not enabled; treat as a NOP2
                        (§ if (verifyFlags.contains(VerifyFlag.DISCOURAGE_UPGRADABLE_NOPS)))
                            (§ throw new ScriptException(ScriptError.SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS, "Script used a reserved opcode " + opcode))
                        (§ break)
                    )
                    (§ call executeCheckLockTimeVerify(txContainingThis, (int)index, stack, verifyFlags))
                    (§ break)
                (§ case OP_CHECKSEQUENCEVERIFY)
                    (§ if (!verifyFlags.contains(VerifyFlag.CHECKSEQUENCEVERIFY)))
                    (ß
                        ;; not enabled; treat as a NOP3
                        (§ if (verifyFlags.contains(VerifyFlag.DISCOURAGE_UPGRADABLE_NOPS)))
                            (§ throw new ScriptException(ScriptError.SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS, "Script used a reserved opcode " + opcode))
                        (§ break)
                    )
                    (§ call executeCheckSequenceVerify(txContainingThis, (int)index, stack, verifyFlags))
                    (§ break)
                (§ case OP_NOP1)
                (§ case OP_NOP4)
                (§ case OP_NOP5)
                (§ case OP_NOP6)
                (§ case OP_NOP7)
                (§ case OP_NOP8)
                (§ case OP_NOP9)
                (§ case OP_NOP10)
                    (§ if (verifyFlags.contains(VerifyFlag.DISCOURAGE_UPGRADABLE_NOPS)))
                        (§ throw new ScriptException(ScriptError.SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS, "Script used a reserved opcode " + opcode))
                    (§ break)

                (§ default)
                    (§ throw new ScriptException(ScriptError.SCRIPT_ERR_BAD_OPCODE, "Script used a reserved or disabled opcode: " + opcode))
                )
            )

            (§ if (MAX_STACK_SIZE < stack.size() + altstack.size() || stack.size() + altstack.size() < 0))
                (§ throw new ScriptException(ScriptError.SCRIPT_ERR_STACK_SIZE, "Stack size exceeded range"))
        )

        (§ if (!ifStack.isEmpty()))
            (§ throw new ScriptException(ScriptError.SCRIPT_ERR_UNBALANCED_CONDITIONAL, "OP_IF/OP_NOTIF without OP_ENDIF"))
    )

    ;; This is more or less a direct translation of the code in Bitcoin Core.
    #_private
    #_static
    (§ method void executeCheckLockTimeVerify(Transaction txContainingThis, int index, LinkedList<byte[]> stack, Set<VerifyFlag> verifyFlags))
        (§ throws ScriptException)
    (ß
        (§ if (stack.size() < 1))
            (§ throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_CHECKLOCKTIMEVERIFY on a stack with size < 1"))

        ;; Thus as a special case we tell CScriptNum to accept up to 5-byte bignums to avoid year 2038 issue.
        #_final
        (§ var BigInteger nLockTime = castToBigInteger(stack.getLast(), 5, verifyFlags.contains(VerifyFlag.MINIMALDATA)))

        (§ if (nLockTime.compareTo(BigInteger.ZERO) < 0))
            (§ throw new ScriptException(ScriptError.SCRIPT_ERR_NEGATIVE_LOCKTIME, "Negative locktime"))

        ;; There are two kinds of nLockTime, need to ensure we're comparing apples-to-apples.
        (§ if (!(((txContainingThis.getLockTime() <  Transaction.LOCKTIME_THRESHOLD) && (nLockTime.compareTo(Transaction.LOCKTIME_THRESHOLD_BIG)) <  0) || ((txContainingThis.getLockTime() >= Transaction.LOCKTIME_THRESHOLD) && (nLockTime.compareTo(Transaction.LOCKTIME_THRESHOLD_BIG)) >= 0))))
            (§ throw new ScriptException(ScriptError.SCRIPT_ERR_UNSATISFIED_LOCKTIME, "Locktime requirement type mismatch"))

        ;; Now that we know we're comparing apples-to-apples, the comparison is a simple numeric one.
        (§ if (0 < nLockTime.compareTo(BigInteger.valueOf(txContainingThis.getLockTime()))))
            (§ throw new ScriptException(ScriptError.SCRIPT_ERR_UNSATISFIED_LOCKTIME, "Locktime requirement not satisfied"))

        ;; Finally the nLockTime feature can be disabled and thus CHECKLOCKTIMEVERIFY bypassed if every txin has been
        ;; finalized by setting nSequence to maxint.  The transaction would be allowed into the blockchain, making
        ;; the opcode ineffective.
        ;;
        ;; Testing if this vin is not final is sufficient to prevent this condition.  Alternatively we could test all
        ;; inputs, but testing just this input minimizes the data required to prove correct CHECKLOCKTIMEVERIFY execution.
        (§ if (!txContainingThis.getInput(index).hasSequence()))
            (§ throw new ScriptException(ScriptError.SCRIPT_ERR_UNSATISFIED_LOCKTIME, "Transaction contains a final transaction input for a CHECKLOCKTIMEVERIFY script."))
    )

    #_private
    #_static
    (§ method void executeCheckSequenceVerify(Transaction txContainingThis, int index, LinkedList<byte[]> stack, Set<VerifyFlag> verifyFlags))
        (§ throws ScriptException)
    (ß
        (§ if (stack.size() < 1))
            (§ throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_CHECKSEQUENCEVERIFY on a stack with size < 1"))

        ;; Note that elsewhere numeric opcodes are limited to operands in the range -2**31+1 to 2**31-1, however
        ;; it is legal for opcodes to produce results exceeding that range.  This limitation is implemented by
        ;; CScriptNum's default 4-byte limit.
        ;;
        ;; Thus as a special case we tell CScriptNum to accept up to 5-byte bignums, which are good until 2**39-1,
        ;; well beyond the 2**32-1 limit of the nSequence field itself.
        #_final
        (§ var long nSequence = castToBigInteger(stack.getLast(), 5, verifyFlags.contains(VerifyFlag.MINIMALDATA)).longValue())

        ;; In the rare event that the argument may be < 0 due to some arithmetic being done first, you can always
        ;; use 0 MAX CHECKSEQUENCEVERIFY.
        (§ if (nSequence < 0))
            (§ throw new ScriptException(ScriptError.SCRIPT_ERR_NEGATIVE_LOCKTIME, "Negative sequence"))

        ;; To provide for future soft-fork extensibility, if the operand has the disabled lock-time flag set,
        ;; CHECKSEQUENCEVERIFY behaves as a NOP.
        (§ if ((nSequence & Transaction.SEQUENCE_LOCKTIME_DISABLE_FLAG) != 0))
            (§ return)

        ;; Compare the specified sequence number with the input.
        (§ if (!checkSequence(nSequence, txContainingThis, index)))
            (§ throw new ScriptException(ScriptError.SCRIPT_ERR_UNSATISFIED_LOCKTIME, "Unsatisfied CHECKLOCKTIMEVERIFY lock time"))
    )

    #_private
    #_static
    (§ method boolean checkSequence(long nSequence, Transaction txContainingThis, int index))
    (ß
        ;; Relative lock times are supported by comparing the passed in operand to the sequence number
        ;; of the input.
        (§ var long txToSequence = txContainingThis.getInput(index).getSequenceNumber())

        ;; Fail if the transaction's version number is not set high enough to trigger BIP 68 rules.
        (§ if (txContainingThis.getVersion() < 2))
            (§ return false)

        ;; Sequence numbers with their most significant bit set are not consensus constrained.  Testing
        ;; that the transaction's sequence number do not have this bit set prevents using this property
        ;; to get around a CHECKSEQUENCEVERIFY check.
        (§ if ((txToSequence & Transaction.SEQUENCE_LOCKTIME_DISABLE_FLAG) != 0))
            (§ return false)

        ;; Mask off any bits that do not have consensus-enforced meaning before doing the integer comparisons.
        (§ var long nLockTimeMask =  Transaction.SEQUENCE_LOCKTIME_TYPE_FLAG | Transaction.SEQUENCE_LOCKTIME_MASK)
        (§ var long txToSequenceMasked = txToSequence & nLockTimeMask)
        (§ var long nSequenceMasked = nSequence & nLockTimeMask)

        ;; There are two kinds of nSequence: lock-by-blockheight and lock-by-blocktime, distinguished by
        ;; whether nSequenceMasked < CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG.
        ;;
        ;; We want to compare apples to apples, so fail the script unless the type of nSequenceMasked
        ;; being tested is the same as the nSequenceMasked in the transaction.
        (§ if (!((txToSequenceMasked <  Transaction.SEQUENCE_LOCKTIME_TYPE_FLAG && nSequenceMasked <  Transaction.SEQUENCE_LOCKTIME_TYPE_FLAG) || (txToSequenceMasked >= Transaction.SEQUENCE_LOCKTIME_TYPE_FLAG && nSequenceMasked >= Transaction.SEQUENCE_LOCKTIME_TYPE_FLAG))))
            (§ return false)

        ;; Now that we know we're comparing apples-to-apples, the comparison is a simple numeric one.
        (§ if (txToSequenceMasked < nSequenceMasked))
            (§ return false)

        (§ return true)
    )

    #_private
    #_static
    (§ method void executeCheckSig(Transaction txContainingThis, int index, Script script, LinkedList<byte[]> stack, int lastCodeSepLocation, int opcode, Set<VerifyFlag> verifyFlags))
        (§ throws ScriptException)
    (ß
        #_final
        (§ var boolean requireCanonical = verifyFlags.contains(VerifyFlag.STRICTENC) || verifyFlags.contains(VerifyFlag.DERSIG) || verifyFlags.contains(VerifyFlag.LOW_S))
        (§ if (stack.size() < 2))
            (§ throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_CHECKSIG(VERIFY) on a stack with size < 2"))

        (§ var byte[] pubKey = stack.pollLast())
        (§ var byte[] sigBytes = stack.pollLast())

        (§ var byte[] prog = script.getProgram())
        (§ var byte[] connectedScript = Arrays.copyOfRange(prog, lastCodeSepLocation, prog.length))

        (§ var UnsafeByteArrayOutputStream outStream = new UnsafeByteArrayOutputStream(sigBytes.length + 1))
        (§ try)
        (ß
            (§ call writeBytes(outStream, sigBytes))
        )
        (§ catch (IOException e))
        (ß
            (§ throw new RuntimeException(e)) ;; Cannot happen.
        )
        (§ ass connectedScript = removeAllInstancesOf(connectedScript, outStream.toByteArray()))

        ;; TODO: Use int for indexes everywhere, we can't have that many inputs/outputs.
        (§ var boolean sigValid = false)
        (§ try)
        (ß
            (§ var TransactionSignature sig = TransactionSignature.decodeFromBitcoin(sigBytes, requireCanonical, verifyFlags.contains(VerifyFlag.LOW_S)))

            ;; TODO: Should check hash type is known.
            (§ var Sha256Hash hash = txContainingThis.hashForSignature(index, connectedScript, (byte)sig.sighashFlags))
            (§ ass sigValid = ECKey.verify(hash.getBytes(), sig, pubKey))
        )
        (§ catch (Exception e))
        (ß
            ;; There is (at least) one exception that could be hit here (EOFException, if the sig is too short).
            ;; Because I can't verify there aren't more, we use a very generic Exception catch.

            ;; This RuntimeException occurs when signing as we run partial/invalid scripts to see if they need more
            ;; signing work to be done inside LocalTransactionSigner.signInputs.
            (§ if (!e.getMessage().contains("Reached past end of ASN.1 stream")))
                (§ call log.warn("Signature checking failed!", e))
        )

        (§ if (opcode == OP_CHECKSIG))
            (§ call stack.add(sigValid ? new byte[] (ß 1 ) :else new byte[] (ß )))
        (§ elseif (opcode == OP_CHECKSIGVERIFY && !sigValid))
            (§ throw new ScriptException(ScriptError.SCRIPT_ERR_CHECKSIGVERIFY, "Script failed OP_CHECKSIGVERIFY"))
    )

    #_private
    #_static
    (§ method int executeMultiSig(Transaction txContainingThis, int index, Script script, LinkedList<byte[]> stack, int opCount, int lastCodeSepLocation, int opcode, Set<VerifyFlag> verifyFlags))
        (§ throws ScriptException)
    (ß
        #_final
        (§ var boolean requireCanonical = verifyFlags.contains(VerifyFlag.STRICTENC) || verifyFlags.contains(VerifyFlag.DERSIG) || verifyFlags.contains(VerifyFlag.LOW_S))
        (§ if (stack.size() < 1))
            (§ throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_CHECKMULTISIG(VERIFY) on a stack with size < 2"))

        (§ var int pubKeyCount = castToBigInteger(stack.pollLast(), verifyFlags.contains(VerifyFlag.MINIMALDATA)).intValue())
        (§ if (pubKeyCount < 0 || MAX_PUBKEYS_PER_MULTISIG < pubKeyCount))
            (§ throw new ScriptException(ScriptError.SCRIPT_ERR_PUBKEY_COUNT, "OP_CHECKMULTISIG(VERIFY) with pubkey count out of range"))

        (§ ass opCount = opCount + pubKeyCount)
        (§ if (MAX_OPS_PER_SCRIPT < opCount))
            (§ throw new ScriptException(ScriptError.SCRIPT_ERR_OP_COUNT, "Total op count > 201 during OP_CHECKMULTISIG(VERIFY)"))
        (§ if (stack.size() < pubKeyCount + 1))
            (§ throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_CHECKMULTISIG(VERIFY) on a stack with size < num_of_pubkeys + 2"))

        (§ var LinkedList<byte[]> pubkeys = new LinkedList<>())
        (§ for (int i = 0 :for i < pubKeyCount :for i = i + 1))
            (§ call pubkeys.add(stack.pollLast()))

        (§ var int sigCount = castToBigInteger(stack.pollLast(), verifyFlags.contains(VerifyFlag.MINIMALDATA)).intValue())
        (§ if (sigCount < 0 || pubKeyCount < sigCount))
            (§ throw new ScriptException(ScriptError.SCRIPT_ERR_SIG_COUNT, "OP_CHECKMULTISIG(VERIFY) with sig count out of range"))
        (§ if (stack.size() < sigCount + 1))
            (§ throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_CHECKMULTISIG(VERIFY) on a stack with size < num_of_pubkeys + num_of_signatures + 3"))

        (§ var LinkedList<byte[]> sigs = new LinkedList<>())
        (§ for (int i = 0 :for i < sigCount :for i = i + 1))
            (§ call sigs.add(stack.pollLast()))

        (§ var byte[] prog = script.getProgram())
        (§ var byte[] connectedScript = Arrays.copyOfRange(prog, lastCodeSepLocation, prog.length))

        (§ for (byte[] sig :for sigs))
        (ß
            (§ var UnsafeByteArrayOutputStream outStream = new UnsafeByteArrayOutputStream(sig.length + 1))
            (§ try)
            (ß
                (§ call writeBytes(outStream, sig))
            )
            (§ catch (IOException e))
            (ß
                (§ throw new RuntimeException(e)) ;; Cannot happen.
            )
            (§ ass connectedScript = removeAllInstancesOf(connectedScript, outStream.toByteArray()))
        )

        (§ var boolean valid = true)
        (§ while (0 < sigs.size()))
        (ß
            (§ var byte[] pubKey = pubkeys.pollFirst())
            ;; We could reasonably move this out of the loop, but because signature verification is significantly
            ;; more expensive than hashing, its not a big deal.
            (§ try)
            (ß
                (§ var TransactionSignature sig = TransactionSignature.decodeFromBitcoin(sigs.getFirst(), requireCanonical))
                (§ var Sha256Hash hash = txContainingThis.hashForSignature(index, connectedScript, (byte)sig.sighashFlags))
                (§ if (ECKey.verify(hash.getBytes(), sig, pubKey)))
                    (§ call sigs.pollFirst())
            )
            (§ catch (Exception _))
            (ß
                ;; There is (at least) one exception that could be hit here (EOFException, if the sig is too short).
                ;; Because I can't verify there aren't more, we use a very generic Exception catch.
            )

            (§ if (pubkeys.size() < sigs.size()))
            (ß
                (§ ass valid = false)
                (§ break)
            )
        )

        ;; We uselessly remove a stack object to emulate a Bitcoin Core bug.
        (§ var byte[] nullDummy = stack.pollLast())
        (§ if (verifyFlags.contains(VerifyFlag.NULLDUMMY) && 0 < nullDummy.length))
            (§ throw new ScriptException(ScriptError.SCRIPT_ERR_SIG_NULLFAIL, "OP_CHECKMULTISIG(VERIFY) with non-null nulldummy: " + Arrays.toString(nullDummy)))

        (§ if (opcode == OP_CHECKMULTISIG))
            (§ call stack.add(valid ? new byte[] (ß 1 ) :else new byte[] (ß )))
        (§ elseif (opcode == OP_CHECKMULTISIGVERIFY && !valid))
            (§ throw new ScriptException(ScriptError.SCRIPT_ERR_SIG_NULLFAIL, "Script failed OP_CHECKMULTISIGVERIFY"))

        (§ return opCount)
    )

    ;;;
     ; Verifies that this script (interpreted as a scriptSig) correctly spends the given scriptPubKey, enabling all validation rules.
     ; @param txContainingThis The transaction in which this input scriptSig resides.
     ;                         Accessing txContainingThis from another thread while this method runs results in undefined behavior.
     ; @param scriptSigIndex The index in txContainingThis of the scriptSig (note: NOT the index of the scriptPubKey).
     ; @param scriptPubKey The connected scriptPubKey containing the conditions needed to claim the value.
     ; @deprecated Use {@link #correctlySpends(org.bitcoinj.core.Transaction, long, org.bitcoinj.script.Script, java.util.Set)}
     ; instead so that verification flags do not change as new verification options are added.
     ;;
    #_deprecated
    #_public
    (§ method void correctlySpends(Transaction txContainingThis, long scriptSigIndex, Script scriptPubKey))
        (§ throws ScriptException)
    (ß
        (§ call correctlySpends(txContainingThis, scriptSigIndex, scriptPubKey, ALL_VERIFY_FLAGS))
    )

    ;;;
     ; Verifies that this script (interpreted as a scriptSig) correctly spends the given scriptPubKey.
     ; @param txContainingThis The transaction in which this input scriptSig resides.
     ;                         Accessing txContainingThis from another thread while this method runs results in undefined behavior.
     ; @param scriptSigIndex The index in txContainingThis of the scriptSig (note: NOT the index of the scriptPubKey).
     ; @param scriptPubKey The connected scriptPubKey containing the conditions needed to claim the value.
     ; @param verifyFlags Each flag enables one validation rule.  If in doubt, use {@link #correctlySpends(Transaction, long, Script)}
     ;                    which sets all flags.
     ;;
    #_public
    (§ method void correctlySpends(Transaction txContainingThis, long scriptSigIndex, Script scriptPubKey, Set<VerifyFlag> verifyFlags))
        (§ throws ScriptException)
    (ß
        ;; Clone the transaction because executing the script involves editing it, and if we die, we'll leave
        ;; the tx half broken (also it's not so thread safe to work on it directly).
        (§ try)
        (ß
            (§ ass txContainingThis = txContainingThis.getParams().getDefaultSerializer().makeTransaction(txContainingThis.bitcoinSerialize()))
        )
        (§ catch (ProtocolException e))
        (ß
            (§ throw new RuntimeException(e)) ;; Should not happen unless we were given a totally broken transaction.
        )

        (§ if (MAX_SCRIPT_SIZE < getProgram().length || MAX_SCRIPT_SIZE < scriptPubKey.getProgram().length))
            (§ throw new ScriptException(ScriptError.SCRIPT_ERR_SCRIPT_SIZE, "Script larger than 10,000 bytes"))

        (§ var LinkedList<byte[]> stack = new LinkedList<>())
        (§ var LinkedList<byte[]> p2shStack = nil)

        (§ call executeScript(txContainingThis, scriptSigIndex, this, stack, verifyFlags))
        (§ if (verifyFlags.contains(VerifyFlag.P2SH)))
            (§ ass p2shStack = new LinkedList<>(stack))
        (§ call executeScript(txContainingThis, scriptSigIndex, scriptPubKey, stack, verifyFlags))

        (§ if (stack.size() == 0))
            (§ throw new ScriptException(ScriptError.SCRIPT_ERR_EVAL_FALSE, "Stack empty at end of script execution."))

        (§ if (!castToBool(stack.pollLast())))
            (§ throw new ScriptException(ScriptError.SCRIPT_ERR_EVAL_FALSE, "Script resulted in a non-true stack: " + stack))

        ;; P2SH is pay to script hash.  It means that the scriptPubKey has a special form which is a valid
        ;; program but it has "useless" form that if evaluated as a normal program always returns true.
        ;; Instead, miners recognize it as special based on its template - it provides a hash of the real scriptPubKey
        ;; and that must be provided by the input.  The goal of this bizarre arrangement is twofold:
        ;;
        ;; (1) You can sum up a large, complex script (like a CHECKMULTISIG script) with an address that's the same
        ;;     size as a regular address.  This means it doesn't overload scannable QR codes/NFC tags or become
        ;;     un-wieldy to copy/paste.
        ;; (2) It allows the working set to be smaller: nodes perform best when they can store as many unspent outputs
        ;;     in RAM as possible, so if the outputs are made smaller and the inputs get bigger, then it's better for
        ;;     overall scalability and performance.

        ;; TODO: Check if we can take out enforceP2SH if there's a checkpoint at the enforcement block.
        (§ if (verifyFlags.contains(VerifyFlag.P2SH) && scriptPubKey.isPayToScriptHash()))
        (ß
            (§ for (ScriptChunk chunk :for chunks))
                (§ if (chunk.isOpCode() && OP_16 < chunk.opcode))
                    (§ throw new ScriptException(ScriptError.SCRIPT_ERR_SIG_PUSHONLY, "Attempted to spend a P2SH scriptPubKey with a script that contained script ops"))

            (§ var byte[] scriptPubKeyBytes = p2shStack.pollLast())
            (§ var Script scriptPubKeyP2SH = new Script(scriptPubKeyBytes))

            (§ call executeScript(txContainingThis, scriptSigIndex, scriptPubKeyP2SH, p2shStack, verifyFlags))

            (§ if (p2shStack.size() == 0))
                (§ throw new ScriptException(ScriptError.SCRIPT_ERR_EVAL_FALSE, "P2SH stack empty at end of script execution."))

            (§ if (!castToBool(p2shStack.pollLast())))
                (§ throw new ScriptException(ScriptError.SCRIPT_ERR_EVAL_FALSE, "P2SH script execution resulted in a non-true stack"))
        )
    )

    ;; Utility that doesn't copy for internal use.
    #_private
    (§ method byte[] getQuickProgram())
    (ß
        (§ return (program != nil) ? program :else getProgram())
    )

    ;;;
     ; Get the {@link org.bitcoinj.script.Script.ScriptType}.
     ; @return The script type.
     ;;
    #_public
    (§ method ScriptType getScriptType())
    (ß
        (§ if (isSentToAddress()))
            (§ return ScriptType.P2PKH)
        (§ if (isSentToRawPubKey()))
            (§ return ScriptType.PUB_KEY)
        (§ if (isPayToScriptHash()))
            (§ return ScriptType.P2SH)

        (§ return ScriptType.NO_TYPE)
    )

    #_override
    #_public
    (§ method boolean equals(Object o))
    (ß
        (§ if (this == o))
            (§ return true)
        (§ if (o == nil || getClass() != o.getClass()))
            (§ return false)
        (§ return Arrays.equals(getQuickProgram(), ((Script)o).getQuickProgram()))
    )

    #_override
    #_public
    (§ method int hashCode())
    (ß
        (§ return Arrays.hashCode(getQuickProgram()))
    )
)

#_(ns org.bitcoinj.script #_"ScriptBuilder"
    (:import [java.math BigInteger]
             [java.util ArrayList Arrays Collections List Stack])
    (:import [com.google.common.base Preconditions]
             [com.google.common.collect Lists])
  #_(:require [org.bitcoinj.core Address ECKey Utils]
             [org.bitcoinj.crypto TransactionSignature]
             #_static #_[org.bitcoinj.script.ScriptOpCodes *]))

;;;
 ; <p>Tools for the construction of commonly used script types.  You don't normally need this as it's hidden
 ; behind convenience methods on {@link org.bitcoinj.core.Transaction}, but they are useful when working with
 ; the protocol at a lower level.</p>
 ;;
#_public
(§ class ScriptBuilder
    #_private
    (§ field List<ScriptChunk> chunks)

    ;;; Creates a fresh ScriptBuilder with an empty program. ;;
    #_public
    (§ constructor ScriptBuilder())
    (ß
        (§ ass chunks = Lists.newLinkedList())
    )

    ;;; Creates a fresh ScriptBuilder with the given program as the starting point. ;;
    #_public
    (§ constructor ScriptBuilder(Script template))
    (ß
        (§ ass chunks = new ArrayList<>(template.getChunks()))
    )

    ;;; Adds the given chunk to the end of the program. ;;
    #_public
    (§ method ScriptBuilder addChunk(ScriptChunk chunk))
    (ß
        (§ return addChunk(chunks.size(), chunk))
    )

    ;;; Adds the given chunk at the given index in the program. ;;
    #_public
    (§ method ScriptBuilder addChunk(int index, ScriptChunk chunk))
    (ß
        (§ call chunks.add(index, chunk))
        (§ return this)
    )

    ;;; Adds the given opcode to the end of the program. ;;
    #_public
    (§ method ScriptBuilder op(int opcode))
    (ß
        (§ return op(chunks.size(), opcode))
    )

    ;;; Adds the given opcode to the given index in the program. ;;
    #_public
    (§ method ScriptBuilder op(int index, int opcode))
    (ß
        (§ call Preconditions.checkArgument(OP_PUSHDATA4 < opcode))
        (§ return addChunk(index, new ScriptChunk(opcode, nil)))
    )

    ;;; Adds a copy of the given byte array as a data element (i.e. PUSHDATA) at the end of the program. ;;
    #_public
    (§ method ScriptBuilder data(byte[] data))
    (ß
        (§ return (data.length == 0) ? smallNum(0) :else data(chunks.size(), data))
    )

    ;;; Adds a copy of the given byte array as a data element (i.e. PUSHDATA) at the given index in the program. ;;
    #_public
    (§ method ScriptBuilder data(int index, byte[] data))
    (ß
        ;; implements BIP62
        (§ var byte[] copy = Arrays.copyOf(data, data.length))
        (§ var int opcode)
        (§ if (data.length == 0))
        (ß
            (§ ass opcode = OP_0)
        )
        (§ elseif (data.length == 1))
        (ß
            (§ var byte b = data[0])
            (§ if (1 <= b && b <= 16))
                (§ ass opcode = Script.encodeToOpN(b))
            (§ else)
                (§ ass opcode = 1)
        )
        (§ elseif (data.length < OP_PUSHDATA1))
        (ß
            (§ ass opcode = data.length)
        )
        (§ elseif (data.length < 256))
        (ß
            (§ ass opcode = OP_PUSHDATA1)
        )
        (§ elseif (data.length < 65536))
        (ß
            (§ ass opcode = OP_PUSHDATA2)
        )
        (§ else)
        (ß
            (§ throw new RuntimeException("Unimplemented"))
        )
        (§ return addChunk(index, new ScriptChunk(opcode, copy)))
    )

    ;;;
     ; Adds the given number to the end of the program.
     ; Automatically uses shortest encoding possible.
     ;;
    #_public
    (§ method ScriptBuilder number(long num))
    (ß
        (§ return (0 <= num && num <= 16) ? smallNum((int)num) :else bigNum(num))
    )

    ;;;
     ; Adds the given number to the given index in the program.
     ; Automatically uses shortest encoding possible.
     ;;
    #_public
    (§ method ScriptBuilder number(int index, long num))
    (ß
        (§ return (0 <= num && num <= 16) ? smallNum(index, (int)num) :else bigNum(index, num))
    )

    ;;;
     ; Adds the given number as a OP_N opcode to the end of the program.
     ; Only handles values 0-16 inclusive.
     ;
     ; @see #number(int)
     ;;
    #_public
    (§ method ScriptBuilder smallNum(int num))
    (ß
        (§ return smallNum(chunks.size(), num))
    )

    ;;; Adds the given number as a push data chunk.
     ; This is intended to use for negative numbers or values > 16, and although
     ; it will accept numbers in the range 0-16 inclusive, the encoding would be
     ; considered non-standard.
     ;
     ; @see #number(int)
     ;;
    #_protected
    (§ method ScriptBuilder bigNum(long num))
    (ß
        (§ return bigNum(chunks.size(), num))
    )

    ;;;
     ; Adds the given number as a OP_N opcode to the given index in the program.
     ; Only handles values 0-16 inclusive.
     ;
     ; @see #number(int)
     ;;
    #_public
    (§ method ScriptBuilder smallNum(int index, int num))
    (ß
        (§ call Preconditions.checkArgument(0 <= num, "Cannot encode negative numbers with smallNum"))
        (§ call Preconditions.checkArgument(num <= 16, "Cannot encode numbers larger than 16 with smallNum"))

        (§ return addChunk(index, new ScriptChunk(Script.encodeToOpN(num), nil)))
    )

    ;;;
     ; Adds the given number as a push data chunk to the given index in the program.
     ; This is intended to use for negative numbers or values > 16, and although
     ; it will accept numbers in the range 0-16 inclusive, the encoding would be
     ; considered non-standard.
     ;
     ; @see #number(int)
     ;;
    #_protected
    (§ method ScriptBuilder bigNum(int index, long num))
    (ß
        #_final
        (§ var byte[] data)

        (§ if (num == 0))
        (ß
            (§ ass data = new byte[0])
        )
        (§ else)
        (ß
            (§ var Stack<Byte> result = new Stack<>())
            #_final
            (§ var boolean neg = num < 0)
            (§ var long absvalue = Math.abs(num))

            (§ while (absvalue != 0))
            (ß
                (§ call result.push((byte)(absvalue & 0xff)))
                (§ ass absvalue = absvalue >> 8)
            )

            (§ if ((result.peek() & 0x80) != 0))
            (ß
                ;; The most significant byte is >= 0x80, so push an extra byte that
                ;; contains just the sign of the value.
                (§ call result.push((byte)(neg ? 0x80 :else 0)))
            )
            (§ elseif (neg))
            (ß
                ;; The most significant byte is < 0x80 and the value is negative,
                ;; set the sign bit so it is subtracted and interpreted as a
                ;; negative when converting back to an integral.
                (§ call result.push((byte)(result.pop() | 0x80)))
            )

            (§ ass data = new byte[result.size()])
            (§ for (int byteIdx = 0 :for byteIdx < data.length :for byteIdx = byteIdx + 1))
                (§ ass data[byteIdx] = result.get(byteIdx))
        )

        ;; At most the encoded value could take up to 8 bytes, so we don't need
        ;; to use OP_PUSHDATA opcodes.
        (§ return addChunk(index, new ScriptChunk(data.length, data)))
    )

    ;;; Creates a new immutable Script based on the state of the builder. ;;
    #_public
    (§ method Script build())
    (ß
        (§ return new Script(chunks))
    )

    ;;; Creates a scriptPubKey that encodes payment to the given address. ;;
    #_public
    #_static
    (§ method Script createOutputScript(Address to))
    (ß
        (§ if (to.isP2SHAddress()))
        (ß
            ;; OP_HASH160 <scriptHash> OP_EQUAL
            (§ return new ScriptBuilder().op(OP_HASH160).data(to.getHash160()).op(OP_EQUAL).build())
        )
        (§ else)
        (ß
            ;; OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG
            (§ return new ScriptBuilder().op(OP_DUP).op(OP_HASH160).data(to.getHash160()).op(OP_EQUALVERIFY).op(OP_CHECKSIG).build())
        )
    )

    ;;; Creates a scriptPubKey that encodes payment to the given raw public key. ;;
    #_public
    #_static
    (§ method Script createOutputScript(ECKey key))
    (ß
        (§ return new ScriptBuilder().data(key.getPubKey()).op(OP_CHECKSIG).build())
    )

    ;;;
     ; Creates a scriptSig that can redeem a pay-to-address output.
     ; If given signature is null, incomplete scriptSig will be created with OP_0 instead of signature.
     ;;
    #_public
    #_static
    (§ method Script createInputScript(#_nilable TransactionSignature signature, ECKey pubKey))
    (ß
        (§ var byte[] pubkeyBytes = pubKey.getPubKey())
        (§ var byte[] sigBytes = (signature != nil) ? signature.encodeToBitcoin() :else new byte[] (ß ))
        (§ return new ScriptBuilder().data(sigBytes).data(pubkeyBytes).build())
    )

    ;;;
     ; Creates a scriptSig that can redeem a pay-to-pubkey output.
     ; If given signature is null, incomplete scriptSig will be created with OP_0 instead of signature.
     ;;
    #_public
    #_static
    (§ method Script createInputScript(#_nilable TransactionSignature signature))
    (ß
        (§ var byte[] sigBytes = (signature != nil) ? signature.encodeToBitcoin() :else new byte[] (ß ))
        (§ return new ScriptBuilder().data(sigBytes).build())
    )

    ;;; Creates a program that requires at least N of the given keys to sign, using OP_CHECKMULTISIG. ;;
    #_public
    #_static
    (§ method Script createMultiSigOutputScript(int threshold, List<ECKey> pubkeys))
    (ß
        (§ call Preconditions.checkArgument(0 < threshold))
        (§ call Preconditions.checkArgument(threshold <= pubkeys.size()))
        (§ call Preconditions.checkArgument(pubkeys.size() <= 16)) ;; That's the max we can represent with a single opcode.

        (§ var ScriptBuilder builder = new ScriptBuilder())
        (§ call builder.smallNum(threshold))
        (§ for (ECKey key :for pubkeys))
            (§ call builder.data(key.getPubKey()))
        (§ call builder.smallNum(pubkeys.size()))
        (§ call builder.op(OP_CHECKMULTISIG))
        (§ return builder.build())
    )

    ;;; Create a program that satisfies an OP_CHECKMULTISIG program. ;;
    #_public
    #_static
    (§ method Script createMultiSigInputScript(List<TransactionSignature> signatures))
    (ß
        (§ var List<byte[]> sigs = new ArrayList<>(signatures.size()))
        (§ for (TransactionSignature signature :for signatures))
            (§ call sigs.add(signature.encodeToBitcoin()))

        (§ return createMultiSigInputScriptBytes(sigs, nil))
    )

    ;;; Create a program that satisfies an OP_CHECKMULTISIG program. ;;
    #_public
    #_static
    (§ method Script createMultiSigInputScript(TransactionSignature... signatures))
    (ß
        (§ return createMultiSigInputScript(Arrays.asList(signatures)))
    )

    ;;; Create a program that satisfies an OP_CHECKMULTISIG program, using pre-encoded signatures. ;;
    #_public
    #_static
    (§ method Script createMultiSigInputScriptBytes(List<byte[]> signatures))
    (ß
        (§ return createMultiSigInputScriptBytes(signatures, nil))
    )

    ;;;
     ; Create a program that satisfies a pay-to-script hashed OP_CHECKMULTISIG program.
     ; If given signature list is null, incomplete scriptSig will be created with OP_0 instead of signatures.
     ;;
    #_public
    #_static
    (§ method Script createP2SHMultiSigInputScript(#_nilable List<TransactionSignature> signatures, Script multisigProgram))
    (ß
        (§ var List<byte[]> sigs = new ArrayList<>())
        (§ if (signatures == nil))
        (ß
            ;; Create correct number of empty signatures.
            (§ var int numSigs = multisigProgram.getNumberOfSignaturesRequiredToSpend())
            (§ for (int i = 0 :for i < numSigs :for i = i + 1))
                (§ call sigs.add(new byte[] (ß )))
        )
        (§ else)
        (ß
            (§ for (TransactionSignature signature :for signatures))
                (§ call sigs.add(signature.encodeToBitcoin()))
        )
        (§ return createMultiSigInputScriptBytes(sigs, multisigProgram.getProgram()))
    )

    ;;;
     ; Create a program that satisfies an OP_CHECKMULTISIG program, using pre-encoded signatures.
     ; Optionally, appends the script program bytes if spending a P2SH output.
     ;;
    #_public
    #_static
    (§ method Script createMultiSigInputScriptBytes(List<byte[]> signatures, #_nilable byte[] multisigProgramBytes))
    (ß
        (§ call Preconditions.checkArgument(signatures.size() <= 16))

        (§ var ScriptBuilder builder = new ScriptBuilder())
        (§ call builder.smallNum(0)) ;; Work around a bug in CHECKMULTISIG that is now a required part of the protocol.
        (§ for (byte[] signature :for signatures))
            (§ call builder.data(signature))
        (§ if (multisigProgramBytes!= nil))
            (§ call builder.data(multisigProgramBytes))
        (§ return builder.build())
    )

    ;;;
     ; Returns a copy of the given scriptSig with the signature inserted in the given position.
     ;
     ; This function assumes that any missing sigs have OP_0 placeholders.  If given scriptSig
     ; already has all the signatures in place, IllegalArgumentException will be thrown.
     ;
     ; @param targetIndex Where to insert the signature.
     ; @param sigsPrefixCount How many items to copy verbatim (e.g. initial OP_0 for multisig).
     ; @param sigsSuffixCount How many items to copy verbatim at end (e.g. redeemScript for P2SH).
     ;;
    #_public
    #_static
    (§ method Script updateScriptWithSignature(Script scriptSig, byte[] signature, int targetIndex, int sigsPrefixCount, int sigsSuffixCount))
    (ß
        (§ var List<ScriptChunk> inputChunks = scriptSig.getChunks())
        (§ var int totalChunks = inputChunks.size())

        ;; Check if we have a place to insert, otherwise just return given scriptSig unchanged.
        ;; We assume here that OP_0 placeholders always go after the sigs, so
        ;; to find if we have sigs missing, we can just check the chunk in latest sig position.
        (§ var boolean hasMissingSigs = inputChunks.get(totalChunks - sigsSuffixCount - 1).equalsOpCode(OP_0))
        (§ call Preconditions.checkArgument(hasMissingSigs, "ScriptSig is already filled with signatures"))

        ;; copy the prefix
        (§ var ScriptBuilder builder = new ScriptBuilder())
        (§ for (ScriptChunk chunk :for inputChunks.subList(0, sigsPrefixCount)))
            (§ call builder.addChunk(chunk))

        ;; Copy the sigs.
        (§ var int pos = 0)
        (§ var boolean inserted = false)
        (§ for (ScriptChunk chunk :for inputChunks.subList(sigsPrefixCount, totalChunks - sigsSuffixCount)))
        (ß
            (§ if (pos == targetIndex))
            (ß
                (§ ass inserted = true)
                (§ call builder.data(signature))
                (§ ass pos = pos + 1)
            )
            (§ if (!chunk.equalsOpCode(OP_0)))
            (ß
                (§ call builder.addChunk(chunk))
                (§ ass pos = pos + 1)
            )
        )

        ;; Add OP_0's if needed, since we skipped them in the previous loop.
        (§ while (pos < totalChunks - sigsPrefixCount - sigsSuffixCount))
        (ß
            (§ if (pos == targetIndex))
            (ß
                (§ ass inserted = true)
                (§ call builder.data(signature))
            )
            (§ else)
            (ß
                (§ call builder.addChunk(new ScriptChunk(OP_0, nil)))
            )
            (§ ass pos = pos + 1)
        )

        ;; Copy the suffix.
        (§ for (ScriptChunk chunk :for inputChunks.subList(totalChunks - sigsSuffixCount, totalChunks)))
            (§ call builder.addChunk(chunk))

        (§ call Preconditions.checkState(inserted))
        (§ return builder.build())
    )

    ;;;
     ; Creates a scriptPubKey that sends to the given script hash.  Read
     ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki">BIP 16</a>
     ; to learn more about this kind of script.
     ;;
    #_public
    #_static
    (§ method Script createP2SHOutputScript(byte[] hash))
    (ß
        (§ call Preconditions.checkArgument(hash.length == 20))

        (§ return new ScriptBuilder().op(OP_HASH160).data(hash).op(OP_EQUAL).build())
    )

    ;;;
     ; Creates a scriptPubKey for the given redeem script.
     ;;
    #_public
    #_static
    (§ method Script createP2SHOutputScript(Script redeemScript))
    (ß
        (§ var byte[] hash = Utils.sha256hash160(redeemScript.getProgram()))
        (§ return ScriptBuilder.createP2SHOutputScript(hash))
    )

    ;;;
     ; Creates a P2SH output script with given public keys and threshold.
     ; Given public keys will be placed in redeem script in the lexicographical sorting order.
     ;;
    #_public
    #_static
    (§ method Script createP2SHOutputScript(int threshold, List<ECKey> pubkeys))
    (ß
        (§ var Script redeemScript = createRedeemScript(threshold, pubkeys))
        (§ return createP2SHOutputScript(redeemScript))
    )

    ;;;
     ; Creates redeem script with given public keys and threshold.
     ; Given public keys will be placed in redeem script in the lexicographical sorting order.
     ;;
    #_public
    #_static
    (§ method Script createRedeemScript(int threshold, List<ECKey> pubkeys))
    (ß
        (§ ass pubkeys = new ArrayList<>(pubkeys))
        (§ call Collections.sort(pubkeys, ECKey.PUBKEY_COMPARATOR))
        (§ return ScriptBuilder.createMultiSigOutputScript(threshold, pubkeys))
    )

    ;;;
     ; Creates a script of the form OP_RETURN [data].  This feature allows you to attach
     ; a small piece of data (like a hash of something stored elsewhere) to a zero valued
     ; output which can never be spent and thus does not pollute the ledger.
     ;;
    #_public
    #_static
    (§ method Script createOpReturnScript(byte[] data))
    (ß
        (§ call Preconditions.checkArgument(data.length <= 80))

        (§ return new ScriptBuilder().op(OP_RETURN).data(data).build())
    )

    #_public
    #_static
    (§ method Script createCLTVPaymentChannelOutput(BigInteger time, ECKey from, ECKey to))
    (ß
        (§ var byte[] timeBytes = Utils.reverseBytes(Utils.encodeMPI(time, false)))
        (§ if (5 < timeBytes.length))
            (§ throw new RuntimeException("Time too large to encode as 5-byte int"))

        (§ return new ScriptBuilder().op(OP_IF).data(to.getPubKey()).op(OP_CHECKSIGVERIFY).op(OP_ELSE).data(timeBytes).op(OP_CHECKLOCKTIMEVERIFY).op(OP_DROP).op(OP_ENDIF).data(from.getPubKey()).op(OP_CHECKSIG).build())
    )

    #_public
    #_static
    (§ method Script createCLTVPaymentChannelRefund(TransactionSignature signature))
    (ß
        (§ var ScriptBuilder builder = new ScriptBuilder())
        (§ call builder.data(signature.encodeToBitcoin()))
        (§ call builder.data(new byte[] (ß 0 ))) ;; Use the CHECKLOCKTIMEVERIFY if branch.
        (§ return builder.build())
    )

    #_public
    #_static
    (§ method Script createCLTVPaymentChannelP2SHRefund(TransactionSignature signature, Script redeemScript))
    (ß
        (§ var ScriptBuilder builder = new ScriptBuilder())
        (§ call builder.data(signature.encodeToBitcoin()))
        (§ call builder.data(new byte[] (ß 0 ))) ;; Use the CHECKLOCKTIMEVERIFY if branch.
        (§ call builder.data(redeemScript.getProgram()))
        (§ return builder.build())
    )

    #_public
    #_static
    (§ method Script createCLTVPaymentChannelP2SHInput(byte[] from, byte[] to, Script redeemScript))
    (ß
        (§ var ScriptBuilder builder = new ScriptBuilder())
        (§ call builder.data(from))
        (§ call builder.data(to))
        (§ call builder.smallNum(1)) ;; Use the CHECKLOCKTIMEVERIFY if branch.
        (§ call builder.data(redeemScript.getProgram()))
        (§ return builder.build())
    )

    #_public
    #_static
    (§ method Script createCLTVPaymentChannelInput(TransactionSignature from, TransactionSignature to))
    (ß
        (§ return createCLTVPaymentChannelInput(from.encodeToBitcoin(), to.encodeToBitcoin()))
    )

    #_public
    #_static
    (§ method Script createCLTVPaymentChannelInput(byte[] from, byte[] to))
    (ß
        (§ var ScriptBuilder builder = new ScriptBuilder())
        (§ call builder.data(from))
        (§ call builder.data(to))
        (§ call builder.smallNum(1)) ;; Use the CHECKLOCKTIMEVERIFY if branch.
        (§ return builder.build())
    )
)

#_(ns org.bitcoinj.script #_"ScriptChunk"
    (:import [java.io IOException OutputStream]
             [java.util Arrays])
    (:import [com.google.common.base Objects Preconditions])
  #_(:require [org.bitcoinj.core Utils]
             #_static #_[org.bitcoinj.script.ScriptOpCodes *]))

;;;
 ; A script element that is either a data push (signature, pubkey, etc.) or a non-push (logic, numeric, etc.) operation.
 ;;
#_public
(§ class ScriptChunk
    ;;; Operation to be executed.  Opcodes are defined in {@link ScriptOpCodes}. ;;
    #_public
    #_final
    (§ field int opcode)
    ;;;
     ; For push operations, this is the vector to be pushed on the stack.
     ; For {@link ScriptOpCodes#OP_0}, the vector is empty.
     ; Null for non-push operations.
     ;;
    #_nilable
    #_public
    #_final
    (§ field byte[] data)
    #_private
    (§ field int startLocationInProgram)

    #_public
    (§ constructor ScriptChunk(int opcode, byte[] data))
    (ß
        (§ this (opcode, data, -1))
    )

    #_public
    (§ constructor ScriptChunk(int opcode, byte[] data, int startLocationInProgram))
    (ß
        (§ ass this.opcode = opcode)
        (§ ass this.data = data)
        (§ ass this.startLocationInProgram = startLocationInProgram)
    )

    #_public
    (§ method boolean equalsOpCode(int opcode))
    (ß
        (§ return (opcode == this.opcode))
    )

    ;;;
     ; If this chunk is a single byte of non-pushdata content (could be OP_RESERVED or some invalid Opcode).
     ;;
    #_public
    (§ method boolean isOpCode())
    (ß
        (§ return (OP_PUSHDATA4 < opcode))
    )

    ;;;
     ; Returns true if this chunk is pushdata content, including the single-byte pushdatas.
     ;;
    #_public
    (§ method boolean isPushData())
    (ß
        (§ return (opcode <= OP_16))
    )

    #_public
    (§ method int getStartLocationInProgram())
    (ß
        (§ call Preconditions.checkState(0 <= startLocationInProgram))

        (§ return startLocationInProgram)
    )

    ;;; If this chunk is an OP_N opcode returns the equivalent integer value. ;;
    #_public
    (§ method int decodeOpN())
    (ß
        (§ call Preconditions.checkState(isOpCode()))

        (§ return Script.decodeFromOpN(opcode))
    )

    ;;;
     ; Called on a pushdata chunk, returns true if it uses the smallest possible way (according to BIP62) to push the data.
     ;;
    #_public
    (§ method boolean isShortestPossiblePushData())
    (ß
        (§ call Preconditions.checkState(isPushData()))

        (§ if (data == nil))
            (§ return true) ;; OP_N
        (§ if (data.length == 0))
            (§ return opcode == OP_0)
        (§ if (data.length == 1))
        (ß
            (§ var byte b = data[0])
            (§ if (0x01 <= b && b <= 0x10))
                (§ return (opcode == OP_1 + b - 1))
            (§ if ((b & 0xFF) == 0x81))
                (§ return (opcode == OP_1NEGATE))
        )
        (§ if (data.length < OP_PUSHDATA1))
            (§ return opcode == data.length)
        (§ if (data.length < 256))
            (§ return opcode == OP_PUSHDATA1)
        (§ if (data.length < 65536))
            (§ return opcode == OP_PUSHDATA2)

        ;; Can never be used, but implemented for completeness.
        (§ return (opcode == OP_PUSHDATA4))
    )

    #_public
    (§ method void write(OutputStream stream))
        (§ throws IOException)
    (ß
        (§ if (isOpCode()))
        (ß
            (§ call Preconditions.checkState(data == nil))
            (§ call stream.write(opcode))
        )
        (§ elseif (data != nil))
        (ß
            (§ if (opcode < OP_PUSHDATA1))
            (ß
                (§ call Preconditions.checkState(data.length == opcode))
                (§ call stream.write(opcode))
            )
            (§ elseif (opcode == OP_PUSHDATA1))
            (ß
                (§ call Preconditions.checkState(data.length <= 0xff))
                (§ call stream.write(OP_PUSHDATA1))
                (§ call stream.write(data.length))
            )
            (§ elseif (opcode == OP_PUSHDATA2))
            (ß
                (§ call Preconditions.checkState(data.length <= 0xffff))
                (§ call stream.write(OP_PUSHDATA2))
                (§ call stream.write(0xff & data.length))
                (§ call stream.write(0xff & (data.length >> 8)))
            )
            (§ elseif (opcode == OP_PUSHDATA4))
            (ß
                (§ call Preconditions.checkState(data.length <= Script.MAX_SCRIPT_ELEMENT_SIZE))
                (§ call stream.write(OP_PUSHDATA4))
                (§ call Utils.uint32ToByteStreamLE(data.length, stream))
            )
            (§ else)
            (ß
                (§ throw new RuntimeException("Unimplemented"))
            )
            (§ call stream.write(data))
        )
        (§ else)
        (ß
            (§ call stream.write(opcode)) ;; smallNum
        )
    )

    #_override
    #_public
    (§ method String toString())
    (ß
        (§ var StringBuilder sb = new StringBuilder())
        (§ if (isOpCode()))
            (§ call sb.append(getOpCodeName(opcode)))
        (§ elseif (data != nil)) ;; Data chunk.
            (§ call sb.append(getPushDataName(opcode)).append("[").append(Utils.HEX.encode(data)).append("]"))
        (§ else) ;; Small num.
            (§ call sb.append(Script.decodeFromOpN(opcode)))
        (§ return sb.toString())
    )

    #_override
    #_public
    (§ method boolean equals(Object o))
    (ß
        (§ if (this == o))
            (§ return true)
        (§ if (o == nil || getClass() != o.getClass()))
            (§ return false)
        (§ var ScriptChunk other = (ScriptChunk)o)
        (§ return (opcode == other.opcode && startLocationInProgram == other.startLocationInProgram && Arrays.equals(data, other.data)))
    )

    #_override
    #_public
    (§ method int hashCode())
    (ß
        (§ return Objects.hashCode(opcode, startLocationInProgram, Arrays.hashCode(data)))
    )
)

#_(ns org.bitcoinj.script #_"ScriptError"
    (:import [java.util HashMap Map]))

#_public
(§ enum ScriptError
    (§ item SCRIPT_ERR_OK("OK"))
    (§ item SCRIPT_ERR_UNKNOWN_ERROR("UNKNOWN_ERROR"))
    (§ item SCRIPT_ERR_EVAL_FALSE("EVAL_FALSE"))
    (§ item SCRIPT_ERR_OP_RETURN("OP_RETURN"))

    ;;;max sizes ;;
    (§ item SCRIPT_ERR_SCRIPT_SIZE("SCRIPT_SIZE"))
    (§ item SCRIPT_ERR_PUSH_SIZE("PUSH_SIZE"))
    (§ item SCRIPT_ERR_OP_COUNT("OP_COUNT"))
    (§ item SCRIPT_ERR_STACK_SIZE("STACK_SIZE"))
    (§ item SCRIPT_ERR_SIG_COUNT("SIG_COUNT"))
    (§ item SCRIPT_ERR_PUBKEY_COUNT("PUBKEY_COUNT"))

    ;;;failed verify operations ;;
    (§ item SCRIPT_ERR_VERIFY("VERIFY"))
    (§ item SCRIPT_ERR_EQUALVERIFY("EQUALVERIFY"))
    (§ item SCRIPT_ERR_CHECKMULTISIGVERIFY("CHECKMULTISIGVERIFY"))
    (§ item SCRIPT_ERR_CHECKSIGVERIFY("CHECKSIGVERIFY"))
    (§ item SCRIPT_ERR_NUMEQUALVERIFY("NUMEQUALVERIFY"))

    ;;;logical/format/canonical errors ;;
    (§ item SCRIPT_ERR_BAD_OPCODE("BAD_OPCODE"))
    (§ item SCRIPT_ERR_DISABLED_OPCODE("DISABLED_OPCODE"))
    (§ item SCRIPT_ERR_INVALID_STACK_OPERATION("INVALID_STACK_OPERATION"))
    (§ item SCRIPT_ERR_INVALID_ALTSTACK_OPERATION("INVALID_ALTSTACK_OPERATION"))
    (§ item SCRIPT_ERR_UNBALANCED_CONDITIONAL("UNBALANCED_CONDITIONAL"))

    ;;;CHECKLOCKTIMEVERIFY and CHECKSEQUENCEVERIFY ;;
    (§ item SCRIPT_ERR_NEGATIVE_LOCKTIME("NEGATIVE_LOCKTIME"))
    (§ item SCRIPT_ERR_UNSATISFIED_LOCKTIME("UNSATISFIED_LOCKTIME"))

    ;;;malleability ;;
    (§ item SCRIPT_ERR_SIG_HASHTYPE("SIG_HASHTYPE"))
    (§ item SCRIPT_ERR_SIG_DER("SIG_DER"))
    (§ item SCRIPT_ERR_MINIMALDATA("MINIMALDATA"))
    (§ item SCRIPT_ERR_SIG_PUSHONLY("SIG_PUSHONLY"))
    (§ item SCRIPT_ERR_SIG_HIGH_S("SIG_HIGH_S"))
    (§ item SCRIPT_ERR_SIG_NULLDUMMY("SIG_NULLDUMMY"))
    (§ item SCRIPT_ERR_PUBKEYTYPE("PUBKEYTYPE"))
    (§ item SCRIPT_ERR_CLEANSTACK("CLEANSTACK"))
    (§ item SCRIPT_ERR_MINIMALIF("MINIMALIF"))
    (§ item SCRIPT_ERR_SIG_NULLFAIL("NULLFAIL"))

    ;;;softfork safeness ;;
    (§ item SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS("DISCOURAGE_UPGRADABLE_NOPS"))
    (§ item SCRIPT_ERR_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM("DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM"))

    ;;;segregated witness ;;
    (§ item SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH("WITNESS_PROGRAM_WRONG_LENGTH"))
    (§ item SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY("WITNESS_PROGRAM_WITNESS_EMPTY"))
    (§ item SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH("WITNESS_PROGRAM_MISMATCH"))
    (§ item SCRIPT_ERR_WITNESS_MALLEATED("WITNESS_MALLEATED"))
    (§ item SCRIPT_ERR_WITNESS_MALLEATED_P2SH("WITNESS_MALLEATED_P2SH"))
    (§ item SCRIPT_ERR_WITNESS_UNEXPECTED("WITNESS_UNEXPECTED"))
    (§ item SCRIPT_ERR_WITNESS_PUBKEYTYPE("WITNESS_PUBKEYTYPE"))

    (§ item SCRIPT_ERR_ERROR_COUNT("ERROR_COUNT"))

    #_private
    #_final
    (§ field String mnemonic)
    #_private
    #_static
    #_final
    (§ field Map<String, ScriptError> mnemonicToScriptErrorMap)

    #_private
    (§ constructor ScriptError(String name))
    (ß
        (§ ass this.mnemonic = name)
    )

    #_static
    (ß
        (§ ass mnemonicToScriptErrorMap = new HashMap<>())
        (§ for (ScriptError err :for ScriptError.values()))
            (§ call mnemonicToScriptErrorMap.put(err.getMnemonic(), err))
    )

    #_public
    (§ method String getMnemonic())
    (ß
        (§ return mnemonic)
    )

    #_public
    #_static
    (§ method ScriptError fromMnemonic(String name))
    (ß
        (§ var ScriptError err = mnemonicToScriptErrorMap.get(name))
        (§ if (err == nil))
            (§ throw new IllegalArgumentException(name + " is not a valid name"))
        (§ return err)
    )
)

#_(ns org.bitcoinj.script #_"ScriptOpCodes"
    (:import [java.util Map])
    (:import [com.google.common.collect ImmutableMap]))

;;;
 ; Various constants that define the assembly-like scripting language that forms part of the Bitcoin protocol.
 ; See {@link org.bitcoinj.script.Script} for details.  Also provides a method to convert them to a string.
 ;;
#_public
(§ class ScriptOpCodes
    ;; push value
    #_public
    #_static
    #_final
    (§ field int OP_0 = 0x00) ;; push empty vector
    #_public
    #_static
    #_final
    (§ field int OP_FALSE = OP_0)
    #_public
    #_static
    #_final
    (§ field int OP_PUSHDATA1 = 0x4c)
    #_public
    #_static
    #_final
    (§ field int OP_PUSHDATA2 = 0x4d)
    #_public
    #_static
    #_final
    (§ field int OP_PUSHDATA4 = 0x4e)
    #_public
    #_static
    #_final
    (§ field int OP_1NEGATE = 0x4f)
    #_public
    #_static
    #_final
    (§ field int OP_RESERVED = 0x50)
    #_public
    #_static
    #_final
    (§ field int OP_1 = 0x51)
    #_public
    #_static
    #_final
    (§ field int OP_TRUE = OP_1)
    #_public
    #_static
    #_final
    (§ field int OP_2 = 0x52)
    #_public
    #_static
    #_final
    (§ field int OP_3 = 0x53)
    #_public
    #_static
    #_final
    (§ field int OP_4 = 0x54)
    #_public
    #_static
    #_final
    (§ field int OP_5 = 0x55)
    #_public
    #_static
    #_final
    (§ field int OP_6 = 0x56)
    #_public
    #_static
    #_final
    (§ field int OP_7 = 0x57)
    #_public
    #_static
    #_final
    (§ field int OP_8 = 0x58)
    #_public
    #_static
    #_final
    (§ field int OP_9 = 0x59)
    #_public
    #_static
    #_final
    (§ field int OP_10 = 0x5a)
    #_public
    #_static
    #_final
    (§ field int OP_11 = 0x5b)
    #_public
    #_static
    #_final
    (§ field int OP_12 = 0x5c)
    #_public
    #_static
    #_final
    (§ field int OP_13 = 0x5d)
    #_public
    #_static
    #_final
    (§ field int OP_14 = 0x5e)
    #_public
    #_static
    #_final
    (§ field int OP_15 = 0x5f)
    #_public
    #_static
    #_final
    (§ field int OP_16 = 0x60)

    ;; control
    #_public
    #_static
    #_final
    (§ field int OP_NOP = 0x61)
    #_public
    #_static
    #_final
    (§ field int OP_VER = 0x62)
    #_public
    #_static
    #_final
    (§ field int OP_IF = 0x63)
    #_public
    #_static
    #_final
    (§ field int OP_NOTIF = 0x64)
    #_public
    #_static
    #_final
    (§ field int OP_VERIF = 0x65)
    #_public
    #_static
    #_final
    (§ field int OP_VERNOTIF = 0x66)
    #_public
    #_static
    #_final
    (§ field int OP_ELSE = 0x67)
    #_public
    #_static
    #_final
    (§ field int OP_ENDIF = 0x68)
    #_public
    #_static
    #_final
    (§ field int OP_VERIFY = 0x69)
    #_public
    #_static
    #_final
    (§ field int OP_RETURN = 0x6a)

    ;; stack ops
    #_public
    #_static
    #_final
    (§ field int OP_TOALTSTACK = 0x6b)
    #_public
    #_static
    #_final
    (§ field int OP_FROMALTSTACK = 0x6c)
    #_public
    #_static
    #_final
    (§ field int OP_2DROP = 0x6d)
    #_public
    #_static
    #_final
    (§ field int OP_2DUP = 0x6e)
    #_public
    #_static
    #_final
    (§ field int OP_3DUP = 0x6f)
    #_public
    #_static
    #_final
    (§ field int OP_2OVER = 0x70)
    #_public
    #_static
    #_final
    (§ field int OP_2ROT = 0x71)
    #_public
    #_static
    #_final
    (§ field int OP_2SWAP = 0x72)
    #_public
    #_static
    #_final
    (§ field int OP_IFDUP = 0x73)
    #_public
    #_static
    #_final
    (§ field int OP_DEPTH = 0x74)
    #_public
    #_static
    #_final
    (§ field int OP_DROP = 0x75)
    #_public
    #_static
    #_final
    (§ field int OP_DUP = 0x76)
    #_public
    #_static
    #_final
    (§ field int OP_NIP = 0x77)
    #_public
    #_static
    #_final
    (§ field int OP_OVER = 0x78)
    #_public
    #_static
    #_final
    (§ field int OP_PICK = 0x79)
    #_public
    #_static
    #_final
    (§ field int OP_ROLL = 0x7a)
    #_public
    #_static
    #_final
    (§ field int OP_ROT = 0x7b)
    #_public
    #_static
    #_final
    (§ field int OP_SWAP = 0x7c)
    #_public
    #_static
    #_final
    (§ field int OP_TUCK = 0x7d)

    ;; splice ops
    #_public
    #_static
    #_final
    (§ field int OP_CAT = 0x7e)
    #_public
    #_static
    #_final
    (§ field int OP_SUBSTR = 0x7f)
    #_public
    #_static
    #_final
    (§ field int OP_LEFT = 0x80)
    #_public
    #_static
    #_final
    (§ field int OP_RIGHT = 0x81)
    #_public
    #_static
    #_final
    (§ field int OP_SIZE = 0x82)

    ;; bit logic
    #_public
    #_static
    #_final
    (§ field int OP_INVERT = 0x83)
    #_public
    #_static
    #_final
    (§ field int OP_AND = 0x84)
    #_public
    #_static
    #_final
    (§ field int OP_OR = 0x85)
    #_public
    #_static
    #_final
    (§ field int OP_XOR = 0x86)
    #_public
    #_static
    #_final
    (§ field int OP_EQUAL = 0x87)
    #_public
    #_static
    #_final
    (§ field int OP_EQUALVERIFY = 0x88)
    #_public
    #_static
    #_final
    (§ field int OP_RESERVED1 = 0x89)
    #_public
    #_static
    #_final
    (§ field int OP_RESERVED2 = 0x8a)

    ;; numeric
    #_public
    #_static
    #_final
    (§ field int OP_1ADD = 0x8b)
    #_public
    #_static
    #_final
    (§ field int OP_1SUB = 0x8c)
    #_public
    #_static
    #_final
    (§ field int OP_2MUL = 0x8d)
    #_public
    #_static
    #_final
    (§ field int OP_2DIV = 0x8e)
    #_public
    #_static
    #_final
    (§ field int OP_NEGATE = 0x8f)
    #_public
    #_static
    #_final
    (§ field int OP_ABS = 0x90)
    #_public
    #_static
    #_final
    (§ field int OP_NOT = 0x91)
    #_public
    #_static
    #_final
    (§ field int OP_0NOTEQUAL = 0x92)
    #_public
    #_static
    #_final
    (§ field int OP_ADD = 0x93)
    #_public
    #_static
    #_final
    (§ field int OP_SUB = 0x94)
    #_public
    #_static
    #_final
    (§ field int OP_MUL = 0x95)
    #_public
    #_static
    #_final
    (§ field int OP_DIV = 0x96)
    #_public
    #_static
    #_final
    (§ field int OP_MOD = 0x97)
    #_public
    #_static
    #_final
    (§ field int OP_LSHIFT = 0x98)
    #_public
    #_static
    #_final
    (§ field int OP_RSHIFT = 0x99)
    #_public
    #_static
    #_final
    (§ field int OP_BOOLAND = 0x9a)
    #_public
    #_static
    #_final
    (§ field int OP_BOOLOR = 0x9b)
    #_public
    #_static
    #_final
    (§ field int OP_NUMEQUAL = 0x9c)
    #_public
    #_static
    #_final
    (§ field int OP_NUMEQUALVERIFY = 0x9d)
    #_public
    #_static
    #_final
    (§ field int OP_NUMNOTEQUAL = 0x9e)
    #_public
    #_static
    #_final
    (§ field int OP_LESSTHAN = 0x9f)
    #_public
    #_static
    #_final
    (§ field int OP_GREATERTHAN = 0xa0)
    #_public
    #_static
    #_final
    (§ field int OP_LESSTHANOREQUAL = 0xa1)
    #_public
    #_static
    #_final
    (§ field int OP_GREATERTHANOREQUAL = 0xa2)
    #_public
    #_static
    #_final
    (§ field int OP_MIN = 0xa3)
    #_public
    #_static
    #_final
    (§ field int OP_MAX = 0xa4)
    #_public
    #_static
    #_final
    (§ field int OP_WITHIN = 0xa5)

    ;; crypto
    #_public
    #_static
    #_final
    (§ field int OP_RIPEMD160 = 0xa6)
    #_public
    #_static
    #_final
    (§ field int OP_SHA1 = 0xa7)
    #_public
    #_static
    #_final
    (§ field int OP_SHA256 = 0xa8)
    #_public
    #_static
    #_final
    (§ field int OP_HASH160 = 0xa9)
    #_public
    #_static
    #_final
    (§ field int OP_HASH256 = 0xaa)
    #_public
    #_static
    #_final
    (§ field int OP_CODESEPARATOR = 0xab)
    #_public
    #_static
    #_final
    (§ field int OP_CHECKSIG = 0xac)
    #_public
    #_static
    #_final
    (§ field int OP_CHECKSIGVERIFY = 0xad)
    #_public
    #_static
    #_final
    (§ field int OP_CHECKMULTISIG = 0xae)
    #_public
    #_static
    #_final
    (§ field int OP_CHECKMULTISIGVERIFY = 0xaf)

    ;; block state
    ;;; Check lock time of the block.  Introduced in BIP 65, replacing OP_NOP2 ;;
    #_public
    #_static
    #_final
    (§ field int OP_CHECKLOCKTIMEVERIFY = 0xb1)
    #_public
    #_static
    #_final
    (§ field int OP_CHECKSEQUENCEVERIFY = 0xb2)

    ;; expansion
    #_public
    #_static
    #_final
    (§ field int OP_NOP1 = 0xb0)
    ;;; Deprecated by BIP 65 ;;
    #_deprecated
    #_public
    #_static
    #_final
    (§ field int OP_NOP2 = OP_CHECKLOCKTIMEVERIFY)
    ;;; Deprecated by BIP 112 ;;
    #_deprecated
    #_public
    #_static
    #_final
    (§ field int OP_NOP3 = OP_CHECKSEQUENCEVERIFY)
    #_public
    #_static
    #_final
    (§ field int OP_NOP4 = 0xb3)
    #_public
    #_static
    #_final
    (§ field int OP_NOP5 = 0xb4)
    #_public
    #_static
    #_final
    (§ field int OP_NOP6 = 0xb5)
    #_public
    #_static
    #_final
    (§ field int OP_NOP7 = 0xb6)
    #_public
    #_static
    #_final
    (§ field int OP_NOP8 = 0xb7)
    #_public
    #_static
    #_final
    (§ field int OP_NOP9 = 0xb8)
    #_public
    #_static
    #_final
    (§ field int OP_NOP10 = 0xb9)
    #_public
    #_static
    #_final
    (§ field int OP_INVALIDOPCODE = 0xff)

    #_private
    #_static
    #_final
    (§ var Map<Integer, String> opCodeMap = ImmutableMap.<Integer, String>builder().put(OP_0, "0").put(OP_PUSHDATA1, "PUSHDATA1").put(OP_PUSHDATA2, "PUSHDATA2").put(OP_PUSHDATA4, "PUSHDATA4").put(OP_1NEGATE, "1NEGATE").put(OP_RESERVED, "RESERVED").put(OP_1, "1").put(OP_2, "2").put(OP_3, "3").put(OP_4, "4").put(OP_5, "5").put(OP_6, "6").put(OP_7, "7").put(OP_8, "8").put(OP_9, "9").put(OP_10, "10").put(OP_11, "11").put(OP_12, "12").put(OP_13, "13").put(OP_14, "14").put(OP_15, "15").put(OP_16, "16").put(OP_NOP, "NOP").put(OP_VER, "VER").put(OP_IF, "IF").put(OP_NOTIF, "NOTIF").put(OP_VERIF, "VERIF").put(OP_VERNOTIF, "VERNOTIF").put(OP_ELSE, "ELSE").put(OP_ENDIF, "ENDIF").put(OP_VERIFY, "VERIFY").put(OP_RETURN, "RETURN").put(OP_TOALTSTACK, "TOALTSTACK").put(OP_FROMALTSTACK, "FROMALTSTACK").put(OP_2DROP, "2DROP").put(OP_2DUP, "2DUP").put(OP_3DUP, "3DUP").put(OP_2OVER, "2OVER").put(OP_2ROT, "2ROT").put(OP_2SWAP, "2SWAP").put(OP_IFDUP, "IFDUP").put(OP_DEPTH, "DEPTH").put(OP_DROP, "DROP").put(OP_DUP, "DUP").put(OP_NIP, "NIP").put(OP_OVER, "OVER").put(OP_PICK, "PICK").put(OP_ROLL, "ROLL").put(OP_ROT, "ROT").put(OP_SWAP, "SWAP").put(OP_TUCK, "TUCK").put(OP_CAT, "CAT").put(OP_SUBSTR, "SUBSTR").put(OP_LEFT, "LEFT").put(OP_RIGHT, "RIGHT").put(OP_SIZE, "SIZE").put(OP_INVERT, "INVERT").put(OP_AND, "AND").put(OP_OR, "OR").put(OP_XOR, "XOR").put(OP_EQUAL, "EQUAL").put(OP_EQUALVERIFY, "EQUALVERIFY").put(OP_RESERVED1, "RESERVED1").put(OP_RESERVED2, "RESERVED2").put(OP_1ADD, "1ADD").put(OP_1SUB, "1SUB").put(OP_2MUL, "2MUL").put(OP_2DIV, "2DIV").put(OP_NEGATE, "NEGATE").put(OP_ABS, "ABS").put(OP_NOT, "NOT").put(OP_0NOTEQUAL, "0NOTEQUAL").put(OP_ADD, "ADD").put(OP_SUB, "SUB").put(OP_MUL, "MUL").put(OP_DIV, "DIV").put(OP_MOD, "MOD").put(OP_LSHIFT, "LSHIFT").put(OP_RSHIFT, "RSHIFT").put(OP_BOOLAND, "BOOLAND").put(OP_BOOLOR, "BOOLOR").put(OP_NUMEQUAL, "NUMEQUAL").put(OP_NUMEQUALVERIFY, "NUMEQUALVERIFY").put(OP_NUMNOTEQUAL, "NUMNOTEQUAL").put(OP_LESSTHAN, "LESSTHAN").put(OP_GREATERTHAN, "GREATERTHAN").put(OP_LESSTHANOREQUAL, "LESSTHANOREQUAL").put(OP_GREATERTHANOREQUAL, "GREATERTHANOREQUAL").put(OP_MIN, "MIN").put(OP_MAX, "MAX").put(OP_WITHIN, "WITHIN").put(OP_RIPEMD160, "RIPEMD160").put(OP_SHA1, "SHA1").put(OP_SHA256, "SHA256").put(OP_HASH160, "HASH160").put(OP_HASH256, "HASH256").put(OP_CODESEPARATOR, "CODESEPARATOR").put(OP_CHECKSIG, "CHECKSIG").put(OP_CHECKSIGVERIFY, "CHECKSIGVERIFY").put(OP_CHECKMULTISIG, "CHECKMULTISIG").put(OP_CHECKMULTISIGVERIFY, "CHECKMULTISIGVERIFY").put(OP_NOP1, "NOP1").put(OP_CHECKLOCKTIMEVERIFY, "CHECKLOCKTIMEVERIFY").put(OP_CHECKSEQUENCEVERIFY, "CHECKSEQUENCEVERIFY").put(OP_NOP4, "NOP4").put(OP_NOP5, "NOP5").put(OP_NOP6, "NOP6").put(OP_NOP7, "NOP7").put(OP_NOP8, "NOP8").put(OP_NOP9, "NOP9").put(OP_NOP10, "NOP10").build())

    #_private
    #_static
    #_final
    (§ var Map<String, Integer> opCodeNameMap = ImmutableMap.<String, Integer>builder().put("0", OP_0).put("PUSHDATA1", OP_PUSHDATA1).put("PUSHDATA2", OP_PUSHDATA2).put("PUSHDATA4", OP_PUSHDATA4).put("1NEGATE", OP_1NEGATE).put("RESERVED", OP_RESERVED).put("1", OP_1).put("2", OP_2).put("3", OP_3).put("4", OP_4).put("5", OP_5).put("6", OP_6).put("7", OP_7).put("8", OP_8).put("9", OP_9).put("10", OP_10).put("11", OP_11).put("12", OP_12).put("13", OP_13).put("14", OP_14).put("15", OP_15).put("16", OP_16).put("NOP", OP_NOP).put("VER", OP_VER).put("IF", OP_IF).put("NOTIF", OP_NOTIF).put("VERIF", OP_VERIF).put("VERNOTIF", OP_VERNOTIF).put("ELSE", OP_ELSE).put("ENDIF", OP_ENDIF).put("VERIFY", OP_VERIFY).put("RETURN", OP_RETURN).put("TOALTSTACK", OP_TOALTSTACK).put("FROMALTSTACK", OP_FROMALTSTACK).put("2DROP", OP_2DROP).put("2DUP", OP_2DUP).put("3DUP", OP_3DUP).put("2OVER", OP_2OVER).put("2ROT", OP_2ROT).put("2SWAP", OP_2SWAP).put("IFDUP", OP_IFDUP).put("DEPTH", OP_DEPTH).put("DROP", OP_DROP).put("DUP", OP_DUP).put("NIP", OP_NIP).put("OVER", OP_OVER).put("PICK", OP_PICK).put("ROLL", OP_ROLL).put("ROT", OP_ROT).put("SWAP", OP_SWAP).put("TUCK", OP_TUCK).put("CAT", OP_CAT).put("SUBSTR", OP_SUBSTR).put("LEFT", OP_LEFT).put("RIGHT", OP_RIGHT).put("SIZE", OP_SIZE).put("INVERT", OP_INVERT).put("AND", OP_AND).put("OR", OP_OR).put("XOR", OP_XOR).put("EQUAL", OP_EQUAL).put("EQUALVERIFY", OP_EQUALVERIFY).put("RESERVED1", OP_RESERVED1).put("RESERVED2", OP_RESERVED2).put("1ADD", OP_1ADD).put("1SUB", OP_1SUB).put("2MUL", OP_2MUL).put("2DIV", OP_2DIV).put("NEGATE", OP_NEGATE).put("ABS", OP_ABS).put("NOT", OP_NOT).put("0NOTEQUAL", OP_0NOTEQUAL).put("ADD", OP_ADD).put("SUB", OP_SUB).put("MUL", OP_MUL).put("DIV", OP_DIV).put("MOD", OP_MOD).put("LSHIFT", OP_LSHIFT).put("RSHIFT", OP_RSHIFT).put("BOOLAND", OP_BOOLAND).put("BOOLOR", OP_BOOLOR).put("NUMEQUAL", OP_NUMEQUAL).put("NUMEQUALVERIFY", OP_NUMEQUALVERIFY).put("NUMNOTEQUAL", OP_NUMNOTEQUAL).put("LESSTHAN", OP_LESSTHAN).put("GREATERTHAN", OP_GREATERTHAN).put("LESSTHANOREQUAL", OP_LESSTHANOREQUAL).put("GREATERTHANOREQUAL", OP_GREATERTHANOREQUAL).put("MIN", OP_MIN).put("MAX", OP_MAX).put("WITHIN", OP_WITHIN).put("RIPEMD160", OP_RIPEMD160).put("SHA1", OP_SHA1).put("SHA256", OP_SHA256).put("HASH160", OP_HASH160).put("HASH256", OP_HASH256).put("CODESEPARATOR", OP_CODESEPARATOR).put("CHECKSIG", OP_CHECKSIG).put("CHECKSIGVERIFY", OP_CHECKSIGVERIFY).put("CHECKMULTISIG", OP_CHECKMULTISIG).put("CHECKMULTISIGVERIFY", OP_CHECKMULTISIGVERIFY).put("NOP1", OP_NOP1).put("CHECKLOCKTIMEVERIFY", OP_CHECKLOCKTIMEVERIFY).put("CHECKSEQUENCEVERIFY", OP_CHECKSEQUENCEVERIFY).put("NOP2", OP_NOP2).put("NOP3", OP_NOP3).put("NOP4", OP_NOP4).put("NOP5", OP_NOP5).put("NOP6", OP_NOP6).put("NOP7", OP_NOP7).put("NOP8", OP_NOP8).put("NOP9", OP_NOP9).put("NOP10", OP_NOP10).build())

    ;;;
     ; Converts the given OpCode into a string (e.g. "0", "PUSHDATA", or "NON_OP(10)")
     ;;
    #_public
    #_static
    (§ method String getOpCodeName(int opcode))
    (ß
        (§ if (opCodeMap.containsKey(opcode)))
            (§ return opCodeMap.get(opcode))

        (§ return "NON_OP(" + opcode + ")")
    )

    ;;;
     ; Converts the given pushdata OpCode into a string (e.g. "PUSHDATA2", or "PUSHDATA(23)")
     ;;
    #_public
    #_static
    (§ method String getPushDataName(int opcode))
    (ß
        (§ if (opCodeMap.containsKey(opcode)))
            (§ return opCodeMap.get(opcode))

        (§ return "PUSHDATA(" + opcode + ")")
    )

    ;;;
     ; Converts the given OpCodeName into an int.
     ;;
    #_public
    #_static
    (§ method int getOpCode(String opCodeName))
    (ß
        (§ return (opCodeNameMap.containsKey(opCodeName)) ? opCodeNameMap.get(opCodeName) :else OP_INVALIDOPCODE)
    )
)

#_(ns org.bitcoinj.signers #_"CustomTransactionSigner"
    (:import [java.util List])
    (:import [com.google.common.base Preconditions]
             [org.slf4j Logger LoggerFactory])
  #_(:require #_[org.bitcoinj.core *]
             [org.bitcoinj.crypto ChildNumber TransactionSignature]
             [org.bitcoinj.script Script]
             [org.bitcoinj.wallet KeyBag RedeemData]))

;;;
 ; <p>This signer may be used as a template for creating custom multisig transaction signers.</p>
 ;
 ; Concrete implementations have to implement {@link #getSignature(org.bitcoinj.core.Sha256Hash, java.util.List)}
 ; method returning a signature and a public key of the keypair used to created that signature.
 ; It's up to custom implementation where to locate signatures: it may be a network connection,
 ; some local API or something else.
 ; </p>
 ;;
#_public
#_abstract
(§ class CustomTransactionSigner extends StatelessTransactionSigner
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(CustomTransactionSigner.class))

    #_override
    #_public
    (§ method boolean isReady())
    (ß
        (§ return true)
    )

    #_override
    #_public
    (§ method boolean signInputs(ProposedTransaction propTx, KeyBag keyBag))
    (ß
        (§ var Transaction tx = propTx.partialTx)
        (§ var int numInputs = tx.getInputs().size())
        (§ for (int i = 0 :for i < numInputs :for i = i + 1))
        (ß
            (§ var TransactionInput txIn = tx.getInput(i))
            (§ var TransactionOutput txOut = txIn.getConnectedOutput())
            (§ if (txOut == nil))
                (§ continue)

            (§ var Script scriptPubKey = txOut.getScriptPubKey())
            (§ if (!scriptPubKey.isPayToScriptHash()))
            (ß
                (§ call log.warn("CustomTransactionSigner works only with P2SH transactions"))
                (§ return false)
            )

            (§ var Script inputScript = Preconditions.checkNotNull(txIn.getScriptSig()))

            (§ try)
            (ß
                ;; We assume if its already signed, its hopefully got a SIGHASH type that will not invalidate when
                ;; we sign missing pieces (to check this would require either assuming any signatures are signing
                ;; standard output types or a way to get processed signatures out of script execution).
                (§ call txIn.getScriptSig().correctlySpends(tx, i, txIn.getConnectedOutput().getScriptPubKey()))
                (§ call log.warn("Input {} already correctly spends output, assuming SIGHASH type used will be safe and skipping signing.", i))
                (§ continue)
            )
            (§ catch (ScriptException _))
            (ß
                ;; Expected.
            )

            (§ var RedeemData redeemData = txIn.getConnectedRedeemData(keyBag))
            (§ if (redeemData == nil))
            (ß
                (§ call log.warn("No redeem data found for input {}", i))
                (§ continue)
            )

            (§ var Sha256Hash sighash = tx.hashForSignature(i, redeemData.redeemScript, Transaction.SigHash.ALL, false))
            (§ var SignatureAndKey sigKey = getSignature(sighash, propTx.keyPaths.get(scriptPubKey)))
            (§ var TransactionSignature txSig = new TransactionSignature(sigKey.sig, Transaction.SigHash.ALL, false))
            (§ var int sigIndex = inputScript.getSigInsertionIndex(sighash, sigKey.pubKey))
            (§ ass inputScript = scriptPubKey.getScriptSigWithSignature(inputScript, txSig.encodeToBitcoin(), sigIndex))
            (§ call txIn.setScriptSig(inputScript))
        )
        (§ return true)
    )

    #_protected
    #_abstract
    (§ method SignatureAndKey getSignature(Sha256Hash sighash, List<ChildNumber> derivationPath))

    #_public
    (§ class SignatureAndKey
        #_public
        #_final
        (§ field ECKey.ECDSASignature sig)
        #_public
        #_final
        (§ field ECKey pubKey)

        #_public
        (§ constructor SignatureAndKey(ECKey.ECDSASignature sig, ECKey pubKey))
        (ß
            (§ ass this.sig = sig)
            (§ ass this.pubKey = pubKey)
        )
    )
)

#_(ns org.bitcoinj.signers #_"LocalTransactionSigner"
    (:import [java.util EnumSet])
    (:import [org.slf4j Logger LoggerFactory])
  #_(:require [org.bitcoinj.core ECKey ScriptException Transaction TransactionInput]
             [org.bitcoinj.crypto DeterministicKey TransactionSignature]
             [org.bitcoinj.script Script]
             [org.bitcoinj.script.Script VerifyFlag]
             [org.bitcoinj.wallet KeyBag RedeemData]))

;;;
 ; <p>{@link TransactionSigner} implementation for signing inputs using keys from provided {@link org.bitcoinj.wallet.KeyBag}.</p>
 ; <p>This signer doesn't create input scripts for tx inputs.  Instead it expects inputs to contain scripts with
 ; empty sigs and replaces one of the empty sigs with calculated signature.
 ; </p>
 ; <p>This signer is always implicitly added into every wallet and it is the first signer to be executed during tx
 ; completion.  As the first signer to create a signature, it stores derivation path of the signing key in a given
 ; {@link ProposedTransaction} object that will be also passed then to the next signer in chain.  This allows other
 ; signers to use correct signing key for P2SH inputs, because all the keys involved in a single P2SH address have
 ; the same derivation path.</p>
 ; <p>This signer always uses {@link org.bitcoinj.core.Transaction.SigHash#ALL} signing mode.</p>
 ;;
#_public
(§ class LocalTransactionSigner extends StatelessTransactionSigner
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(LocalTransactionSigner.class))

    ;;;
     ; Verify flags that are safe to use when testing if an input is already signed.
     ;;
    #_private
    #_static
    #_final
    (§ field EnumSet<VerifyFlag> MINIMUM_VERIFY_FLAGS = EnumSet.of(VerifyFlag.P2SH, VerifyFlag.NULLDUMMY))

    #_override
    #_public
    (§ method boolean isReady())
    (ß
        (§ return true)
    )

    #_override
    #_public
    (§ method boolean signInputs(ProposedTransaction propTx, KeyBag keyBag))
    (ß
        (§ var Transaction tx = propTx.partialTx)
        (§ var int numInputs = tx.getInputs().size())
        (§ for (int i = 0 :for i < numInputs :for i = i + 1))
        (ß
            (§ var TransactionInput txIn = tx.getInput(i))
            (§ if (txIn.getConnectedOutput() == nil))
            (ß
                (§ call log.warn("Missing connected output, assuming input {} is already signed.", i))
                (§ continue)
            )

            (§ try)
            (ß
                ;; We assume if its already signed, its hopefully got a SIGHASH type that will not invalidate when
                ;; we sign missing pieces (to check this would require either assuming any signatures are signing
                ;; standard output types or a way to get processed signatures out of script execution).
                (§ call txIn.getScriptSig().correctlySpends(tx, i, txIn.getConnectedOutput().getScriptPubKey(), MINIMUM_VERIFY_FLAGS))
                (§ call log.warn("Input {} already correctly spends output, assuming SIGHASH type used will be safe and skipping signing.", i))
                (§ continue)
            )
            (§ catch (ScriptException _))
            (ß
                ;; Expected.
            )

            (§ var RedeemData redeemData = txIn.getConnectedRedeemData(keyBag))

            (§ var Script scriptPubKey = txIn.getConnectedOutput().getScriptPubKey())

            ;; For P2SH inputs we need to share derivation path of the signing key with other signers, so that they
            ;; use correct key to calculate their signatures.
            ;; Married keys all have the same derivation path, so we can safely just take first one here.
            (§ var ECKey pubKey = redeemData.keys.get(0))
            (§ if (pubKey instanceof DeterministicKey))
                (§ call propTx.keyPaths.put(scriptPubKey, (((DeterministicKey)pubKey).getPath())))

            (§ var ECKey key)
            ;; Locate private key in redeem data.  For pay-to-address and pay-to-key inputs RedeemData will always contain
            ;; only one key (with private bytes).  For P2SH inputs RedeemData will contain multiple keys, one of which MAY
            ;; have private bytes.
            (§ if ((key = redeemData.getFullKey()) == nil))
            (ß
                (§ call log.warn("No local key found for input {}", i))
                (§ continue)
            )

            (§ var Script inputScript = txIn.getScriptSig())
            ;; script here would be either a standard CHECKSIG program for pay-to-address or pay-to-pubkey inputs or
            ;; a CHECKMULTISIG program for P2SH inputs.
            (§ var byte[] script = redeemData.redeemScript.getProgram())
            (§ try)
            (ß
                (§ var TransactionSignature signature = tx.calculateSignature(i, key, script, Transaction.SigHash.ALL, false))

                ;; At this point we have incomplete inputScript with OP_0 in place of one or more signatures.  We already
                ;; have calculated the signature using the local key and now need to insert it in the correct place
                ;; within inputScript.  For pay-to-address and pay-to-key script there is only one signature and it always
                ;; goes first in an inputScript (sigIndex = 0).  In P2SH input scripts we need to figure out our relative
                ;; position relative to other signers.  Since we don't have that information at this point, and since
                ;; we always run first, we have to depend on the other signers rearranging the signatures as needed.
                ;; Therefore, always place as first signature.
                (§ var int sigIndex = 0)
                (§ ass inputScript = scriptPubKey.getScriptSigWithSignature(inputScript, signature.encodeToBitcoin(), sigIndex))
                (§ call txIn.setScriptSig(inputScript))
            )
            (§ catch (ECKey.KeyIsEncryptedException e))
            (ß
                (§ throw e)
            )
            (§ catch (ECKey.MissingPrivateKeyException _))
            (ß
                (§ call log.warn("No private key in keypair for input {}", i))
            )
        )
        (§ return true)
    )
)

#_(ns org.bitcoinj.signers #_"MissingSigResolutionSigner"
    (:import [org.slf4j Logger LoggerFactory])
  #_(:require [org.bitcoinj.core ECKey TransactionInput]
             [org.bitcoinj.crypto TransactionSignature]
             [org.bitcoinj.script Script ScriptChunk]
             [org.bitcoinj.wallet KeyBag Wallet]))

;;;
 ; This transaction signer resolves missing signatures in accordance with the given {@link org.bitcoinj.wallet.Wallet.MissingSigsMode}.
 ; If missingSigsMode is USE_OP_ZERO this signer does nothing assuming missing signatures are already presented in scriptSigs as OP_0.
 ; In MissingSigsMode.THROW mode this signer will throw an exception.  It would be MissingSignatureException
 ; for P2SH or MissingPrivateKeyException for other transaction types.
 ;;
#_public
(§ class MissingSigResolutionSigner extends StatelessTransactionSigner
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(MissingSigResolutionSigner.class))

    #_public
    (§ field Wallet.MissingSigsMode missingSigsMode = Wallet.MissingSigsMode.USE_DUMMY_SIG)

    #_public
    (§ constructor MissingSigResolutionSigner())
    (ß
    )

    #_public
    (§ constructor MissingSigResolutionSigner(Wallet.MissingSigsMode missingSigsMode))
    (ß
        (§ ass this.missingSigsMode = missingSigsMode)
    )

    #_override
    #_public
    (§ method boolean isReady())
    (ß
        (§ return true)
    )

    #_override
    #_public
    (§ method boolean signInputs(ProposedTransaction propTx, KeyBag keyBag))
    (ß
        (§ if (missingSigsMode == Wallet.MissingSigsMode.USE_OP_ZERO))
            (§ return true)

        (§ var int numInputs = propTx.partialTx.getInputs().size())
        (§ var byte[] dummySig = TransactionSignature.dummy().encodeToBitcoin())
        (§ for (int i = 0 :for i < numInputs :for i = i + 1))
        (ß
            (§ var TransactionInput txIn = propTx.partialTx.getInput(i))
            (§ if (txIn.getConnectedOutput() == nil))
            (ß
                (§ call log.warn("Missing connected output, assuming input {} is already signed.", i))
                (§ continue)
            )

            (§ var Script scriptPubKey = txIn.getConnectedOutput().getScriptPubKey())
            (§ var Script inputScript = txIn.getScriptSig())
            (§ if (scriptPubKey.isPayToScriptHash() || scriptPubKey.isSentToMultiSig()))
            (ß
                (§ var int sigSuffixCount = scriptPubKey.isPayToScriptHash() ? 1 :else 0)
                ;; All chunks except the first one (OP_0) and the last (redeem script) are signatures.
                (§ for (int j = 1 :for j < inputScript.getChunks().size() - sigSuffixCount :for j = j + 1))
                (ß
                    (§ var ScriptChunk scriptChunk = inputScript.getChunks().get(j))
                    (§ if (scriptChunk.equalsOpCode(0)))
                    (ß
                        (§ if (missingSigsMode == Wallet.MissingSigsMode.THROW))
                            (§ throw new MissingSignatureException())

                        (§ if (missingSigsMode == Wallet.MissingSigsMode.USE_DUMMY_SIG))
                            (§ call txIn.setScriptSig(scriptPubKey.getScriptSigWithSignature(inputScript, dummySig, j - 1)))
                    )
                )
            )
            (§ else)
            (ß
                (§ if (inputScript.getChunks().get(0).equalsOpCode(0)))
                (ß
                    (§ if (missingSigsMode == Wallet.MissingSigsMode.THROW))
                        (§ throw new ECKey.MissingPrivateKeyException())

                    (§ if (missingSigsMode == Wallet.MissingSigsMode.USE_DUMMY_SIG))
                        (§ call txIn.setScriptSig(scriptPubKey.getScriptSigWithSignature(inputScript, dummySig, 0)))
                )
            )
            ;; TODO: Handle non-P2SH multisig.
        )
        (§ return true)
    )
)

#_(ns org.bitcoinj.signers #_"StatelessTransactionSigner")

;;;
 ; A signer that doesn't have any state to be serialized.
 ;;
#_public
#_abstract
(§ class StatelessTransactionSigner implements TransactionSigner
    #_override
    #_public
    (§ method void deserialize(byte[] data))
    (ß
    )

    #_override
    #_public
    (§ method byte[] serialize())
    (ß
        (§ return new byte[0])
    )
)

#_(ns org.bitcoinj.signers #_"TransactionSigner"
    (:import [java.util HashMap List Map])
  #_(:require [org.bitcoinj.core Transaction]
             [org.bitcoinj.crypto ChildNumber]
             [org.bitcoinj.script Script]
             [org.bitcoinj.wallet KeyBag]))

;;;
 ; <p>Implementations of this interface are intended to sign inputs of the given transaction.
 ; Given transaction may already be partially signed or somehow altered by other signers.</p>
 ; <p>To make use of the signer, you need to add it into the wallet by calling
 ; {@link org.bitcoinj.wallet.Wallet#addTransactionSigner(TransactionSigner)}.
 ; Signer will be serialized along with the wallet data.  In order for a wallet to recreate
 ; signer after deserialization, each signer should have no-args constructor.</p>
 ;;
#_public
(§ interface TransactionSigner
    ;;;
     ; This class wraps transaction proposed to complete keeping a metadata that may be updated, used and effectively
     ; shared by transaction signers.
     ;;
    (§ class ProposedTransaction
        #_public
        #_final
        (§ field Transaction partialTx)

        ;;;
         ; HD key paths used for each input to derive a signing key.  It's useful for multisig inputs only.
         ; The keys used to create a single P2SH address have the same derivation path, so to use a correct key each signer
         ; has to know a derivation path of signing keys used by previous signers.  For each input signers will use the
         ; same derivation path and we need to store only one key path per input.  As TransactionInput is mutable, inputs
         ; are identified by their scriptPubKeys (keys in this map).
         ;;
        #_public
        #_final
        (§ field Map<Script, List<ChildNumber>> keyPaths)

        #_public
        (§ constructor ProposedTransaction(Transaction partialTx))
        (ß
            (§ ass this.partialTx = partialTx)
            (§ ass this.keyPaths = new HashMap<>())
        )
    )

    (§ class MissingSignatureException extends RuntimeException
    )

    ;;;
     ; Returns true if this signer is ready to be used.
     ;;
    (§ method boolean isReady())

    ;;;
     ; Returns byte array of data representing state of this signer.
     ; It's used to serialize/deserialize this signer.
     ;;
    (§ method byte[] serialize())

    ;;;
     ; Uses given byte array of data to reconstruct internal state of this signer.
     ;;
    (§ method void deserialize(byte[] data))

    ;;;
     ; Signs given transaction's inputs.
     ; Returns true if signer is compatible with given transaction (can do something meaningful with it).
     ; Otherwise this method returns false.
     ;;
    (§ method boolean signInputs(ProposedTransaction propTx, KeyBag keyBag))
)

#_(ns org.bitcoinj.store #_"BlockStore"
  #_(:require [org.bitcoinj.core NetworkParameters Sha256Hash StoredBlock]))

;;;
 ; An implementor of BlockStore saves StoredBlock objects to disk.  Different implementations store them in
 ; different ways.  An in-memory implementation (MemoryBlockStore) exists for unit testing but real apps will
 ; want to use implementations that save to disk.
 ;
 ; A BlockStore is a map of hashes to StoredBlock.  The hash is the double digest of the Bitcoin serialization
 ; of the block header, <b>not</b> the header with the extra data as well.
 ;
 ; BlockStores are thread safe.
 ;;
#_public
(§ interface BlockStore
    ;;;
     ; Saves the given block header+extra data.  The key isn't specified explicitly as it can be calculated
     ; from the StoredBlock directly.  Can throw if there is a problem with the underlying storage layer such
     ; as running out of disk space.
     ;;
    (§ method void put(StoredBlock block))
        (§ throws BlockStoreException)

    ;;;
     ; Returns the StoredBlock given a hash.  The returned values block.getHash() method will be equal to the
     ; parameter. If no such block is found, returns null.
     ;;
    (§ method StoredBlock get(Sha256Hash hash))
        (§ throws BlockStoreException)

    ;;;
     ; Returns the {@link StoredBlock} that represents the top of the chain of greatest total work.  Note that
     ; this can be arbitrarily expensive, you probably should use {@link org.bitcoinj.core.BlockChain#getChainHead()}
     ; or perhaps {@link org.bitcoinj.core.BlockChain#getBestChainHeight()} which will run in constant time and
     ; not take any heavyweight locks.
     ;;
    (§ method StoredBlock getChainHead())
        (§ throws BlockStoreException)

    ;;;
     ; Sets the {@link StoredBlock} that represents the top of the chain of greatest total work.
     ;;
    (§ method void setChainHead(StoredBlock chainHead))
        (§ throws BlockStoreException)

    ;;; Closes the store. ;;
    (§ method void close())
        (§ throws BlockStoreException)

    ;;;
     ; Get the {@link org.bitcoinj.core.NetworkParameters} of this store.
     ; @return the network params.
     ;;
    (§ method NetworkParameters getParams())
)

#_(ns org.bitcoinj.store #_"BlockStoreException")

;;;
 ; Thrown when something goes wrong with storing a block.  Examples: out of disk space.
 ;;
#_public
(§ class BlockStoreException extends Exception
    #_public
    (§ constructor BlockStoreException(String message))
    (ß
        (§ super (message))
    )

    #_public
    (§ constructor BlockStoreException(Throwable t))
    (ß
        (§ super (t))
    )

    #_public
    (§ constructor BlockStoreException(String message, Throwable t))
    (ß
        (§ super (message, t))
    )
)

#_(ns org.bitcoinj.store #_"ChainFileLockedException")

;;;
 ; Thrown by {@link SPVBlockStore} when the process cannot gain exclusive access to the chain file.
 ;;
#_public
(§ class ChainFileLockedException extends BlockStoreException
    #_public
    (§ constructor ChainFileLockedException(String message))
    (ß
        (§ super (message))
    )

    #_public
    (§ constructor ChainFileLockedException(Throwable t))
    (ß
        (§ super (t))
    )
)

#_(ns org.bitcoinj.store #_"DatabaseFullPrunedBlockStore"
    (:import [java.io ByteArrayInputStream ByteArrayOutputStream IOException]
             [java.math BigInteger]
             #_[java.sql *]
             #_[java.util *])
    (:import [com.google.common.collect Lists]
             [org.slf4j Logger LoggerFactory])
  #_(:require #_[org.bitcoinj.core *]
             [org.bitcoinj.script Script]))

;;;
 ; <p>A generic full pruned block store for a relational database.  This generic class
 ; requires certain table structures for the block store.</p>
 ;
 ; <p>The following are the tables and field names/types that are assumed:</p>
 ;
 ; <p><br/>
 ; <b>setting</b> table
 ; <table>
 ;     <tr><th>Field Name</th><th>Type (generic)</th></tr>
 ;     <tr><td>name</td><td>string</td></tr>
 ;     <tr><td>value</td><td>binary</td></tr>
 ; </table>
 ; </p>
 ;
 ; <p><br/>
 ; <b>headers</b> table
 ; <table>
 ;     <tr><th>Field Name</th><th>Type (generic)</th></tr>
 ;     <tr><td>hash</td><td>binary</td></tr>
 ;     <tr><td>chainwork</td><td>binary</td></tr>
 ;     <tr><td>height</td><td>integer</td></tr>
 ;     <tr><td>header</td><td>binary</td></tr>
 ;     <tr><td>wasundoable</td><td>boolean</td></tr>
 ; </table>
 ; </p>
 ;
 ; <p><br/>
 ; <b>undoableblocks</b> table
 ; <table>
 ;     <tr><th>Field Name</th><th>Type (generic)</th></tr>
 ;     <tr><td>hash</td><td>binary</td></tr>
 ;     <tr><td>height</td><td>integer</td></tr>
 ;     <tr><td>txoutchanges</td><td>binary</td></tr>
 ;     <tr><td>transactions</td><td>binary</td></tr>
 ; </table>
 ; </p>
 ;
 ; <p><br/>
 ; <b>openoutputs</b> table
 ; <table>
 ;     <tr><th>Field Name</th><th>Type (generic)</th></tr>
 ;     <tr><td>hash</td><td>binary</td></tr>
 ;     <tr><td>index</td><td>integer</td></tr>
 ;     <tr><td>height</td><td>integer</td></tr>
 ;     <tr><td>value</td><td>integer</td></tr>
 ;     <tr><td>scriptbytes</td><td>binary</td></tr>
 ;     <tr><td>toaddress</td><td>string</td></tr>
 ;     <tr><td>addresstargetable</td><td>integer</td></tr>
 ;     <tr><td>coinbase</td><td>boolean</td></tr>
 ; </table>
 ; </p>
 ;
 ;;
#_public
#_abstract
(§ class DatabaseFullPrunedBlockStore implements FullPrunedBlockStore
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(DatabaseFullPrunedBlockStore.class))

    #_private
    #_static
    #_final
    (§ field String CHAIN_HEAD_SETTING                = "chainhead")
    #_private
    #_static
    #_final
    (§ field String VERIFIED_CHAIN_HEAD_SETTING       = "verifiedchainhead")
    #_private
    #_static
    #_final
    (§ field String VERSION_SETTING                   = "version")

    ;; Drop table SQL.
    #_private
    #_static
    #_final
    (§ field String DROP_SETTINGS_TABLE               = "DROP TABLE settings")
    #_private
    #_static
    #_final
    (§ field String DROP_HEADERS_TABLE                = "DROP TABLE headers")
    #_private
    #_static
    #_final
    (§ field String DROP_UNDOABLE_TABLE               = "DROP TABLE undoableblocks")
    #_private
    #_static
    #_final
    (§ field String DROP_OPEN_OUTPUT_TABLE            = "DROP TABLE openoutputs")

    ;; Queries SQL.
    #_private
    #_static
    #_final
    (§ field String SELECT_SETTINGS_SQL               = "SELECT value FROM settings WHERE name = ?")
    #_private
    #_static
    #_final
    (§ field String INSERT_SETTINGS_SQL               = "INSERT INTO settings(name, value) VALUES(?, ?)")
    #_private
    #_static
    #_final
    (§ field String UPDATE_SETTINGS_SQL               = "UPDATE settings SET value = ? WHERE name = ?")

    #_private
    #_static
    #_final
    (§ field String SELECT_HEADERS_SQL                = "SELECT chainwork, height, header, wasundoable FROM headers WHERE hash = ?")
    #_private
    #_static
    #_final
    (§ field String INSERT_HEADERS_SQL                = "INSERT INTO headers(hash, chainwork, height, header, wasundoable) VALUES(?, ?, ?, ?, ?)")
    #_private
    #_static
    #_final
    (§ field String UPDATE_HEADERS_SQL                = "UPDATE headers SET wasundoable=? WHERE hash=?")

    #_private
    #_static
    #_final
    (§ field String SELECT_UNDOABLEBLOCKS_SQL         = "SELECT txoutchanges, transactions FROM undoableblocks WHERE hash = ?")
    #_private
    #_static
    #_final
    (§ field String INSERT_UNDOABLEBLOCKS_SQL         = "INSERT INTO undoableblocks(hash, height, txoutchanges, transactions) VALUES(?, ?, ?, ?)")
    #_private
    #_static
    #_final
    (§ field String UPDATE_UNDOABLEBLOCKS_SQL         = "UPDATE undoableblocks SET txoutchanges=?, transactions=? WHERE hash = ?")
    #_private
    #_static
    #_final
    (§ field String DELETE_UNDOABLEBLOCKS_SQL         = "DELETE FROM undoableblocks WHERE height <= ?")

    #_private
    #_static
    #_final
    (§ field String SELECT_OPENOUTPUTS_SQL            = "SELECT height, value, scriptbytes, coinbase, toaddress, addresstargetable FROM openoutputs WHERE hash = ? AND index = ?")
    #_private
    #_static
    #_final
    (§ field String SELECT_OPENOUTPUTS_COUNT_SQL      = "SELECT COUNT(*) FROM openoutputs WHERE hash = ?")
    #_private
    #_static
    #_final
    (§ field String INSERT_OPENOUTPUTS_SQL            = "INSERT INTO openoutputs (hash, index, height, value, scriptbytes, toaddress, addresstargetable, coinbase) VALUES (?, ?, ?, ?, ?, ?, ?, ?)")
    #_private
    #_static
    #_final
    (§ field String DELETE_OPENOUTPUTS_SQL            = "DELETE FROM openoutputs WHERE hash = ? AND index = ?")

    ;; Dump table SQL (this is just for data sizing statistics).
    #_private
    #_static
    #_final
    (§ field String SELECT_DUMP_SETTINGS_SQL          = "SELECT name, value FROM settings")
    #_private
    #_static
    #_final
    (§ field String SELECT_DUMP_HEADERS_SQL           = "SELECT chainwork, header FROM headers")
    #_private
    #_static
    #_final
    (§ field String SELECT_DUMP_UNDOABLEBLOCKS_SQL    = "SELECT txoutchanges, transactions FROM undoableblocks")
    #_private
    #_static
    #_final
    (§ field String SELECT_DUMP_OPENOUTPUTS_SQL       = "SELECT value, scriptbytes FROM openoutputs")

    #_private
    #_static
    #_final
    (§ field String SELECT_TRANSACTION_OUTPUTS_SQL    = "SELECT hash, value, scriptbytes, height, index, coinbase, toaddress, addresstargetable FROM openoutputs where toaddress = ?")

    ;; Select the balance of an address SQL.
    #_private
    #_static
    #_final
    (§ field String SELECT_BALANCE_SQL                = "select sum(value) from openoutputs where toaddress = ?")

    ;; Tables exist SQL.
    #_private
    #_static
    #_final
    (§ field String SELECT_CHECK_TABLES_EXIST_SQL     = "SELECT * FROM settings WHERE 1 = 2")

    ;; Compatibility SQL.
    #_private
    #_static
    #_final
    (§ field String SELECT_COMPATIBILITY_COINBASE_SQL = "SELECT coinbase FROM openoutputs WHERE 1 = 2")

    #_protected
    (§ field Sha256Hash chainHeadHash)
    #_protected
    (§ field StoredBlock chainHeadBlock)
    #_protected
    (§ field Sha256Hash verifiedChainHeadHash)
    #_protected
    (§ field StoredBlock verifiedChainHeadBlock)
    #_protected
    (§ field NetworkParameters params)
    #_protected
    (§ field ThreadLocal<Connection> conn)
    #_protected
    (§ field List<Connection> allConnections)
    #_protected
    (§ field String connectionURL)
    #_protected
    (§ field int fullStoreDepth)
    #_protected
    (§ field String username)
    #_protected
    (§ field String password)
    #_protected
    (§ field String schemaName)

    ;;;
     ; <p>Create a new DatabaseFullPrunedBlockStore, using the full connection URL instead of a hostname and password,
     ; and optionally allowing a schema to be specified.</p>
     ;
     ; @param params A copy of the NetworkParameters used.
     ; @param connectionURL The jdbc url to connect to the database.
     ; @param fullStoreDepth The number of blocks of history stored in full (something like 1000 is pretty safe).
     ; @param username The database username.
     ; @param password The password to the database.
     ; @param schemaName The name of the schema to put the tables in.  May be null if no schema is being used.
     ; @throws BlockStoreException if there is a failure to connect and/or initialise the database.
     ;;
    #_public
    (§ constructor DatabaseFullPrunedBlockStore(NetworkParameters params, String connectionURL, int fullStoreDepth, #_nilable String username, #_nilable String password, #_nilable String schemaName))
        (§ throws BlockStoreException)
    (ß
        (§ ass this.params = params)
        (§ ass this.fullStoreDepth = fullStoreDepth)
        (§ ass this.connectionURL = connectionURL)
        (§ ass this.schemaName = schemaName)
        (§ ass this.username = username)
        (§ ass this.password = password)
        (§ ass this.conn = new ThreadLocal<>())
        (§ ass this.allConnections = new LinkedList<>())

        (§ try)
        (ß
            (§ call Class.forName(getDatabaseDriverClass()))
            (§ call log.info(getDatabaseDriverClass() + " loaded. "))
        )
        (§ catch (ClassNotFoundException e))
        (ß
            (§ call log.error("check CLASSPATH for database driver jar ", e))
        )

        (§ call maybeConnect())

        (§ try)
        (ß
            ;; Create tables if needed.
            (§ if (!tablesExist()))
                (§ call createTables())
            (§ else)
                (§ call checkCompatibility())
            (§ call initFromDatabase())
        )
        (§ catch (SQLException e))
        (ß
            (§ throw new BlockStoreException(e))
        )
    )

    ;;;
     ; Get the database driver class, i.e <i>org.postgresql.Driver</i>.
     ; @return the fully qualified database driver class.
     ;;
    #_protected
    #_abstract
    (§ method String getDatabaseDriverClass())

    ;;;
     ; Get the SQL statements that create the schema (DDL).
     ; @return the list of SQL statements.
     ;;
    #_protected
    #_abstract
    (§ method List<String> getCreateSchemeSQL())

    ;;;
     ; Get the SQL statements that create the tables (DDL).
     ; @return the list of SQL statements.
     ;;
    #_protected
    #_abstract
    (§ method List<String> getCreateTablesSQL())

    ;;;
     ; Get the SQL statements that create the indexes (DDL).
     ; @return the list of SQL statements.
     ;;
    #_protected
    #_abstract
    (§ method List<String> getCreateIndexesSQL())

    ;;;
     ; Get the database specific error code that indicated a duplicate key error when inserting a record.
     ; <p>This is the code returned by {@link java.sql.SQLException#getSQLState()}.</p>
     ; @return the database duplicate error code.
     ;;
    #_protected
    #_abstract
    (§ method String getDuplicateKeyErrorCode())

    ;;;
     ; Get the SQL to select the total balance for a given address.
     ; @return the SQL prepared statement.
     ;;
    #_protected
    (§ method String getBalanceSelectSQL())
    (ß
        (§ return SELECT_BALANCE_SQL)
    )

    ;;;
     ; Get the SQL statement that checks if tables exist.
     ; @return the SQL prepared statement.
     ;;
    #_protected
    (§ method String getTablesExistSQL())
    (ß
        (§ return SELECT_CHECK_TABLES_EXIST_SQL)
    )

    ;;;
     ; Get the SQL statements to check if the database is compatible.
     ; @return the SQL prepared statements.
     ;;
    #_protected
    (§ method List<String> getCompatibilitySQL())
    (ß
        (§ var List<String> sql = new ArrayList<>())
        (§ call sql.add(SELECT_COMPATIBILITY_COINBASE_SQL))
        (§ return sql)
    )

    ;;;
     ; Get the SQL to select the transaction outputs for a given address.
     ; @return the SQL prepared statement.
     ;;
    #_protected
    (§ method String getTransactionOutputSelectSQL())
    (ß
        (§ return SELECT_TRANSACTION_OUTPUTS_SQL)
    )

    ;;;
     ; Get the SQL to drop all the tables (DDL).
     ; @return the SQL drop statements.
     ;;
    #_protected
    (§ method List<String> getDropTablesSQL())
    (ß
        (§ var List<String> sql = new ArrayList<>())
        (§ call sql.add(DROP_SETTINGS_TABLE))
        (§ call sql.add(DROP_HEADERS_TABLE))
        (§ call sql.add(DROP_UNDOABLE_TABLE))
        (§ call sql.add(DROP_OPEN_OUTPUT_TABLE))
        (§ return sql)
    )

    ;;;
     ; Get the SQL to select a setting value.
     ; @return the SQL select statement.
     ;;
    #_protected
    (§ method String getSelectSettingsSQL())
    (ß
        (§ return SELECT_SETTINGS_SQL)
    )

    ;;;
     ; Get the SQL to insert a settings record.
     ; @return the SQL insert statement.
     ;;
    #_protected
    (§ method String getInsertSettingsSQL())
    (ß
        (§ return INSERT_SETTINGS_SQL)
    )

    ;;;
     ; Get the SQL to update a setting value.
     ; @return the SQL update statement.
     ;;
    #_protected
    (§ method String getUpdateSettingsSLQ())
    (ß
        (§ return UPDATE_SETTINGS_SQL)
    )

    ;;;
     ; Get the SQL to select a headers record.
     ; @return the SQL select statement.
     ;;
    #_protected
    (§ method String getSelectHeadersSQL())
    (ß
        (§ return SELECT_HEADERS_SQL)
    )

    ;;;
     ; Get the SQL to insert a headers record.
     ; @return the SQL insert statement.
     ;;
    #_protected
    (§ method String getInsertHeadersSQL())
    (ß
        (§ return INSERT_HEADERS_SQL)
    )

    ;;;
     ; Get the SQL to update a headers record.
     ; @return the SQL update statement.
     ;;
    #_protected
    (§ method String getUpdateHeadersSQL())
    (ß
        (§ return UPDATE_HEADERS_SQL)
    )

    ;;;
     ; Get the SQL to select an undoableblocks record.
     ; @return the SQL select statement.
     ;;
    #_protected
    (§ method String getSelectUndoableBlocksSQL())
    (ß
        (§ return SELECT_UNDOABLEBLOCKS_SQL)
    )

    ;;;
     ; Get the SQL to insert a undoableblocks record.
     ; @return the SQL insert statement.
     ;;
    #_protected
    (§ method String getInsertUndoableBlocksSQL())
    (ß
        (§ return INSERT_UNDOABLEBLOCKS_SQL)
    )

    ;;;
     ; Get the SQL to update a undoableblocks record.
     ; @return the SQL update statement.
     ;;
    #_protected
    (§ method String getUpdateUndoableBlocksSQL())
    (ß
        (§ return UPDATE_UNDOABLEBLOCKS_SQL)
    )

    ;;;
     ; Get the SQL to delete a undoableblocks record.
     ; @return the SQL delete statement.
     ;;
    #_protected
    (§ method String getDeleteUndoableBlocksSQL())
    (ß
        (§ return DELETE_UNDOABLEBLOCKS_SQL)
    )

    ;;;
     ; Get the SQL to select a openoutputs record.
     ; @return the SQL select statement.
     ;;
    #_protected
    (§ method String getSelectOpenoutputsSQL())
    (ß
        (§ return SELECT_OPENOUTPUTS_SQL)
    )

    ;;;
     ; Get the SQL to select count of openoutputs.
     ; @return the SQL select statement.
     ;;
    #_protected
    (§ method String getSelectOpenoutputsCountSQL())
    (ß
        (§ return SELECT_OPENOUTPUTS_COUNT_SQL)
    )

    ;;;
     ; Get the SQL to insert a openoutputs record.
     ; @return the SQL insert statement.
     ;;
    #_protected
    (§ method String getInsertOpenoutputsSQL())
    (ß
        (§ return INSERT_OPENOUTPUTS_SQL)
    )

    ;;;
     ; Get the SQL to delete a openoutputs record.
     ; @return the SQL delete statement.
     ;;
    #_protected
    (§ method String getDeleteOpenoutputsSQL())
    (ß
        (§ return DELETE_OPENOUTPUTS_SQL)
    )

    ;;;
     ; Get the SQL to select the setting dump fields for sizing/statistics.
     ; @return the SQL select statement.
     ;;
    #_protected
    (§ method String getSelectSettingsDumpSQL())
    (ß
        (§ return SELECT_DUMP_SETTINGS_SQL)
    )

    ;;;
     ; Get the SQL to select the headers dump fields for sizing/statistics.
     ; @return the SQL select statement.
     ;;
    #_protected
    (§ method String getSelectHeadersDumpSQL())
    (ß
        (§ return SELECT_DUMP_HEADERS_SQL)
    )

    ;;;
     ; Get the SQL to select the undoableblocks dump fields for sizing/statistics.
     ; @return the SQL select statement.
     ;;
    #_protected
    (§ method String getSelectUndoableblocksDumpSQL())
    (ß
        (§ return SELECT_DUMP_UNDOABLEBLOCKS_SQL)
    )

    ;;;
     ; Get the SQL to select the openoutouts dump fields for sizing/statistics.
     ; @return the SQL select statement.
     ;;
    #_protected
    (§ method String getSelectopenoutputsDumpSQL())
    (ß
        (§ return SELECT_DUMP_OPENOUTPUTS_SQL)
    )

    ;;;
     ; <p>If there isn't a connection on the {@link ThreadLocal} then create and store it.</p>
     ; <p>This will also automatically set up the schema if it does not exist within the DB.</p>
     ; @throws BlockStoreException if successful connection to the DB couldn't be made.
     ;;
    #_protected
    #_synchronized
    #_final
    (§ method void maybeConnect())
        (§ throws BlockStoreException)
    (ß
        (§ try)
        (ß
            (§ if (conn.get() != nil && !conn.get().isClosed()))
                (§ return)

            (§ if (username == nil || password == nil))
            (ß
                (§ call conn.set(DriverManager.getConnection(connectionURL)))
            )
            (§ else)
            (ß
                (§ var Properties props = new Properties())
                (§ call props.setProperty("user", this.username))
                (§ call props.setProperty("password", this.password))
                (§ call conn.set(DriverManager.getConnection(connectionURL, props)))
            )
            (§ call allConnections.add(conn.get()))
            (§ var Connection connection = conn.get())
            ;; Set the schema if one is needed.
            (§ if (schemaName != nil))
            (ß
                (§ var Statement s = connection.createStatement())
                (§ for (String sql :for getCreateSchemeSQL()))
                    (§ call s.execute(sql))
            )
            (§ call log.info("Made a new connection to database " + connectionURL))
        )
        (§ catch (SQLException e))
        (ß
            (§ throw new BlockStoreException(e))
        )
    )

    #_override
    #_public
    #_synchronized
    (§ method void close())
    (ß
        (§ for (Connection conn :for allConnections))
        (ß
            (§ try)
            (ß
                (§ if (!conn.getAutoCommit()))
                    (§ call conn.rollback())
                (§ call conn.close())
                (§ if (conn == this.conn.get()))
                    (§ call this.conn.set(nil))
            )
            (§ catch (SQLException e))
            (ß
                (§ throw new RuntimeException(e))
            )
        )
        (§ call allConnections.clear())
    )

    ;;;
     ; <p>Check if a tables exists within the database.</p>
     ;
     ; <p>This specifically checks for the 'settings' table and
     ; if it exists makes an assumption that the rest of the data
     ; structures are present.</p>
     ;
     ; @return if the tables exist.
     ; @throws java.sql.SQLException
     ;;
    #_private
    (§ method boolean tablesExist())
        (§ throws SQLException)
    (ß
        (§ var PreparedStatement ps = nil)
        (§ try)
        (ß
            (§ ass ps = conn.get().prepareStatement(getTablesExistSQL()))
            (§ var ResultSet results = ps.executeQuery())
            (§ call results.close())
            (§ return true)
        )
        (§ catch (SQLException _))
        (ß
            (§ return false)
        )
        (§ finally)
        (ß
            (§ if (ps != nil && !ps.isClosed()))
                (§ call ps.close())
        )
    )

    ;;;
     ; Check that the database is compatible with this version of the {@link DatabaseFullPrunedBlockStore}.
     ; @throws BlockStoreException if the database is not compatible.
     ;;
    #_private
    (§ method void checkCompatibility())
        (§ throws SQLException, BlockStoreException)
    (ß
        (§ for (String sql :for getCompatibilitySQL()))
        (ß
            (§ var PreparedStatement ps = nil)
            (§ try)
            (ß
                (§ ass ps = conn.get().prepareStatement(sql))
                (§ var ResultSet results = ps.executeQuery())
                (§ call results.close())
            )
            (§ catch (SQLException e))
            (ß
                (§ throw new BlockStoreException("Database block store is not compatible with the current release.  See bitcoinj release notes for further information: " + e.getMessage()))
            )
            (§ finally)
            (ß
                (§ if (ps != nil && !ps.isClosed()))
                    (§ call ps.close())
            )
        )
    )

    ;;;
     ; Create the tables in the database.
     ; @throws java.sql.SQLException if there is a database error.
     ; @throws BlockStoreException if the block store could not be created.
     ;;
    #_private
    (§ method void createTables())
        (§ throws SQLException, BlockStoreException)
    (ß
        (§ var Statement s = conn.get().createStatement())
        ;; Create all the database tables.
        (§ for (String sql :for getCreateTablesSQL()))
        (ß
            (§ if (log.isDebugEnabled()))
                (§ call log.debug("DatabaseFullPrunedBlockStore : CREATE table [SQL= {0}]", sql))
            (§ call s.executeUpdate(sql))
        )
        ;; Create all the database indexes.
        (§ for (String sql :for getCreateIndexesSQL()))
        (ß
            (§ if (log.isDebugEnabled()))
                (§ call log.debug("DatabaseFullPrunedBlockStore : CREATE index [SQL= {0}]", sql))
            (§ call s.executeUpdate(sql))
        )
        (§ call s.close())

        ;; Insert the initial settings for this store.
        (§ var PreparedStatement ps = conn.get().prepareStatement(getInsertSettingsSQL()))
        (§ call ps.setString(1, CHAIN_HEAD_SETTING))
        (§ call ps.setNull(2, Types.BINARY))
        (§ call ps.execute())
        (§ call ps.setString(1, VERIFIED_CHAIN_HEAD_SETTING))
        (§ call ps.setNull(2, Types.BINARY))
        (§ call ps.execute())
        (§ call ps.setString(1, VERSION_SETTING))
        (§ call ps.setBytes(2, "03".getBytes()))
        (§ call ps.execute())
        (§ call ps.close())

        (§ call createNewStore(params))
    )

    ;;;
     ; Create a new store for the given {@link org.bitcoinj.core.NetworkParameters}.
     ; @param params The network.
     ; @throws BlockStoreException if the store couldn't be created.
     ;;
    #_private
    (§ method void createNewStore(NetworkParameters params))
        (§ throws BlockStoreException)
    (ß
        (§ try)
        (ß
            ;; Set up the genesis block.  When we start out fresh, it is by definition the top of the chain.
            (§ var StoredBlock storedGenesisHeader = new StoredBlock(params.getGenesisBlock().cloneAsHeader(), params.getGenesisBlock().getWork(), 0))
            ;; The coinbase in the genesis block is not spendable.  This is because of how Bitcoin Core inits
            ;; its database - the genesis transaction isn't actually in the db so its spent flags can never be updated.
            (§ var List<Transaction> genesisTransactions = Lists.newLinkedList())
            (§ var StoredUndoableBlock storedGenesis = new StoredUndoableBlock(params.getGenesisBlock().getHash(), genesisTransactions))
            (§ call put(storedGenesisHeader, storedGenesis))
            (§ call setChainHead(storedGenesisHeader))
            (§ call setVerifiedChainHead(storedGenesisHeader))
        )
        (§ catch (VerificationException e))
        (ß
            (§ throw new RuntimeException(e)) ;; Cannot happen.
        )
    )

    ;;;
     ; Initialise the store state from the database.
     ; @throws java.sql.SQLException if there is a database error.
     ; @throws BlockStoreException if there is a block store error.
     ;;
    #_private
    (§ method void initFromDatabase())
        (§ throws SQLException, BlockStoreException)
    (ß
        (§ var PreparedStatement ps = conn.get().prepareStatement(getSelectSettingsSQL()))
        (§ var ResultSet rs)
        (§ call ps.setString(1, CHAIN_HEAD_SETTING))
        (§ ass rs = ps.executeQuery())
        (§ if (!rs.next()))
            (§ throw new BlockStoreException("corrupt database block store - no chain head pointer"))

        (§ var Sha256Hash hash = Sha256Hash.wrap(rs.getBytes(1)))
        (§ call rs.close())
        (§ ass this.chainHeadBlock = get(hash))
        (§ ass this.chainHeadHash = hash)
        (§ if (this.chainHeadBlock == nil))
            (§ throw new BlockStoreException("corrupt database block store - head block not found"))

        (§ call ps.setString(1, VERIFIED_CHAIN_HEAD_SETTING))
        (§ ass rs = ps.executeQuery())
        (§ if (!rs.next()))
            (§ throw new BlockStoreException("corrupt database block store - no verified chain head pointer"))

        (§ ass hash = Sha256Hash.wrap(rs.getBytes(1)))
        (§ call rs.close())
        (§ call ps.close())
        (§ ass this.verifiedChainHeadBlock = get(hash))
        (§ ass this.verifiedChainHeadHash = hash)
        (§ if (this.verifiedChainHeadBlock == nil))
            (§ throw new BlockStoreException("corrupt database block store - verified head block not found"))
    )

    #_protected
    (§ method void putUpdateStoredBlock(StoredBlock storedBlock, boolean wasUndoable))
        (§ throws SQLException)
    (ß
        (§ try)
        (ß
            (§ var PreparedStatement ps = conn.get().prepareStatement(getInsertHeadersSQL()))
            ;; We skip the first 4 bytes because (on mainnet) the minimum target has 4 0-bytes.
            (§ var byte[] hashBytes = new byte[28])
            (§ call System.arraycopy(storedBlock.getHeader().getHash().getBytes(), 4, hashBytes, 0, 28))
            (§ call ps.setBytes(1, hashBytes))
            (§ call ps.setBytes(2, storedBlock.getChainWork().toByteArray()))
            (§ call ps.setInt(3, storedBlock.getHeight()))
            (§ call ps.setBytes(4, storedBlock.getHeader().cloneAsHeader().unsafeBitcoinSerialize()))
            (§ call ps.setBoolean(5, wasUndoable))
            (§ call ps.executeUpdate())
            (§ call ps.close())
        )
        (§ catch (SQLException e))
        (ß
            ;; It is possible we try to add a duplicate StoredBlock if we upgraded.
            ;; In that case, we just update the entry to mark it wasUndoable.
            (§ if (!(e.getSQLState().equals(getDuplicateKeyErrorCode())) || !wasUndoable))
                (§ throw e)

            (§ var PreparedStatement ps = conn.get().prepareStatement(getUpdateHeadersSQL()))
            (§ call ps.setBoolean(1, true))
            ;; We skip the first 4 bytes because (on mainnet) the minimum target has 4 0-bytes.
            (§ var byte[] hashBytes = new byte[28])
            (§ call System.arraycopy(storedBlock.getHeader().getHash().getBytes(), 4, hashBytes, 0, 28))
            (§ call ps.setBytes(2, hashBytes))
            (§ call ps.executeUpdate())
            (§ call ps.close())
        )
    )

    #_override
    #_public
    (§ method void put(StoredBlock storedBlock))
        (§ throws BlockStoreException)
    (ß
        (§ call maybeConnect())
        (§ try)
        (ß
            (§ call putUpdateStoredBlock(storedBlock, false))
        )
        (§ catch (SQLException e))
        (ß
            (§ throw new BlockStoreException(e))
        )
    )

    #_override
    #_public
    (§ method void put(StoredBlock storedBlock, StoredUndoableBlock undoableBlock))
        (§ throws BlockStoreException)
    (ß
        (§ call maybeConnect())
        ;; We skip the first 4 bytes because (on mainnet) the minimum target has 4 0-bytes.
        (§ var byte[] hashBytes = new byte[28])
        (§ call System.arraycopy(storedBlock.getHeader().getHash().getBytes(), 4, hashBytes, 0, 28))
        (§ var int height = storedBlock.getHeight())
        (§ var byte[] transactions = nil)
        (§ var byte[] txOutChanges = nil)
        (§ try)
        (ß
            (§ var ByteArrayOutputStream bos = new ByteArrayOutputStream())
            (§ if (undoableBlock.getTxOutChanges() != nil))
            (ß
                (§ call undoableBlock.getTxOutChanges().serializeToStream(bos))
                (§ ass txOutChanges = bos.toByteArray())
            )
            (§ else)
            (ß
                (§ var int numTxn = undoableBlock.getTransactions().size())
                (§ call bos.write(0xff & numTxn))
                (§ call bos.write(0xff & (numTxn >> 8)))
                (§ call bos.write(0xff & (numTxn >> 16)))
                (§ call bos.write(0xff & (numTxn >> 24)))
                (§ for (Transaction tx :for undoableBlock.getTransactions()))
                    (§ call tx.bitcoinSerialize(bos))
                (§ ass transactions = bos.toByteArray())
            )
            (§ call bos.close())
        )
        (§ catch (IOException e))
        (ß
            (§ throw new BlockStoreException(e))
        )

        (§ try)
        (ß
            (§ try)
            (ß
                (§ var PreparedStatement ps = conn.get().prepareStatement(getInsertUndoableBlocksSQL()))
                (§ call ps.setBytes(1, hashBytes))
                (§ call ps.setInt(2, height))
                (§ if (transactions == nil))
                (ß
                    (§ call ps.setBytes(3, txOutChanges))
                    (§ call ps.setNull(4, Types.BINARY))
                )
                (§ else)
                (ß
                    (§ call ps.setNull(3, Types.BINARY))
                    (§ call ps.setBytes(4, transactions))
                )
                (§ call ps.executeUpdate())
                (§ call ps.close())
                (§ try)
                (ß
                    (§ call putUpdateStoredBlock(storedBlock, true))
                )
                (§ catch (SQLException e))
                (ß
                    (§ throw new BlockStoreException(e))
                )
            )
            (§ catch (SQLException e))
            (ß
                (§ if (!e.getSQLState().equals(getDuplicateKeyErrorCode())))
                    (§ throw new BlockStoreException(e))

                ;; There is probably an update-or-insert statement, but it wasn't obvious from the docs.
                (§ var PreparedStatement ps = conn.get().prepareStatement(getUpdateUndoableBlocksSQL()))
                (§ call ps.setBytes(3, hashBytes))
                (§ if (transactions == nil))
                (ß
                    (§ call ps.setBytes(1, txOutChanges))
                    (§ call ps.setNull(2, Types.BINARY))
                )
                (§ else)
                (ß
                    (§ call ps.setNull(1, Types.BINARY))
                    (§ call ps.setBytes(2, transactions))
                )
                (§ call ps.executeUpdate())
                (§ call ps.close())
            )
        )
        (§ catch (SQLException e))
        (ß
            (§ throw new BlockStoreException(e))
        )
    )

    #_public
    (§ method StoredBlock get(Sha256Hash hash, boolean wasUndoableOnly))
        (§ throws BlockStoreException)
    (ß
        ;; Optimize for chain head.
        (§ if (chainHeadHash != nil && chainHeadHash.equals(hash)))
            (§ return chainHeadBlock)

        (§ if (verifiedChainHeadHash != nil && verifiedChainHeadHash.equals(hash)))
            (§ return verifiedChainHeadBlock)

        (§ call maybeConnect())
        (§ var PreparedStatement ps = nil)
        (§ try)
        (ß
            (§ ass ps = conn.get().prepareStatement(getSelectHeadersSQL()))
            ;; We skip the first 4 bytes because (on mainnet) the minimum target has 4 0-bytes.
            (§ var byte[] hashBytes = new byte[28])
            (§ call System.arraycopy(hash.getBytes(), 4, hashBytes, 0, 28))
            (§ call ps.setBytes(1, hashBytes))
            (§ var ResultSet results = ps.executeQuery())
            (§ if (!results.next()))
                (§ return nil)

            ;; Parse it.
            (§ if (wasUndoableOnly && !results.getBoolean(4)))
                (§ return nil)

            (§ var BigInteger chainWork = new BigInteger(results.getBytes(1)))
            (§ var int height = results.getInt(2))
            (§ var Block b = params.getDefaultSerializer().makeBlock(results.getBytes(3)))
            (§ call b.verifyHeader())
            (§ var StoredBlock stored = new StoredBlock(b, chainWork, height))
            (§ return stored)
        )
        (§ catch (SQLException e))
        (ß
            (§ throw new BlockStoreException(e))
        )
        (§ catch (ProtocolException e))
        (ß
            ;; Corrupted database.
            (§ throw new BlockStoreException(e))
        )
        (§ catch (VerificationException e))
        (ß
            ;; Should not be able to happen unless the database contains bad blocks.
            (§ throw new BlockStoreException(e))
        )
        (§ finally)
        (ß
            (§ if (ps != nil))
            (ß
                (§ try)
                (ß
                    (§ call ps.close())
                )
                (§ catch (SQLException _))
                (ß
                    (§ throw new BlockStoreException("Failed to close PreparedStatement"))
                )
            )
        )
    )

    #_override
    #_public
    (§ method StoredBlock get(Sha256Hash hash))
        (§ throws BlockStoreException)
    (ß
        (§ return get(hash, false))
    )

    #_override
    #_public
    (§ method StoredBlock getOnceUndoableStoredBlock(Sha256Hash hash))
        (§ throws BlockStoreException)
    (ß
        (§ return get(hash, true))
    )

    #_override
    #_public
    (§ method StoredUndoableBlock getUndoBlock(Sha256Hash hash))
        (§ throws BlockStoreException)
    (ß
        (§ call maybeConnect())
        (§ var PreparedStatement ps = nil)
        (§ try)
        (ß
            (§ ass ps = conn.get().prepareStatement(getSelectUndoableBlocksSQL()))
            ;; We skip the first 4 bytes because (on mainnet) the minimum target has 4 0-bytes.

            (§ var byte[] hashBytes = new byte[28])
            (§ call System.arraycopy(hash.getBytes(), 4, hashBytes, 0, 28))
            (§ call ps.setBytes(1, hashBytes))
            (§ var ResultSet results = ps.executeQuery())
            (§ if (!results.next()))
                (§ return nil)

            ;; Parse it.
            (§ var byte[] txOutChanges = results.getBytes(1))
            (§ var byte[] transactions = results.getBytes(2))
            (§ var StoredUndoableBlock block)
            (§ if (txOutChanges == nil))
            (ß
                (§ var int numTxn = (transactions[0] & 0xff) | ((transactions[1] & 0xff) << 8) | ((transactions[2] & 0xff) << 16) | ((transactions[3] & 0xff) << 24))
                (§ var int offset = 4)
                (§ var List<Transaction> transactionList = new LinkedList<>())
                (§ for (int i = 0 :for i < numTxn :for i = i + 1))
                (ß
                    (§ var Transaction tx = params.getDefaultSerializer().makeTransaction(transactions, offset))
                    (§ call transactionList.add(tx))
                    (§ ass offset = offset + tx.getMessageSize())
                )
                (§ ass block = new StoredUndoableBlock(hash, transactionList))
            )
            (§ else)
            (ß
                (§ var TransactionOutputChanges outChangesObject = new TransactionOutputChanges(new ByteArrayInputStream(txOutChanges)))
                (§ ass block = new StoredUndoableBlock(hash, outChangesObject))
            )
            (§ return block)
        )
        (§ catch (SQLException e))
        (ß
            (§ throw new BlockStoreException(e))
        )
        (§ catch (NullPointerException e))
        (ß
            ;; Corrupted database.
            (§ throw new BlockStoreException(e))
        )
        (§ catch (ClassCastException e))
        (ß
            ;; Corrupted database.
            (§ throw new BlockStoreException(e))
        )
        (§ catch (ProtocolException e))
        (ß
            ;; Corrupted database.
            (§ throw new BlockStoreException(e))
        )
        (§ catch (IOException e))
        (ß
            ;; Corrupted database.
            (§ throw new BlockStoreException(e))
        )
        (§ finally)
        (ß
            (§ if (ps != nil))
            (ß
                (§ try)
                (ß
                    (§ call ps.close())
                )
                (§ catch (SQLException _))
                (ß
                    (§ throw new BlockStoreException("Failed to close PreparedStatement"))
                )
            )
        )
    )

    #_override
    #_public
    (§ method StoredBlock getChainHead())
        (§ throws BlockStoreException)
    (ß
        (§ return chainHeadBlock)
    )

    #_override
    #_public
    (§ method void setChainHead(StoredBlock chainHead))
        (§ throws BlockStoreException)
    (ß
        (§ var Sha256Hash hash = chainHead.getHeader().getHash())
        (§ ass this.chainHeadHash = hash)
        (§ ass this.chainHeadBlock = chainHead)
        (§ call maybeConnect())
        (§ try)
        (ß
            (§ var PreparedStatement ps = conn.get().prepareStatement(getUpdateSettingsSLQ()))
            (§ call ps.setString(2, CHAIN_HEAD_SETTING))
            (§ call ps.setBytes(1, hash.getBytes()))
            (§ call ps.executeUpdate())
            (§ call ps.close())
        )
        (§ catch (SQLException e))
        (ß
            (§ throw new BlockStoreException(e))
        )
    )

    #_override
    #_public
    (§ method StoredBlock getVerifiedChainHead())
        (§ throws BlockStoreException)
    (ß
        (§ return verifiedChainHeadBlock)
    )

    #_override
    #_public
    (§ method void setVerifiedChainHead(StoredBlock chainHead))
        (§ throws BlockStoreException)
    (ß
        (§ var Sha256Hash hash = chainHead.getHeader().getHash())
        (§ ass this.verifiedChainHeadHash = hash)
        (§ ass this.verifiedChainHeadBlock = chainHead)
        (§ call maybeConnect())
        (§ try)
        (ß
            (§ var PreparedStatement ps = conn.get().prepareStatement(getUpdateSettingsSLQ()))
            (§ call ps.setString(2, VERIFIED_CHAIN_HEAD_SETTING))
            (§ call ps.setBytes(1, hash.getBytes()))
            (§ call ps.executeUpdate())
            (§ call ps.close())
        )
        (§ catch (SQLException e))
        (ß
            (§ throw new BlockStoreException(e))
        )
        (§ if (this.chainHeadBlock.getHeight() < chainHead.getHeight()))
            (§ call setChainHead(chainHead))
        (§ call removeUndoableBlocksWhereHeightIsLessThan(chainHead.getHeight() - fullStoreDepth))
    )

    #_private
    (§ method void removeUndoableBlocksWhereHeightIsLessThan(int height))
        (§ throws BlockStoreException)
    (ß
        (§ try)
        (ß
            (§ var PreparedStatement ps = conn.get().prepareStatement(getDeleteUndoableBlocksSQL()))
            (§ call ps.setInt(1, height))
            (§ if (log.isDebugEnabled()))
                (§ call log.debug("Deleting undoable undoable block with height <= " + height))
            (§ call ps.executeUpdate())
            (§ call ps.close())
        )
        (§ catch (SQLException e))
        (ß
            (§ throw new BlockStoreException(e))
        )
    )

    #_override
    #_public
    (§ method UTXO getTransactionOutput(Sha256Hash hash, long index))
        (§ throws BlockStoreException)
    (ß
        (§ call maybeConnect())
        (§ var PreparedStatement ps = nil)
        (§ try)
        (ß
            (§ ass ps = conn.get().prepareStatement(getSelectOpenoutputsSQL()))
            (§ call ps.setBytes(1, hash.getBytes()))
            ;; index is actually an unsigned int
            (§ call ps.setInt(2, (int)index))
            (§ var ResultSet results = ps.executeQuery())
            (§ if (!results.next()))
                (§ return nil)

            ;; Parse it.
            (§ var int height = results.getInt(1))
            (§ var Coin value = Coin.valueOf(results.getLong(2)))
            (§ var byte[] scriptBytes = results.getBytes(3))
            (§ var boolean coinbase = results.getBoolean(4))
            (§ var String address = results.getString(5))
            (§ return new UTXO(hash, index, value, height, coinbase, new Script(scriptBytes), address))
        )
        (§ catch (SQLException e))
        (ß
            (§ throw new BlockStoreException(e))
        )
        (§ finally)
        (ß
            (§ if (ps != nil))
            (ß
                (§ try)
                (ß
                    (§ call ps.close())
                )
                (§ catch (SQLException _))
                (ß
                    (§ throw new BlockStoreException("Failed to close PreparedStatement"))
                )
            )
        )
    )

    #_override
    #_public
    (§ method void addUnspentTransactionOutput(UTXO out))
        (§ throws BlockStoreException)
    (ß
        (§ call maybeConnect())
        (§ var PreparedStatement ps = nil)
        (§ try)
        (ß
            (§ ass ps = conn.get().prepareStatement(getInsertOpenoutputsSQL()))
            (§ call ps.setBytes(1, out.getHash().getBytes()))
            ;; index is actually an unsigned int
            (§ call ps.setInt(2, (int)out.getIndex()))
            (§ call ps.setInt(3, out.getHeight()))
            (§ call ps.setLong(4, out.getValue().value))
            (§ call ps.setBytes(5, out.getScript().getProgram()))
            (§ call ps.setString(6, out.getAddress()))
            (§ call ps.setInt(7, out.getScript().getScriptType().ordinal()))
            (§ call ps.setBoolean(8, out.isCoinbase()))
            (§ call ps.executeUpdate())
            (§ call ps.close())
        )
        (§ catch (SQLException e))
        (ß
            (§ if (!(e.getSQLState().equals(getDuplicateKeyErrorCode()))))
                (§ throw new BlockStoreException(e))
        )
        (§ finally)
        (ß
            (§ if (ps != nil))
            (ß
                (§ try)
                (ß
                    (§ call ps.close())
                )
                (§ catch (SQLException e))
                (ß
                    (§ throw new BlockStoreException(e))
                )
            )
        )
    )

    #_override
    #_public
    (§ method void removeUnspentTransactionOutput(UTXO out))
        (§ throws BlockStoreException)
    (ß
        (§ call maybeConnect())
        ;; TODO: This should only need one query (maybe a stored procedure).
        (§ if (getTransactionOutput(out.getHash(), out.getIndex()) == nil))
            (§ throw new BlockStoreException("Tried to remove a UTXO from DatabaseFullPrunedBlockStore that it didn't have!"))

        (§ try)
        (ß
            (§ var PreparedStatement ps = conn.get().prepareStatement(getDeleteOpenoutputsSQL()))
            (§ call ps.setBytes(1, out.getHash().getBytes()))
            ;; index is actually an unsigned int
            (§ call ps.setInt(2, (int)out.getIndex()))
            (§ call ps.executeUpdate())
            (§ call ps.close())
        )
        (§ catch (SQLException e))
        (ß
            (§ throw new BlockStoreException(e))
        )
    )

    #_override
    #_public
    (§ method void beginDatabaseBatchWrite())
        (§ throws BlockStoreException)
    (ß
        (§ call maybeConnect())
        (§ if (log.isDebugEnabled()))
            (§ call log.debug("Starting database batch write with connection: " + conn.get()))

        (§ try)
        (ß
            (§ call conn.get().setAutoCommit(false))
        )
        (§ catch (SQLException e))
        (ß
            (§ throw new BlockStoreException(e))
        )
    )

    #_override
    #_public
    (§ method void commitDatabaseBatchWrite())
        (§ throws BlockStoreException)
    (ß
        (§ call maybeConnect())
        (§ if (log.isDebugEnabled()))
            (§ call log.debug("Committing database batch write with connection: " + conn.get()))

        (§ try)
        (ß
            (§ call conn.get().commit())
            (§ call conn.get().setAutoCommit(true))
        )
        (§ catch (SQLException e))
        (ß
            (§ throw new BlockStoreException(e))
        )
    )

    #_override
    #_public
    (§ method void abortDatabaseBatchWrite())
        (§ throws BlockStoreException)
    (ß
        (§ call maybeConnect())
        (§ if (log.isDebugEnabled()))
            (§ call log.debug("Rollback database batch write with connection: " + conn.get()))

        (§ try)
        (ß
            (§ if (!conn.get().getAutoCommit()))
            (ß
                (§ call conn.get().rollback())
                (§ call conn.get().setAutoCommit(true))
            )
            (§ else)
            (ß
                (§ call log.warn("Warning: Rollback attempt without transaction"))
            )
        )
        (§ catch (SQLException e))
        (ß
            (§ throw new BlockStoreException(e))
        )
    )

    #_override
    #_public
    (§ method boolean hasUnspentOutputs(Sha256Hash hash, int numOutputs))
        (§ throws BlockStoreException)
    (ß
        (§ call maybeConnect())
        (§ var PreparedStatement ps = nil)
        (§ try)
        (ß
            (§ ass ps = conn.get().prepareStatement(getSelectOpenoutputsCountSQL()))
            (§ call ps.setBytes(1, hash.getBytes()))
            (§ var ResultSet results = ps.executeQuery())
            (§ if (!results.next()))
                (§ throw new BlockStoreException("Got no results from a COUNT(*) query"))

            (§ var int count = results.getInt(1))
            (§ return (count != 0))
        )
        (§ catch (SQLException e))
        (ß
            (§ throw new BlockStoreException(e))
        )
        (§ finally)
        (ß
            (§ if (ps != nil))
            (ß
                (§ try)
                (ß
                    (§ call ps.close())
                )
                (§ catch (SQLException _))
                (ß
                    (§ throw new BlockStoreException("Failed to close PreparedStatement"))
                )
            )
        )
    )

    #_override
    #_public
    (§ method NetworkParameters getParams())
    (ß
        (§ return params)
    )

    ;;;
     ; Resets the store by deleting the contents of the tables and reinitialising them.
     ; @throws BlockStoreException if the tables couldn't be cleared and initialised.
     ;;
    #_public
    (§ method void resetStore())
        (§ throws BlockStoreException)
    (ß
        (§ call maybeConnect())
        (§ try)
        (ß
            (§ call deleteStore())
            (§ call createTables())
            (§ call initFromDatabase())
        )
        (§ catch (SQLException e))
        (ß
            (§ throw new RuntimeException(e))
        )
    )

    ;;;
     ; Deletes the store by deleting the tables within the database.
     ; @throws BlockStoreException if tables couldn't be deleted.
     ;;
    #_public
    (§ method void deleteStore())
        (§ throws BlockStoreException)
    (ß
        (§ call maybeConnect())
        (§ try)
        (ß
            (§ var Statement s = conn.get().createStatement())
            (§ for (String sql :for getDropTablesSQL()))
                (§ call s.execute(sql))
            (§ call s.close())
        )
        (§ catch (SQLException e))
        (ß
            (§ throw new RuntimeException(e))
        )
    )

    ;;;
     ; Calculate the balance for a coinbase, to-address, or p2sh address.
     ;
     ; <p>The balance {@link org.bitcoinj.store.DatabaseFullPrunedBlockStore#getBalanceSelectSQL()} returns
     ; the balance (summed) as a number, then use calculateClientSide=false.</p>
     ;
     ; <p>The balance {@link org.bitcoinj.store.DatabaseFullPrunedBlockStore#getBalanceSelectSQL()} returns
     ; all the open outputs as stored in the DB (binary), then use calculateClientSide=true.</p>
     ;
     ; @param address The address to calculate the balance of.
     ; @return The balance of the address supplied.  If the address has not been seen,
     ;         or there are no outputs open for this address, the return value is 0.
     ; @throws BlockStoreException if there is an error getting the balance.
     ;;
    #_public
    (§ method BigInteger calculateBalanceForAddress(Address address))
        (§ throws BlockStoreException)
    (ß
        (§ call maybeConnect())
        (§ var PreparedStatement ps = nil)
        (§ try)
        (ß
            (§ ass ps = conn.get().prepareStatement(getBalanceSelectSQL()))
            (§ call ps.setString(1, address.toString()))
            (§ var ResultSet rs = ps.executeQuery())
            (§ var BigInteger balance = BigInteger.ZERO)
            (§ return rs.next() ? BigInteger.valueOf(rs.getLong(1)) :else balance)
        )
        (§ catch (SQLException e))
        (ß
            (§ throw new BlockStoreException(e))
        )
        (§ finally)
        (ß
            (§ if (ps != nil))
            (ß
                (§ try)
                (ß
                    (§ call ps.close())
                )
                (§ catch (SQLException _))
                (ß
                    (§ throw new BlockStoreException("Could not close statement"))
                )
            )
        )
    )
)

#_(ns org.bitcoinj.store #_"FullPrunedBlockStore"
  #_(:require #_[org.bitcoinj.core *]))

;;;
 ; <p>An implementor of FullPrunedBlockStore saves StoredBlock objects to some storage mechanism.</p>
 ;
 ; <p>In addition to keeping track of a chain using {@link StoredBlock}s, it should also keep track of
 ; a second copy of the chain which holds {@link StoredUndoableBlock}s.  In this way, an application can
 ; perform a headers-only initial sync and then use that information to more efficiently download a locally
 ; verified full copy of the block chain.</p>
 ;
 ; <p>A FullPrunedBlockStore should function well as a standard {@link BlockStore} and then be able to
 ; trivially switch to being used as a FullPrunedBlockStore.</p>
 ;
 ; <p>It should store the {@link StoredUndoableBlock}s of a number of recent blocks before verifiedHead.height
 ; and all those after verifiedHead.height.
 ; It is advisable to store any {@link StoredUndoableBlock} which has a height > verifiedHead.height - N.
 ; Because N determines the memory usage, it is recommended that N be customizable.  N should be chosen such
 ; that re-orgs beyond that point are vanishingly unlikely, e.g. a few thousand blocks is a reasonable choice.</p>
 ;
 ; <p>It must store the {@link StoredBlock} of all blocks.</p>
 ;
 ; <p>A FullPrunedBlockStore contains a map of hashes to [Full]StoredBlock.  The hash is the double digest of
 ; the Bitcoin serialization of the block header, <b>not</b> the header with the extra data as well.</p>
 ;
 ; <p>A FullPrunedBlockStore also contains a map of hash+index to UTXO.  Again, the hash is
 ; a standard Bitcoin double-SHA256 hash of the transaction.</p>
 ;
 ; <p>FullPrunedBlockStores are thread safe.</p>
 ;;
#_public
(§ interface FullPrunedBlockStore extends BlockStore
    ;;;
     ; <p>Saves the given {@link StoredUndoableBlock} and {@link StoredBlock}.  Calculates keys from the {@link StoredBlock}.</p>
     ;
     ; <p>Though not required for proper function of a FullPrunedBlockStore, any user of a FullPrunedBlockStore should ensure
     ; that a StoredUndoableBlock for each block up to the fully verified chain head has been added to this block store using
     ; this function (not put(StoredBlock)), so that the ability to perform reorgs is maintained.</p>
     ;
     ; @throws BlockStoreException if there is a problem with the underlying storage layer, such as running out of disk space.
     ;;
    (§ method void put(StoredBlock storedBlock, StoredUndoableBlock undoableBlock))
        (§ throws BlockStoreException)

    ;;;
     ; Returns the StoredBlock that was added as a StoredUndoableBlock given a hash.  The returned values block.getHash()
     ; method will be equal to the parameter.  If no such block is found, returns null.
     ;;
    (§ method StoredBlock getOnceUndoableStoredBlock(Sha256Hash hash))
        (§ throws BlockStoreException)

    ;;;
     ; Returns a {@link StoredUndoableBlock} whose block.getHash() method will be equal to the parameter.  If no such
     ; block is found, returns null.  Note that this may return null more often than get(Sha256Hash hash) as not all
     ; {@link StoredBlock}s have a {@link StoredUndoableBlock} copy stored as well.
     ;;
    (§ method StoredUndoableBlock getUndoBlock(Sha256Hash hash))
        (§ throws BlockStoreException)

    ;;;
     ; Gets a {@link org.bitcoinj.core.UTXO} with the given hash and index, or null if none is found.
     ;;
    (§ method UTXO getTransactionOutput(Sha256Hash hash, long index))
        (§ throws BlockStoreException)

    ;;;
     ; Adds a {@link org.bitcoinj.core.UTXO} to the list of unspent TransactionOutputs.
     ;;
    (§ method void addUnspentTransactionOutput(UTXO out))
        (§ throws BlockStoreException)

    ;;;
     ; Removes a {@link org.bitcoinj.core.UTXO} from the list of unspent TransactionOutputs.
     ; Note that the coinbase of the genesis block should NEVER be spendable and thus never in the list.
     ; @throws BlockStoreException if there is an underlying storage issue, or out was not in the list.
     ;;
    (§ method void removeUnspentTransactionOutput(UTXO out))
        (§ throws BlockStoreException)

    ;;;
     ; True if this store has any unspent outputs from a transaction with a hash equal to the first parameter.
     ; @param numOutputs The number of outputs the given transaction has.
     ;;
    (§ method boolean hasUnspentOutputs(Sha256Hash hash, int numOutputs))
        (§ throws BlockStoreException)

    ;;;
     ; Returns the {@link StoredBlock} that represents the top of the chain of greatest total work that has
     ; been fully verified and the point in the chain at which the unspent transaction output set in this
     ; store represents.
     ;;
    (§ method StoredBlock getVerifiedChainHead())
        (§ throws BlockStoreException)

    ;;;
     ; Sets the {@link StoredBlock} that represents the top of the chain of greatest total work that has been
     ; fully verified.  It should generally be set after a batch of updates to the transaction unspent output set,
     ; before a call to commitDatabaseBatchWrite.
     ;
     ; If chainHead has a greater height than the non-verified chain head (i.e. that set with
     ; {@link BlockStore#setChainHead}) the non-verified chain head should be set to the one set here.
     ; In this way a class using a FullPrunedBlockStore only in full-verification mode can ignore the regular
     ; {@link BlockStore} functions implemented as a part of a FullPrunedBlockStore.
     ;;
    (§ method void setVerifiedChainHead(StoredBlock chainHead))
        (§ throws BlockStoreException)

    ;;;
     ; <p>Begins/Commits/Aborts a database transaction.</p>
     ;
     ; <p>If abortDatabaseBatchWrite() is called by the same thread that called beginDatabaseBatchWrite(),
     ; any data writes between this call and abortDatabaseBatchWrite() made by the same thread
     ; should be discarded.</p>
     ;
     ; <p>Furthermore, any data written after a call to beginDatabaseBatchWrite() should not be readable
     ; by any other threads until commitDatabaseBatchWrite() has been called by this thread.
     ; Multiple calls to beginDatabaseBatchWrite() in any given thread should be ignored and treated as one call.</p>
     ;;
    (§ method void beginDatabaseBatchWrite())
        (§ throws BlockStoreException)

    (§ method void commitDatabaseBatchWrite())
        (§ throws BlockStoreException)

    (§ method void abortDatabaseBatchWrite())
        (§ throws BlockStoreException)
)

#_(ns org.bitcoinj.store #_"H2FullPrunedBlockStore"
    (:import #_[java.sql *]
             [java.util ArrayList Collections List])
  #_(:require #_[org.bitcoinj.core *]))

;;;
 ; A full pruned block store using the H2 pure-java embedded database.
 ;
 ; Note that because of the heavy delete load on the database, during IBD,
 ; you may see the database files grow quite large (around 1.5G).
 ; H2 automatically frees some space at shutdown, so close()ing the database
 ; decreases the space usage somewhat (to only around 1.3G).
 ;;
#_public
(§ class H2FullPrunedBlockStore extends DatabaseFullPrunedBlockStore
    #_private
    #_static
    #_final
    (§ field String H2_DUPLICATE_KEY_ERROR_CODE = "23505")
    #_private
    #_static
    #_final
    (§ field String DATABASE_DRIVER_CLASS = "org.h2.Driver")
    #_private
    #_static
    #_final
    (§ field String DATABASE_CONNECTION_URL_PREFIX = "jdbc:h2:")

    ;; create table SQL
    #_private
    #_static
    #_final
    (§ field String CREATE_SETTINGS_TABLE = "CREATE TABLE settings ( "
            + "name VARCHAR(32) NOT NULL CONSTRAINT settings_pk PRIMARY KEY,"
            + "value BLOB"
            + ")")

    #_private
    #_static
    #_final
    (§ field String CREATE_HEADERS_TABLE = "CREATE TABLE headers ( "
            + "hash BINARY(28) NOT NULL CONSTRAINT headers_pk PRIMARY KEY,"
            + "chainwork BLOB NOT NULL,"
            + "height INT NOT NULL,"
            + "header BLOB NOT NULL,"
            + "wasundoable BOOL NOT NULL"
            + ")")

    #_private
    #_static
    #_final
    (§ field String CREATE_UNDOABLE_TABLE = "CREATE TABLE undoableblocks ( "
            + "hash BINARY(28) NOT NULL CONSTRAINT undoableblocks_pk PRIMARY KEY,"
            + "height INT NOT NULL,"
            + "txoutchanges BLOB,"
            + "transactions BLOB"
            + ")")

    #_private
    #_static
    #_final
    (§ field String CREATE_OPEN_OUTPUT_TABLE = "CREATE TABLE openoutputs ("
            + "hash BINARY(32) NOT NULL,"
            + "index INT NOT NULL,"
            + "height INT NOT NULL,"
            + "value BIGINT NOT NULL,"
            + "scriptbytes BLOB NOT NULL,"
            + "toaddress VARCHAR(35),"
            + "addresstargetable TINYINT,"
            + "coinbase BOOLEAN,"
            + "PRIMARY KEY (hash, index),"
            + ")")

    ;; Some indexes to speed up inserts.
    #_private
    #_static
    #_final
    (§ field String CREATE_OUTPUTS_ADDRESS_MULTI_INDEX     = "CREATE INDEX openoutputs_hash_index_height_toaddress_idx ON openoutputs (hash, index, height, toaddress)")
    #_private
    #_static
    #_final
    (§ field String CREATE_OUTPUTS_TOADDRESS_INDEX         = "CREATE INDEX openoutputs_toaddress_idx ON openoutputs (toaddress)")
    #_private
    #_static
    #_final
    (§ field String CREATE_OUTPUTS_ADDRESSTARGETABLE_INDEX = "CREATE INDEX openoutputs_addresstargetable_idx ON openoutputs (addresstargetable)")
    #_private
    #_static
    #_final
    (§ field String CREATE_OUTPUTS_HASH_INDEX              = "CREATE INDEX openoutputs_hash_idx ON openoutputs (hash)")
    #_private
    #_static
    #_final
    (§ field String CREATE_UNDOABLE_TABLE_INDEX            = "CREATE INDEX undoableblocks_height_idx ON undoableblocks (height)")

    ;;;
     ; Creates a new H2FullPrunedBlockStore, with given credentials for H2 database.
     ; @param params A copy of the NetworkParameters used.
     ; @param dbName The path to the database on disk.
     ; @param username The username to use in the database.
     ; @param password The username's password to use in the database.
     ; @param fullStoreDepth The number of blocks of history stored in full (something like 1000 is pretty safe).
     ; @throws BlockStoreException if the database fails to open for any reason.
     ;;
    #_public
    (§ constructor H2FullPrunedBlockStore(NetworkParameters params, String dbName, String username, String password, int fullStoreDepth))
        (§ throws BlockStoreException)
    (ß
        (§ super (params, DATABASE_CONNECTION_URL_PREFIX + dbName + ";create=true;LOCK_TIMEOUT=60000;DB_CLOSE_ON_EXIT=FALSE", fullStoreDepth, username, password, nil))
    )

    ;;;
     ; Creates a new H2FullPrunedBlockStore.
     ; @param params A copy of the NetworkParameters used.
     ; @param dbName The path to the database on disk.
     ; @param fullStoreDepth The number of blocks of history stored in full (something like 1000 is pretty safe).
     ; @throws BlockStoreException if the database fails to open for any reason.
     ;;
    #_public
    (§ constructor H2FullPrunedBlockStore(NetworkParameters params, String dbName, int fullStoreDepth))
        (§ throws BlockStoreException)
    (ß
        (§ this (params, dbName, nil, nil, fullStoreDepth))
    )

    ;;;
     ; Creates a new H2FullPrunedBlockStore with the given cache size.
     ; @param params A copy of the NetworkParameters used.
     ; @param dbName The path to the database on disk.
     ; @param fullStoreDepth The number of blocks of history stored in full (something like 1000 is pretty safe).
     ; @param cacheSize The number of kilobytes to dedicate to H2 Cache.  The default value of 16MB (16384) is a safe bet
     ;                  to achieve good performance/cost when importing blocks from disk, past 32MB makes little sense,
     ;                  and below 4MB sees a sharp drop in performance.
     ; @throws BlockStoreException if the database fails to open for any reason.
     ;;
    #_public
    (§ constructor H2FullPrunedBlockStore(NetworkParameters params, String dbName, int fullStoreDepth, int cacheSize))
        (§ throws BlockStoreException)
    (ß
        (§ this (params, dbName, fullStoreDepth))

        (§ try)
        (ß
            (§ var Statement s = conn.get().createStatement())
            (§ call s.executeUpdate("SET CACHE_SIZE " + cacheSize))
            (§ call s.close())
        )
        (§ catch (SQLException e))
        (ß
            (§ throw new BlockStoreException(e))
        )
    )

    #_override
    #_protected
    (§ method String getDuplicateKeyErrorCode())
    (ß
        (§ return H2_DUPLICATE_KEY_ERROR_CODE)
    )

    #_override
    #_protected
    (§ method List<String> getCreateTablesSQL())
    (ß
        (§ var List<String> sql = new ArrayList<>())
        (§ call sql.add(CREATE_SETTINGS_TABLE))
        (§ call sql.add(CREATE_HEADERS_TABLE))
        (§ call sql.add(CREATE_UNDOABLE_TABLE))
        (§ call sql.add(CREATE_OPEN_OUTPUT_TABLE))
        (§ return sql)
    )

    #_override
    #_protected
    (§ method List<String> getCreateIndexesSQL())
    (ß
        (§ var List<String> sql = new ArrayList<>())
        (§ call sql.add(CREATE_UNDOABLE_TABLE_INDEX))
        (§ call sql.add(CREATE_OUTPUTS_ADDRESS_MULTI_INDEX))
        (§ call sql.add(CREATE_OUTPUTS_ADDRESSTARGETABLE_INDEX))
        (§ call sql.add(CREATE_OUTPUTS_HASH_INDEX))
        (§ call sql.add(CREATE_OUTPUTS_TOADDRESS_INDEX))
        (§ return sql)
    )

    #_override
    #_protected
    (§ method List<String> getCreateSchemeSQL())
    (ß
        ;; do nothing
        (§ return Collections.emptyList())
    )

    #_override
    #_protected
    (§ method String getDatabaseDriverClass())
    (ß
        (§ return DATABASE_DRIVER_CLASS)
    )
)

#_(ns org.bitcoinj.store #_"MemoryBlockStore"
    (:import [java.util LinkedHashMap Map])
  #_(:require #_[org.bitcoinj.core *]))

;;;
 ; Keeps {@link org.bitcoinj.core.StoredBlock}s in memory.  Used primarily for unit testing.
 ;;
#_public
(§ class MemoryBlockStore implements BlockStore
    #_private
    (§ field LinkedHashMap<Sha256Hash, StoredBlock> blockMap = new LinkedHashMap<Sha256Hash, StoredBlock>()
        (ß
            #_override
            #_protected
            (§ method boolean removeEldestEntry(Map.Entry<Sha256Hash, StoredBlock> eldest))
            (ß
                (§ return (5000 < blockMap.size()))
            )
        ))
    #_private
    (§ field StoredBlock chainHead)
    #_private
    (§ field NetworkParameters params)

    #_public
    (§ constructor MemoryBlockStore(NetworkParameters params))
    (ß
        ;; Insert the genesis block.
        (§ try)
        (ß
            (§ var Block genesisHeader = params.getGenesisBlock().cloneAsHeader())
            (§ var StoredBlock storedGenesis = new StoredBlock(genesisHeader, genesisHeader.getWork(), 0))
            (§ call put(storedGenesis))
            (§ call setChainHead(storedGenesis))
            (§ ass this.params = params)
        )
        (§ catch (BlockStoreException e))
        (ß
            (§ throw new RuntimeException(e)) ;; Cannot happen.
        )
        (§ catch (VerificationException e))
        (ß
            (§ throw new RuntimeException(e)) ;; Cannot happen.
        )
    )

    #_override
    #_public
    #_synchronized
    #_final
    (§ method void put(StoredBlock block))
        (§ throws BlockStoreException)
    (ß
        (§ if (blockMap == nil))
            (§ throw new BlockStoreException("MemoryBlockStore is closed"))

        (§ var Sha256Hash hash = block.getHeader().getHash())
        (§ call blockMap.put(hash, block))
    )

    #_override
    #_public
    #_synchronized
    (§ method StoredBlock get(Sha256Hash hash))
        (§ throws BlockStoreException)
    (ß
        (§ if (blockMap == nil))
            (§ throw new BlockStoreException("MemoryBlockStore is closed"))

        (§ return blockMap.get(hash))
    )

    #_override
    #_public
    (§ method StoredBlock getChainHead())
        (§ throws BlockStoreException)
    (ß
        (§ if (blockMap == nil))
            (§ throw new BlockStoreException("MemoryBlockStore is closed"))

        (§ return chainHead)
    )

    #_override
    #_public
    #_final
    (§ method void setChainHead(StoredBlock chainHead))
        (§ throws BlockStoreException)
    (ß
        (§ if (blockMap == nil))
            (§ throw new BlockStoreException("MemoryBlockStore is closed"))

        (§ ass this.chainHead = chainHead)
    )

    #_override
    #_public
    (§ method void close())
    (ß
        (§ ass blockMap = nil)
    )

    #_override
    #_public
    (§ method NetworkParameters getParams())
    (ß
        (§ return params)
    )
)

#_(ns org.bitcoinj.store #_"MemoryFullPrunedBlockStore"
    (:import #_[java.util *])
    (:import [com.google.common.base Objects Preconditions]
             [com.google.common.collect Lists])
  #_(:require #_[org.bitcoinj.core *]))

;;;
 ; Used as a key for memory map (to avoid having to think about NetworkParameters,
 ; which is required for {@link TransactionOutPoint}.
 ;;
(§ class StoredTransactionOutPoint
    ;;; Hash of the transaction to which we refer. ;;
    (§ field Sha256Hash hash)
    ;;; Which output of that transaction we are talking about. ;;
    (§ field long index)

    (§ constructor StoredTransactionOutPoint(Sha256Hash hash, long index))
    (ß
        (§ ass this.hash = hash)
        (§ ass this.index = index)
    )

    (§ constructor StoredTransactionOutPoint(UTXO out))
    (ß
        (§ ass this.hash = out.getHash())
        (§ ass this.index = out.getIndex())
    )

    ;;;
     ; The hash of the transaction to which we refer.
     ;;
    (§ method Sha256Hash getHash())
    (ß
        (§ return hash)
    )

    ;;;
     ; The index of the output in transaction to which we refer.
     ;;
    (§ method long getIndex())
    (ß
        (§ return index)
    )

    #_override
    #_public
    (§ method int hashCode())
    (ß
        (§ return Objects.hashCode(getIndex(), getHash()))
    )

    #_override
    #_public
    (§ method String toString())
    (ß
        (§ return "Stored transaction out point: " + hash + ":" + index)
    )

    #_override
    #_public
    (§ method boolean equals(Object o))
    (ß
        (§ if (this == o))
            (§ return true)
        (§ if (o == nil || getClass() != o.getClass()))
            (§ return false)
        (§ var StoredTransactionOutPoint other = (StoredTransactionOutPoint)o)
        (§ return (getIndex() == other.getIndex() && Objects.equal(getHash(), other.getHash())))
    )
)

;;;
 ; A HashMap<KeyType, ValueType> that is DB transaction-aware.
 ; This class is not thread-safe.
 ;;
(§ class TransactionalHashMap<KeyType, ValueType>
    (§ field ThreadLocal<HashMap<KeyType, ValueType>> tempMap)
    (§ field ThreadLocal<HashSet<KeyType>> tempSetRemoved)
    #_private
    (§ field ThreadLocal<Boolean> inTransaction)

    (§ field HashMap<KeyType, ValueType> map)

    #_public
    (§ constructor TransactionalHashMap())
    (ß
        (§ ass tempMap = new ThreadLocal<>())
        (§ ass tempSetRemoved = new ThreadLocal<>())
        (§ ass inTransaction = new ThreadLocal<>())
        (§ ass map = new HashMap<>())
    )

    #_public
    (§ method void beginDatabaseBatchWrite())
    (ß
        (§ call inTransaction.set(true))
    )

    #_public
    (§ method void commitDatabaseBatchWrite())
    (ß
        (§ if (tempSetRemoved.get() != nil))
            (§ for (KeyType key :for tempSetRemoved.get()))
                (§ call map.remove(key))
        (§ if (tempMap.get() != nil))
            (§ for (Map.Entry<KeyType, ValueType> entry :for tempMap.get().entrySet()))
                (§ call map.put(entry.getKey(), entry.getValue()))
        (§ call abortDatabaseBatchWrite())
    )

    #_public
    (§ method void abortDatabaseBatchWrite())
    (ß
        (§ call inTransaction.set(false))
        (§ call tempSetRemoved.remove())
        (§ call tempMap.remove())
    )

    #_nilable
    #_public
    (§ method ValueType get(KeyType key))
    (ß
        (§ if (Boolean.TRUE.equals(inTransaction.get())))
        (ß
            (§ if (tempMap.get() != nil))
            (ß
                (§ var ValueType value = tempMap.get().get(key))
                (§ if (value != nil))
                    (§ return value)
            )
            (§ if (tempSetRemoved.get() != nil && tempSetRemoved.get().contains(key)))
                (§ return nil)
        )
        (§ return map.get(key))
    )

    #_public
    (§ method List<ValueType> values())
    (ß
        (§ var List<ValueType> valueTypes = new ArrayList<>())
        (§ for (KeyType keyType :for map.keySet()))
            (§ call valueTypes.add(get(keyType)))
        (§ return valueTypes)
    )

    #_public
    (§ method void put(KeyType key, ValueType value))
    (ß
        (§ if (Boolean.TRUE.equals(inTransaction.get())))
        (ß
            (§ if (tempSetRemoved.get() != nil))
                (§ call tempSetRemoved.get().remove(key))
            (§ if (tempMap.get() == nil))
                (§ call tempMap.set(new HashMap<KeyType, ValueType>()))
            (§ call tempMap.get().put(key, value))
        )
        (§ else)
        (ß
            (§ call map.put(key, value))
        )
    )

    #_nilable
    #_public
    (§ method ValueType remove(KeyType key))
    (ß
        (§ if (Boolean.TRUE.equals(inTransaction.get())))
        (ß
            (§ var ValueType retVal = map.get(key))
            (§ if (retVal != nil))
            (ß
                (§ if (tempSetRemoved.get() == nil))
                    (§ call tempSetRemoved.set(new HashSet<KeyType>()))
                (§ call tempSetRemoved.get().add(key))
            )
            (§ if (tempMap.get() != nil))
            (ß
                (§ var ValueType tempVal = tempMap.get().remove(key))
                (§ if (tempVal != nil))
                    (§ return tempVal)
            )
            (§ return retVal)
        )
        (§ else)
        (ß
            (§ return map.remove(key))
        )
    )
)

;;;
 ; A Map with multiple key types that is DB per-thread-transaction-aware.
 ; However, this class is not thread-safe.
 ; @param <UniqueKeyType> Is a key that must be unique per object.
 ; @param <MultiKeyType> Is a key that can have multiple values.
 ;;
(§ class TransactionalMultiKeyHashMap<UniqueKeyType, MultiKeyType, ValueType>
    (§ field TransactionalHashMap<UniqueKeyType, ValueType> mapValues)
    (§ field HashMap<MultiKeyType, Set<UniqueKeyType>> mapKeys)

    #_public
    (§ constructor TransactionalMultiKeyHashMap())
    (ß
        (§ ass mapValues = new TransactionalHashMap<>())
        (§ ass mapKeys = new HashMap<>())
    )

    #_public
    (§ method void beginTransaction())
    (ß
        (§ call mapValues.beginDatabaseBatchWrite())
    )

    #_public
    (§ method void commitTransaction())
    (ß
        (§ call mapValues.commitDatabaseBatchWrite())
    )

    #_public
    (§ method void abortTransaction())
    (ß
        (§ call mapValues.abortDatabaseBatchWrite())
    )

    #_nilable
    #_public
    (§ method ValueType get(UniqueKeyType key))
    (ß
        (§ return mapValues.get(key))
    )

    #_public
    (§ method void put(UniqueKeyType uniqueKey, MultiKeyType multiKey, ValueType value))
    (ß
        (§ call mapValues.put(uniqueKey, value))
        (§ var Set<UniqueKeyType> set = mapKeys.get(multiKey))
        (§ if (set == nil))
        (ß
            (§ ass set = new HashSet<>())
            (§ call set.add(uniqueKey))
            (§ call mapKeys.put(multiKey, set))
        )
        (§ else)
        (ß
            (§ call set.add(uniqueKey))
        )
    )

    #_nilable
    #_public
    (§ method ValueType removeByUniqueKey(UniqueKeyType key))
    (ß
        (§ return mapValues.remove(key))
    )

    #_public
    (§ method void removeByMultiKey(MultiKeyType key))
    (ß
        (§ var Set<UniqueKeyType> set = mapKeys.remove(key))
        (§ if (set != nil))
            (§ for (UniqueKeyType uniqueKey :for set))
                (§ call removeByUniqueKey(uniqueKey))
    )
)

;;;
 ; Keeps {@link StoredBlock}s, {@link StoredUndoableBlock}s and {@link org.bitcoinj.core.UTXO}s in memory.
 ; Used primarily for unit testing.
 ;;
#_public
(§ class MemoryFullPrunedBlockStore implements FullPrunedBlockStore
    #_protected
    #_static
    (§ class StoredBlockAndWasUndoableFlag
        #_public
        (§ field StoredBlock block)
        #_public
        (§ field boolean wasUndoable)
        #_public
        (§ constructor StoredBlockAndWasUndoableFlag(StoredBlock block, boolean wasUndoable))
        (ß
            (§ ass this.block = block)
            (§ ass this.wasUndoable = wasUndoable)
        )
    )
    #_private
    (§ field TransactionalHashMap<Sha256Hash, StoredBlockAndWasUndoableFlag> blockMap)
    #_private
    (§ field TransactionalMultiKeyHashMap<Sha256Hash, Integer, StoredUndoableBlock> fullBlockMap)
    ;; TODO: Use something more suited to remove-heavy use?
    #_private
    (§ field TransactionalHashMap<StoredTransactionOutPoint, UTXO> transactionOutputMap)
    #_private
    (§ field StoredBlock chainHead)
    #_private
    (§ field StoredBlock verifiedChainHead)
    #_private
    (§ field int fullStoreDepth)
    #_private
    (§ field NetworkParameters params)

    ;;;
     ; Set up the MemoryFullPrunedBlockStore.
     ; @param params The network parameters of this block store - used to get genesis block.
     ; @param fullStoreDepth The depth of blocks to keep FullStoredBlocks instead of StoredBlocks.
     ;;
    #_public
    (§ constructor MemoryFullPrunedBlockStore(NetworkParameters params, int fullStoreDepth))
    (ß
        (§ ass blockMap = new TransactionalHashMap<>())
        (§ ass fullBlockMap = new TransactionalMultiKeyHashMap<>())
        (§ ass transactionOutputMap = new TransactionalHashMap<>())
        (§ ass this.fullStoreDepth = (0 < fullStoreDepth) ? fullStoreDepth :else 1)
        ;; Insert the genesis block.
        (§ try)
        (ß
            (§ var StoredBlock storedGenesisHeader = new StoredBlock(params.getGenesisBlock().cloneAsHeader(), params.getGenesisBlock().getWork(), 0))
            ;; The coinbase in the genesis block is not spendable.
            (§ var List<Transaction> genesisTransactions = Lists.newLinkedList())
            (§ var StoredUndoableBlock storedGenesis = new StoredUndoableBlock(params.getGenesisBlock().getHash(), genesisTransactions))
            (§ call put(storedGenesisHeader, storedGenesis))
            (§ call setChainHead(storedGenesisHeader))
            (§ call setVerifiedChainHead(storedGenesisHeader))
            (§ ass this.params = params)
        )
        (§ catch (BlockStoreException e))
        (ß
            (§ throw new RuntimeException(e)) ;; Cannot happen.
        )
        (§ catch (VerificationException e))
        (ß
            (§ throw new RuntimeException(e)) ;; Cannot happen.
        )
    )

    #_override
    #_public
    #_synchronized
    (§ method void put(StoredBlock block))
        (§ throws BlockStoreException)
    (ß
        (§ call Preconditions.checkNotNull(blockMap, "MemoryFullPrunedBlockStore is closed"))
        (§ var Sha256Hash hash = block.getHeader().getHash())
        (§ call blockMap.put(hash, new StoredBlockAndWasUndoableFlag(block, false)))
    )

    #_override
    #_public
    #_synchronized
    #_final
    (§ method void put(StoredBlock storedBlock, StoredUndoableBlock undoableBlock))
        (§ throws BlockStoreException)
    (ß
        (§ call Preconditions.checkNotNull(blockMap, "MemoryFullPrunedBlockStore is closed"))
        (§ var Sha256Hash hash = storedBlock.getHeader().getHash())
        (§ call fullBlockMap.put(hash, storedBlock.getHeight(), undoableBlock))
        (§ call blockMap.put(hash, new StoredBlockAndWasUndoableFlag(storedBlock, true)))
    )

    #_override
    #_nilable
    #_public
    #_synchronized
    (§ method StoredBlock get(Sha256Hash hash))
        (§ throws BlockStoreException)
    (ß
        (§ call Preconditions.checkNotNull(blockMap, "MemoryFullPrunedBlockStore is closed"))
        (§ var StoredBlockAndWasUndoableFlag storedBlock = blockMap.get(hash))
        (§ return (storedBlock != nil) ? storedBlock.block :else nil)
    )

    #_override
    #_nilable
    #_public
    #_synchronized
    (§ method StoredBlock getOnceUndoableStoredBlock(Sha256Hash hash))
        (§ throws BlockStoreException)
    (ß
        (§ call Preconditions.checkNotNull(blockMap, "MemoryFullPrunedBlockStore is closed"))
        (§ var StoredBlockAndWasUndoableFlag storedBlock = blockMap.get(hash))
        (§ return (storedBlock != nil && storedBlock.wasUndoable) ? storedBlock.block :else nil)
    )

    #_override
    #_nilable
    #_public
    #_synchronized
    (§ method StoredUndoableBlock getUndoBlock(Sha256Hash hash))
        (§ throws BlockStoreException)
    (ß
        (§ call Preconditions.checkNotNull(fullBlockMap, "MemoryFullPrunedBlockStore is closed"))
        (§ return fullBlockMap.get(hash))
    )

    #_override
    #_public
    #_synchronized
    (§ method StoredBlock getChainHead())
        (§ throws BlockStoreException)
    (ß
        (§ call Preconditions.checkNotNull(blockMap, "MemoryFullPrunedBlockStore is closed"))
        (§ return chainHead)
    )

    #_override
    #_public
    #_synchronized
    #_final
    (§ method void setChainHead(StoredBlock chainHead))
        (§ throws BlockStoreException)
    (ß
        (§ call Preconditions.checkNotNull(blockMap, "MemoryFullPrunedBlockStore is closed"))
        (§ ass this.chainHead = chainHead)
    )

    #_override
    #_public
    #_synchronized
    (§ method StoredBlock getVerifiedChainHead())
        (§ throws BlockStoreException)
    (ß
        (§ call Preconditions.checkNotNull(blockMap, "MemoryFullPrunedBlockStore is closed"))
        (§ return verifiedChainHead)
    )

    #_override
    #_public
    #_synchronized
    #_final
    (§ method void setVerifiedChainHead(StoredBlock chainHead))
        (§ throws BlockStoreException)
    (ß
        (§ call Preconditions.checkNotNull(blockMap, "MemoryFullPrunedBlockStore is closed"))
        (§ ass this.verifiedChainHead = chainHead)
        (§ if (this.chainHead.getHeight() < chainHead.getHeight()))
            (§ call setChainHead(chainHead))
        ;; Potential leak here if not all blocks get setChainHead'd.
        ;; Though the FullPrunedBlockStore allows for this, the current AbstractBlockChain will not do it.
        (§ call fullBlockMap.removeByMultiKey(chainHead.getHeight() - fullStoreDepth))
    )

    #_override
    #_public
    (§ method void close())
    (ß
        (§ ass blockMap = nil)
        (§ ass fullBlockMap = nil)
        (§ ass transactionOutputMap = nil)
    )

    #_override
    #_nilable
    #_public
    #_synchronized
    (§ method UTXO getTransactionOutput(Sha256Hash hash, long index))
        (§ throws BlockStoreException)
    (ß
        (§ call Preconditions.checkNotNull(transactionOutputMap, "MemoryFullPrunedBlockStore is closed"))
        (§ return transactionOutputMap.get(new StoredTransactionOutPoint(hash, index)))
    )

    #_override
    #_public
    #_synchronized
    (§ method void addUnspentTransactionOutput(UTXO out))
        (§ throws BlockStoreException)
    (ß
        (§ call Preconditions.checkNotNull(transactionOutputMap, "MemoryFullPrunedBlockStore is closed"))
        (§ call transactionOutputMap.put(new StoredTransactionOutPoint(out), out))
    )

    #_override
    #_public
    #_synchronized
    (§ method void removeUnspentTransactionOutput(UTXO out))
        (§ throws BlockStoreException)
    (ß
        (§ call Preconditions.checkNotNull(transactionOutputMap, "MemoryFullPrunedBlockStore is closed"))
        (§ if (transactionOutputMap.remove(new StoredTransactionOutPoint(out)) == nil))
            (§ throw new BlockStoreException("Tried to remove a UTXO from MemoryFullPrunedBlockStore that it didn't have!"))
    )

    #_override
    #_public
    #_synchronized
    (§ method void beginDatabaseBatchWrite())
        (§ throws BlockStoreException)
    (ß
        (§ call blockMap.beginDatabaseBatchWrite())
        (§ call fullBlockMap.beginTransaction())
        (§ call transactionOutputMap.beginDatabaseBatchWrite())
    )

    #_override
    #_public
    #_synchronized
    (§ method void commitDatabaseBatchWrite())
        (§ throws BlockStoreException)
    (ß
        (§ call blockMap.commitDatabaseBatchWrite())
        (§ call fullBlockMap.commitTransaction())
        (§ call transactionOutputMap.commitDatabaseBatchWrite())
    )

    #_override
    #_public
    #_synchronized
    (§ method void abortDatabaseBatchWrite())
        (§ throws BlockStoreException)
    (ß
        (§ call blockMap.abortDatabaseBatchWrite())
        (§ call fullBlockMap.abortTransaction())
        (§ call transactionOutputMap.abortDatabaseBatchWrite())
    )

    #_override
    #_public
    #_synchronized
    (§ method boolean hasUnspentOutputs(Sha256Hash hash, int numOutputs))
        (§ throws BlockStoreException)
    (ß
        (§ for (int i = 0 :for i < numOutputs :for i = i + 1))
            (§ if (getTransactionOutput(hash, i) != nil))
                (§ return true)
        (§ return false)
    )

    #_override
    #_public
    (§ method NetworkParameters getParams())
    (ß
        (§ return params)
    )
)

#_(ns org.bitcoinj.store #_"PostgresFullPrunedBlockStore"
    (:import [java.io ByteArrayOutputStream IOException]
             [java.sql PreparedStatement ResultSet SQLException Types]
             [java.util ArrayList List])
    (:import [org.slf4j Logger LoggerFactory])
  #_(:require #_[org.bitcoinj.core *]))

;;;
 ; <p>A full pruned block store using the Postgres database engine.  As an added bonus an address index is calculated,
 ; so you can use {@link #calculateBalanceForAddress(org.bitcoinj.core.Address)} to quickly look up
 ; the quantity of bitcoins controlled by that address.</p>
 ;;
#_public
(§ class PostgresFullPrunedBlockStore extends DatabaseFullPrunedBlockStore
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(PostgresFullPrunedBlockStore.class))

    #_private
    #_static
    #_final
    (§ field String POSTGRES_DUPLICATE_KEY_ERROR_CODE = "23505")
    #_private
    #_static
    #_final
    (§ field String DATABASE_DRIVER_CLASS = "org.postgresql.Driver")
    #_private
    #_static
    #_final
    (§ field String DATABASE_CONNECTION_URL_PREFIX = "jdbc:postgresql://")

    ;; create table SQL
    #_private
    #_static
    #_final
    (§ field String CREATE_SETTINGS_TABLE = "CREATE TABLE settings ("
          + "name character varying(32) NOT NULL, "
          + "value bytea, "
          + "CONSTRAINT setting_pk PRIMARY KEY (name)"
          + ")")

    #_private
    #_static
    #_final
    (§ field String CREATE_HEADERS_TABLE = "CREATE TABLE headers ("
          + "hash bytea NOT NULL, "
          + "chainwork bytea NOT NULL, "
          + "height integer NOT NULL, "
          + "header bytea NOT NULL, "
          + "wasundoable boolean NOT NULL, "
          + "CONSTRAINT headers_pk PRIMARY KEY (hash)"
          + ")")

    #_private
    #_static
    #_final
    (§ field String CREATE_UNDOABLE_TABLE = "CREATE TABLE undoableblocks ("
          + "hash bytea NOT NULL, "
          + "height integer NOT NULL, "
          + "txoutchanges bytea, "
          + "transactions bytea, "
          + "CONSTRAINT undoableblocks_pk PRIMARY KEY (hash)"
          + ")")

    #_private
    #_static
    #_final
    (§ field String CREATE_OPEN_OUTPUT_TABLE = "CREATE TABLE openoutputs ("
          + "hash bytea NOT NULL, "
          + "index integer NOT NULL, "
          + "height integer NOT NULL, "
          + "value bigint NOT NULL, "
          + "scriptbytes bytea NOT NULL, "
          + "toaddress character varying(35), "
          + "addresstargetable smallint, "
          + "coinbase boolean, "
          + "CONSTRAINT openoutputs_pk PRIMARY KEY (hash,index)"
          + ")")

    ;; Some indexes to speed up inserts.
    #_private
    #_static
    #_final
    (§ field String CREATE_OUTPUTS_ADDRESS_MULTI_INDEX     = "CREATE INDEX openoutputs_hash_index_num_height_toaddress_idx ON openoutputs USING btree (hash, index, height, toaddress)")
    #_private
    #_static
    #_final
    (§ field String CREATE_OUTPUTS_TOADDRESS_INDEX         = "CREATE INDEX openoutputs_toaddress_idx ON openoutputs USING btree (toaddress)")
    #_private
    #_static
    #_final
    (§ field String CREATE_OUTPUTS_ADDRESSTARGETABLE_INDEX = "CREATE INDEX openoutputs_addresstargetable_idx ON openoutputs USING btree (addresstargetable)")
    #_private
    #_static
    #_final
    (§ field String CREATE_OUTPUTS_HASH_INDEX              = "CREATE INDEX openoutputs_hash_idx ON openoutputs USING btree (hash)")
    #_private
    #_static
    #_final
    (§ field String CREATE_UNDOABLE_TABLE_INDEX            = "CREATE INDEX undoableblocks_height_idx ON undoableBlocks USING btree (height)")

    #_private
    #_static
    #_final
    (§ field String SELECT_UNDOABLEBLOCKS_EXISTS_SQL       = "select 1 from undoableblocks where hash = ?")

    ;;;
     ; Creates a new PostgresFullPrunedBlockStore.
     ;
     ; @param params A copy of the NetworkParameters used.
     ; @param fullStoreDepth The number of blocks of history stored in full (something like 1000 is pretty safe).
     ; @param hostname The hostname of the database to connect to.
     ; @param dbName The database to connect to.
     ; @param username The database username.
     ; @param password The password to the database.
     ; @throws BlockStoreException if the database fails to open for any reason.
     ;;
    #_public
    (§ constructor PostgresFullPrunedBlockStore(NetworkParameters params, int fullStoreDepth, String hostname, String dbName, String username, String password))
        (§ throws BlockStoreException)
    (ß
        (§ super (params, DATABASE_CONNECTION_URL_PREFIX + hostname + "/" + dbName, fullStoreDepth, username, password, nil))
    )

    ;;;
     ; <p>Create a new PostgresFullPrunedBlockStore, storing the tables in the schema specified.  You may want to
     ; specify a schema to avoid name collisions, or just to keep the database better organized.  The schema is not
     ; required, and if one is not provided than the default schema for the username will be used.  See
     ; <a href="http://www.postgres.org/docs/9.3/static/ddl-schemas.html">the postgres schema docs</a>
     ; for more on schemas.</p>
     ;
     ; @param params A copy of the NetworkParameters used.
     ; @param fullStoreDepth The number of blocks of history stored in full (something like 1000 is pretty safe).
     ; @param hostname The hostname of the database to connect to.
     ; @param dbName The database to connect to.
     ; @param username The database username.
     ; @param password The password to the database.
     ; @param schemaName The name of the schema to put the tables in.  May be null if no schema is being used.
     ; @throws BlockStoreException if the database fails to open for any reason.
     ;;
    #_public
    (§ constructor PostgresFullPrunedBlockStore(NetworkParameters params, int fullStoreDepth, String hostname, String dbName, String username, String password, #_nilable String schemaName))
        (§ throws BlockStoreException)
    (ß
        (§ super (params, DATABASE_CONNECTION_URL_PREFIX + hostname + "/" + dbName, fullStoreDepth, username, password, schemaName))
    )

    #_override
    #_protected
    (§ method String getDuplicateKeyErrorCode())
    (ß
        (§ return POSTGRES_DUPLICATE_KEY_ERROR_CODE)
    )

    #_override
    #_protected
    (§ method List<String> getCreateTablesSQL())
    (ß
        (§ var List<String> sql = new ArrayList<>())
        (§ call sql.add(CREATE_SETTINGS_TABLE))
        (§ call sql.add(CREATE_HEADERS_TABLE))
        (§ call sql.add(CREATE_UNDOABLE_TABLE))
        (§ call sql.add(CREATE_OPEN_OUTPUT_TABLE))
        (§ return sql)
    )

    #_override
    #_protected
    (§ method List<String> getCreateIndexesSQL())
    (ß
        (§ var List<String> sql = new ArrayList<>())
        (§ call sql.add(CREATE_UNDOABLE_TABLE_INDEX))
        (§ call sql.add(CREATE_OUTPUTS_ADDRESS_MULTI_INDEX))
        (§ call sql.add(CREATE_OUTPUTS_ADDRESSTARGETABLE_INDEX))
        (§ call sql.add(CREATE_OUTPUTS_HASH_INDEX))
        (§ call sql.add(CREATE_OUTPUTS_TOADDRESS_INDEX))
        (§ return sql)
    )

    #_override
    #_protected
    (§ method List<String> getCreateSchemeSQL())
    (ß
        (§ var List<String> sql = new ArrayList<>())
        (§ call sql.add("CREATE SCHEMA IF NOT EXISTS " + schemaName))
        (§ call sql.add("set search_path to '" + schemaName +"'"))
        (§ return sql)
    )

    #_override
    #_protected
    (§ method String getDatabaseDriverClass())
    (ß
        (§ return DATABASE_DRIVER_CLASS)
    )

    #_override
    #_public
    (§ method void put(StoredBlock storedBlock, StoredUndoableBlock undoableBlock))
        (§ throws BlockStoreException)
    (ß
        (§ call maybeConnect())
        ;; We skip the first 4 bytes because (on mainnet) the minimum target has 4 0-bytes.
        (§ var byte[] hashBytes = new byte[28])
        (§ call System.arraycopy(storedBlock.getHeader().getHash().getBytes(), 4, hashBytes, 0, 28))
        (§ var int height = storedBlock.getHeight())
        (§ var byte[] transactions = nil)
        (§ var byte[] txOutChanges = nil)
        (§ try)
        (ß
            (§ var ByteArrayOutputStream bos = new ByteArrayOutputStream())
            (§ if (undoableBlock.getTxOutChanges() != nil))
            (ß
                (§ call undoableBlock.getTxOutChanges().serializeToStream(bos))
                (§ ass txOutChanges = bos.toByteArray())
            )
            (§ else)
            (ß
                (§ var int numTxn = undoableBlock.getTransactions().size())
                (§ call bos.write(0xff & numTxn))
                (§ call bos.write(0xff & (numTxn >> 8)))
                (§ call bos.write(0xff & (numTxn >> 16)))
                (§ call bos.write(0xff & (numTxn >> 24)))
                (§ for (Transaction tx :for undoableBlock.getTransactions()))
                    (§ call tx.bitcoinSerialize(bos))
                (§ ass transactions = bos.toByteArray())
            )
            (§ call bos.close())
        )
        (§ catch (IOException e))
        (ß
            (§ throw new BlockStoreException(e))
        )

        (§ try)
        (ß
            (§ if (log.isDebugEnabled()))
                (§ call log.debug("Looking for undoable block with hash: " + Utils.HEX.encode(hashBytes)))

            (§ var PreparedStatement findS = conn.get().prepareStatement(SELECT_UNDOABLEBLOCKS_EXISTS_SQL))
            (§ call findS.setBytes(1, hashBytes))

            (§ var ResultSet rs = findS.executeQuery())
            (§ if (rs.next()))
            (ß
                ;; We already have this output, update it.
                (§ call findS.close())

                ;; Postgres insert-or-updates are very complex (and finnicky).
                ;; This level of transaction isolation seems to work for bitcoinj.
                (§ var PreparedStatement ps = conn.get().prepareStatement(getUpdateUndoableBlocksSQL()))
                (§ call ps.setBytes(3, hashBytes))

                (§ if (log.isDebugEnabled()))
                    (§ call log.debug("Updating undoable block with hash: " + Utils.HEX.encode(hashBytes)))

                (§ if (transactions == nil))
                (ß
                    (§ call ps.setBytes(1, txOutChanges))
                    (§ call ps.setNull(2, Types.BINARY))
                )
                (§ else)
                (ß
                    (§ call ps.setNull(1, Types.BINARY))
                    (§ call ps.setBytes(2, transactions))
                )
                (§ call ps.executeUpdate())
                (§ call ps.close())

                (§ return)
            )

            (§ var PreparedStatement ps = conn.get().prepareStatement(getInsertUndoableBlocksSQL()))
            (§ call ps.setBytes(1, hashBytes))
            (§ call ps.setInt(2, height))

            (§ if (log.isDebugEnabled()))
                (§ call log.debug("Inserting undoable block with hash: " + Utils.HEX.encode(hashBytes)  + " at height " + height))

            (§ if (transactions == nil))
            (ß
                (§ call ps.setBytes(3, txOutChanges))
                (§ call ps.setNull(4, Types.BINARY))
            )
            (§ else)
            (ß
                (§ call ps.setNull(3, Types.BINARY))
                (§ call ps.setBytes(4, transactions))
            )
            (§ call ps.executeUpdate())
            (§ call ps.close())
            (§ try)
            (ß
                (§ call putUpdateStoredBlock(storedBlock, true))
            )
            (§ catch (SQLException e))
            (ß
                (§ throw new BlockStoreException(e))
            )
        )
        (§ catch (SQLException e))
        (ß
            (§ if (!e.getSQLState().equals(POSTGRES_DUPLICATE_KEY_ERROR_CODE)))
                (§ throw new BlockStoreException(e))
        )
    )
)

#_(ns org.bitcoinj.store #_"SPVBlockStore"
    (:import #_[java.io *]
             #_[java.nio *]
             #_[java.nio.channels *]
             #_[java.util *]
             #_[java.util.concurrent.locks *])
    (:import [com.google.common.base Charsets Preconditions]
             #_[org.slf4j *])
  #_(:require #_[org.bitcoinj.core *]
             #_[org.bitcoinj.utils *]))

;; TODO: Lose the mmap in this class.  There are too many platform bugs that require odd workarounds.

;;;
 ; An SPVBlockStore holds a limited number of block headers in a memory mapped ring buffer.  With such a store,
 ; you may not be able to process very deep re-orgs and could be disconnected from the chain (requiring a replay),
 ; but as they are virtually unheard of this is not a significant risk.
 ;;
#_public
(§ class SPVBlockStore implements BlockStore
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(SPVBlockStore.class))

    ;;; The default number of headers that will be stored in the ring buffer. ;;
    #_public
    #_static
    #_final
    (§ field int DEFAULT_CAPACITY = 5000)
    #_public
    #_static
    #_final
    (§ field String HEADER_MAGIC = "SPVB")

    #_protected
    #_volatile
    (§ field MappedByteBuffer buffer)
    #_protected
    #_final
    (§ field int capacity)
    #_protected
    #_final
    (§ field NetworkParameters params)

    #_protected
    (§ field ReentrantLock lock = Threading.lock("SPVBlockStore"))

    ;; The entire ring-buffer is mmapped and accessing it should be as fast as accessing regular memory once it's
    ;; faulted in.  Unfortunately, in theory practice and theory are the same.  In practice they aren't.
    ;;
    ;; MMapping a file in Java does not give us a byte[] as you may expect but rather a ByteBuffer, and whilst on
    ;; the OpenJDK/Oracle JVM calls into the get() methods are compiled down to inlined native code on Android each
    ;; get() call is actually a full-blown JNI method under the hood, meaning it's unbelievably slow.  The caches
    ;; below let us stay in the JIT-compiled Java world without expensive JNI transitions and make a 10x difference!
    #_protected
    (§ field LinkedHashMap<Sha256Hash, StoredBlock> blockCache = new LinkedHashMap<Sha256Hash, StoredBlock>()
        (ß
            #_override
            #_protected
            (§ method boolean removeEldestEntry(Map.Entry<Sha256Hash, StoredBlock> entry))
            (ß
                (§ return (2050 < size())) ;; Slightly more than the difficulty transition period.
            )
        ))

    ;; Use a separate cache to track get() misses.  This is to efficiently handle the case of an unconnected block
    ;; during chain download.  Each new block will do a get() on the unconnected block so if we haven't seen it yet
    ;; we must efficiently respond.
    ;;
    ;; We don't care about the value in this cache.  It is always notFoundMarker.  Unfortunately LinkedHashSet does
    ;; not provide the removeEldestEntry control.
    #_private
    #_static
    #_final
    (§ field Object NOT_FOUND_MARKER = new Object())
    #_protected
    (§ field LinkedHashMap<Sha256Hash, Object> notFoundCache = new LinkedHashMap<Sha256Hash, Object>()
        (ß
            #_override
            #_protected
            (§ method boolean removeEldestEntry(Map.Entry<Sha256Hash, Object> entry))
            (ß
                (§ return (100 < size())) ;; This was chosen arbitrarily.
            )
        ))

    ;; Used to stop other applications/processes from opening the store.
    #_protected
    (§ field FileLock fileLock)
    #_protected
    (§ field RandomAccessFile randomAccessFile)

    ;;;
     ; Creates and initializes an SPV block store that can hold {@link #DEFAULT_CAPACITY} blocks.
     ; Will create the given file if it's missing.  This operation will block on disk.
     ; @param file File to use for the block store.
     ; @throws BlockStoreException if something goes wrong.
     ;;
    #_public
    (§ constructor SPVBlockStore(NetworkParameters params, File file))
        (§ throws BlockStoreException)
    (ß
        (§ this (params, file, DEFAULT_CAPACITY))
    )

    ;;;
     ; Creates and initializes an SPV block store that can hold a given amount of blocks.
     ; Will create the given file if it's missing.  This operation will block on disk.
     ; @param file File to use for the block store.
     ; @param capacity Custom capacity.
     ; @throws BlockStoreException if something goes wrong.
     ;;
    #_public
    (§ constructor SPVBlockStore(NetworkParameters params, File file, int capacity))
        (§ throws BlockStoreException)
    (ß
        (§ call Preconditions.checkNotNull(file))
        (§ ass this.params = Preconditions.checkNotNull(params))
        (§ call Preconditions.checkArgument(capacity > 0))

        (§ ass this.capacity = capacity)
        (§ try)
        (ß
            (§ var boolean exists = file.exists())
            ;; Set up the backing file.
            (§ ass randomAccessFile = new RandomAccessFile(file, "rw"))
            (§ var long fileSize = getFileSize(capacity))
            (§ if (!exists))
            (ß
                (§ call log.info("Creating new SPV block chain file " + file))
                (§ call randomAccessFile.setLength(fileSize))
            )
            (§ elseif (randomAccessFile.length() != fileSize))
            (ß
                (§ throw new BlockStoreException("File size on disk does not match expected size: " + randomAccessFile.length() + " vs " + fileSize))
            )

            (§ var FileChannel channel = randomAccessFile.getChannel())
            (§ ass fileLock = channel.tryLock())
            (§ if (fileLock == nil))
                (§ throw new ChainFileLockedException("Store file is already locked by another process"))

            ;; Map it into memory read/write.  The kernel will take care of flushing writes to disk at the most
            ;; efficient times, which may mean that until the map is deallocated the data on disk is randomly
            ;; inconsistent.  However the only process accessing it is us, via this mapping, so our own view will
            ;; always be correct.  Once we establish the mmap the underlying file and channel can go away.  Note
            ;; that the details of mmapping vary between platforms.
            (§ ass buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, fileSize))

            ;; Check or initialize the header bytes to ensure we don't try to open some random file.
            (§ var byte[] header)
            (§ if (exists))
            (ß
                (§ ass header = new byte[4])
                (§ call buffer.get(header))
                (§ if (!new String(header, Charsets.US_ASCII).equals(HEADER_MAGIC)))
                    (§ throw new BlockStoreException("Header bytes do not equal " + HEADER_MAGIC))
            )
            (§ else)
            (ß
                (§ call initNewStore(params))
            )
        )
        (§ catch (Exception e1))
        (ß
            (§ try)
            (ß
                (§ if (randomAccessFile != nil))
                    (§ call randomAccessFile.close())
            )
            (§ catch (IOException e2))
            (ß
                (§ throw new BlockStoreException(e2))
            )
            (§ throw new BlockStoreException(e1))
        )
    )

    #_private
    (§ method void initNewStore(NetworkParameters params))
        (§ throws Exception)
    (ß
        (§ var byte[] header = HEADER_MAGIC.getBytes("US-ASCII"))
        (§ call buffer.put(header))
        ;; Insert the genesis block.
        (§ call lock.lock())
        (§ try)
        (ß
            (§ call setRingCursor(buffer, FILE_PROLOGUE_BYTES))
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
        (§ var Block genesis = params.getGenesisBlock().cloneAsHeader())
        (§ var StoredBlock storedGenesis = new StoredBlock(genesis, genesis.getWork(), 0))
        (§ call put(storedGenesis))
        (§ call setChainHead(storedGenesis))
    )

    ;;; Returns the size in bytes of the file that is used to store the chain with the current parameters. ;;
    #_public
    #_static
    #_final
    (§ method int getFileSize(int capacity))
    (ß
        (§ return RECORD_SIZE * capacity + FILE_PROLOGUE_BYTES) ;; extra kilobyte for stuff
    )

    #_override
    #_public
    (§ method void put(StoredBlock block))
        (§ throws BlockStoreException)
    (ß
        #_final
        (§ var MappedByteBuffer buffer = this.buffer)
        (§ if (buffer == nil))
            (§ throw new BlockStoreException("Store closed"))

        (§ call lock.lock())
        (§ try)
        (ß
            (§ var int cursor = getRingCursor(buffer))
            ;; Wrapped around.
            (§ if (cursor == getFileSize(capacity)))
                (§ ass cursor = FILE_PROLOGUE_BYTES)
            (§ call buffer.position(cursor))
            (§ var Sha256Hash hash = block.getHeader().getHash())
            (§ call notFoundCache.remove(hash))
            (§ call buffer.put(hash.getBytes()))
            (§ call block.serializeCompact(buffer))
            (§ call setRingCursor(buffer, buffer.position()))
            (§ call blockCache.put(hash, block))
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    #_override
    #_nilable
    #_public
    (§ method StoredBlock get(Sha256Hash hash))
        (§ throws BlockStoreException)
    (ß
        #_final
        (§ var MappedByteBuffer buffer = this.buffer)
        (§ if (buffer == nil))
            (§ throw new BlockStoreException("Store closed"))

        (§ call lock.lock())
        (§ try)
        (ß
            (§ var StoredBlock cacheHit = blockCache.get(hash))
            (§ if (cacheHit != nil))
                (§ return cacheHit)
            (§ if (notFoundCache.get(hash) != nil))
                (§ return nil)

            ;; Starting from the current tip of the ring work backwards until we have either
            ;; found the block or wrapped around.
            (§ var int cursor = getRingCursor(buffer))
            #_final
            (§ var int startingPoint = cursor)
            #_final
            (§ var int fileSize = getFileSize(capacity))
            #_final
            (§ var byte[] targetHashBytes = hash.getBytes())
            (§ var byte[] scratch = new byte[32])
            (§ do)
            (ß
                (§ ass cursor = cursor - RECORD_SIZE)
                ;; We hit the start, so wrap around.
                (§ if (cursor < FILE_PROLOGUE_BYTES))
                    (§ ass cursor = fileSize - RECORD_SIZE)
                ;; Cursor is now at the start of the next record to check, so read the hash and compare it.
                (§ call buffer.position(cursor))
                (§ call buffer.get(scratch))
                (§ if (Arrays.equals(scratch, targetHashBytes)))
                (ß
                    ;; Found the target.
                    (§ var StoredBlock storedBlock = StoredBlock.deserializeCompact(params, buffer))
                    (§ call blockCache.put(hash, storedBlock))
                    (§ return storedBlock)
                )
            )
            (§ again (cursor != startingPoint))

            ;; Not found.
            (§ call notFoundCache.put(hash, NOT_FOUND_MARKER))
            (§ return nil)
        )
        (§ catch (ProtocolException e))
        (ß
            (§ throw new RuntimeException(e)) ;; Cannot happen.
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    #_protected
    (§ field StoredBlock lastChainHead)

    #_override
    #_public
    (§ method StoredBlock getChainHead())
        (§ throws BlockStoreException)
    (ß
        #_final
        (§ var MappedByteBuffer buffer = this.buffer)
        (§ if (buffer == nil))
            (§ throw new BlockStoreException("Store closed"))

        (§ call lock.lock())
        (§ try)
        (ß
            (§ if (lastChainHead == nil))
            (ß
                (§ var byte[] headHash = new byte[32])
                (§ call buffer.position(8))
                (§ call buffer.get(headHash))
                (§ var Sha256Hash hash = Sha256Hash.wrap(headHash))
                (§ var StoredBlock block = get(hash))
                (§ if (block == nil))
                    (§ throw new BlockStoreException("Corrupted block store: could not find chain head: " + hash))

                (§ ass lastChainHead = block)
            )
            (§ return lastChainHead)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    #_override
    #_public
    (§ method void setChainHead(StoredBlock chainHead))
        (§ throws BlockStoreException)
    (ß
        #_final
        (§ var MappedByteBuffer buffer = this.buffer)
        (§ if (buffer == nil))
            (§ throw new BlockStoreException("Store closed"))

        (§ call lock.lock())
        (§ try)
        (ß
            (§ ass lastChainHead = chainHead)
            (§ var byte[] headHash = chainHead.getHeader().getHash().getBytes())
            (§ call buffer.position(8))
            (§ call buffer.put(headHash))
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    #_override
    #_public
    (§ method void close())
        (§ throws BlockStoreException)
    (ß
        (§ try)
        (ß
            (§ call buffer.force())
            (§ ass buffer = nil) ;; Allow it to be GCd and the underlying file mapping to go away.
            (§ call randomAccessFile.close())
        )
        (§ catch (IOException e))
        (ß
            (§ throw new BlockStoreException(e))
        )
    )

    #_override
    #_public
    (§ method NetworkParameters getParams())
    (ß
        (§ return params)
    )

    #_protected
    #_static
    #_final
    (§ field int RECORD_SIZE = 32 + StoredBlock.COMPACT_SERIALIZED_SIZE) ;; hash

    ;; File format:
    ;;   4 header bytes = "SPVB"
    ;;   4 cursor bytes, which indicate the offset from the first kb where the next block header should be written
    ;;   32 bytes for the hash of the chain head
    ;;
    ;; For each header (128 bytes)
    ;;   32 bytes hash of the header
    ;;   12 bytes of chain work
    ;;    4 bytes of height
    ;;   80 bytes of block header data
    #_protected
    #_static
    #_final
    (§ field int FILE_PROLOGUE_BYTES = 1024)

    ;;; Returns the offset from the file start where the latest block should be written (end of prev block). ;;
    #_private
    (§ method int getRingCursor(ByteBuffer buffer))
    (ß
        (§ var int c = buffer.getInt(4))
        (§ call Preconditions.checkState(FILE_PROLOGUE_BYTES <= c, "Integer overflow"))
        (§ return c)
    )

    #_private
    (§ method void setRingCursor(ByteBuffer buffer, int newCursor))
    (ß
        (§ call Preconditions.checkArgument(0 <= newCursor))
        (§ call buffer.putInt(4, newCursor))
    )
)

#_(ns org.bitcoinj.uri #_"BitcoinURI"
    (:import [java.io UnsupportedEncodingException]
             [java.net URI URISyntaxException URLDecoder]
             [java.util ArrayList Collections LinkedHashMap List Locale Map])
    (:import [com.google.common.base Preconditions])
  #_(:require [org.bitcoinj.core Address AddressFormatException Coin NetworkParameters]
             [org.bitcoinj.params AbstractBitcoinNetParams]))

;;;
 ; <p>Provides a standard implementation of a Bitcoin URI with support for the following:</p>
 ;
 ; <ul>
 ; <li>URLEncoded URIs (as passed in by IE on the command line)</li>
 ; <li>BIP21 names (including the "req-" prefix handling requirements)</li>
 ; </ul>
 ;
 ; <h2>Accepted formats</h2>
 ;
 ; <p>The following input forms are accepted:</p>
 ;
 ; <ul>
 ; <li>{@code bitcoin:<address>}</li>
 ; <li>{@code bitcoin:<address>?<name1>=<value1>&<name2>=<value2>} with multiple additional name/value pairs</li>
 ; </ul>
 ;
 ; <p>The name/value pairs are processed as follows.</p>
 ; <ol>
 ; <li>URL encoding is stripped and treated as UTF-8</li>
 ; <li>names prefixed with {@code req-} are treated as required and if unknown or conflicting cause a parse exception</li>
 ; <li>Unknown names not prefixed with {@code req-} are added to a Map, accessible by parameter name</li>
 ; <li>Known names not prefixed with {@code req-} are processed unless they are malformed</li>
 ; </ol>
 ;
 ; <p>The following names are known and have the following formats:</p>
 ; <ul>
 ; <li>{@code amount} decimal value to 8 dp (e.g. 0.12345678) <b>Note that the exponent notation is not supported any more.</b></li>
 ; <li>{@code label} any URL encoded alphanumeric</li>
 ; <li>{@code message} any URL encoded alphanumeric</li>
 ; </ul>
 ;
 ; @author Andreas Schildbach (initial code)
 ; @author Jim Burton (enhancements for MultiBit)
 ; @author Gary Rowe (BIP21 support)
 ; @see <a href="https://github.com/bitcoin/bips/blob/master/bip-0021.mediawiki">BIP 0021</a>
 ;;
#_public
(§ class BitcoinURI
    ;; Not worth turning into an enum.
    #_public
    #_static
    #_final
    (§ field String FIELD_MESSAGE = "message")
    #_public
    #_static
    #_final
    (§ field String FIELD_LABEL = "label")
    #_public
    #_static
    #_final
    (§ field String FIELD_AMOUNT = "amount")
    #_public
    #_static
    #_final
    (§ field String FIELD_ADDRESS = "address")
    #_public
    #_static
    #_final
    (§ field String FIELD_PAYMENT_REQUEST_URL = "r")

    ;;;
     ; URI for Bitcoin network.  Use {@link org.bitcoinj.params.AbstractBitcoinNetParams#BITCOIN_SCHEME}
     ; if you specifically need Bitcoin, or use {@link org.bitcoinj.core.NetworkParameters#getUriScheme}
     ; to get the scheme from network parameters.
     ;;
    #_deprecated
    #_public
    #_static
    #_final
    (§ field String BITCOIN_SCHEME = "bitcoin")
    #_private
    #_static
    #_final
    (§ field String ENCODED_SPACE_CHARACTER = "%20")
    #_private
    #_static
    #_final
    (§ field String AMPERSAND_SEPARATOR = "&")
    #_private
    #_static
    #_final
    (§ field String QUESTION_MARK_SEPARATOR = "?")

    ;;;
     ; Contains all the parameters in the order in which they were processed.
     ;;
    #_private
    #_final
    (§ field Map<String, Object> parameterMap = new LinkedHashMap<>())

    ;;;
     ; Constructs a new BitcoinURI from the given string.  Can be for any network.
     ;
     ; @param uri The raw URI data to be parsed (see class comments for accepted formats).
     ; @throws BitcoinURIParseException if the URI is not syntactically or semantically valid.
     ;;
    #_public
    (§ constructor BitcoinURI(String uri))
        (§ throws BitcoinURIParseException)
    (ß
        (§ this (nil, uri))
    )

    ;;;
     ; Constructs a new object by trying to parse the input as a valid Bitcoin URI.
     ;
     ; @param params The network parameters that determine which network the URI is from, or null if you
     ;               don't have any expectation about what network the URI is for and wish to check yourself.
     ; @param input The raw URI data to be parsed (see class comments for accepted formats).
     ;
     ; @throws BitcoinURIParseException if the input fails Bitcoin URI syntax and semantic checks.
     ;;
    #_public
    (§ constructor BitcoinURI(#_nilable NetworkParameters params, String input))
        (§ throws BitcoinURIParseException)
    (ß
        (§ call Preconditions.checkNotNull(input))

        (§ var String scheme = (params != nil) ? params.getUriScheme() :else AbstractBitcoinNetParams.BITCOIN_SCHEME)

        ;; Attempt to form the URI (fail fast syntax checking to official standards).
        (§ var URI uri)
        (§ try)
        (ß
            (§ ass uri = new URI(input))
        )
        (§ catch (URISyntaxException e))
        (ß
            (§ throw new BitcoinURIParseException("Bad URI syntax", e))
        )

        ;; URI is formed as  bitcoin:<address>?<query parameters>
        ;; blockchain.info generates URIs of non-BIP compliant form bitcoin://address?....
        ;; We support both until Ben fixes his code.

        ;; Remove the bitcoin scheme.
        ;; (Note: getSchemeSpecificPart() is not used as it unescapes the label and parse then fails.
        ;; For instance with  bitcoin:129mVqKUmJ9uwPxKJBnNdABbuaaNfho4Ha?amount=0.06&label=Tom%20%26%20Jerry
        ;; the & (%26) in Tom and Jerry gets interpreted as a separator and the label then gets parsed
        ;; as 'Tom ' instead of 'Tom & Jerry'.)
        (§ var String blockchainInfoScheme = scheme + "://")
        (§ var String correctScheme = scheme + ":")
        (§ var String schemeSpecificPart)
        (§ if (input.startsWith(blockchainInfoScheme)))
            (§ ass schemeSpecificPart = input.substring(blockchainInfoScheme.length()))
        (§ elseif (input.startsWith(correctScheme)))
            (§ ass schemeSpecificPart = input.substring(correctScheme.length()))
        (§ else)
            (§ throw new BitcoinURIParseException("Unsupported URI scheme: " + uri.getScheme()))

        ;; Split off the address from the rest of the query parameters.
        (§ var String[] addressSplitTokens = schemeSpecificPart.split("\\?", 2))
        (§ if (addressSplitTokens.length == 0))
            (§ throw new BitcoinURIParseException("No data found after the bitcoin: prefix"))

        (§ var String addressToken = addressSplitTokens[0]) ;; may be empty!

        (§ var String[] nameValuePairTokens)
        (§ if (addressSplitTokens.length == 1))
        (ß
            ;; Only an address is specified - use an empty '<name>=<value>' token array.
            (§ ass nameValuePairTokens = new String[] (ß ))
        )
        (§ else)
        (ß
            ;; Split into '<name>=<value>' tokens.
            (§ ass nameValuePairTokens = addressSplitTokens[1].split("&"))
        )

        ;; Attempt to parse the rest of the URI parameters.
        (§ call parseParameters(params, addressToken, nameValuePairTokens))

        (§ if (!addressToken.isEmpty()))
        (ß
            ;; Attempt to parse the addressToken as a Bitcoin address for this network.
            (§ try)
            (ß
                (§ var Address address = Address.fromBase58(params, addressToken))
                (§ call putWithValidation(FIELD_ADDRESS, address))
            )
            (§ catch (#_final AddressFormatException e))
            (ß
                (§ throw new BitcoinURIParseException("Bad address", e))
            )
        )

        (§ if (addressToken.isEmpty() && getPaymentRequestUrl() == nil))
            (§ throw new BitcoinURIParseException("No address and no r= parameter found"))
    )

    ;;;
     ; @param params The network parameters or null.
     ; @param nameValuePairTokens The tokens representing the name value pairs (assumed to be separated by '=' e.g. 'amount=0.2').
     ;;
    #_private
    (§ method void parseParameters(#_nilable NetworkParameters params, String addressToken, String[] nameValuePairTokens))
        (§ throws BitcoinURIParseException)
    (ß
        ;; Attempt to decode the rest of the tokens into a parameter map.
        (§ for (String nameValuePairToken :for nameValuePairTokens))
        (ß
            #_final
            (§ var int sepIndex = nameValuePairToken.indexOf("="))
            (§ if (sepIndex == -1))
                (§ throw new BitcoinURIParseException("Malformed Bitcoin URI - no separator in '" + nameValuePairToken + "'"))
            (§ if (sepIndex == 0))
                (§ throw new BitcoinURIParseException("Malformed Bitcoin URI - empty name '" + nameValuePairToken + "'"))

            #_final
            (§ var String nameToken = nameValuePairToken.substring(0, sepIndex).toLowerCase(Locale.ENGLISH))
            #_final
            (§ var String valueToken = nameValuePairToken.substring(sepIndex + 1))

            ;; Parse the amount.
            (§ if (FIELD_AMOUNT.equals(nameToken)))
            (ß
                ;; Decode the amount (contains an optional decimal component to 8dp).
                (§ try)
                (ß
                    (§ var Coin amount = Coin.parseCoin(valueToken))
                    (§ if (params != nil && amount.isGreaterThan(params.getMaxMoney())))
                        (§ throw new BitcoinURIParseException("Max number of coins exceeded"))
                    (§ if (amount.signum() < 0))
                        (§ throw new ArithmeticException("Negative coins specified"))

                    (§ call putWithValidation(FIELD_AMOUNT, amount))
                )
                (§ catch (IllegalArgumentException e))
                (ß
                    (§ throw new OptionalFieldValidationException(String.format(Locale.US, "'%s' is not a valid amount", valueToken), e))
                )
                (§ catch (ArithmeticException e))
                (ß
                    (§ throw new OptionalFieldValidationException(String.format(Locale.US, "'%s' has too many decimal places", valueToken), e))
                )
            )
            (§ else)
            (ß
                (§ if (nameToken.startsWith("req-")))
                (ß
                    ;; A required parameter that we do not know about.
                    (§ throw new RequiredFieldValidationException("'" + nameToken + "' is required but not known, this URI is not valid"))
                )

                ;; Known fields and unknown parameters that are optional.
                (§ try)
                (ß
                    (§ if (0 < valueToken.length()))
                        (§ call putWithValidation(nameToken, URLDecoder.decode(valueToken, "UTF-8")))
                )
                (§ catch (UnsupportedEncodingException e))
                (ß
                    (§ throw new RuntimeException(e)) ;; Can't happen.
                )
            )
        )

        ;; Note to the future:
        ;; when you want to implement 'req-expires', have a look at commit 410a53791841 which had it in.
    )

    ;;;
     ; Put the value against the key in the map checking for duplication.  This avoids address field overwrite etc.
     ;
     ; @param key The key for the map.
     ; @param value The value to store.
     ;;
    #_private
    (§ method void putWithValidation(String key, Object value))
        (§ throws BitcoinURIParseException)
    (ß
        (§ if (parameterMap.containsKey(key)))
            (§ throw new BitcoinURIParseException(String.format(Locale.US, "'%s' is duplicated, URI is invalid", key)))

        (§ call parameterMap.put(key, value))
    )

    ;;;
     ; The Bitcoin Address from the URI, if one was present.  It's possible to have Bitcoin URI's with no address
     ; if a r= payment protocol parameter is specified, though this form is not recommended as older wallets
     ; can't understand it.
     ;;
    #_nilable
    #_public
    (§ method Address getAddress())
    (ß
        (§ return (Address)parameterMap.get(FIELD_ADDRESS))
    )

    ;;;
     ; @return The amount name encoded using a pure integer value based at 10,000,000 units is 1 BTC.
     ;         May be null if no amount is specified.
     ;;
    #_public
    (§ method Coin getAmount())
    (ß
        (§ return (Coin)parameterMap.get(FIELD_AMOUNT))
    )

    ;;;
     ; @return the label from the URI.
     ;;
    #_public
    (§ method String getLabel())
    (ß
        (§ return (String)parameterMap.get(FIELD_LABEL))
    )

    ;;;
     ; @return the message from the URI.
     ;;
    #_public
    (§ method String getMessage())
    (ß
        (§ return (String)parameterMap.get(FIELD_MESSAGE))
    )

    ;;;
     ; @return the URL where a payment request (as specified in BIP 70) may be fetched.
     ;;
    #_public
    #_final
    (§ method String getPaymentRequestUrl())
    (ß
        (§ return (String)parameterMap.get(FIELD_PAYMENT_REQUEST_URL))
    )

    ;;;
     ; Returns the URLs where a payment request (as specified in BIP 70) may be fetched.
     ; The first URL is the main URL, all subsequent URLs are fallbacks.
     ;;
    #_public
    (§ method List<String> getPaymentRequestUrls())
    (ß
        (§ var ArrayList<String> urls = new ArrayList<>())
        (§ while (true))
        (ß
            (§ var int i = urls.size())
            (§ var String paramName = FIELD_PAYMENT_REQUEST_URL + (0 < i ? Integer.toString(i) :else ""))
            (§ var String url = (String)parameterMap.get(paramName))
            (§ if (url == nil))
                (§ break)
            (§ call urls.add(url))
        )
        (§ call Collections.reverse(urls))
        (§ return urls)
    )

    ;;;
     ; @param name The name of the parameter.
     ; @return the parameter value, or null if not present.
     ;;
    #_public
    (§ method Object getParameterByName(String name))
    (ß
        (§ return parameterMap.get(name))
    )

    #_override
    #_public
    (§ method String toString())
    (ß
        (§ var StringBuilder sb = new StringBuilder("BitcoinURI["))
        (§ var boolean first = true)
        (§ for (Map.Entry<String, Object> entry :for parameterMap.entrySet()))
        (ß
            (§ if (first))
                (§ ass first = false)
            (§ else)
                (§ call sb.append(","))
            (§ call sb.append("'").append(entry.getKey()).append("'='").append(entry.getValue()).append("'"))
        )
        (§ call sb.append("]"))
        (§ return sb.toString())
    )

    ;;;
     ; Simple Bitcoin URI builder using known good fields.
     ;
     ; @param address The Bitcoin address.
     ; @param amount The amount.
     ; @param label A label.
     ; @param message A message.
     ; @return a String containing the Bitcoin URI.
     ;;
    #_public
    #_static
    (§ method String convertToBitcoinURI(Address address, Coin amount, String label, String message))
    (ß
        (§ return convertToBitcoinURI(address.getParameters(), address.toString(), amount, label, message))
    )

    ;;;
     ; Simple Bitcoin URI builder using known good fields.
     ;
     ; @param params The network parameters that determine which network the URI is for.
     ; @param address The Bitcoin address.
     ; @param amount The amount.
     ; @param label A label.
     ; @param message A message.
     ; @return a String containing the Bitcoin URI.
     ;;
    #_public
    #_static
    (§ method String convertToBitcoinURI(NetworkParameters params, String address, #_nilable Coin amount, #_nilable String label, #_nilable String message))
    (ß
        (§ call Preconditions.checkNotNull(params))
        (§ call Preconditions.checkNotNull(address))

        (§ if (amount != nil && amount.signum() < 0))
            (§ throw new IllegalArgumentException("Coin must be positive"))

        (§ var StringBuilder sb = new StringBuilder())
        (§ var String scheme = params.getUriScheme())
        (§ call sb.append(scheme).append(":").append(address))

        (§ var boolean questionMarkHasBeenOutput = false)

        (§ if (amount != nil))
        (ß
            (§ call sb.append(QUESTION_MARK_SEPARATOR).append(FIELD_AMOUNT).append("="))
            (§ call sb.append(amount.toPlainString()))
            (§ ass questionMarkHasBeenOutput = true)
        )

        (§ if (label != nil && !"".equals(label)))
        (ß
            (§ if (questionMarkHasBeenOutput))
            (ß
                (§ call sb.append(AMPERSAND_SEPARATOR))
            )
            (§ else)
            (ß
                (§ call sb.append(QUESTION_MARK_SEPARATOR))
                (§ ass questionMarkHasBeenOutput = true)
            )
            (§ call sb.append(FIELD_LABEL).append("=").append(encodeURLString(label)))
        )

        (§ if (message != nil && !"".equals(message)))
        (ß
            (§ if (questionMarkHasBeenOutput))
            (ß
                (§ call sb.append(AMPERSAND_SEPARATOR))
            )
            (§ else)
            (ß
                (§ call sb.append(QUESTION_MARK_SEPARATOR))
            )
            (§ call sb.append(FIELD_MESSAGE).append("=").append(encodeURLString(message)))
        )

        (§ return sb.toString())
    )

    ;;;
     ; Encode a string using URL encoding.
     ;
     ; @param stringToEncode The string to URL encode.
     ;;
    #_static
    (§ method String encodeURLString(String stringToEncode))
    (ß
        (§ try)
        (ß
            (§ return java.net.URLEncoder.encode(stringToEncode, "UTF-8").replace("+", ENCODED_SPACE_CHARACTER))
        )
        (§ catch (UnsupportedEncodingException e))
        (ß
            (§ throw new RuntimeException(e)) ;; Can't happen.
        )
    )
)

#_(ns org.bitcoinj.uri #_"BitcoinURIParseException")

;;;
 ; <p>Exception to provide the following to {@link BitcoinURI}:</p>
 ; <ul>
 ; <li>Provision of parsing error messages.</li>
 ; </ul>
 ; <p>This base exception acts as a general failure mode not attributable to a specific cause (other than
 ; that reported in the exception message).  Since this is in English, it may not be worth reporting directly
 ; to the user other than as part of a "general failure to parse" response.</p>
 ;;
#_public
(§ class BitcoinURIParseException extends Exception
    #_public
    (§ constructor BitcoinURIParseException(String s))
    (ß
        (§ super (s))
    )

    #_public
    (§ constructor BitcoinURIParseException(String s, Throwable throwable))
    (ß
        (§ super (s, throwable))
    )
)

#_(ns org.bitcoinj.uri #_"OptionalFieldValidationException")

;;;
 ; <p>Exception to provide the following to {@link org.bitcoinj.uri.BitcoinURI}:</p>
 ; <ul>
 ; <li>Provision of parsing error messages.</li>
 ; </ul>
 ; <p>This exception occurs when an optional field is detected (under the Bitcoin URI scheme) and fails
 ; to pass the associated test (such as {@code amount} not being a valid number).</p>
 ;
 ; @since 0.3.0
 ;
 ;;
#_public
(§ class OptionalFieldValidationException extends BitcoinURIParseException
    #_public
    (§ constructor OptionalFieldValidationException(String s))
    (ß
        (§ super (s))
    )

    #_public
    (§ constructor OptionalFieldValidationException(String s, Throwable throwable))
    (ß
        (§ super (s, throwable))
    )
)

#_(ns org.bitcoinj.uri #_"RequiredFieldValidationException")

;;;
 ; <p>Exception to provide the following to {@link BitcoinURI}:</p>
 ; <ul>
 ; <li>Provision of parsing error messages.</li>
 ; </ul>
 ; <p>This exception occurs when a required field is detected (under the BIP21 rules) and fails
 ; to pass the associated test (such as {@code req-expires} being out of date), or the required field is unknown
 ; to this version of the client in which case it should fail for security reasons.</p>
 ;
 ; @since 0.3.0
 ;
 ;;
#_public
(§ class RequiredFieldValidationException extends BitcoinURIParseException
    #_public
    (§ constructor RequiredFieldValidationException(String s))
    (ß
        (§ super (s))
    )

    #_public
    (§ constructor RequiredFieldValidationException(String s, Throwable throwable))
    (ß
        (§ super (s, throwable))
    )
)

#_(ns org.bitcoinj.utils #_"BtcAutoFormat"
    (:import [java.math BigDecimal]
             #_static #_[java.math.BigDecimal ONE]
             #_static #_[java.math.BigDecimal ZERO]
             [java.math BigInteger]
             #_static #_[java.math.RoundingMode HALF_UP]
             [java.text DecimalFormat DecimalFormatSymbols NumberFormat]
             [java.util Locale])
    (:import [com.google.common.collect ImmutableList])
    (:import #_static #_[org.bitcoinj.core.Coin SMALLEST_UNIT_EXPONENT]))

;;;
 ; <p>This class, a concrete extension of {@link BtcFormat}, is distinguished by its
 ; accommodation of multiple denominational units as follows:
 ;
 ; <p>When formatting Bitcoin monetary values, an instance of this class automatically adjusts
 ; the denominational units in which it represents a given value so as to minimize the number
 ; of consecutive zeros in the number that is displayed, and includes either a currency code or
 ; symbol in the formatted value to indicate which denomination was chosen.
 ;
 ; <p>When parsing <code>String</code> representations of Bitcoin monetary values, instances of
 ; this class automatically recognize units indicators consisting of currency codes and
 ; symbols, including including those containing currency or metric prefixes such as
 ; <code>"¢"</code> or <code>"c"</code> to indicate hundredths, and interpret each number being
 ; parsed in accordance with the recognized denominational units.
 ;
 ; <p>A more detailed explanation, including examples, is in the documentation for the {@link
 ; BtcFormat} class, and further information beyond that is in the documentation for the {@link
 ; java.text.Format} class, from which this class descends.
 ;
 ; @see java.text.Format
 ; @see java.text.NumberFormat
 ; @see java.text.DecimalFormat
 ; @see DecimalFormatSymbols
 ; @see org.bitcoinj.core.Coin
 ;;

#_public
#_final
(§ class BtcAutoFormat extends BtcFormat
    ;;;
     ; Enum for specifying the style of currency indicators thas are used
     ; when formatting, ether codes or symbols.
     ;;
    #_public
    (§ enum Style
        ;; Notes:
         ; 1) The odd-looking character in the replacements below, named "currency sign," is used
         ;    in the patterns recognized by Java's number formatter.  A single occurrence of this
         ;    character specifies a currency symbol, while two adjacent occurrences indicate an
         ;    international currency code.
         ; 2) The positive and negative patterns each have three parts: prefix, number, suffix.
         ;    The number characters are limited to digits, zero, decimal-separator, group-separator,
         ;    and scientific-notation specifier: [#0.,E]
         ;    All number characters besides 'E' must be single-quoted in order to appear as
         ;    literals in either the prefix or suffix.
         ; These patterns are explained in the documentation for java.text.DecimalFormat.
         ;;

        ;;; Constant for the formatting style that uses a currency code, e.g. "BTC". ;;
        (§ item CODE
        (ß
            #_override
            (§ method void apply(DecimalFormat decimalFormat))
            (ß
                ;; To switch to using codes from symbols, we replace each single occurrence of the
                 ; currency-sign character with two such characters in a row.
                 ; We also insert a space character between every occurence of this character and an
                 ; adjacent numerical digit or negative sign (that is, between the currency-sign and
                 ; the signed-number).
                 ;;
                (§ call decimalFormat.applyPattern(negify(decimalFormat.toPattern()).replaceAll("¤", "¤¤").replaceAll("([#0.,E-])¤¤", "$1 ¤¤").replaceAll("¤¤([0#.,E-])", "¤¤ $1")))
            )
        ))

        ;;; Constant for the formatting style that uses a currency symbol, e.g. "฿". ;;
        (§ item SYMBOL
        (ß
            #_override
            (§ method void apply(DecimalFormat decimalFormat))
            (ß
                ;; To make certain we are using symbols rather than codes, we replace
                 ; each double occurrence of the currency sign character with a single.
                 ;;
                (§ call decimalFormat.applyPattern(negify(decimalFormat.toPattern()).replaceAll("¤¤", "¤")))
            )
        ))

        ;;; Effect a style corresponding to an enum value on the given number formatter object. ;;
        #_abstract
        (§ method void apply(DecimalFormat decimalFormat))
    )

    ;;; Constructor. ;;
    #_protected
    (§ constructor BtcAutoFormat(Locale locale, Style style, int fractionPlaces))
    (ß
        (§ super ((DecimalFormat)NumberFormat.getCurrencyInstance(locale), fractionPlaces, ImmutableList.<Integer>of()))

        (§ call style.apply(this.numberFormat))
    )

    ;;;
     ; Calculate the appropriate denomination for the given Bitcoin monetary value.
     ; This method takes a BigInteger representing a quantity of satoshis, and returns the
     ; number of places that value's decimal point is to be moved when formatting said value
     ; in order that the resulting number represents the correct quantity of denominational
     ; units.
     ;
     ; <p>As a side-effect, this sets the units indicators of the underlying NumberFormat object.
     ; Only invoke this from a synchronized method, and be sure to put the DecimalFormatSymbols
     ; back to its proper state, otherwise immutability, equals() and hashCode() fail.
     ;;
    #_override
    #_protected
    (§ method int scale(BigInteger satoshis, int fractionPlaces))
    (ß
        ;; The algorithm is as follows.  TODO: is there a way to optimize step 4?
         ; 1. Can we use coin denomination w/ no rounding?  If yes, do it.
         ; 2. Else, can we use millicoin denomination w/ no rounding?  If yes, do it.
         ; 3. Else, can we use micro denomination w/ no rounding?  If yes, do it.
         ; 4. Otherwise we must round:
         ;   (a) round to nearest coin + decimals
         ;   (b) round to nearest millicoin + decimals
         ;   (c) round to nearest microcoin + decimals
         ;   Subtract each of (a), (b) and (c) from the true value, and choose the
         ;   denomination that gives smallest absolute difference.  It case of tie,
         ;   use the smaller denomination.
         ;;
        (§ var int places)
        (§ var int coinOffset = Math.max(SMALLEST_UNIT_EXPONENT - fractionPlaces, 0))
        (§ var BigDecimal inCoins = new BigDecimal(satoshis).movePointLeft(coinOffset))
        (§ if (inCoins.remainder(ONE).compareTo(ZERO) == 0))
        (ß
            (§ ass places = COIN_SCALE)
        )
        (§ else)
        (ß
            (§ var BigDecimal inMillis = inCoins.movePointRight(MILLICOIN_SCALE))
            (§ if (inMillis.remainder(ONE).compareTo(ZERO) == 0))
            (ß
                (§ ass places = MILLICOIN_SCALE)
            )
            (§ else)
            (ß
                (§ var BigDecimal inMicros = inCoins.movePointRight(MICROCOIN_SCALE))
                (§ if (inMicros.remainder(ONE).compareTo(ZERO) == 0))
                (ß
                    (§ ass places = MICROCOIN_SCALE)
                )
                (§ else)
                (ß
                    ;; No way to avoid rounding: so what denomination gives smallest error?
                    (§ var BigDecimal a = inCoins.subtract(inCoins.setScale(0, HALF_UP)).movePointRight(coinOffset).abs())
                    (§ var BigDecimal b = inMillis.subtract(inMillis.setScale(0, HALF_UP)).movePointRight(coinOffset - MILLICOIN_SCALE).abs())
                    (§ var BigDecimal c = inMicros.subtract(inMicros.setScale(0, HALF_UP)).movePointRight(coinOffset - MICROCOIN_SCALE).abs())
                    (§ if (a.compareTo(b) < 0))
                        (§ ass places = (a.compareTo(c) < 0) ? COIN_SCALE :else MICROCOIN_SCALE)
                    (§ elseif (b.compareTo(c) < 0))
                        (§ ass places = MILLICOIN_SCALE)
                    (§ else)
                        (§ ass places = MICROCOIN_SCALE)
                )
            )
        )
        (§ call prefixUnitsIndicator(numberFormat, places))
        (§ return places)
    )

    ;;;
     ; Returns the <code>int</code> value indicating coin denomination.  This is what causes
     ; the number in a parsed value that lacks a units indicator to be interpreted as a quantity
     ; of bitcoins.
     ;;
    #_override
    #_protected
    (§ method int scale())
    (ß
        (§ return COIN_SCALE)
    )

    ;;;
     ; Return the number of decimal places in the fraction part of numbers formatted by this
     ; instance.  This is the maximum number of fraction places that will be displayed;
     ; the actual number used is limited to a precision of satoshis.
     ;;
    #_public
    (§ method int fractionPlaces())
    (ß
        (§ return minimumFractionDigits)
    )

    ;;;
     ; Return true if the other instance is equivalent to this one.
     ; Formatters for different locales will never be equal, even if they behave identically.
     ;;
    #_override
    #_public
    (§ method boolean equals(Object o))
    (ß
        (§ if (this == o))
            (§ return true)
        (§ if (!(o instanceof BtcAutoFormat)))
            (§ return false)
        (§ return super.equals(o))
    )

    ;;;
     ; Return a brief description of this formatter.  The exact details of the representation
     ; are unspecified and subject to change, but will include some representation of the
     ; pattern and the number of fractional decimal places.
     ;;
    #_override
    #_public
    (§ method String toString())
    (ß
        (§ return "Auto-format " + pattern())
    )
)

#_(ns org.bitcoinj.utils #_"BtcFixedFormat"
    (:import [java.math BigInteger]
             [java.text DecimalFormat NumberFormat]
             [java.util Locale List])
    (:import [com.google.common.base Objects Preconditions])
    (:import #_static #_[org.bitcoinj.core.Coin SMALLEST_UNIT_EXPONENT]))

;;;
 ; This class, a concrete extension of {@link BtcFormat}, is distinguished in that each
 ; instance formats and by-default parses all Bitcoin monetary values in units of a single
 ; denomination that is specified at the time that instance is constructed.
 ;
 ; By default, neither currency codes nor symbols are included in formatted values as
 ; output, nor recognized in parsed values as input.  The can be overridden by applying a
 ; custom pattern using either the {@link BtcFormat.Builder#localizedPattern}
 ; or {@link BtcFormat.Builder#localizedPattern} methods, as described in the documentation
 ; for the {@link BtcFormat.Builder} class.
 ;
 ; A more detailed explanation, including examples, is in the documentation for the
 ; {@link BtcFormat} class, and further information beyond that is in the documentation
 ; for the {@link java.text.Format} class, from which this class descends.
 ;
 ; @see java.text.Format
 ; @see java.text.NumberFormat
 ; @see java.text.DecimalFormat
 ; @see org.bitcoinj.core.Coin
 ;;

#_public
#_final
(§ class BtcFixedFormat extends BtcFormat
    ;;;
     ; A constant specifying the use of as many optional decimal places in the fraction part
     ; of a formatted number as are useful for expressing precision.  This value can be passed
     ; as the final argument to a factory method or {@link #format(Object, int, int...)}.
     ;;
    #_public
    #_static
    #_final
    (§ field int[] REPEATING_PLACES = (ß 1,1,1,1,1,1,1,1,1,1,1,1,1,1 ))

    ;;;
     ; A constant specifying the use of as many optional groups of <strong>two</strong>
     ; decimal places in the fraction part of a formatted number as are useful for expressing
     ; precision.  This value can be passed as the final argument to a factory method or
     ; {@link #format(Object, int, int...)}.
     ;;
    #_public
    #_static
    #_final
    (§ field int[] REPEATING_DOUBLETS = (ß 2,2,2,2,2,2,2 ))

    ;;;
     ; A constant specifying the use of as many optional groups of <strong>three</strong>
     ; decimal places in the fraction part of a formatted number as are useful for expressing
     ; precision.  This value can be passed as the final argument to a factory method or
     ; {@link #format(Object, int, int...)}.
     ;;
    #_public
    #_static
    #_final
    (§ field int[] REPEATING_TRIPLETS = (ß 3,3,3,3,3 ))

    ;;;
     ; The number of places the decimal point of formatted values is shifted rightward from
     ; thet same value expressed in bitcoins.
     ;;
    #_private
    #_final
    (§ field int scale)

    ;;; Constructor. ;;
    #_protected
    (§ constructor BtcFixedFormat(Locale locale, int scale, int minDecimals, List<Integer> groups))
    (ß
        (§ super ((DecimalFormat)NumberFormat.getInstance(locale), minDecimals, groups))

        (§ call Preconditions.checkArgument(scale <= SMALLEST_UNIT_EXPONENT, "decimal cannot be shifted " + String.valueOf(scale) + " places"))

        (§ ass this.scale = scale)
    )

    ;;;
     ; Return the decimal-place shift for this object's unit-denomination.  For example, if
     ; the denomination is millibitcoins, this method will return the value <code>3</code>.
     ; As a side-effect, prefixes the currency signs of the underlying NumberFormat object.
     ; This method is invoked by the superclass when formatting.  The arguments are ignored
     ; because the denomination is fixed regardless of the value being formatted.
     ;;
    #_override
    #_protected
    (§ method int scale(BigInteger satoshis, int fractionPlaces))
    (ß
        (§ call prefixUnitsIndicator(numberFormat, scale))
        (§ return scale)
    )

    ;;;
     ; Return the decimal-place shift for this object's fixed unit-denomination.  For example,
     ; if the denomination is millibitcoins, this method will return the value <code>3</code>.
     ;;
    #_override
    #_public
    (§ method int scale())
    (ß
        (§ return scale)
    )

    ;;;
     ; Return the currency code that identifies the units in which values formatted and
     ; (by-default) parsed by this instance are denominated.  For example, if the formatter's
     ; denomination is millibitcoins, then this method will return <code>"mBTC"</code>,
     ; assuming the default base currency-code is not overridden using a {@link BtcFormat.Builder}.
     ;;
    #_public
    (§ method String code())
    (ß
        (§ return prefixCode(coinCode(), scale))
    )

    ;;;
     ; Return the currency symbol that identifies the units in which values formatted by this
     ; instance are denominated.  For example, when invoked on an instance denominated in
     ; millibitcoins, this method by default returns <code>"₥฿"</code>, depending on the
     ; locale.
     ;;
    #_public
    (§ method String symbol())
    (ß
        (§ return prefixSymbol(coinSymbol(), scale))
    )

    ;;;
     ; Return the fractional decimal-placing used when formatting.  This method returns an
     ; <code>int</code> array.  The value of the first element is the minimum number of
     ; decimal places to be used in all cases, limited to a precision of satoshis.  The value
     ; of each successive element is the size of an optional place-group that will be applied,
     ; possibly partially, if useful for expressing precision.  The actual size of each group
     ; is limited to, and may be reduced to the limit of, a precision of no smaller than
     ; satoshis.
     ;;
    #_public
    (§ method int[] fractionPlaceGroups())
    (ß
        (§ var Object[] boxedArray = decimalGroups.toArray())
        (§ var int len = boxedArray.length + 1)
        (§ var int[] array = new int[len])
        (§ ass array[0] = minimumFractionDigits)
        (§ for (int i = 1 :for i < len :for i = i + 1))
            (§ ass array[i] = (Integer)boxedArray[i-1])
        (§ return array)
    )

    ;;;
     ; Return true if the given object is equivalent to this one.  Formatters for different
     ; locales will never be equal, even if they behave identically.
     ;;
    #_override
    #_public
    (§ method boolean equals(Object o))
    (ß
        (§ if (o == this))
            (§ return true)
        (§ if (!(o instanceof BtcFixedFormat)))
            (§ return false)
        (§ var BtcFixedFormat other = (BtcFixedFormat)o)
        (§ return (super.equals(other) && other.scale() == scale() && other.decimalGroups.equals(decimalGroups)))
    )

    ;;; Return a hash code value for this instance.
     ;  @see java.lang.Object#hashCode
     ;;
    #_override
    #_public
    (§ method int hashCode())
    (ß
        (§ return Objects.hashCode(super.hashCode(), scale))
    )

    #_private
    #_static
    (§ method String prefixLabel(int scale))
    (ß
        (§ switch (scale))
        (ß
        (§ case COIN_SCALE)
            (§ return "Coin-")
        (§ case 1)
            (§ return "Decicoin-")
        (§ case 2)
            (§ return "Centicoin-")
        (§ case MILLICOIN_SCALE)
            (§ return "Millicoin-")
        (§ case MICROCOIN_SCALE)
            (§ return "Microcoin-")
        (§ case -1)
            (§ return "Dekacoin-")
        (§ case -2)
            (§ return "Hectocoin-")
        (§ case -3)
            (§ return "Kilocoin-")
        (§ case -6)
            (§ return "Megacoin-")
        (§ default)
            (§ return "Fixed (" + scale + ") ")
        )
    )

    ;;;
     ; Returns a brief description of this formatter.  The exact details of the representation
     ; are unspecified and subject to change, but will include some representation of the
     ; formatting/parsing pattern and the fractional decimal place grouping.
     ;;
    #_override
    #_public
    (§ method String toString())
    (ß
        (§ return prefixLabel(scale) + "format " + pattern())
    )
)

#_(ns org.bitcoinj.utils #_"BtcFormat"
    (:import [java.math BigDecimal BigInteger]
             #_static #_[java.math.RoundingMode HALF_UP]
             [java.text AttributedCharacterIterator DecimalFormat DecimalFormatSymbols FieldPosition Format NumberFormat ParseException ParsePosition]
             [java.util Locale List ArrayList]
             [java.util.regex Matcher Pattern])
    (:import [com.google.common.base Objects Preconditions Strings]
             [com.google.common.collect ImmutableList])
  #_(:require [org.bitcoinj.core Coin]
             [org.bitcoinj.utils.BtcAutoFormat Style]
             #_static #_[org.bitcoinj.utils.BtcAutoFormat.Style *]))

;;;
 ; <p>Instances of this class format and parse locale-specific numerical representations of Bitcoin monetary values.
 ;
 ; <p>A primary goal of this class is to minimize the danger of human-misreading of monetary values due to mis-counting
 ; the number of zeros (or, more generally, of decimal places) in the number that represents a Bitcoin monetary value.
 ; Some of the features offered for doing this are:
 ; <ol>
 ;   <li>automatic adjustment of denominational units in which a value is represented so as to lessen the number of adjacent zeros,
 ;   <li>use of locale-specific decimal-separators to group digits in the integer portion of formatted numbers,
 ;   <li>fine control over the number and  grouping of fractional decimal places, and
 ;   <li>access to character information that allows for vertical alignment of tabular columns of formatted values.
 ; </ol>
 ;
 ; <h3>Basic Usage</h3>
 ;
 ; Basic usage is very simple:
 ; <ol>
 ;   <li>Construct a new formatter object using one of the factory methods.
 ;   <li>Format a value by passing it as an argument to the {@link BtcFormat#format(Object)} method.
 ;   <li>Parse a value by passing a <code>String</code>-type representation of it to the {@link BtcFormat#parse(String)} method.
 ; </ol>
 ;
 ; <p>For example, depending on your locale, values might be formatted and parsed as follows:
 ;
 ; <blockquote><pre>
 ; BtcFormat f = BtcFormat.getInstance();
 ; String c = f.format(Coin.COIN);                <strong>// "BTC 1.00"</strong>
 ; String k = f.format(Coin.COIN.multiply(1000)); <strong>// "BTC 1,000.00"</strong>
 ; String m = f.format(Coin.COIN.divide(1000));   <strong>// "mBTC 1.00"</strong>
 ; Coin all = f.parseObject("M฿ 21");             <strong>// All the money in the world</strong>
 ; </pre></blockquote>
 ;
 ; <h3>Auto-Denomination versus Fixed-Denomination</h3>
 ;
 ; There are two provided concrete classes, one that automatically denominates values to be formatted, {@link BtcAutoFormat},
 ; and another that formats any value in units of a fixed, specified denomination, {@link BtcFixedFormat}.
 ;
 ; <h5>Automatic Denomination</h5>
 ;
 ; Automatic denomination means that the formatter adjusts the denominational units in which a formatted number is
 ; expressed based on the monetary value that number represents.  An auto-denominating formatter is defined by its
 ; style, specified by one of the enumerated values of {@link BtcAutoFormat.Style}.  There are two styles constants:
 ; {@link BtcAutoFormat.Style#CODE} (the default), and {@link BtcAutoFormat.Style#SYMBOL}.  The difference is that
 ; the <code>CODE</code> style uses an internationally-distinct currency code, such as <code>"BTC"</code>, to indicate
 ; the units of denomination, while the <code>SYMBOL</code> style uses a possibly-ambiguous currency symbol such as
 ; <code>"฿"</code>.
 ;
 ; <p>The denomination used when formatting will be either bitcoin, millicoin or microcoin, depending on the value
 ; being represented, chosen so as to minimize the number of consecutive zeros displayed without losing precision.
 ; For example, depending on the locale, a value of one bitcoin might be formatted as <pre>฿1.00</pre> where a value
 ; exceeding that by one satoshi would be <pre>µ฿1,000,000.01</pre>.
 ;
 ; <h5>Fixed Denomination</h5>
 ;
 ; Fixed denomination means that the same denomination of units is used for every value that is formatted or parsed
 ; by a given formatter instance.  A fixed-denomination formatter is defined by its scale, which is the number of
 ; places one must shift the decimal point in increasing precision to convert the representation of a given quantity
 ; of bitcoins into a representation of the same value denominated in the formatter's units.  For example, a scale
 ; value of <code>3</code> specifies a denomination of millibitcoins, because to represent <code>1.0000 BTC</code>,
 ; or one bitcoin, in millibitcoins, one shifts the decimal point three places, that is, to <code>1000.0 mBTC</code>.
 ;
 ; <h3>Construction</h3>
 ;
 ; There are two ways to obtain an instance of this class:
 ; <ol>
 ;   <li>Use one of the factory methods; or
 ;   <li>Use a {@link BtcFormat.Builder} object.
 ; </ol>
 ;
 ; <p>The factory methods are appropriate for basic use where the default configuration is either used or modified.
 ; The <code>Builder</code> class provides more control over the configuration, and gives access to some features
 ; not available through the factory methods, such as using custom formatting patterns and currency symbols.
 ;
 ; <h5>Factory Methods</h5>
 ;
 ; Although formatting and parsing is performed by one of the concrete subclasses, you can obtain formatters using
 ; the various static factory methods of this abstract base class <code>BtcFormat</code>.  There are a variety of
 ; overloaded methods that allow you to obtain a formatter that behaves according to your needs.
 ;
 ; <p>The primary distinction is between automatic- and fixed-denomination formatters.  By default, the
 ; <code>getInstance()</code> method with no arguments returns a new, automatic-denominating <code>BtcAutoFormat</code>
 ; instance for your default locale that will display exactly two fractional decimal places and a currency code.
 ; For example, if you happen to be in the USA:
 ;
 ; <blockquote><pre>
 ; BtcFormat f = BtcFormat.getInstance();
 ; String s = f.format(Coin.COIN); <strong>// "BTC 1.00"</strong>
 ; </pre></blockquote>
 ;
 ; <p>The first argument to <code>getInstance()</code> can determine whether you get an auto- or fixed-denominating
 ; formatter.  If the type of the first argument is an <code>int</code>, then the value of that <code>int</code>
 ; will be interpreted as the decimal-place scale of the {@link BtcFixedFormat} instance that is returned, and thus
 ; will determine its denomination.  For example, if you want to format values in units of microbitcoins:
 ;
 ; <blockquote><pre>
 ; BtcFormat m = BtcFormat.getInstance(6);
 ; String s = m.format(Coin.COIN); <strong>// "1,000,000.00"</strong>
 ; </pre></blockquote>
 ;
 ; <p>This class provides several constants bound to common scale values:
 ;
 ; <blockquote><pre>
 ; BtcFormat milliFormat = BtcFormat.getInstance(MILLICOIN_SCALE);
 ; </pre></blockquote>
 ;
 ; <p>Alternatively, if the type of the first argument to <code>getInstance()</code> is one of the enumerated values
 ; of the {@link BtcAutoFormat.Style} type, either <code>CODE</code> or <code>SYMBOL</code>, then you will get a
 ; {@link BtcAutoFormat} instance that uses either a currency code or symbol, respectively, to indicate the results
 ; of its auto-denomination.
 ;
 ; <blockquote><pre>
 ; BtcFormat s = BtcFormat.getInstance(SYMBOL);
 ; Coin value = Coin.parseCoin("0.1234");
 ; String mil = s.format(value);              <strong>// "₥฿123.40"</strong>
 ; String mic = s.format(value.divide(1000)); <strong>// "µ฿123.40"</strong>
 ; </pre></blockquote>
 ;
 ; <p>An alternative way to specify whether you want an auto- or fixed-denomination formatter is to use one
 ; of the factory methods that is named to indicate that characteristics of the new instance returned.  For
 ; fixed-denomination formatters, these methods are {@link #getCoinInstance()}, {@link #getMilliInstance()},
 ; and {@link #getMicroInstance()}.  These three methods are equivalent to invoking <code>getInstance()</code>
 ; with a first argument of <code>0</code>, <code>3</code> and <code>6</code>, respectively.  For auto-denominating
 ; formatters the relevant factory methods are {@link #getCodeInstance()} and {@link #getSymbolInstance()},
 ; which are equivalent to <code>getInstance(Style.CODE)</code>, and <code>getInstance(Style.SYMBOL)</code>.
 ;
 ; <p>Regardless of how you specify whether your new formatter is to be of automatic- or fixed-denomination, the
 ; next (and possibly first) parameter to each of the factory methods is an optional <code>Locale</code> value.
 ;
 ; For example, here we construct four instances for the same locale that each format
 ; differently the same one-bitcoin value:
 ;
 ; <blockquote><pre>
 ; <strong>// Next line returns "1,00 BTC"</strong>
 ; BtcFormat.getInstance(Locale.GERMANY).format(Coin.COIN);
 ; <strong>// Next line returns "1,00 ฿"</strong>
 ; BtcFormat.getInstance(SYMBOL, Locale.GERMANY).format(Coin.COIN);
 ; <strong>// Next line returns "1.000,00"</strong>
 ; BtcFormat.getMilliInstance(Locale.GERMANY).format(Coin.COIN);
 ; <strong>// Next line returns "10.000,00"</strong>
 ; BtcFormat.getInstance(4, Locale.GERMANY).format(Coin.COIN);
 ; </pre></blockquote>
 ;
 ; Omitting such a <code>Locale</code> parameter will give you a formatter for your default locale.
 ;
 ; <p>The final (and possibly only) arguments to the factory methods serve to set the default number of
 ; fractional decimal places that will be displayed when formatting monetary values.  In the case of an
 ; auto-denominating formatter, this can be a single <code>int</code> value, which will determine the number
 ; of fractional decimal places to be used in all cases, except where either (1) doing so would provide
 ; a place for fractional satoshis, or (2) that default value is overridden when invoking
 ; the <code>format()</code> method as described below.
 ;
 ; <p>In the case of a fixed-denomination formatter, you can pass any number of <code>int</code> values.
 ; The first will determine the minimum number of fractional decimal places, and each following <code>int</code>
 ; value specifies the size of an optional group of decimal-places to be displayed only if useful for expressing
 ; precision.  As with auto-denominating formatters, numbers will never be formatted with a decimal place that
 ; represents a fractional quantity of satoshis, and these defaults can be overridden by arguments to the
 ; <code>format()</code> method.  See below for examples.
 ;
 ; <h5>The <code>Builder</code> Class</h5>
 ;
 ; A new {@link BtcFormat.Builder} instance is returned by the {@link #builder()} method.  Such an object has
 ; methods that set the configuration parameters of a <code>BtcFormat</code> object.  Its {@link Builder#build()}
 ; method constructs and returns a <code>BtcFormat</code> instance configured according to those settings.
 ;
 ; <p>In addition to setter-methods that correspond to the factory-method parameters explained above,
 ; a <code>Builder</code> also allows you to specify custom formatting and parsing patterns and currency symbols
 ; and codes.  For example, rather than using the default currency symbol, which has the same unicode character
 ; point as the national currency symbol of Thailand, some people prefer to use a capital letter "B" with
 ; a vertical overstrike.
 ;
 ; <blockquote><pre>
 ; BtcFormat.Builder builder = BtcFormat.builder();
 ; builder.style(SYMBOL);
 ; builder.symbol("B&#x5c;u20e6"); <strong>// unicode char "double vertical stroke overlay"</strong>
 ; BtcFormat f = builder.build();
 ; String out = f.format(COIN); <strong>// "B⃦1.00" depending on locale</strong>
 ; </pre></blockquote>
 ;
 ; The <code>Builder</code> methods are chainable.  So, for example, if you are
 ; deferential to ISO 4217, you might construct a formatter in a single line this way:
 ;
 ; <blockquote><pre>
 ; BtcFormat f = BtcFormat.builder().style(CODE).code("XBT").build();
 ; String out = f.format(COIN); <strong>// "XBT 1.00"</strong>
 ; </pre></blockquote>
 ;
 ; <p>See the documentation of the {@link BtcFormat.Builder} class for details.
 ;
 ; <h3>Formatting</h3>
 ;
 ; <p>You format a Bitcoin monetary value by passing it to the {@link BtcFormat#format(Object)} method.  This argument
 ; can be either a {@link org.bitcoinj.core.Coin}-type object or a numerical object such as {@link java.lang.Long} or
 ; {@link java.math.BigDecimal}.  Integer-based types such as {@link java.math.BigInteger} are interpreted as representing
 ; a number of satoshis, while a {@link java.math.BigDecimal} is interpreted as representing a number of bitcoins.
 ; A value having a fractional amount of satoshis is rounded to the nearest whole satoshi at least, and possibly to
 ; a greater unit depending on the number of fractional decimal-places displayed.  The <code>format()</code> method will
 ; not accept an argument whose type is <code>String</code>, <code>Float</code> nor <code>Double</code>.
 ;
 ; <p>Subsequent to the monetary value to be formatted, the {@link #format(Object)} method also accepts as arguments
 ; optional <code>int</code> values that specify the number of decimal places to use to represent the fractional portion
 ; of the number.  This overrides the default, and enables a single formatter instance to be reused, formatting different
 ; values that require different numbers of fractional decimal places.  These parameters have the same meaning as those
 ; that set the default values in the factory methods as described above.  Namely, a single <code>int</code> value determines
 ; the minimum number of fractional decimal places that will be used in all cases, to a precision limit of satoshis.
 ; Instances of {@link BtcFixedFormat} also accept a variable-length sequence of additional <code>int</code> values, each
 ; of which specifies the size of a group of fractional decimal-places to be used in addition to all preceding places, only
 ; if useful to express precision, and only to a maximum precision of satoshis.  For example:
 ;
 ; <blockquote><pre>
 ; BtcFormat f = BtcFormat.getCoinInstance();
 ; Coin value = COIN.add(Coin.valueOf(5)); <strong>// 100000005 satoshis</strong>
 ; f.format(value, 2);       <strong>// "1.00"</strong>
 ; f.format(value, 3);       <strong>// "1.000"</strong>
 ; f.format(value, 2, 3);    <strong>// "1.00" three more zeros doesn't help</strong>
 ; f.format(value, 2, 3, 3); <strong>// "1.00000005" </strong>
 ; f.format(value, 2, 3, 4); <strong>// "1.00000005" fractions of satoshis have no place</strong>
 ; f.format(value, 2, 3, 2); <strong>// "1.0000001" rounds to nearest usable place</strong>
 ; </pre></blockquote>
 ;
 ; <p>Note that if using all the fractional decimal places in a specified group would give a place to fractions of satoshis,
 ; then the size of that group will be reduced to a maximum precision of satoshis.  Either all or none of the allowed decimal
 ; places of that group will still be applied as doing so is useful for expressing the precision of the value being formatted.
 ;
 ; <p>Several convenient constants of repeating group-size sequences are provided: {@link BtcFixedFormat#REPEATING_PLACES},
 ; {@link BtcFixedFormat#REPEATING_DOUBLETS} and {@link BtcFixedFormat#REPEATING_TRIPLETS}.  These signify repeating groups
 ; of one, two and three decimals places, respectively.  For example, to display only as many fractional places as useful
 ; in order to prevent hanging zeros on the least-significant end of formatted numbers:
 ;
 ; <blockquote><pre>
 ; format(value, 0, REPEATING_PLACES);
 ; </pre></blockquote>
 ;
 ; <p>When using an automatically-denominating formatter, you might want to know what denomination was chosen.  You can get
 ; the currency-units indicator, as well as any other field in the formatted output, by using a {@link java.text.FieldPosition}
 ; instance constructed using an appropriate constant from the {@link java.text.NumberFormat.Field} class:
 ;
 ; <blockquote><pre>
 ; BtcFormat de = BtcFormat.getInstance(Locale.GERMANY);
 ; FieldPosition currField = new FieldPosition(NumberFormat.Field.CURRENCY);
 ; <strong>// next line formats the value as "987.654.321,23 µBTC"</strong>
 ; String output = de.format(valueOf(98765432123L), new StringBuffer(), currField);
 ; <strong>// next line sets variable currencyCode to "µBTC"</strong>
 ; String currencyCode = output.substring(currField.getBeginIndex(), currField.getEndIndex()));
 ; </pre></blockquote>
 ;
 ; <p>When using a fixed-denomination formatter whose scale can be expressed as a standard "metric" prefix,
 ; you can invoke the <code>code()</code> and <code>symbol()</code> methods to obtain a <code>String</code>
 ; whose value is the appropriate currency code or symbol, respectively, for that formatter.
 ;
 ; <blockquote><pre>
 ; BtcFixedFormat kilo = (BtcFixedFormat)BtcFormat(-3); <strong>// scale -3 for kilocoins</strong>
 ; Coin value = Coin.parseCoin("1230");
 ; <strong>// variable coded will be set to "kBTC 1.23"</strong>
 ; String coded = kilo.code() + " " + kilo.format(value);
 ; <strong>// variable symbolic will be set to "k฿1.23"</strong>
 ; String symbolic = kilo.symbol() + kilo.format(value);
 ; BtcFormat(4).code(); <strong>// unnamed denomination has no code; raises exception</strong>
 ; </pre></blockquote>
 ;
 ; <h5>Formatting for Tabular Columns</h5>
 ;
 ; When displaying tables of monetary values, you can lessen the risk of human misreading-error by vertically
 ; aligning the decimal separator of those values.  This example demonstrates one way to do that:
 ;
 ; <blockquote><pre>
 ; <strong>// The elements of this array are the values we will format:</strong>
 ; Coin[] rows = { MAX_MONEY, MAX_MONEY.subtract(SATOSHI), Coin.parseCoin("1234"), COIN,
 ;                 COIN.divide(1000), valueOf(10000), valueOf(1000), valueOf(100), SATOSHI };
 ; BtcFormat f = BtcFormat.getCoinInstance(2, REPEATING_PLACES);
 ; FieldPosition fp = new FieldPosition(DECIMAL_SEPARATOR); <strong>// see java.text.NumberFormat.Field</strong>
 ; String[] output = new String[rows.length];
 ; int[] indexes = new int[rows.length];
 ; int maxIndex = 0;
 ; for (int i = 0; i < rows.length; i++)
 ; {
 ;     output[i] = f.format(rows[i], new StringBuffer(), fp).toString();
 ;     indexes[i] = fp.getBeginIndex();
 ;     if (maxIndex < indexes[i])
 ;         maxIndex = indexes[i];
 ; }
 ; for (int i = 0; i < output.length; i++)
 ; {
 ;     System.out.println(repeat(" ", maxIndex - indexes[i]) + output[i]);
 ; }
 ; </pre></blockquote>
 ;
 ; Assuming you are using a monospaced font, and depending on your locale, the foregoing will print the following:
 ;
 ; <blockquote><pre>
 ; 21,000,000.00
 ; 20,999,999.99999999
 ;      1,234.00
 ;          1.00
 ;          0.001
 ;          0.0001
 ;          0.00001
 ;          0.000001
 ;          0.00000001
 ; </pre></blockquote>
 ;
 ; If you need to vertically-align columns printed in a proportional font, then see the documentation
 ; for the {@link java.text.NumberFormat} class for an explanation of how to do that.
 ;
 ; <h3>Parsing</h3>
 ;
 ; <p>The {@link #parse(String)} method accepts a <code>String</code> argument, and returns a {@link Coin}-type value.
 ; The difference in parsing behavior between instances of {@link BtcFixedFormat} and {@link BtcAutoFormat} is analogous
 ; to the difference in formatting behavior between instances of those classes.  Instances of {@link BtcAutoFormat} recognize
 ; currency codes and symbols in the <code>String</code> being parsed, and interpret them as indicators of the units in which
 ; the number being parsed is denominated.  On the other hand, instances of {@link BtcFixedFormat} by default recognize no
 ; codes nor symbols, but rather interpret every number as being denominated in the units that were specified when constructing
 ; the instance doing the parsing.  This default behavior of {@link BtcFixedFormat} can be overridden by setting a parsing
 ; pattern that includes a currency sign using the {@link BtcFormat.Builder#pattern()} method.
 ;
 ; <p>The {@link BtcAutoFormat#parse(String)}</code> method of {@link BtcAutoFormat} (and of {@link BtcAutoFormat} configured
 ; with applicable non-default pattern) will recognize a variety of currency symbols and codes, including all standard
 ; international (metric) prefixes from micro to mega.  For example, denominational units of microcoins may be specified
 ; by <code>µ฿</code>, <code>u฿</code>, <code>µB⃦</code>, <code>µɃ</code>, <code>µBTC</code> or other appropriate permutations
 ; of those characters.  Additionally, if either or both of a custom currency code or symbol is configured using
 ; {@link BtcFormat.Builder#code} or {@link BtcFormat.Builder#code}, then such code or symbol will be recognized in addition
 ; to those recognized by default.
 ;
 ; <p>Instances of this class that recognize currency signs will recognize both currency symbols and codes, regardless of which
 ; that instance uses for formatting.  However, if the style is <code>CODE</code> (and unless overridden by a custom pattern)
 ; then a space character must separate the units indicator from the number.  When parsing with a <code>SYMBOL</code>-style
 ; <code>BtcFormat</code> instance, on the other hand, whether or not the units indicator must be separated by a space from
 ; the number is determined by the locale.  The {@link BtcFormat#pattern()} method returns a representation of the pattern
 ; that can be examined to determine whether a space must separate currency signs from numbers in parsed <code>String</code>s.
 ;
 ; <p>When parsing, if the currency-units indicator is absent, then a {@link BtcAutoFormat} instance will infer a denomination
 ; of bitcoins while a {@link BtcFixedFormat} will infer the denomination in which it expresses formatted values.  Note: by
 ; default (unless overridden by a custom pattern), if the locale or style requires a space to separate the number from the
 ; units indicator, that space must be present in the String to be parsed, even if the units indicator is absent.
 ;
 ; <p>The <code>parse()</code> method returns an instance of the {@link Coin} class.  Therefore, attempting to parse a value
 ; greater than the maximum that a <code>Coin</code> object can represent will raise a <code>ParseException</code>, as will
 ; any other detected parsing error.
 ;
 ; <h3>Limitations</h3>
 ;
 ; <h5>Parsing</h5>
 ;
 ; Parsing is performed by an underlying {@link java.text.NumberFormat} object.  While this delivers the benefit
 ; of recognizing locale-specific patterns, some have criticized other aspects of its behavior.  For example, see
 ; <a href="http://www.ibm.com/developerworks/library/j-numberformat/">this article by Joe Sam Shirah</a>.  In particular,
 ; explicit positive-signs are not recognized.  If you are parsing input from end-users, then you should consider whether
 ; you would benefit from any of the work-arounds mentioned in that article.
 ;
 ; <h5>Exotic Locales</h5>
 ;
 ; This class is not well-tested in locales that use non-ascii character sets, especially those where writing proceeds
 ; from right-to-left.  Helpful feedback in that regard is appreciated.
 ;
 ; <h3>Thread-Safety</h3>
 ;
 ; <p>Instances of this class are immutable.
 ;
 ; @see java.text.Format
 ; @see java.text.NumberFormat
 ; @see java.text.DecimalFormat
 ; @see java.text.DecimalFormatSymbols
 ; @see java.text.FieldPosition
 ; @see org.bitcoinj.core.Coin
 ;;

#_public
#_abstract
(§ class BtcFormat extends Format
    ;; CONCURRENCY NOTES
     ;
     ; There is one mutable member of this class, the `DecimalFormat` object bound to variable `numberFormat`.
     ; The relevant methods invoked on it are: setMinimumFractionDigits(), setMaximumFractionDigits(), and
     ; setDecimalFormatSymbols(), along with the respective getter methods corresponding to each.  The first
     ; two methods are used to set the number of fractional decimal places displayed when formatting, which is
     ; reflected in the patterns returned by the public pattern() and localizedPattern() methods.  The last
     ; method sets the value of that object's member `DecimalFormatSymbols` object for formatting and parsing,
     ; which is also reflected in the aforementioned patterns.  The patterns, which are the passed-through
     ; return values of the DecimalFormat object's toPattern() and toLocalizedPattern() methods, and the value
     ; of the DecimalFormat object's DecimalFormatSymbols member are among the values compared between instances
     ; of this class in determining the return values of the `equals()` and `hashCode()` methods.
     ;
     ; From the foregoing, you can understand that immutability is achieved as follows: access to the variable
     ; `numberFormat` referent's fraction-digits and format-symbols fields are synchronized on that DecimalFormat
     ; object.  The state of those fraction-digits limits and decimal-format symbols must be returned to a static
     ; state after being changed for formatting or parsing since the user can see them reflected in the return
     ; values of above-mentioned methods and because `equals()` and `hashCode()` use them for comparisons.
     ;;

    ;;; The conventional international currency code for bitcoins: "BTC" ;;
    #_private
    #_static
    #_final
    (§ field String COIN_CODE = "BTC")
    ;;; The default currency symbols for bitcoins. ;;
    #_private
    #_static
    #_final
    (§ field String COIN_SYMBOL = "฿")
    ;;; An alternative currency symbol to use in locales where the default symbol is used for the national currency. ;;
    #_protected
    #_static
    #_final
    (§ field String COIN_SYMBOL_ALT = "Ƀ")

    #_protected
    #_final
    (§ field DecimalFormat numberFormat) ;; warning: mutable
    #_protected
    #_final
    (§ field int minimumFractionDigits)
    #_protected
    #_final
    (§ field List<Integer> decimalGroups)

    ;; Scale is the number of decimal-places difference from same value in bitcoins.

    ;;;
     ; A constant useful for specifying a denomination of bitcoins, the <code>int</code> value <code>0</code>.
     ;;
    #_public
    #_static
    #_final
    (§ field int COIN_SCALE = 0)

    ;;;
     ; A constant useful for specifying a denomination of millibitcoins, the <code>int</code> value <code>3</code>.
     ;;
    #_public
    #_static
    #_final
    (§ field int MILLICOIN_SCALE = 3)

    ;;;
     ; A constant useful for specifying a denomination of microbitcoins, the <code>int</code> value <code>6</code>.
     ;;
    #_public
    #_static
    #_final
    (§ field int MICROCOIN_SCALE = 6)

    ;;;
     ; Return the number of decimal places by which any value denominated in the units indicated
     ; by the given scale differs from that same value denominated in satoshis.
     ;;
    #_private
    #_static
    (§ method int offSatoshis(int scale))
    (ß
        (§ return Coin.SMALLEST_UNIT_EXPONENT - scale)
    )

    #_private
    #_static
    (§ method Locale defaultLocale())
    (ß
        (§ return Locale.getDefault())
    )

    ;;;
     ; <p>This class constructs new instances of {@link BtcFormat}, allowing for the configuration of those instances
     ; before they are constructed.  After obtaining a <code>Builder</code> object from the {@link BtcFormat#builder()}
     ; method, invoke the necessary setter methods to obtain your desired configuration.  Finaly, the {@link #build()}
     ; method returns a new <code>BtcFormat</code> object that has the specified configuration.
     ;
     ; <p>All the setter methods override defaults.  Invoking <code>build()</code> without invoking any of the setting
     ; methods is equivalent to invoking {@link BtcFormat#getInstance()} with no arguments.
     ;
     ; <p>Each setter methods returns the same instance on which it is invoked, thus these methods can be chained.
     ;
     ; <p>Instances of this class are <strong>not</strong> thread-safe.
     ;;
    #_public
    #_static
    (§ class Builder
        #_private
        (§ enum Variant
            (§ item AUTO
            (ß
                #_override
                (§ method BtcFormat newInstance(Builder b))
                (ß
                    (§ return getInstance(b.style, b.locale, b.minimumFractionDigits))
                )
            ))
            (§ item FIXED)
            (§ item UNSET)

            (§ method BtcFormat newInstance(Builder b))
            (ß
                (§ return getInstance(b.scale, b.locale, b.minimumFractionDigits, b.fractionGroups))
            )
        )
        ;; Parameters are initialized to default or unset values.
        #_private
        (§ field Variant variant = Variant.UNSET)
        #_private
        (§ field Locale locale = defaultLocale())
        #_private
        (§ field int minimumFractionDigits = 2)
        #_private
        (§ field int[] fractionGroups = (ß ))
        #_private
        (§ field Style style = BtcAutoFormat.Style.CODE)
        #_private
        (§ field int scale = 0)
        #_private
        (§ field String symbol = "", code = "", pattern = "", localizedPattern = "")

        #_private
        (§ constructor Builder())
        (ß
        )

        ;;;
         ; Specify the new <code>BtcFormat</code> is to be automatically-denominating.
         ; The argument determines which of either codes or symbols the new <code>BtcFormat</code>
         ; will use by default to indicate the denominations it chooses when formatting values.
         ;
         ; <p>Note that the <code>Style</code> argument specifies the <em>default</em> style, which is
         ; overridden by invoking either {@link #pattern(String)} or {@link #localizedPattern(String)}.
         ;
         ; @throws IllegalArgumentException if {@link #scale(int)} has previously been invoked on this instance.
         ;;
        #_public
        (§ method Builder style(BtcAutoFormat.Style val))
        (ß
            (§ if (variant == Variant.FIXED))
                (§ throw new IllegalStateException("You cannot invoke both style() and scale()"))

            (§ ass variant = Variant.AUTO)
            (§ ass style = val)
            (§ return this)
        )

        ;;;
         ; Specify the number of decimal places in the fraction part of formatted numbers.
         ; This is equivalent to the {@link #minimumFractionDigits(int)} method, but named
         ; appropriately for the context of generating {@link BtcAutoFormat} instances.
         ;
         ; <p>If neither this method nor <code>minimumFactionDigits()</code> is invoked,
         ; the default value will be <code>2</code>.
         ;;
        #_public
        (§ method Builder fractionDigits(int val))
        (ß
            (§ return minimumFractionDigits(val))
        )

        ;;;
         ; Specify a fixed-denomination of units to use when formatting and parsing values.
         ; The argument specifies the number of decimal places, in increasing precision, by which
         ; each formatted value will differ from that same value denominated in bitcoins.  For example,
         ; a denomination of millibitcoins is specified with a value of <code>3</code>.
         ;
         ; <p>The <code>BtcFormat</code> class provides appropriately named <code>int</code>-type constants
         ; for the three common values, {@link BtcFormat#COIN_SCALE}, {@link BtcFormat#MILLICOIN_SCALE}
         ; and {@link BtcFormat#MICROCOIN_SCALE}.
         ;
         ; <p>If neither this method nor {@link #style(BtcAutoFormat.Style)} is invoked on a <code>Builder</code>,
         ; then the <code>BtcFormat</code> will default to a fixed-denomination of bitcoins, equivalent
         ; to invoking this method with an argument of <code>0</code>.
         ;;
        #_public
        (§ method Builder scale(int val))
        (ß
            (§ if (variant == Variant.AUTO))
                (§ throw new IllegalStateException("You cannot invoke both scale() and style()"))

            (§ ass variant = Variant.FIXED)
            (§ ass scale = val)
            (§ return this)
        )

        ;;;
         ; Specify the minimum number of decimal places in the fraction part of formatted values.
         ; This method is equivalent to {@link #fractionDigits(int)}, but named appropriately for
         ; the context of generating a fixed-denomination formatter.
         ;
         ; <p>If neither this method nor <code>fractionDigits()</code> is invoked, the default value
         ; will be <code>2</code>.
         ;;
        #_public
        (§ method Builder minimumFractionDigits(int val))
        (ß
            (§ ass minimumFractionDigits = val)
            (§ return this)
        )

        ;;;
         ; Specify the sizes of a variable number of optional decimal-place groups in the fraction
         ; part of formatted values.  A group of each specified size will be used in addition to
         ; all previously applied decimal places only if doing so is useful for expressing precision.
         ; The size of each group is limited to a maximum precision of satoshis.
         ;
         ; <p>If this method is not invoked, then the number of fractional decimal places will be limited to
         ; the value passed to {@link #minimumFractionDigits}, or <code>2</code> if that method is not invoked.
         ;;
        #_public
        (§ method Builder fractionGroups(int... val))
        (ß
            (§ ass fractionGroups = val)
            (§ return this)
        )

        ;;;
         ; Specify the {@link java.util.Locale} for formatting and parsing.
         ; If this method is not invoked, then the runtime default locale will be used.
         ;;
        #_public
        (§ method Builder locale(Locale val))
        (ß
            (§ ass locale = val)
            (§ return this)
        )

        ;;;
         ; Specify a currency symbol to be used in the denomination-unit indicators of formatted values.
         ; This method only sets the symbol, but does not cause it to be used.  You must also invoke either
         ; <code>style(SYMBOL)</code>, or else apply a custom pattern that includes a single currency-sign
         ; character by invoking either {@link #pattern(String)} or {@link #localizedPattern(String)}.
         ;
         ; <p>Specify only the base symbol.  The appropriate prefix will be applied according to
         ; the denomination of formatted and parsed values.
         ;;
        #_public
        (§ method Builder symbol(String val))
        (ß
            (§ ass symbol = val)
            (§ return this)
        )

        ;;;
         ; Specify a custom currency code to be used in the denomination-unit indicators of formatted values.
         ; This method only sets the code, but does not cause it to be used.  You must also invoke either
         ; <code>style(CODE)</code>, or else apply a custom pattern that includes a double currency-sign
         ; character by invoking either {@link #pattern(String)} or {@link #localizedPattern(String)}.
         ;
         ; <p>Specify only the base code.  The appropriate prefix will be applied according to
         ; the denomination of formatted and parsed values.
         ;;
        #_public
        (§ method Builder code(String val))
        (ß
            (§ ass code = val)
            (§ return this)
        )

        ;;;
         ; Use the given pattern when formatting and parsing.  The format of this pattern is identical to
         ; that used by the {@link java.text.DecimalFormat} class.
         ;
         ; <p>If the pattern lacks a negative subpattern, then the formatter will indicate negative values
         ; by placing a minus sign immediately preceding the number part of formatted values.
         ;
         ; <p>Note that while the pattern format specified by the {@link java.text.DecimalFormat} class
         ; includes a mechanism for setting the number of fractional decimal places, that part of the pattern
         ; is ignored.  Instead, use the {@link #fractionDigits(int)}, {@link #minimumFractionDigits(int)}
         ; and {@link #fractionGroups(int...)} methods.
         ;
         ; <p>Warning: if you set a pattern that includes a currency-sign for a fixed-denomination formatter
         ; that uses a non-standard scale, then an exception will be raised when you try to format a value.
         ; The standard scales include all for which a metric prefix exists from micro to mega.
         ;
         ; <p>Note that by applying a pattern you override the configured formatting style of
         ; {@link BtcAutoFormat} instances.
         ;;
        #_public
        (§ method Builder pattern(String val))
        (ß
            (§ if (localizedPattern != ""))
                (§ throw new IllegalStateException("You cannot invoke both pattern() and localizedPattern()"))

            (§ ass pattern = val)
            (§ return this)
        )

        ;;;
         ; Use the given localized-pattern for formatting and parsing.  The format of this pattern is identical
         ; to the patterns used by the {@link java.text.DecimalFormat} class.
         ;
         ; <p>The pattern is localized according to the locale of the <code>BtcFormat</code> instance, the symbols
         ; for which can be examined by inspecting the {@link java.text.DecimalFormatSymbols} object returned by
         ; {@link BtcFormat#symbols()}.  So, for example, if you are in Germany, then the non-localized pattern of
         ; <pre>"#,##0.###"</pre> would be localized as <pre>"#.##0,###"</pre>.
         ;
         ; <p>If the pattern lacks a negative subpattern, then the formatter will indicate negative values by
         ; placing a minus sign immediately preceding the number part of formatted values.
         ;
         ; <p>Note that while the pattern format specified by the {@link java.text.DecimalFormat} class includes
         ; a mechanism for setting the number of fractional decimal places, that part of the pattern is ignored.
         ; Instead, use the {@link #fractionDigits(int)}, {@link #minimumFractionDigits(int)} and
         ; {@link #fractionGroups(int...)} methods.
         ;
         ; <p>Warning: if you set a pattern that includes a currency-sign for a fixed-denomination formatter
         ; that uses a non-standard scale, then an exception will be raised when you try to format a value.
         ; The standard scales include all for which a metric prefix exists from micro to mega.
         ;
         ; <p>Note that by applying a pattern you override the configured formatting style of
         ; {@link BtcAutoFormat} instances.
         ;;
        #_public
        (§ method Builder localizedPattern(String val))
        (ß
            (§ if (pattern != ""))
                (§ throw new IllegalStateException("You cannot invoke both pattern() and localizedPattern()."))

            (§ ass localizedPattern = val)
            (§ return this)
        )

        ;;;
         ; Return a new {@link BtcFormat} instance.  The object returned will be configured according
         ; to the state of this <code>Builder</code> instance at the time this method is invoked.
         ;;
        #_public
        (§ method BtcFormat build())
        (ß
            (§ var BtcFormat f = variant.newInstance(this))
            (§ if (symbol != "" || code != ""))
            (ß
                (§ sync f.numberFormat)
                (ß
                    (§ var DecimalFormatSymbols defaultSigns = f.numberFormat.getDecimalFormatSymbols())
                    (§ call setSymbolAndCode(f.numberFormat, (symbol != "") ? symbol :else defaultSigns.getCurrencySymbol(), (code != "") ? code :else defaultSigns.getInternationalCurrencySymbol()))
                )
            )
            (§ if (localizedPattern != "" || pattern != ""))
            (ß
                (§ var int places = f.numberFormat.getMinimumFractionDigits())
                (§ if (localizedPattern != ""))
                    (§ call f.numberFormat.applyLocalizedPattern(negify(localizedPattern)))
                (§ else)
                    (§ call f.numberFormat.applyPattern(negify(pattern)))
                (§ call f.numberFormat.setMinimumFractionDigits(places))
                (§ call f.numberFormat.setMaximumFractionDigits(places))
            )
            (§ return f)
        )
    )

    ;;; Return a new {@link Builder} object.  See the documentation of that class for usage details. ;;
    #_public
    #_static
    (§ method Builder builder())
    (ß
        (§ return new Builder())
    )

    ;;; This single constructor is invoked by the overriding subclass constructors. ;;
    #_protected
    (§ constructor BtcFormat(DecimalFormat numberFormat, int minDecimals, List<Integer> groups))
    (ß
        (§ call Preconditions.checkArgument(0 <= minDecimals, "There can be no fewer than zero fractional decimal places"))

        (§ ass this.numberFormat = numberFormat)
        (§ call this.numberFormat.setParseBigDecimal(true))
        (§ call this.numberFormat.setRoundingMode(HALF_UP))
        (§ ass this.minimumFractionDigits = minDecimals)
        (§ call this.numberFormat.setMinimumFractionDigits(this.minimumFractionDigits))
        (§ call this.numberFormat.setMaximumFractionDigits(this.minimumFractionDigits))
        (§ ass this.decimalGroups = groups)
        (§ sync this.numberFormat)
        (ß
            (§ call setSymbolAndCode(this.numberFormat, (this.numberFormat.getDecimalFormatSymbols().getCurrencySymbol().contains(COIN_SYMBOL)) ? COIN_SYMBOL_ALT :else COIN_SYMBOL, COIN_CODE))
        )
    )

    ;;;
     ; Return a new instance of this class using all defaults.  The returned formatter will auto-denominate
     ; values so as to minimize zeros without loss of precision and display a currency code, for example
     ; "<code>BTC</code>", to indicate that denomination.  The returned object will uses the default locale
     ; for formatting the number and placement of the currency-code.  Two fractional decimal places will
     ; be displayed in all formatted numbers.
     ;;
    #_public
    #_static
    (§ method BtcFormat getInstance())
    (ß
        (§ return getInstance(defaultLocale()))
    )

    ;;;
     ; Return a new auto-denominating instance that will indicate units using a currency symbol, for example,
     ; <code>"฿"</code>.  Formatting and parsing will be done according to the default locale.
     ;;
    #_public
    #_static
    (§ method BtcFormat getSymbolInstance())
    (ß
        (§ return getSymbolInstance(defaultLocale()))
    )

    ;;;
     ; Return a new auto-denominating instance that will indicate units using a currency code, for example,
     ; <code>"BTC"</code>.  Formatting and parsing will be done according to the default locale.
     ;;
    #_public
    #_static
    (§ method BtcFormat getCodeInstance())
    (ß
        (§ return getCodeInstance(defaultLocale()))
    )

    ;;;
     ; Return a new symbol-style auto-formatter with the given number of fractional decimal places.
     ; Denominational units will be indicated using a currency symbol, for example, <code>"฿"</code>.
     ; The returned object will format the fraction-part of numbers using the given number of decimal
     ; places, or fewer as necessary to avoid giving a place to fractional satoshis.  Formatting and
     ; parsing will be done according to the default locale.
     ;;
    #_public
    #_static
    (§ method BtcFormat getSymbolInstance(int fractionPlaces))
    (ß
        (§ return getSymbolInstance(defaultLocale(), fractionPlaces))
    )

    ;;;
     ; Return a new code-style auto-formatter with the given number of fractional decimal places.
     ; Denominational units will be indicated using a currency code, for example, <code>"BTC"</code>.
     ; The returned object will format the fraction-part of numbers using the given number of decimal
     ; places, or fewer as necessary to avoid giving a place to fractional satoshis.  Formatting and
     ; parsing will be done according to the default locale.
     ;;
    #_public
    #_static
    (§ method BtcFormat getCodeInstance(int minDecimals))
    (ß
        (§ return getCodeInstance(defaultLocale(), minDecimals))
    )

    ;;;
     ; Return a new code-style auto-formatter for the given locale.  The returned object will
     ; select denominational units based on each value being formatted, and will indicate those
     ; units using a currency code, for example, <code>"mBTC"</code>.
     ;;
    #_public
    #_static
    (§ method BtcFormat getInstance(Locale locale))
    (ß
        (§ return getCodeInstance(locale))
    )

    ;;;
     ; Return a new code-style auto-formatter for the given locale.  The returned object will
     ; select denominational units based on each value being formatted, and will indicate those
     ; units using a currency code, for example, <code>"mBTC"</code>.
     ;;
    #_public
    #_static
    (§ method BtcFormat getCodeInstance(Locale locale))
    (ß
        (§ return getInstance(CODE, locale))
    )

    ;;;
     ; Return a new code-style auto-formatter for the given locale with the given number of
     ; fraction places.  The returned object will select denominational units based on each
     ; value being formatted, and will indicate those units using a currency code, for example,
     ; <code>"mBTC"</code>.  The returned object will format the fraction-part of numbers using
     ; the given number of decimal places, or fewer as necessary to avoid giving a place to
     ; fractional satoshis.
     ;;
    #_public
    #_static
    (§ method BtcFormat getInstance(Locale locale, int minDecimals))
    (ß
        (§ return getCodeInstance(locale, minDecimals))
    )

    ;;;
     ; Return a new code-style auto-formatter for the given locale with the given number of
     ; fraction places.  The returned object will select denominational units based on each
     ; value being formatted, and will indicate those units using a currency code, for example,
     ; <code>"mBTC"</code>.  The returned object will format the fraction-part of numbers using
     ; the given number of decimal places, or fewer as necessary to avoid giving a place to
     ; fractional satoshis.
     ;;
    #_public
    #_static
    (§ method BtcFormat getCodeInstance(Locale locale, int minDecimals))
    (ß
        (§ return getInstance(CODE, locale, minDecimals))
    )

    ;;;
     ; Return a new symbol-style auto-formatter for the given locale.  The returned object will
     ; select denominational units based on each value being formatted, and will indicate those
     ; units using a currency symbol, for example, <code>"µ฿"</code>.
     ;;
    #_public
    #_static
    (§ method BtcFormat getSymbolInstance(Locale locale))
    (ß
        (§ return getInstance(SYMBOL, locale))
    )

    ;;;
     ; Return a new symbol-style auto-formatter for the given locale with the given number of
     ; fraction places.  The returned object will select denominational units based on each
     ; value being formatted, and will indicate those units using a currency symbol, for example,
     ; <code>"µ฿"</code>.  The returned object will format the fraction-part of numbers using
     ; the given number of decimal places, or fewer as necessary to avoid giving a place to
     ; fractional satoshis.
     ;;
    #_public
    #_static
    (§ method BtcFormat getSymbolInstance(Locale locale, int fractionPlaces))
    (ß
        (§ return getInstance(SYMBOL, locale, fractionPlaces))
    )

    ;;;
     ; Return a new auto-denominating formatter.  The returned object will indicate the
     ; denominational units of formatted values using either a currency symbol, such as,
     ; <code>"฿"</code>, or code, such as <code>"mBTC"</code>, depending on the value of
     ; the argument.  Formatting and parsing will be done according to the default locale.
     ;;
    #_public
    #_static
    (§ method BtcFormat getInstance(Style style))
    (ß
        (§ return getInstance(style, defaultLocale()))
    )

    ;;;
     ; Return a new auto-denominating formatter with the given number of fractional decimal
     ; places.  The returned object will indicate the denominational units of formatted values
     ; using either a currency symbol, such as, <code>"฿"</code>, or code, such as
     ; <code>"mBTC"</code>, depending on the value of the first argument.  The returned object
     ; will format the fraction-part of numbers using the given number of decimal places, or
     ; fewer as necessary to avoid giving a place to fractional satoshis.  Formatting and
     ; parsing will be done according to the default locale.
     ;;
    #_public
    #_static
    (§ method BtcFormat getInstance(Style style, int fractionPlaces))
    (ß
        (§ return getInstance(style, defaultLocale(), fractionPlaces))
    )

    ;;;
     ; Return a new auto-formatter with the given style for the given locale.
     ; The returned object that will auto-denominate each formatted value, and will indicate
     ; that denomination using either a currency code, such as "<code>BTC</code>", or symbol,
     ; such as "<code>฿</code>", depending on the value of the first argument.
     ; <p>The number of fractional decimal places in formatted number will be two, or fewer
     ; as necessary to avoid giving a place to fractional satoshis.
     ;;
    #_public
    #_static
    (§ method BtcFormat getInstance(Style style, Locale locale))
    (ß
        (§ return getInstance(style, locale, 2))
    )

    ;;;
     ; Return a new auto-formatter for the given locale with the given number of fraction places.
     ; The returned object will automatically-denominate each formatted value, and will indicate
     ; that denomination using either a currency code, such as <code>"mBTC"</code>, or symbol,
     ; such as "<code>฿</code>", according to the given style argument.  It will format each
     ; number according to the given locale.
     ;
     ; <p>The third parameter is the number of fractional decimal places to use for each formatted
     ; number, reduced as neccesary when formatting to avoid giving a place to fractional satoshis.
     ;;
    #_public
    #_static
    (§ method BtcFormat getInstance(Style style, Locale locale, int fractionPlaces))
    (ß
        (§ return new BtcAutoFormat(locale, style, fractionPlaces))
    )

    ;;;
     ; Return a new coin-denominated formatter.  The returned object will format and parse values
     ; according to the default locale, and will format numbers with two fractional decimal places,
     ; rounding values as necessary.
     ;;
    #_public
    #_static
    (§ method BtcFormat getCoinInstance())
    (ß
        (§ return getCoinInstance(defaultLocale()))
    )

    #_private
    #_static
    (§ method List<Integer> boxAsList(int[] elements))
        (§ throws IllegalArgumentException)
    (ß
        (§ var List<Integer> list = new ArrayList<>(elements.length))
        (§ for (int e :for elements))
        (ß
            (§ call Preconditions.checkArgument(0 < e, "Size of decimal group must be at least one."))
            (§ call list.add(e))
        )
        (§ return list)
    )

    ;;;
     ; Return a new coin-denominated formatter with the specified fraction-places.  The returned
     ; object will format and parse values according to the default locale, and will format the
     ; fraction part of numbers with at least two decimal places.  The sizes of additional groups
     ; of decimal places can be specified by a variable number of <code>int</code> arguments.
     ; Each optional decimal-place group will be applied only if useful for expressing precision,
     ; and will be only partially applied if necessary to avoid giving a place to fractional satoshis.
     ;;
    #_public
    #_static
    (§ method BtcFormat getCoinInstance(int minFractionPlaces, int... groups))
    (ß
        (§ return getInstance(COIN_SCALE, defaultLocale(), minFractionPlaces, boxAsList(groups)))
    )

    ;;;
     ; Return a new coin-denominated formatter for the given locale.  The returned object will
     ; format the fractional part of numbers with two decimal places, rounding as necessary.
     ;;
    #_public
    #_static
    (§ method BtcFormat getCoinInstance(Locale locale))
    (ß
        (§ return getInstance(COIN_SCALE, locale, 2))
    )

    ;;;
     ; Return a newly-constructed instance for the given locale that will format values in terms of bitcoins,
     ; with the given minimum number of fractional decimal places.  Optionally, repeating integer arguments
     ; can be passed, each indicating the size of an additional group of fractional decimal places to be used
     ; as necessary to avoid rounding, to a limiting precision of satoshis.
     ;;
    #_public
    #_static
    (§ method BtcFormat getCoinInstance(Locale locale, int scale, int... groups))
    (ß
        (§ return getInstance(COIN_SCALE, locale, scale, boxAsList(groups)))
    )

    ;;;
     ; Return a new millicoin-denominated formatter.  The returned object will format and parse values for
     ; the default locale, and will format the fractional part of numbers with two decimal places, rounding
     ; as necessary.
     ;;
    #_public
    #_static
    (§ method BtcFormat getMilliInstance())
    (ß
        (§ return getMilliInstance(defaultLocale()))
    )

    ;;;
     ; Return a new millicoin-denominated formatter for the given locale.  The returned object will
     ; format the fractional part of numbers with two decimal places, rounding as necessary.
     ;;
    #_public
    #_static
    (§ method BtcFormat getMilliInstance(Locale locale))
    (ß
        (§ return getInstance(MILLICOIN_SCALE, locale, 2))
    )

    ;;;
     ; Return a new millicoin-denominated formatter with the specified fractional decimal placing.
     ; The returned object will format and parse values according to the default locale, and will format the
     ; fractional part of numbers with the given minimum number of fractional decimal places.  Optionally,
     ; repeating integer arguments can be passed, each indicating the size of an additional group of fractional
     ; decimal places to be used as necessary to avoid rounding, to a limiting precision of satoshis.
     ;;
    #_public
    #_static
    (§ method BtcFormat getMilliInstance(int scale, int... groups))
    (ß
        (§ return getInstance(MILLICOIN_SCALE, defaultLocale(), scale, boxAsList(groups)))
    )

    ;;;
     ; Return a new millicoin-denominated formatter for the given locale with the specified fractional
     ; decimal placing.  The returned object will format the fractional part of numbers with the given
     ; minimum number of fractional decimal places.  Optionally, repeating integer arguments can be passed,
     ; each indicating the size of an additional group of fractional decimal places to be used as necessary
     ; to avoid rounding, to a limiting precision of satoshis.
     ;;
    #_public
    #_static
    (§ method BtcFormat getMilliInstance(Locale locale, int scale, int... groups))
    (ß
        (§ return getInstance(MILLICOIN_SCALE, locale, scale, boxAsList(groups)))
    )

    ;;;
     ; Return a new microcoin-denominated formatter for the default locale.  The returned object will
     ; format the fractional part of numbers with two decimal places, rounding as necessary.
     ;;
    #_public
    #_static
    (§ method BtcFormat getMicroInstance())
    (ß
        (§ return getMicroInstance(defaultLocale()))
    )

    ;;;
     ; Return a new microcoin-denominated formatter for the given locale.  The returned object will
     ; format the fractional part of numbers with two decimal places, rounding as necessary.
     ;;
    #_public
    #_static
    (§ method BtcFormat getMicroInstance(Locale locale))
    (ß
        (§ return getInstance(MICROCOIN_SCALE, locale))
    )

    ;;;
     ; Return a new microcoin-denominated formatter with the specified fractional decimal placing.
     ; The returned object will format and parse values according to the default locale, and will format the
     ; fractional part of numbers with the given minimum number of fractional decimal places.  Optionally,
     ; repeating integer arguments can be passed, each indicating the size of an additional group of fractional
     ; decimal places to be used as necessary to avoid rounding, to a limiting precision of satoshis.
     ;;
    #_public
    #_static
    (§ method BtcFormat getMicroInstance(int scale, int... groups))
    (ß
        (§ return getInstance(MICROCOIN_SCALE, defaultLocale(), scale, boxAsList(groups)))
    )

    ;;;
     ; Return a new microcoin-denominated formatter for the given locale with the specified fractional
     ; decimal placing.  The returned object will format the fractional part of numbers with the given
     ; minimum number of fractional decimal places.  Optionally, repeating integer arguments can be passed,
     ; each indicating the size of an additional group of fractional decimal places to be used as necessary
     ; to avoid rounding, to a limiting precision of satoshis.
     ;;
    #_public
    #_static
    (§ method BtcFormat getMicroInstance(Locale locale, int scale, int... groups))
    (ß
        (§ return getInstance(MICROCOIN_SCALE, locale, scale, boxAsList(groups)))
    )

    ;;;
     ; Return a new fixeed-denomination formatter with the specified fractional decimal placing.
     ; The first argument specifies the denomination as the size of the shift from coin-denomination
     ; in increasingly-precise decimal places.  The returned object will format and parse values according
     ; to the default locale, and will format the fractional part of numbers with the given minimum number
     ; of fractional decimal places.  Optionally, repeating integer arguments can be passed, each indicating
     ; the size of an additional group of fractional decimal places to be used as necessary to avoid rounding,
     ; to a limiting precision of satoshis.
     ;;
    #_public
    #_static
    (§ method BtcFormat getInstance(int scale, int minDecimals, int... groups))
    (ß
        (§ return getInstance(scale, defaultLocale(), minDecimals, boxAsList(groups)))
    )

    ;;;
     ; Return a new fixeed-denomination formatter.  The argument specifies the denomination as the size of
     ; the shift from coin-denomination in increasingly-precise decimal places.  The returned object will
     ; format and parse values according to the default locale, and will format the fractional part of
     ; numbers with two decimal places, or fewer as necessary to avoid giving a place to fractional satoshis.
     ;;
    #_public
    #_static
    (§ method BtcFormat getInstance(int scale))
    (ß
        (§ return getInstance(scale, defaultLocale()))
    )

    ;;;
     ; Return a new fixeed-denomination formatter for the given locale.  The first argument specifies the
     ; denomination as the size of the shift from coin-denomination in increasingly-precise decimal places.
     ; The returned object will format and parse values according to the locale specified by the second
     ; argument, and will format the fractional part of numbers with two decimal places, or fewer as
     ; necessary to avoid giving a place to fractional satoshis.
     ;;
    #_public
    #_static
    (§ method BtcFormat getInstance(int scale, Locale locale))
    (ß
        (§ return getInstance(scale, locale, 2))
    )

    ;;;
     ; Return a new fixed-denomination formatter for the given locale, with the specified fractional
     ; decimal placing.  The first argument specifies the denomination as the size of the shift from
     ; coin-denomination in increasingly-precise decimal places.  The third parameter is the minimum
     ; number of fractional decimal places to use, followed by optional repeating integer parameters
     ; each specifying the size of an additional group of fractional decimal places to use as
     ; necessary to avoid rounding, down to a maximum precision of satoshis.
     ;;
    #_public
    #_static
    (§ method BtcFormat getInstance(int scale, Locale locale, int minDecimals, int... groups))
    (ß
        (§ return getInstance(scale, locale, minDecimals, boxAsList(groups)))
    )

    ;;;
     ; Return a new fixed-denomination formatter for the given locale, with the specified fractional
     ; decimal placing.  The first argument specifies the denomination as the size of the shift from
     ; coin-denomination in increasingly-precise decimal places.  The third parameter is the minimum
     ; number of fractional decimal places to use.  The third argument specifies the minimum number of
     ; fractional decimal places in formatted numbers.  The last argument is a <code>List</code> of
     ; <code>Integer</code> values, each of which specifies the size of an additional group of fractional
     ; decimal places to use as necessary to avoid rounding, down to a maximum precision of satoshis.
     ;;
    #_public
    #_static
    (§ method BtcFormat getInstance(int scale, Locale locale, int minDecimals, List<Integer> groups))
    (ß
        (§ return new BtcFixedFormat(locale, scale, minDecimals, groups))
    )

    ;;;
     ; Formats a bitcoin monetary value and returns an {@link java.text.AttributedCharacterIterator}.
     ; By iterating, you can examine what fields apply to each character.  This can be useful since a character
     ; may be part of more than one field, for example a grouping separator that is also part of the integer field.
     ;
     ; @see java.text.AttributedCharacterIterator
     ;;
    #_override
    #_public
    (§ method AttributedCharacterIterator formatToCharacterIterator(Object obj))
    (ß
        (§ sync numberFormat)
        (ß
            (§ var DecimalFormatSymbols anteSigns = numberFormat.getDecimalFormatSymbols())
            (§ var BigDecimal units = denominateAndRound(inSatoshis(obj), minimumFractionDigits, decimalGroups))
            (§ var List<Integer> anteDigits = setFormatterDigits(numberFormat, units.scale(), units.scale()))
            (§ var AttributedCharacterIterator i = numberFormat.formatToCharacterIterator(units))
            (§ call numberFormat.setDecimalFormatSymbols(anteSigns))
            (§ call setFormatterDigits(numberFormat, anteDigits.get(0), anteDigits.get(1)))
            (§ return i)
        )
    )

    ;;;
     ; Formats a bitcoin value as a number and possibly a units indicator and appends the resulting text
     ; to the given string buffer.  The type of monetary value argument can be any one of any of the following
     ; classes: <code>{@link Coin}</code>, <code>Integer</code>, <code>Long</code>, <code>BigInteger</code>,
     ; <code>BigDecimal</code>.  Numeric types that can represent only an integer are interpreted as that
     ; number of satoshis.  The value of a <code>BigDecimal</code> is interpreted as that number of bitcoins,
     ; rounded to the nearest satoshi as necessary.
     ;
     ; @return the <code>StringBuffer</code> passed in as <code>toAppendTo</code>.
     ;;
    #_override
    #_public
    (§ method StringBuffer format(Object qty, StringBuffer toAppendTo, FieldPosition pos))
    (ß
        (§ return format(qty, toAppendTo, pos, minimumFractionDigits, decimalGroups))
    )

    ;;;
     ; Formats a bitcoin value as a number and possibly a units indicator to a <code>String</code>.
     ; The type of monetary value argument can be any one of any of the following classes:
     ; <code>{@link Coin}</code>, <code>Integer</code>, <code>Long</code>, <code>BigInteger</code>,
     ; <code>BigDecimal</code>.  Numeric types that can represent only an integer are interpreted
     ; as that number of satoshis.  The value of a <code>BigDecimal</code> is interpreted as that
     ; number of bitcoins, rounded to the nearest satoshi as necessary.
     ;
     ; @param minDecimals The minimum number of decimal places in the fractional part of the formatted number.
     ; @param fractionGroups The sizes of optional additional fractional decimal-place groups.
     ; @throws IllegalArgumentException if the number of fraction places is negative.
     ;;
    #_public
    (§ method String format(Object qty, int minDecimals, int... fractionGroups))
    (ß
        (§ return format(qty, new StringBuffer(), new FieldPosition(0), minDecimals, boxAsList(fractionGroups)).toString())
    )

    ;;;
     ; Formats a bitcoin value as a number and possibly a units indicator and appends the resulting
     ; text to the given string buffer.  The type of monetary value argument can be any one of any of
     ; the following classes: <code>{@link Coin}</code>, <code>Integer</code>, <code>Long</code>,
     ; <code>BigInteger</code>, <code>BigDecimal</code>.  Numeric types that can represent only an
     ; integer are interpreted as that number of satoshis.  The value of a <code>BigDecimal</code> is
     ; interpreted as that number of bitcoins, rounded to the nearest satoshi as necessary.
     ;
     ; @param minDecimals The minimum number of decimal places in the fractional part of the formatted number.
     ; @param fractionGroups The sizes of optional additional fractional decimal-place groups.
     ; @throws IllegalArgumentException if the number of fraction places is negative.
     ;;
    #_public
    (§ method StringBuffer format(Object qty, StringBuffer toAppendTo, FieldPosition pos, int minDecimals, int... fractionGroups))
    (ß
        (§ return format(qty, toAppendTo, pos, minDecimals, boxAsList(fractionGroups)))
    )

    #_private
    (§ method StringBuffer format(Object qty, StringBuffer toAppendTo, FieldPosition pos, int minDecimals, List<Integer> fractionGroups))
    (ß
        (§ call Preconditions.checkArgument(0 <= minDecimals, "There can be no fewer than zero fractional decimal places"))

        (§ sync numberFormat)
        (ß
            (§ var DecimalFormatSymbols anteSigns = numberFormat.getDecimalFormatSymbols())
            (§ var BigDecimal denominatedUnitCount = denominateAndRound(inSatoshis(qty), minDecimals, fractionGroups))
            (§ var List<Integer> antePlaces = setFormatterDigits(numberFormat, denominatedUnitCount.scale(), denominatedUnitCount.scale()))
            (§ var StringBuffer s = numberFormat.format(denominatedUnitCount, toAppendTo, pos))
            (§ call numberFormat.setDecimalFormatSymbols(anteSigns))
            (§ call setFormatterDigits(numberFormat, antePlaces.get(0), antePlaces.get(1)))
            (§ return s)
        )
    )

    ;;;
     ; Return the denomination for formatting the given value.  The returned <code>int</code> is the size
     ; of the decimal-place shift between the given Bitcoin-value denominated in bitcoins and that same value
     ; as formatted.  A fixed-denomination formatter will ignore the arguments.
     ;
     ; @param satoshis The number of satoshis having the value for which the shift is calculated.
     ; @param fractionPlaces The number of decimal places available for displaying the fractional part of the denominated value.
     ; @return the size of the shift in increasingly-precise decimal places.
     ;;
    #_protected
    #_abstract
    (§ method int scale(BigInteger satoshis, int fractionPlaces))

    ;;;
     ; Return the denomination of this object.  Fixed-denomination formatters will override with their configured
     ; denomination, auto-formatters with coin denomination.  This determines the interpretation of parsed numbers
     ; lacking a units-indicator.
     ;;
    #_protected
    #_abstract
    (§ method int scale())

    ;;;
     ; Takes a bitcoin monetary value that the client wants to format and returns the number of denominational units
     ; having the equal value, rounded to the appropriate number of decimal places.  Calls the scale() method of the
     ; subclass, which may have the side-effect of changing the currency symbol and code of the underlying `NumberFormat`
     ; object, therefore only invoke this from a synchronized method that resets the NumberFormat.
     ;;
    #_private
    (§ method BigDecimal denominateAndRound(BigInteger satoshis, int minDecimals, List<Integer> fractionGroups))
    (ß
        (§ var int scale = scale(satoshis, minDecimals))
        (§ var BigDecimal denominatedUnitCount = new BigDecimal(satoshis).movePointLeft(offSatoshis(scale)))
        (§ var int places = calculateFractionPlaces(denominatedUnitCount, scale, minDecimals, fractionGroups))
        (§ return denominatedUnitCount.setScale(places, HALF_UP))
    )

    ;;;
     ; Sets the number of fractional decimal places to be displayed on the given NumberFormat object to the value
     ; of the given integer.
     ; @return the minimum and maximum fractional places settings that the formatter had before this change,
     ; as an ImmutableList.
     ;;
    #_private
    #_static
    (§ method ImmutableList<Integer> setFormatterDigits(DecimalFormat formatter, int min, int max))
    (ß
        (§ var ImmutableList<Integer> ante = ImmutableList.of(formatter.getMinimumFractionDigits(), formatter.getMaximumFractionDigits()))
        (§ call formatter.setMinimumFractionDigits(min))
        (§ call formatter.setMaximumFractionDigits(max))
        (§ return ante)
    )

    ;;;
     ; Return the number of fractional decimal places to be displayed when formatting the given number of monetory
     ; units of the denomination indicated by the given decimal scale value, where 0 = coin, 3 = millicoin, and so on.
     ;
     ; @param unitCount      The number of monetary units to be formatted.
     ; @param scale          The denomination of those units as the decimal-place shift from coins.
     ; @param minDecimals    The minimum number of fractional decimal places.
     ; @param fractionGroups The sizes of option fractional decimal-place groups.
     ;;
    #_private
    #_static
    (§ method int calculateFractionPlaces(BigDecimal unitCount, int scale, int minDecimals, List<Integer> fractionGroups))
    (ß
        ;; Taking into account BOTH the user's preference for decimal-place groups, AND the prohibition against displaying
         ; a fractional number of satoshis, determine the maximum possible number of fractional decimal places.
         ;;
        (§ var int places = minDecimals)
        (§ for (int group :for fractionGroups))
            (§ ass places = places + group)
        (§ var int max = Math.min(places, offSatoshis(scale)))

        (§ ass places = Math.min(minDecimals, max))
        (§ for (int group :for fractionGroups))
        (ß
            ;; Compare the value formatted using only this many decimal places to the same value using as many places
             ; as possible.  If there's no difference, then there's no reason to continue adding more places.
             ;;
            (§ if (unitCount.setScale(places, HALF_UP).compareTo(unitCount.setScale(max, HALF_UP)) == 0))
                (§ break)
            (§ ass places = places + group)
            (§ if (max < places))
                (§ ass places = max)
        )
        (§ return places)
    )

    ;;;
     ; Takes an object representing a bitcoin quantity of any type the client is permitted to pass us, and return
     ; a BigInteger representing the number of satoshis having the equivalent value.
     ;;
    #_private
    #_static
    (§ method BigInteger inSatoshis(Object qty))
    (ß
        ;; The value might be bitcoins or satoshis.
        (§ if (qty instanceof Long || qty instanceof Integer))
            (§ return BigInteger.valueOf(((Number)qty).longValue()))
        (§ if (qty instanceof BigInteger))
            (§ return (BigInteger)qty)
        (§ if (qty instanceof BigDecimal))
            (§ return ((BigDecimal)qty).movePointRight(Coin.SMALLEST_UNIT_EXPONENT).setScale(0, BigDecimal.ROUND_HALF_UP).unscaledValue())
        (§ if (qty instanceof Coin))
            (§ return BigInteger.valueOf(((Coin)qty).value))

        (§ throw new IllegalArgumentException("Cannot format a " + qty.getClass().getSimpleName() + " as a Bicoin value"))
    )

    ;;;
     ; Parse a <code>String</code> representation of a Bitcoin monetary value.
     ; Returns a {@link org.bitcoinj.core.Coin} object that represents the parsed value.
     ; @see java.text.NumberFormat
     ;;
    #_override
    #_public
    #_final
    (§ method Object parseObject(String source, ParsePosition pos))
    (ß
        (§ return parse(source, pos))
    )

    #_private
    (§ class ScaleMatcher
        #_public
        (§ field Pattern pattern)
        #_public
        (§ field int scale)

        (§ constructor ScaleMatcher(Pattern p, int s))
        (ß
            (§ ass pattern = p)
            (§ ass scale = s)
        )
    )

    ;; Lazy initialization.  No reason to create all these objects unless needed for parsing.
    ;; Coin indicator regex String.  TODO: does this need to be volatile?
    #_private
    #_volatile
    (§ field String ci = "(" + COIN_SYMBOL + "|" + COIN_SYMBOL_ALT + "|B⃦|" + COIN_CODE + "|XBT)")
    #_private
    (§ field Pattern coinPattern)
    #_private
    #_volatile
    (§ field ScaleMatcher[] denoms)
    (§ method ScaleMatcher[] denomMatchers())
    (ß
        (§ var ScaleMatcher[] result = denoms)
        (§ if (result == nil))
        (ß
            (§ sync this)
            (ß
                (§ ass result = denoms)
                (§ if (result == nil))
                (ß
                    (§ if (!coinSymbol().matches(ci)))
                        (§ ass ci = ci.replaceFirst("\\(", "(" + coinSymbol() + "|"))
                    (§ if (!coinCode().matches(ci)))
                        (§ ass ci = ci.replaceFirst("\\)", "|" + coinCode() + ")"))
                    (§ ass coinPattern = Pattern.compile(ci + "?"))
                    (§ ass result = denoms = new ScaleMatcher[]
                    (ß
                        (ß new ScaleMatcher(Pattern.compile("¢" + ci + "?|c" + ci), 2)) ;; centi
                        (ß new ScaleMatcher(Pattern.compile("₥" + ci + "?|m" + ci), MILLICOIN_SCALE))
                        (ß new ScaleMatcher(Pattern.compile("([µu]" + ci + ")"),    MICROCOIN_SCALE))
                        (ß new ScaleMatcher(Pattern.compile("(da" + ci + ")"),     -1)) ;; deka
                        (ß new ScaleMatcher(Pattern.compile("(h" + ci + ")"),      -2)) ;; hekto
                        (ß new ScaleMatcher(Pattern.compile("(k" + ci + ")"),      -3)) ;; kilo
                        (ß new ScaleMatcher(Pattern.compile("(M" + ci + ")"),      -6)) ;; mega
                    ))
                )
            )
        )
        (§ return result)
    )

    ;;;
     ; Set both the currency symbol and international code of the underlying {@link java.text.NumberFormat} object
     ; to the value of the given <code>String</code>.
     ; This method is invoked in the process of parsing, not formatting.
     ;
     ; Only invoke this from code synchronized on the value of the first argument, and don't forget
     ; to put the symbols back otherwise equals(), hashCode() and immutability will break.
     ;;
    #_private
    #_static
    (§ method DecimalFormatSymbols setSymbolAndCode(DecimalFormat numberFormat, String sign))
    (ß
        (§ return setSymbolAndCode(numberFormat, sign, sign))
    )

    ;;;
     ; Set the currency symbol and international code of the underlying {@link java.text.NumberFormat} object
     ; to the values of the last two arguments, respectively.
     ; This method is invoked in the process of parsing, not formatting.
     ;
     ; Only invoke this from code synchronized on value of the first argument, and don't forget
     ; to put the symbols back otherwise equals(), hashCode() and immutability will break.
     ;;
    #_private
    #_static
    (§ method DecimalFormatSymbols setSymbolAndCode(DecimalFormat numberFormat, String symbol, String code))
    (ß
        (§ call Preconditions.checkState(Thread.holdsLock(numberFormat)))

        (§ var DecimalFormatSymbols fs = numberFormat.getDecimalFormatSymbols())
        (§ var DecimalFormatSymbols ante = (DecimalFormatSymbols)fs.clone())
        (§ call fs.setInternationalCurrencySymbol(code))
        (§ call fs.setCurrencySymbol(symbol))
        (§ call numberFormat.setDecimalFormatSymbols(fs))
        (§ return ante)
    )

    ;;;
     ; Set both the currency symbol and code of the underlying, mutable NumberFormat object according to
     ; the given denominational units scale factor.  This is for formatting, not parsing.
     ;
     ; Set back to zero when you're done formatting otherwise immutability, equals() and hashCode() will break!
     ;
     ; @param scale Number of places the decimal point will be shifted when formatting a quantity of satoshis.
     ; @return the DecimalFormatSymbols before changing.
     ;;
    #_protected
    #_static
    (§ method void prefixUnitsIndicator(DecimalFormat numberFormat, int scale))
    (ß
        ;; Make sure caller intends to reset before changing.
        (§ call Preconditions.checkState(Thread.holdsLock(numberFormat)))

        (§ var DecimalFormatSymbols fs = numberFormat.getDecimalFormatSymbols())
        (§ call setSymbolAndCode(numberFormat, prefixSymbol(fs.getCurrencySymbol(), scale), prefixCode(fs.getInternationalCurrencySymbol(), scale)))
    )

    ;;;
     ; Parse a <code>String</code> representation of a Bitcoin monetary value.  If this object's pattern includes
     ; a currency sign, either symbol or code, as by default is true for instances of {@link BtcAutoFormat} and
     ; false for instances of {@link BtcFixedFormat}, then denominated (i.e. prefixed) currency signs in the parsed
     ; String will be recognized, and the parsed number will be interpreted as a quantity of units having that
     ; recognized denomination.
     ;
     ; If the pattern includes a currency sign but no currency sign is detected in the parsed String,
     ; then the number is interpreted as a quatity of bitcoins.
     ;
     ; If the pattern contains neither a currency symbol nor sign, then instances of {@link BtcAutoFormat} will
     ; interpret the parsed number as a quantity of bitcoins, and instances of {@link BtcAutoFormat} will interpret
     ; the number as a quantity of that instance's configured denomination, which can be ascertained by invoking
     ; the {@link BtcFixedFormat#symbol()} or {@link BtcFixedFormat#code()} method.
     ;
     ; Consider using the single-argument version of this overloaded method unless you need to keep track
     ; of the current parse position.
     ;
     ; @return a Coin object representing the parsed value.
     ; @see java.text.ParsePosition
     ;;
    #_public
    (§ method Coin parse(String source, ParsePosition pos))
    (ß
        (§ var DecimalFormatSymbols anteSigns = nil)
        (§ var int parseScale = COIN_SCALE) ;; default
        (§ var Coin coin = nil)
        (§ sync numberFormat)
        (ß
            (§ if (numberFormat.toPattern().contains("¤")))
            (ß
                (§ for (ScaleMatcher d :for denomMatchers()))
                (ß
                    (§ var Matcher matcher = d.pattern.matcher(source))
                    (§ if (matcher.find()))
                    (ß
                        (§ ass anteSigns = setSymbolAndCode(numberFormat, matcher.group()))
                        (§ ass parseScale = d.scale)
                        (§ break)
                    )
                )
                (§ if (parseScale == COIN_SCALE))
                (ß
                    (§ var Matcher matcher = coinPattern.matcher(source))
                    (§ call matcher.find())
                    (§ ass anteSigns = setSymbolAndCode(numberFormat, matcher.group()))
                )
            )
            (§ else)
                (§ ass parseScale = scale())

            (§ var Number number = numberFormat.parse(source, pos))
            (§ if (number != nil))
                (§ try)
                (ß
                    (§ ass coin = Coin.valueOf(((BigDecimal)number).movePointRight(offSatoshis(parseScale)).setScale(0, HALF_UP).longValue()))
                )
                (§ catch (IllegalArgumentException _))
                (ß
                    (§ call pos.setIndex(0))
                )
            (§ if (anteSigns != nil))
                (§ call numberFormat.setDecimalFormatSymbols(anteSigns))
        )
        (§ return coin)
    )

    ;;; Parse a <code>String</code> representation of a Bitcoin monetary value.  If this object's pattern includes
     ; a currency sign, either symbol or code, as by default is true for instances of {@link BtcAutoFormat} and
     ; false for instances of {@link BtcFixedFormat}, then denominated (i.e. prefixed) currency signs in the parsed
     ; String will be recognized, and the parsed number will be interpreted as a quantity of units having that
     ; recognized denomination.
     ;
     ; If the pattern includes a currency sign but no currency sign is detected in the parsed String,
     ; then the number is interpreted as a quatity of bitcoins.
     ;
     ; If the pattern contains neither a currency symbol nor sign, then instances of {@link BtcAutoFormat} will
     ; interpret the parsed number as a quantity of bitcoins, and instances of {@link BtcAutoFormat} will interpret
     ; the number as a quantity of that instance's configured denomination, which can be ascertained by invoking
     ; the {@link BtcFixedFormat#symbol()} or {@link BtcFixedFormat#code()} method.
     ;
     ; @return a Coin object representing the parsed value.
     ;;
    #_public
    (§ method Coin parse(String source))
        (§ throws ParseException)
    (ß
        (§ return (Coin)parseObject(source))
    )

    #_protected
    #_static
    (§ method String prefixCode(String code, int scale))
    (ß
        (§ switch (scale))
        (ß
        (§ case COIN_SCALE)
            (§ return code)
        (§ case 1)
            (§ return "d" + code)
        (§ case 2)
            (§ return "c" + code)
        (§ case MILLICOIN_SCALE)
            (§ return "m" + code)
        (§ case MICROCOIN_SCALE)
            (§ return "µ" + code)
        (§ case -1)
            (§ return "da" + code)
        (§ case -2)
            (§ return "h" + code)
        (§ case -3)
            (§ return "k" + code)
        (§ case -6)
            (§ return "M" + code)
        (§ default)
            (§ throw new IllegalStateException("No known prefix for scale " + String.valueOf(scale)))
        )
    )

    #_protected
    #_static
    (§ method String prefixSymbol(String symbol, int scale))
    (ß
        (§ switch (scale))
        (ß
        (§ case COIN_SCALE)
            (§ return symbol)
        (§ case 1)
            (§ return "d" + symbol)
        (§ case 2)
            (§ return "¢" + symbol)
        (§ case MILLICOIN_SCALE)
            (§ return "₥" + symbol)
        (§ case MICROCOIN_SCALE)
            (§ return "µ" + symbol)
        (§ case -1)
            (§ return "da" + symbol)
        (§ case -2)
            (§ return "h" + symbol)
        (§ case -3)
            (§ return "k" + symbol)
        (§ case -6)
            (§ return "M" + symbol)
        (§ default)
            (§ throw new IllegalStateException("No known prefix for scale " + String.valueOf(scale)))
        )
    )

    ;;;
     ; Guarantee a formatting pattern has a subpattern for negative values.  This method takes
     ; a pattern that may be missing a negative subpattern, and returns the same pattern with
     ; a negative subpattern appended as needed.
     ;
     ; This method accommodates an imperfection in the Java formatting code and distributed
     ; locale data.  To wit: the subpattern for negative numbers is optional and not all
     ; locales have one.  In those cases, {@link java.text.DecimalFormat} will indicate numbers
     ; less than zero by adding a negative sign as the first character of the prefix of the
     ; positive subpattern.
     ;
     ; We don't like this, since we claim the negative sign applies to the number not the
     ; units, and therefore it ought to be adjacent to the number, displacing the
     ; currency-units indicator if necessary.
     ;;
    #_protected
    #_static
    (§ method String negify(String pattern))
    (ß
        (§ if (pattern.contains(";")))
            (§ return pattern)

        (§ if (pattern.contains("-")))
            (§ throw new IllegalStateException("Positive pattern contains negative sign"))

        ;; The regex matches everything until the first non-quoted number character.
        (§ return pattern + ";" + pattern.replaceFirst("^([^#0,.']*('[^']*')?)*", "$0-"))
    )

    ;;;
     ; Return an array of all locales for which the getInstance() method of this class can
     ; return localized instances.  See {@link java.text.NumberFormat#getAvailableLocales()}.
     ;;
    #_public
    #_static
    (§ method Locale[] getAvailableLocales())
    (ß
        (§ return NumberFormat.getAvailableLocales())
    )

    ;;;
     ; Return the unprefixed currency symbol for bitcoins configured for this object.
     ; The return value of this method is constant throughough the life of an instance.
     ;;
    #_public
    (§ method String coinSymbol())
    (ß
        (§ sync numberFormat)
        (ß
            (§ return numberFormat.getDecimalFormatSymbols().getCurrencySymbol())
        )
    )

    ;;;
     ; Return the unprefixed international currency code for bitcoins configured for this object.
     ; The return value of this method is constant throughough the life of an instance.
     ;;
    #_public
    (§ method String coinCode())
    (ß
        (§ sync numberFormat)
        (ß
            (§ return numberFormat.getDecimalFormatSymbols().getInternationalCurrencySymbol())
        )
    )

    ;;;
     ; Return a representation of the pattern used by this instance for formatting and parsing.
     ; The format is similar to, but not the same as the format recognized by the {@link Builder#pattern}
     ; and {@link Builder#localizedPattern} methods.  The pattern returned by this method is localized,
     ; any currency signs expressed are literally, and optional fractional decimal places are shown
     ; grouped in parentheses.
     ;;
    #_public
    (§ method String pattern())
    (ß
        (§ sync numberFormat)
        (ß
            (§ var StringBuilder groups = new StringBuilder())
            (§ for (int group :for decimalGroups))
                (§ call groups.append("(").append(Strings.repeat("#", group)).append(")"))

            (§ var DecimalFormatSymbols s = numberFormat.getDecimalFormatSymbols())
            (§ var String digit = String.valueOf(s.getDigit()))
            (§ var String exp = s.getExponentSeparator())
            (§ var String groupSep = String.valueOf(s.getGroupingSeparator()))
            (§ var String moneySep = String.valueOf(s.getMonetaryDecimalSeparator()))
            (§ var String zero = String.valueOf(s.getZeroDigit()))
            (§ var String boundary = String.valueOf(s.getPatternSeparator()))
            (§ var String minus = String.valueOf(s.getMinusSign()))
            (§ var String decSep = String.valueOf(s.getDecimalSeparator()))

            (§ var String prefixAndNumber = "(^|" + boundary + ")" + "([^" + Matcher.quoteReplacement(digit + zero + groupSep + decSep + moneySep) + "']*('[^']*')?)*" + "[" + Matcher.quoteReplacement(digit + zero + groupSep + decSep + moneySep + exp) + "]+")

            (§ return numberFormat.toLocalizedPattern().replaceAll(prefixAndNumber, "$0" + groups).replaceAll("¤¤", Matcher.quoteReplacement(coinCode())).replaceAll("¤", Matcher.quoteReplacement(coinSymbol())))
        )
    )

    ;;; Return a copy of the localized symbols used by this instance for formatting and parsing. ;;
    #_public
    (§ method DecimalFormatSymbols symbols())
    (ß
        (§ sync numberFormat)
        (ß
            (§ return numberFormat.getDecimalFormatSymbols())
        )
    )

    ;;;
     ; Return true if the given object is equivalent to this one.
     ; Formatters for different locales will never be equal, even if they behave identically.
     ;;
    #_override
    #_public
    (§ method boolean equals(Object o))
    (ß
        (§ if (o == this))
            (§ return true)
        (§ if (!(o instanceof BtcFormat)))
            (§ return false)
        (§ var BtcFormat other = (BtcFormat)o)
        (§ return (other.pattern().equals(pattern()) && other.symbols().equals(symbols()) && other.minimumFractionDigits == minimumFractionDigits))
    )

    ;;;
     ; Return a hash code value for this instance.
     ; @see java.lang.Object#hashCode
     ;;
    #_override
    #_public
    (§ method int hashCode())
    (ß
        (§ return Objects.hashCode(pattern(), symbols(), minimumFractionDigits, decimalGroups))
    )
)

#_(ns org.bitcoinj.utils #_"ContextPropagatingThreadFactory"
    (:import #_[java.util.concurrent *])
    (:import #_[com.google.common.base *]
             #_[org.slf4j *])
  #_(:require #_[org.bitcoinj.core *]))

;;;
 ; A {@link java.util.concurrent.ThreadFactory} that propagates a {@link org.bitcoinj.core.Context}
 ; from the creating thread into the new thread.  This factory creates daemon threads.
 ;;
#_public
(§ class ContextPropagatingThreadFactory implements ThreadFactory
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(ContextPropagatingThreadFactory.class))

    #_private
    #_final
    (§ field String name)
    #_private
    #_final
    (§ field int priority)

    #_public
    (§ constructor ContextPropagatingThreadFactory(String name, int priority))
    (ß
        (§ ass this.name = name)
        (§ ass this.priority = priority)
    )

    #_public
    (§ constructor ContextPropagatingThreadFactory(String name))
    (ß
        (§ this (name, Thread.NORM_PRIORITY))
    )

    #_override
    #_public
    (§ method Thread newThread(#_final Runnable r))
    (ß
        #_final
        (§ var Context context = Context.get())
        (§ var Thread thread = new Thread(new Runnable()
        (ß
            #_override
            #_public
            (§ method void run())
            (ß
                (§ try)
                (ß
                    (§ call Context.propagate(context))
                    (§ call r.run())
                )
                (§ catch (Exception e))
                (ß
                    (§ call log.error("Exception in thread", e))
                    (§ call Throwables.propagate(e))
                )
            )
        ), name))
        (§ call thread.setPriority(priority))
        (§ call thread.setDaemon(true))
        (§ var Thread.UncaughtExceptionHandler handler = Threading.uncaughtExceptionHandler)
        (§ if (handler != nil))
            (§ call thread.setUncaughtExceptionHandler(handler))
        (§ return thread)
    )
)

#_(ns org.bitcoinj.utils #_"DaemonThreadFactory"
    (:import [java.util.concurrent Executors ThreadFactory]))

;;; Thread factory whose threads are marked as daemon and won't prevent process exit. ;;
#_public
(§ class DaemonThreadFactory implements ThreadFactory
    #_nilable
    #_private
    #_final
    (§ field String name)

    #_public
    (§ constructor DaemonThreadFactory(#_nilable String name))
    (ß
        (§ ass this.name = name)
    )

    #_public
    (§ constructor DaemonThreadFactory())
    (ß
        (§ this (nil))
    )

    #_override
    #_public
    (§ method Thread newThread(#_non-nil Runnable runnable))
    (ß
        (§ var Thread thread = Executors.defaultThreadFactory().newThread(runnable))
        (§ call thread.setDaemon(true))
        (§ if (name != nil))
            (§ call thread.setName(name))
        (§ return thread)
    )
)

#_(ns org.bitcoinj.utils #_"ExchangeRate"
    (:import [java.io Serializable]
             [java.math BigInteger])
    (:import [com.google.common.base Objects Preconditions])
  #_(:require [org.bitcoinj.core Coin]))

;;;
 ; An exchange rate is expressed as a ratio of a {@link Coin} and a {@link Fiat} amount.
 ;;
#_public
(§ class ExchangeRate implements Serializable
    #_public
    #_final
    (§ field Coin coin)
    #_public
    #_final
    (§ field Fiat fiat)

    ;;; Construct exchange rate.  This amount of coin is worth that amount of fiat. ;;
    #_public
    (§ constructor ExchangeRate(Coin coin, Fiat fiat))
    (ß
        (§ call Preconditions.checkArgument(coin.isPositive()))
        (§ call Preconditions.checkArgument(fiat.isPositive()))
        (§ call Preconditions.checkArgument(fiat.currencyCode != nil, "currency code required"))

        (§ ass this.coin = coin)
        (§ ass this.fiat = fiat)
    )

    ;;; Construct exchange rate.  One coin is worth this amount of fiat. ;;
    #_public
    (§ constructor ExchangeRate(Fiat fiat))
    (ß
        (§ this (Coin.COIN, fiat))
    )

    ;;;
     ; Convert a coin amount to a fiat amount using this exchange rate.
     ; @throws ArithmeticException if the converted fiat amount is too high or too low.
     ;;
    #_public
    (§ method Fiat coinToFiat(Coin convertCoin))
    (ß
        ;; Use BigInteger because it's much easier to maintain full precision without overflowing.
        #_final
        (§ var BigInteger converted = BigInteger.valueOf(convertCoin.value).multiply(BigInteger.valueOf(fiat.value)).divide(BigInteger.valueOf(coin.value)))

        (§ if (0 < converted.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) || converted.compareTo(BigInteger.valueOf(Long.MIN_VALUE)) < 0))
            (§ throw new ArithmeticException("Overflow"))

        (§ return Fiat.valueOf(fiat.currencyCode, converted.longValue()))
    )

    ;;;
     ; Convert a fiat amount to a coin amount using this exchange rate.
     ; @throws ArithmeticException if the converted coin amount is too high or too low.
     ;;
    #_public
    (§ method Coin fiatToCoin(Fiat convertFiat))
    (ß
        (§ call Preconditions.checkArgument(convertFiat.currencyCode.equals(fiat.currencyCode), "Currency mismatch: %s vs %s", convertFiat.currencyCode, fiat.currencyCode))

        ;; Use BigInteger because it's much easier to maintain full precision without overflowing.
        #_final
        (§ var BigInteger converted = BigInteger.valueOf(convertFiat.value).multiply(BigInteger.valueOf(coin.value)).divide(BigInteger.valueOf(fiat.value)))

        (§ if (0 < converted.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) || converted.compareTo(BigInteger.valueOf(Long.MIN_VALUE)) < 0))
            (§ throw new ArithmeticException("Overflow"))

        (§ try)
        (ß
            (§ return Coin.valueOf(converted.longValue()))
        )
        (§ catch (IllegalArgumentException e))
        (ß
            (§ throw new ArithmeticException("Overflow: " + e.getMessage()))
        )
    )

    #_override
    #_public
    (§ method boolean equals(Object o))
    (ß
        (§ if (this == o))
            (§ return true)
        (§ if (o == nil || getClass() != o.getClass()))
            (§ return false)
        (§ var ExchangeRate other = (ExchangeRate)o)
        (§ return (Objects.equal(this.coin, other.coin) && Objects.equal(this.fiat, other.fiat)))
    )

    #_override
    #_public
    (§ method int hashCode())
    (ß
        (§ return Objects.hashCode(coin, fiat))
    )
)

#_(ns org.bitcoinj.utils #_"ExponentialBackoff"
    (:import [com.google.common.base Preconditions]
             [com.google.common.primitives Longs])
  #_(:require [org.bitcoinj.core Utils]))

;;;
 ; <p>Tracks successes and failures and calculates a time to retry the operation.</p>
 ;
 ; <p>The retries are exponentially backed off, up to a maximum interval.  On success the back off interval is reset.</p>
 ;;
#_public
(§ class ExponentialBackoff implements Comparable<ExponentialBackoff>
    #_public
    #_static
    #_final
    (§ field int DEFAULT_INITIAL_MILLIS = 100)
    #_public
    #_static
    #_final
    (§ field float DEFAULT_MULTIPLIER = 1.1)
    #_public
    #_static
    #_final
    (§ field int DEFAULT_MAXIMUM_MILLIS = 30 * 1000)

    #_private
    (§ field float backoff)
    #_private
    (§ field long retryTime)
    #_private
    #_final
    (§ field Params params)

    ;;;
     ; Parameters to configure a particular kind of exponential backoff.
     ;;
    #_public
    #_static
    (§ class Params
        #_private
        #_final
        (§ field float initial)
        #_private
        #_final
        (§ field float multiplier)
        #_private
        #_final
        (§ field float maximum)

        ;;;
         ; @param initialMillis The initial interval to wait, in milliseconds.
         ; @param multiplier The multiplier to apply on each failure.
         ; @param maximumMillis The maximum interval to wait, in milliseconds.
         ;;
        #_public
        (§ constructor Params(long initialMillis, float multiplier, long maximumMillis))
        (ß
            (§ call Preconditions.checkArgument(1.0 < multiplier, "multiplier must be greater than 1.0"))
            (§ call Preconditions.checkArgument(initialMillis <= maximumMillis, "maximum must not be less than initial"))

            (§ ass this.initial = initialMillis)
            (§ ass this.multiplier = multiplier)
            (§ ass this.maximum = maximumMillis)
        )

        ;;;
         ; Construct params with default values.
         ;;
        #_public
        (§ constructor Params())
        (ß
            (§ ass initial = DEFAULT_INITIAL_MILLIS)
            (§ ass multiplier = DEFAULT_MULTIPLIER)
            (§ ass maximum = DEFAULT_MAXIMUM_MILLIS)
        )
    )

    #_public
    (§ constructor ExponentialBackoff(Params params))
    (ß
        (§ ass this.params = params)
        (§ call trackSuccess())
    )

    ;;; Track a success - reset back off interval to the initial value. ;;
    #_public
    #_final
    (§ method void trackSuccess())
    (ß
        (§ ass backoff = params.initial)
        (§ ass retryTime = Utils.currentTimeMillis())
    )

    ;;; Track a failure - multiply the back off interval by the multiplier. ;;
    #_public
    (§ method void trackFailure())
    (ß
        (§ ass retryTime = Utils.currentTimeMillis() + (long)backoff)
        (§ ass backoff = Math.min(backoff * params.multiplier, params.maximum))
    )

    ;;; Get the next time to retry, in milliseconds since the epoch. ;;
    #_public
    (§ method long getRetryTime())
    (ß
        (§ return retryTime)
    )

    #_override
    #_public
    (§ method int compareTo(ExponentialBackoff other))
    (ß
        ;; Note that in this implementation compareTo() is not consistent with equals().
        (§ return Longs.compare(retryTime, other.retryTime))
    )

    #_override
    #_public
    (§ method String toString())
    (ß
        (§ return "ExponentialBackoff retry=" + retryTime + " backoff=" + backoff)
    )
)

#_(ns org.bitcoinj.utils #_"Fiat"
    (:import [java.io Serializable]
             [java.math BigDecimal])
    (:import [com.google.common.base Objects Preconditions]
             [com.google.common.math LongMath]
             [com.google.common.primitives Longs])
  #_(:require [org.bitcoinj.core Monetary]))

;;;
 ; Represents a monetary fiat value.  It was decided to not fold this into {@link org.bitcoinj.core.Coin}
 ; because of type safety.  Fiat values always come with an attached currency code.
 ;
 ; This class is immutable.
 ;;
#_public
#_final
(§ class Fiat implements Monetary, Comparable<Fiat>, Serializable
    ;;;
     ; The absolute value of exponent of the value of a "smallest unit" in scientific notation.
     ; We picked 4 rather than 2, because in financial applications it's common to use sub-cent precision.
     ;;
    #_public
    #_static
    #_final
    (§ field int SMALLEST_UNIT_EXPONENT = 4)

    ;;;
     ; The number of smallest units of this monetary value.
     ;;
    #_public
    #_final
    (§ field long value)
    #_public
    #_final
    (§ field String currencyCode)

    #_private
    (§ constructor Fiat(#_final String currencyCode, #_final long value))
    (ß
        (§ ass this.value = value)
        (§ ass this.currencyCode = currencyCode)
    )

    #_public
    #_static
    (§ method Fiat valueOf(#_final String currencyCode, #_final long value))
    (ß
        (§ return new Fiat(currencyCode, value))
    )

    #_override
    #_public
    (§ method int smallestUnitExponent())
    (ß
        (§ return SMALLEST_UNIT_EXPONENT)
    )

    ;;;
     ; Returns the number of "smallest units" of this monetary value.
     ;;
    #_override
    #_public
    (§ method long getValue())
    (ß
        (§ return value)
    )

    #_public
    (§ method String getCurrencyCode())
    (ß
        (§ return currencyCode)
    )

    ;;;
     ; Parses an amount expressed in the way humans are used to.
     ;
     ; This takes string in a format understood by {@link BigDecimal#BigDecimal(String)},
     ; for example "0", "1", "0.10", "1.23E3", "1234.5E-5".
     ;
     ; @throws IllegalArgumentException if you try to specify more than 4 digits after the comma, or a value out of range.
     ;;
    #_public
    #_static
    (§ method Fiat parseFiat(#_final String currencyCode, #_final String str))
    (ß
        (§ try)
        (ß
            (§ var long val = new BigDecimal(str).movePointRight(SMALLEST_UNIT_EXPONENT).longValueExact())
            (§ return Fiat.valueOf(currencyCode, val))
        )
        (§ catch (ArithmeticException e))
        (ß
            (§ throw new IllegalArgumentException(e))
        )
    )

    ;;;
     ; Parses an amount expressed in the way humans are used to.  The amount is cut to 4 digits after the comma.
     ;
     ; This takes string in a format understood by {@link BigDecimal#BigDecimal(String)},
     ; for example "0", "1", "0.10", "1.23E3", "1234.5E-5".
     ;
     ; @throws IllegalArgumentException if you try to specify a value out of range.
     ;;
    #_public
    #_static
    (§ method Fiat parseFiatInexact(#_final String currencyCode, #_final String str))
    (ß
        (§ try)
        (ß
            (§ var long val = new BigDecimal(str).movePointRight(SMALLEST_UNIT_EXPONENT).longValue())
            (§ return Fiat.valueOf(currencyCode, val))
        )
        (§ catch (ArithmeticException e))
        (ß
            (§ throw new IllegalArgumentException(e))
        )
    )

    #_public
    (§ method Fiat add(#_final Fiat value))
    (ß
        (§ call Preconditions.checkArgument(value.currencyCode.equals(currencyCode)))

        (§ return new Fiat(currencyCode, LongMath.checkedAdd(this.value, value.value)))
    )

    #_public
    (§ method Fiat subtract(#_final Fiat value))
    (ß
        (§ call Preconditions.checkArgument(value.currencyCode.equals(currencyCode)))

        (§ return new Fiat(currencyCode, LongMath.checkedSubtract(this.value, value.value)))
    )

    #_public
    (§ method Fiat multiply(#_final long factor))
    (ß
        (§ return new Fiat(currencyCode, LongMath.checkedMultiply(this.value, factor)))
    )

    #_public
    (§ method Fiat divide(#_final long divisor))
    (ß
        (§ return new Fiat(currencyCode, this.value / divisor))
    )

    #_public
    (§ method Fiat[] divideAndRemainder(#_final long divisor))
    (ß
        (§ return new Fiat[] (ß new Fiat(currencyCode, this.value / divisor), new Fiat(currencyCode, this.value % divisor) ))
    )

    #_public
    (§ method long divide(#_final Fiat divisor))
    (ß
        (§ call Preconditions.checkArgument(divisor.currencyCode.equals(currencyCode)))

        (§ return this.value / divisor.value)
    )

    ;;;
     ; Returns true if and only if this instance represents a monetary value greater than zero, otherwise false.
     ;;
    #_public
    (§ method boolean isPositive())
    (ß
        (§ return (signum() == 1))
    )

    ;;;
     ; Returns true if and only if this instance represents a monetary value less than zero, otherwise false.
     ;;
    #_public
    (§ method boolean isNegative())
    (ß
        (§ return (signum() == -1))
    )

    ;;;
     ; Returns true if and only if this instance represents zero monetary value, otherwise false.
     ;;
    #_public
    (§ method boolean isZero())
    (ß
        (§ return (signum() == 0))
    )

    ;;;
     ; Returns true if the monetary value represented by this instance is greater than that of the given other Fiat,
     ; otherwise false.
     ;;
    #_public
    (§ method boolean isGreaterThan(Fiat other))
    (ß
        (§ return (compareTo(other) > 0))
    )

    ;;;
     ; Returns true if the monetary value represented by this instance is less than that of the given other Fiat,
     ; otherwise false.
     ;;
    #_public
    (§ method boolean isLessThan(Fiat other))
    (ß
        (§ return (compareTo(other) < 0))
    )

    #_override
    #_public
    (§ method int signum())
    (ß
        (§ return (this.value == 0) ? 0 :else (this.value < 0) ? -1 :else 1)
    )

    #_public
    (§ method Fiat negate())
    (ß
        (§ return new Fiat(currencyCode, -this.value))
    )

    ;;;
     ; Returns the number of "smallest units" of this monetary value.
     ; It's deprecated in favour of accessing {@link #value} directly.
     ;;
    #_public
    (§ method long longValue())
    (ß
        (§ return this.value)
    )

    #_private
    #_static
    #_final
    (§ field MonetaryFormat FRIENDLY_FORMAT = MonetaryFormat.FIAT.postfixCode())

    ;;;
     ; Returns the value as a 0.12 type string.
     ; More digits after the decimal place will be used if necessary, but two will always be present.
     ;;
    #_public
    (§ method String toFriendlyString())
    (ß
        (§ return FRIENDLY_FORMAT.code(0, currencyCode).format(this).toString())
    )

    #_private
    #_static
    #_final
    (§ field MonetaryFormat PLAIN_FORMAT = MonetaryFormat.FIAT.minDecimals(0).repeatOptionalDecimals(1, 4).noCode())

    ;;;
     ; Returns the value as a plain string.  The result is unformatted with no trailing zeroes.
     ; For instance, a value of 150000 "smallest units" gives an output string of "0.0015".
     ;;
    #_public
    (§ method String toPlainString())
    (ß
        (§ return PLAIN_FORMAT.format(this).toString())
    )

    #_override
    #_public
    (§ method String toString())
    (ß
        (§ return Long.toString(value))
    )

    #_override
    #_public
    (§ method boolean equals(#_final Object o))
    (ß
        (§ if (o == this))
            (§ return true)
        (§ if (o == nil || o.getClass() != getClass()))
            (§ return false)
        #_final
        (§ var Fiat other = (Fiat)o)
        (§ return (this.value == other.value && this.currencyCode.equals(other.currencyCode)))
    )

    #_override
    #_public
    (§ method int hashCode())
    (ß
        (§ return Objects.hashCode(value, currencyCode))
    )

    #_override
    #_public
    (§ method int compareTo(#_final Fiat other))
    (ß
        (§ return this.currencyCode.equals(other.currencyCode) ? Longs.compare(this.value, other.value) :else this.currencyCode.compareTo(other.currencyCode))
    )
)

#_(ns org.bitcoinj.utils #_"ListenerRegistration"
    (:import [java.util List]
             [java.util.concurrent Executor])
    (:import [com.google.common.base Preconditions]))

;;;
 ; A simple wrapper around a listener and an executor, with some utility methods.
 ;;
#_public
(§ class ListenerRegistration<T>
    #_public
    #_final
    (§ field T listener)
    #_public
    #_final
    (§ field Executor executor)

    #_public
    (§ constructor ListenerRegistration(T listener, Executor executor))
    (ß
        (§ ass this.listener = Preconditions.checkNotNull(listener))
        (§ ass this.executor = Preconditions.checkNotNull(executor))
    )

    ;;; Returns true if the listener was removed, else false. ;;
    #_public
    #_static
    (§ method <T> boolean removeFromList(T listener, List<? extends ListenerRegistration<T>> list))
    (ß
        (§ call Preconditions.checkNotNull(listener))

        (§ var ListenerRegistration<T> item = nil)
        (§ for (ListenerRegistration<T> registration :for list))
        (ß
            (§ if (registration.listener == listener))
            (ß
                (§ ass item = registration)
                (§ break)
            )
        )
        (§ return (item != nil && list.remove(item)))
    )
)

#_(ns org.bitcoinj.utils #_"MonetaryFormat"
    (:import [java.math RoundingMode]
             [java.text DecimalFormatSymbols]
             [java.util ArrayList Arrays List Locale])
    (:import [com.google.common.base Preconditions]
             #_static #_[com.google.common.math.LongMath checkedMultiply]
             #_static #_[com.google.common.math.LongMath checkedPow]
             #_static #_[com.google.common.math.LongMath divide])
  #_(:require [org.bitcoinj.core Coin Monetary]))

;;;
 ; Utility for formatting and parsing coin values to and from human readable form.
 ;
 ; MonetaryFormat instances are immutable.  Invoking a configuration method has no effect on the receiving instance;
 ; you must store and use the new instance it returns, instead.  Instances are thread safe, so they may be stored safely
 ; as static constants.
 ;;
#_public
#_final
(§ class MonetaryFormat
    ;;; Standard format for the BTC denomination. ;;
    #_public
    #_static
    #_final
    (§ field MonetaryFormat BTC = new MonetaryFormat().shift(0).minDecimals(2).repeatOptionalDecimals(2, 3))
    ;;; Standard format for the mBTC denomination. ;;
    #_public
    #_static
    #_final
    (§ field MonetaryFormat MBTC = new MonetaryFormat().shift(3).minDecimals(2).optionalDecimals(2))
    ;;; Standard format for the µBTC denomination. ;;
    #_public
    #_static
    #_final
    (§ field MonetaryFormat UBTC = new MonetaryFormat().shift(6).minDecimals(0).optionalDecimals(2))
    ;;; Standard format for fiat amounts. ;;
    #_public
    #_static
    #_final
    (§ field MonetaryFormat FIAT = new MonetaryFormat().shift(0).minDecimals(2).repeatOptionalDecimals(2, 1))
    ;;; Currency code for base 1 Bitcoin. ;;
    #_public
    #_static
    #_final
    (§ field String CODE_BTC = "BTC")
    ;;; Currency code for base 1/1000 Bitcoin. ;;
    #_public
    #_static
    #_final
    (§ field String CODE_MBTC = "mBTC")
    ;;; Currency code for base 1/1000000 Bitcoin. ;;
    #_public
    #_static
    #_final
    (§ field String CODE_UBTC = "µBTC")

    #_public
    #_static
    #_final
    (§ field int MAX_DECIMALS = 8)

    #_private
    #_final
    (§ field char negativeSign)
    #_private
    #_final
    (§ field char positiveSign)
    #_private
    #_final
    (§ field char zeroDigit)
    #_private
    #_final
    (§ field char decimalMark)
    #_private
    #_final
    (§ field int minDecimals)
    #_private
    #_final
    (§ field List<Integer> decimalGroups)
    #_private
    #_final
    (§ field int shift)
    #_private
    #_final
    (§ field RoundingMode roundingMode)
    #_private
    #_final
    (§ field String[] codes)
    #_private
    #_final
    (§ field char codeSeparator)
    #_private
    #_final
    (§ field boolean codePrefixed)

    #_private
    #_static
    #_final
    (§ field String DECIMALS_PADDING = "0000000000000000") ;; a few more than necessary for Bitcoin

    ;;;
     ; Set character to prefix negative values.
     ;;
    #_public
    (§ method MonetaryFormat negativeSign(char negativeSign))
    (ß
        (§ call Preconditions.checkArgument(!Character.isDigit(negativeSign)))
        (§ call Preconditions.checkArgument(0 < negativeSign))

        (§ return (negativeSign == this.negativeSign) ? this :else new MonetaryFormat(negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, codePrefixed))
    )

    ;;;
     ; Set character to prefix positive values.  A zero value means no sign is used in this case.
     ; For parsing, a missing sign will always be interpreted as if the positive sign was used.
     ;;
    #_public
    (§ method MonetaryFormat positiveSign(char positiveSign))
    (ß
        (§ call Preconditions.checkArgument(!Character.isDigit(positiveSign)))

        (§ return (positiveSign == this.positiveSign) ? this :else new MonetaryFormat(negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, codePrefixed))
    )

    ;;;
     ; Set character range to use for representing digits.  It starts with the specified character representing zero.
     ;;
    #_public
    (§ method MonetaryFormat digits(char zeroDigit))
    (ß
        (§ return (zeroDigit == this.zeroDigit) ? this :else new MonetaryFormat(negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, codePrefixed))
    )

    ;;;
     ; Set character to use as the decimal mark.  If the formatted value does not have any decimals,
     ; no decimal mark is used either.
     ;;
    #_public
    (§ method MonetaryFormat decimalMark(char decimalMark))
    (ß
        (§ call Preconditions.checkArgument(!Character.isDigit(decimalMark)))
        (§ call Preconditions.checkArgument(0 < decimalMark))

        (§ return (decimalMark == this.decimalMark) ? this :else new MonetaryFormat(negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, codePrefixed))
    )

    ;;;
     ; Set minimum number of decimals to use for formatting.  If the value precision exceeds all decimals specified
     ; (including additional decimals specified by {@link #optionalDecimals(int...)} or {@link #repeatOptionalDecimals(int, int)}),
     ; the value will be rounded.  This configuration is not relevant for parsing.
     ;;
    #_public
    (§ method MonetaryFormat minDecimals(int minDecimals))
    (ß
        (§ return (minDecimals == this.minDecimals) ? this :else new MonetaryFormat(negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, codePrefixed))
    )

    ;;;
     ; Set additional groups of decimals to use after the minimum decimals, if they are useful for expressing precision.
     ; Each value is a number of decimals in that group.  If the value precision exceeds all decimals specified
     ; (including minimum decimals), the value will be rounded.  This configuration is not relevant for parsing.
     ;
     ; For example, if you pass <tt>4,2</tt> it will add four decimals to your formatted string if needed, and then add
     ; another two decimals if needed.  At this point, rather than adding further decimals the value will be rounded.
     ;
     ; @param groups Any number numbers of decimals, one for each group.
     ;;
    #_public
    (§ method MonetaryFormat optionalDecimals(int... groups))
    (ß
        (§ var List<Integer> decimalGroups = new ArrayList<>(groups.length))
        (§ for (int group :for groups))
            (§ call decimalGroups.add(group))
        (§ return new MonetaryFormat(negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, codePrefixed))
    )

    ;;;
     ; Set repeated additional groups of decimals to use after the minimum decimals, if they are useful for expressing
     ; precision.  If the value precision exceeds all decimals specified (including minimum decimals), the value will be
     ; rounded.  This configuration is not relevant for parsing.
     ;
     ; For example, if you pass <tt>1,8</tt> it will up to eight decimals to your formatted string if needed.
     ; After these have been used up, rather than adding further decimals the value will be rounded.
     ;
     ; @param decimals Value of the group to be repeated.
     ; @param repetitions Number of repetitions.
     ;;
    #_public
    (§ method MonetaryFormat repeatOptionalDecimals(int decimals, int repetitions))
    (ß
        (§ call Preconditions.checkArgument(0 <= repetitions))

        (§ var List<Integer> decimalGroups = new ArrayList<>(repetitions))
        (§ for (int i = 0 :for i < repetitions :for i = i + 1))
            (§ call decimalGroups.add(decimals))
        (§ return new MonetaryFormat(negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, codePrefixed))
    )

    ;;;
     ; Set number of digits to shift the decimal separator to the right, coming from the standard BTC notation that was
     ; common pre-2014.  Note this will change the currency code if enabled.
     ;;
    #_public
    (§ method MonetaryFormat shift(int shift))
    (ß
        (§ return (shift == this.shift) ? this :else new MonetaryFormat(negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, codePrefixed))
    )

    ;;;
     ; Set rounding mode to use when it becomes necessary.
     ;;
    #_public
    (§ method MonetaryFormat roundingMode(RoundingMode roundingMode))
    (ß
        (§ return (roundingMode == this.roundingMode) ? this :else new MonetaryFormat(negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, codePrefixed))
    )

    ;;;
     ; Don't display currency code when formatting.  This configuration is not relevant for parsing.
     ;;
    #_public
    (§ method MonetaryFormat noCode())
    (ß
        (§ return (codes == nil) ? this :else new MonetaryFormat(negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, nil, codeSeparator, codePrefixed))
    )

    ;;;
     ; Configure currency code for given decimal separator shift.  This configuration is not relevant for parsing.
     ;
     ; @param codeShift Decimal separator shift, see {@link #shift}.
     ; @param code Currency code.
     ;;
    #_public
    (§ method MonetaryFormat code(int codeShift, String code))
    (ß
        (§ call Preconditions.checkArgument(0 <= codeShift))

        #_final
        (§ var String[] codes = (this.codes != nil) ? Arrays.copyOf(this.codes, this.codes.length) :else new String[MAX_DECIMALS])

        (§ ass codes[codeShift] = code)
        (§ return new MonetaryFormat(negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, codePrefixed))
    )

    ;;;
     ; Separator between currency code and formatted value.  This configuration is not relevant for parsing.
     ;;
    #_public
    (§ method MonetaryFormat codeSeparator(char codeSeparator))
    (ß
        (§ call Preconditions.checkArgument(!Character.isDigit(codeSeparator)))
        (§ call Preconditions.checkArgument(0 < codeSeparator))

        (§ return (codeSeparator == this.codeSeparator) ? this :else new MonetaryFormat(negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, codePrefixed))
    )

    ;;;
     ; Prefix formatted output by currency code.  This configuration is not relevant for parsing.
     ;;
    #_public
    (§ method MonetaryFormat prefixCode())
    (ß
        (§ return codePrefixed ? this :else new MonetaryFormat(negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, true))
    )

    ;;;
     ; Postfix formatted output with currency code.  This configuration is not relevant for parsing.
     ;;
    #_public
    (§ method MonetaryFormat postfixCode())
    (ß
        (§ return !codePrefixed ? this :else new MonetaryFormat(negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, false))
    )

    ;;;
     ; Configure this instance with values from a {@link Locale}.
     ;;
    #_public
    (§ method MonetaryFormat withLocale(Locale locale))
    (ß
        (§ var DecimalFormatSymbols dfs = new DecimalFormatSymbols(locale))
        (§ var char negativeSign = dfs.getMinusSign())
        (§ var char zeroDigit = dfs.getZeroDigit())
        (§ var char decimalMark = dfs.getMonetaryDecimalSeparator())
        (§ return new MonetaryFormat(negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, codePrefixed))
    )

    #_public
    (§ constructor MonetaryFormat())
    (ß
        ;; defaults
        (§ ass this.negativeSign = \-)
        (§ ass this.positiveSign = 0) ;; none
        (§ ass this.zeroDigit = \0)
        (§ ass this.decimalMark = \.)
        (§ ass this.minDecimals = 2)
        (§ ass this.decimalGroups = nil)
        (§ ass this.shift = 0)
        (§ ass this.roundingMode = RoundingMode.HALF_UP)
        (§ ass this.codes = new String[MAX_DECIMALS])
        (§ ass this.codes[0] = CODE_BTC)
        (§ ass this.codes[3] = CODE_MBTC)
        (§ ass this.codes[6] = CODE_UBTC)
        (§ ass this.codeSeparator = \space)
        (§ ass this.codePrefixed = true)
    )

    #_private
    (§ constructor MonetaryFormat(char negativeSign, char positiveSign, char zeroDigit, char decimalMark, int minDecimals, List<Integer> decimalGroups, int shift, RoundingMode roundingMode, String[] codes, char codeSeparator, boolean codePrefixed))
    (ß
        (§ ass this.negativeSign = negativeSign)
        (§ ass this.positiveSign = positiveSign)
        (§ ass this.zeroDigit = zeroDigit)
        (§ ass this.decimalMark = decimalMark)
        (§ ass this.minDecimals = minDecimals)
        (§ ass this.decimalGroups = decimalGroups)
        (§ ass this.shift = shift)
        (§ ass this.roundingMode = roundingMode)
        (§ ass this.codes = codes)
        (§ ass this.codeSeparator = codeSeparator)
        (§ ass this.codePrefixed = codePrefixed)
    )

    ;;;
     ; Format the given monetary value to a human readable form.
     ;;
    #_public
    (§ method CharSequence format(Monetary monetary))
    (ß
        ;; preparation
        (§ var int maxDecimals = minDecimals)
        (§ if (decimalGroups != nil))
            (§ for (int group :for decimalGroups))
                (§ ass maxDecimals = maxDecimals + group)
        (§ var int smallestUnitExponent = monetary.smallestUnitExponent())
        (§ call Preconditions.checkState(maxDecimals <= smallestUnitExponent, "The maximum possible number of decimals (%s) cannot exceed %s.", maxDecimals, smallestUnitExponent))

        ;; rounding
        (§ var long satoshis = Math.abs(monetary.getValue()))
        (§ var long precisionDivisor = checkedPow(10, smallestUnitExponent - shift - maxDecimals))
        (§ ass satoshis = checkedMultiply(divide(satoshis, precisionDivisor, roundingMode), precisionDivisor))

        ;; shifting
        (§ var long shiftDivisor = checkedPow(10, smallestUnitExponent - shift))
        (§ var long numbers = satoshis / shiftDivisor)
        (§ var long decimals = satoshis % shiftDivisor)

        ;; formatting
        (§ var String decimalsStr = String.format(Locale.US, "%0" + (smallestUnitExponent - shift) + "d", decimals))
        (§ var StringBuilder sb = new StringBuilder(decimalsStr))
        (§ while (minDecimals < sb.length() && sb.charAt(sb.length() - 1) == \0))
            (§ call sb.setLength(sb.length() - 1)) ;; trim trailing zero
        (§ var int i = minDecimals)
        (§ if (decimalGroups != nil))
        (ß
            (§ for (int group :for decimalGroups))
            (ß
                (§ if (i < sb.length() && sb.length() < i + group))
                (ß
                    (§ while (sb.length() < i + group))
                        (§ call sb.append("0"))
                    (§ break)
                )
                (§ ass i = i + group)
            )
        )
        (§ if (0 < sb.length()))
            (§ call sb.insert(0, decimalMark))
        (§ call sb.insert(0, numbers))
        (§ if (monetary.getValue() < 0))
            (§ call sb.insert(0, negativeSign))
        (§ elseif (positiveSign != 0))
            (§ call sb.insert(0, positiveSign))
        (§ if (codes != nil))
        (ß
            (§ if (codePrefixed))
            (ß
                (§ call sb.insert(0, codeSeparator))
                (§ call sb.insert(0, code()))
            )
            (§ else)
            (ß
                (§ call sb.append(codeSeparator))
                (§ call sb.append(code()))
            )
        )

        ;; Convert to non-arabic digits.
        (§ if (zeroDigit != \0))
        (ß
            (§ var int offset = zeroDigit - \0)
            (§ for (int d = 0 :for d < sb.length() :for d = d + 1))
            (ß
                (§ var char c = sb.charAt(d))
                (§ if (Character.isDigit(c)))
                    (§ call sb.setCharAt(d, (char)(c + offset)))
            )
        )
        (§ return sb)
    )

    ;;;
     ; Parse a human readable coin value to a {@link org.bitcoinj.core.Coin} instance.
     ;
     ; @throws NumberFormatException if the string cannot be parsed for some reason.
     ;;
    #_public
    (§ method Coin parse(String str))
        (§ throws NumberFormatException)
    (ß
        (§ return Coin.valueOf(parseValue(str, Coin.SMALLEST_UNIT_EXPONENT)))
    )

    ;;;
     ; Parse a human readable fiat value to a {@link org.bitcoinj.utils.Fiat} instance.
     ;
     ; @throws NumberFormatException if the string cannot be parsed for some reason.
     ;;
    #_public
    (§ method Fiat parseFiat(String currencyCode, String str))
        (§ throws NumberFormatException)
    (ß
        (§ return Fiat.valueOf(currencyCode, parseValue(str, Fiat.SMALLEST_UNIT_EXPONENT)))
    )

    #_private
    (§ method long parseValue(String str, int smallestUnitExponent))
    (ß
        (§ call Preconditions.checkState(smallestUnitExponent <= DECIMALS_PADDING.length()))

        (§ if (str.isEmpty()))
            (§ throw new NumberFormatException("empty string"))

        (§ var char first = str.charAt(0))
        (§ if (first == negativeSign || first == positiveSign))
            (§ ass str = str.substring(1))
        (§ var String numbers)
        (§ var String decimals)
        (§ var int decimalMarkIndex = str.indexOf(decimalMark))
        (§ if (decimalMarkIndex != -1))
        (ß
            (§ ass numbers = str.substring(0, decimalMarkIndex))
            (§ ass decimals = (str + DECIMALS_PADDING).substring(decimalMarkIndex + 1))
            (§ if (decimals.indexOf(decimalMark) != -1))
                (§ throw new NumberFormatException("more than one decimal mark"))
        )
        (§ else)
        (ß
            (§ ass numbers = str)
            (§ ass decimals = DECIMALS_PADDING)
        )

        (§ var String satoshis = numbers + decimals.substring(0, smallestUnitExponent - shift))
        (§ for (char c :for satoshis.toCharArray()))
            (§ if (!Character.isDigit(c)))
                (§ throw new NumberFormatException("illegal character: " + c))

        ;; Non-arabic digits allowed here.
        (§ var long value = Long.parseLong(satoshis))
        (§ if (first == negativeSign))
            (§ ass value = -value)
        (§ return value)
    )

    ;;;
     ; Get currency code that will be used for current shift.
     ;;
    #_public
    (§ method String code())
    (ß
        (§ if (codes == nil))
            (§ return nil)
        (§ if (codes[shift] == nil))
            (§ throw new NumberFormatException("missing code for shift: " + shift))
        (§ return codes[shift])
    )
)

#_(ns org.bitcoinj.utils #_"Threading"
    (:import #_[java.util.concurrent *]
             [java.util.concurrent.locks ReentrantLock])
    (:import [com.google.common.util.concurrent CycleDetectingLockFactory ListeningExecutorService MoreExecutors Uninterruptibles]
             [org.slf4j Logger LoggerFactory])
  #_(:require #_[org.bitcoinj.core *]))

;;;
 ; Various threading related utilities.  Provides a wrapper around explicit lock creation that lets you control whether
 ; bitcoinj performs cycle detection or not.  Cycle detection is useful to detect bugs but comes with a small cost.
 ; Also provides a worker thread that is designed for event listeners to be dispatched on.
 ;;
#_public
(§ class Threading
    ;;;
     ; An executor with one thread that is intended for running event listeners on.  This ensures all event listener
     ; code runs without any locks being held.  It's intended for the API user to run things on.  Callbacks registered
     ; by bitcoinj internally shouldn't normally run here, although currently there are a few exceptions.
     ;;
    #_public
    #_static
    (§ field Executor USER_THREAD)

    ;;;
     ; A dummy executor that just invokes the runnable immediately.  Use this over
     ; {@link com.google.common.util.concurrent.MoreExecutors#sameThreadExecutor()} because the latter creates
     ; a new object each time in order to implement the more complex {@link ExecutorService} interface, which is
     ; overkill for our needs.
     ;;
    #_public
    #_static
    #_final
    (§ field Executor SAME_THREAD)

    ;;;
     ; Put a dummy task into the queue and wait for it to be run.  Because it's single threaded, this means all
     ; tasks submitted before this point are now completed.  Usually you won't want to use this method - it's a
     ; convenience primarily used in unit testing.  If you want to wait for an event to be called the right thing
     ; to do is usually to create a {@link com.google.common.util.concurrent.SettableFuture} and then call set
     ; on it.  You can then either block on that future, compose it, add listeners to it and so on.
     ;;
    #_public
    #_static
    (§ method void waitForUserCode())
    (ß
        #_final
        (§ var CountDownLatch latch = new CountDownLatch(1))
        (§ call USER_THREAD.execute(new Runnable()
        (ß
            #_override
            #_public
            (§ method void run())
            (ß
                (§ call latch.countDown())
            )
        )))
        (§ call Uninterruptibles.awaitUninterruptibly(latch))
    )

    ;;;
     ; An exception handler that will be invoked for any exceptions that occur in the user thread, and any unhandled
     ; exceptions that are caught whilst the framework is processing network traffic or doing other background tasks.
     ; The purpose of this is to allow you to report back unanticipated crashes from your users to a central collection
     ; center for analysis and debugging.  You should configure this <b>before</b> any bitcoinj library code is run,
     ; setting it after you started network traffic and other forms of processing may result in the change not taking effect.
     ;;
    #_nilable
    #_public
    #_static
    #_volatile
    (§ field Thread.UncaughtExceptionHandler uncaughtExceptionHandler)

    #_public
    #_static
    (§ class UserThread extends Thread implements Executor
        #_private
        #_static
        #_final
        (§ field Logger log = LoggerFactory.getLogger(UserThread.class))

        ;; 10,000 pending tasks is entirely arbitrary and may or may not be appropriate for the device we're running on.
        #_public
        #_static
        (§ field int WARNING_THRESHOLD = 10000)

        #_private
        (§ field LinkedBlockingQueue<Runnable> tasks)

        #_public
        (§ constructor UserThread())
        (ß
            (§ super ("bitcoinj user thread"))

            (§ call setDaemon(true))
            (§ ass tasks = new LinkedBlockingQueue<>())
            (§ call start())
        )

        #_suppress(ß "InfiniteLoopStatement")
        #_override
        #_public
        (§ method void run())
        (ß
            (§ while (true))
            (ß
                (§ var Runnable task = Uninterruptibles.takeUninterruptibly(tasks))
                (§ try)
                (ß
                    (§ call task.run())
                )
                (§ catch (Throwable t))
                (ß
                    (§ call log.warn("Exception in user thread", t))
                    (§ var Thread.UncaughtExceptionHandler handler = uncaughtExceptionHandler)
                    (§ if (handler != nil))
                        (§ call handler.uncaughtException(this, t))
                )
            )
        )

        #_override
        #_public
        (§ method void execute(Runnable command))
        (ß
            #_final
            (§ var int size = tasks.size())
            (§ if (size == WARNING_THRESHOLD))
            (ß
                (§ call log.warn("User thread has {} pending tasks, memory exhaustion may occur.\n" + "If you see this message, check your memory consumption and see if it's problematic or excessively spikey.\n" + "If it is, check for deadlocked or slow event handlers. If it isn't, try adjusting the constant \n" + "Threading.UserThread.WARNING_THRESHOLD upwards until it's a suitable level for your app, or Integer.MAX_VALUE to disable." , size))
            )
            (§ call Uninterruptibles.putUninterruptibly(tasks, command))
        )
    )

    #_static
    (ß
        ;; Default policy goes here.  If you want to change this, use one of the static methods before instantiating
        ;; any bitcoinj objects.  The policy change will take effect only on new objects from that point onwards.
        (§ call throwOnLockCycles())

        (§ ass USER_THREAD = new UserThread())
        (§ ass SAME_THREAD = new Executor()
        (ß
            #_override
            #_public
            (§ method void execute(#_non-nil Runnable runnable))
            (ß
                (§ call runnable.run())
            )
        ))
    )

    #_private
    #_static
    (§ field CycleDetectingLockFactory.Policy policy)
    #_public
    #_static
    (§ field CycleDetectingLockFactory factory)

    #_public
    #_static
    (§ method ReentrantLock lock(String name))
    (ß
        (§ return Utils.isAndroidRuntime() ? new ReentrantLock(true) :else factory.newReentrantLock(name))
    )

    #_public
    #_static
    (§ method void warnOnLockCycles())
    (ß
        (§ call setPolicy(CycleDetectingLockFactory.Policies.WARN))
    )

    #_public
    #_static
    (§ method void throwOnLockCycles())
    (ß
        (§ call setPolicy(CycleDetectingLockFactory.Policies.THROW))
    )

    #_public
    #_static
    (§ method void ignoreLockCycles())
    (ß
        (§ call setPolicy(CycleDetectingLockFactory.Policies.DISABLED))
    )

    #_public
    #_static
    (§ method void setPolicy(CycleDetectingLockFactory.Policy policy))
    (ß
        (§ ass Threading.policy = policy)
        (§ ass factory = CycleDetectingLockFactory.newInstance(policy))
    )

    #_public
    #_static
    (§ method CycleDetectingLockFactory.Policy getPolicy())
    (ß
        (§ return policy)
    )

    ;;; A caching thread pool that creates daemon threads, which won't keep the JVM alive waiting for more work. ;;
    #_public
    #_static
    (§ field ListeningExecutorService THREAD_POOL = MoreExecutors.listeningDecorator(Executors.newCachedThreadPool(new ThreadFactory()
        (ß
            #_override
            #_public
            (§ method Thread newThread(Runnable r))
            (ß
                (§ var Thread t = new Thread(r))
                (§ call t.setName("Threading.THREAD_POOL worker"))
                (§ call t.setDaemon(true))
                (§ return t)
            )
        ))))
)

#_(ns org.bitcoinj.utils #_"VersionTally"
    (:import [java.util Stack])
  #_(:require [org.bitcoinj.core NetworkParameters StoredBlock]
             [org.bitcoinj.store BlockStore BlockStoreException]))

;;;
 ; Caching counter for the block versions within a moving window.  This class is NOT thread safe
 ; (as if two threads are trying to use it concurrently, there's risk of getting versions out of sequence).
 ;
 ; @see org.bitcoinj.core.NetworkParameters#getMajorityWindow()
 ; @see org.bitcoinj.core.NetworkParameters#getMajorityEnforceBlockUpgrade()
 ; @see org.bitcoinj.core.NetworkParameters#getMajorityRejectBlockOutdated()
 ;;
#_public
(§ class VersionTally
    ;;;
     ; Cache of version numbers.
     ;;
    #_private
    #_final
    (§ field long[] versionWindow)

    ;;;
     ; Offset within the version window at which the next version will be written.
     ;;
    #_private
    (§ field int versionWriteHead = 0)

    ;;;
     ; Number of versions written into the tally.  Until this matches the length
     ; of the version window, we do not have sufficient data to return values.
     ;;
    #_private
    (§ field int versionsStored = 0)

    #_public
    (§ constructor VersionTally(#_final NetworkParameters params))
    (ß
        (§ ass versionWindow = new long[params.getMajorityWindow()])
    )

    ;;;
     ; Add a new block version to the tally, and return the count for that version within the window.
     ;
     ; @param version The block version to add.
     ;;
    #_public
    (§ method void add(#_final long version))
    (ß
        (§ ass versionWindow[versionWriteHead] = version)
        (§ ass versionWriteHead = versionWriteHead + 1)
        (§ if (versionWriteHead == versionWindow.length))
            (§ ass versionWriteHead = 0)
        (§ ass versionsStored = versionsStored + 1)
    )

    ;;;
     ; Get the count of blocks at or above the given version, within the window.
     ;
     ; @param version The block version to query.
     ; @return the count for the block version, or null if the window is not yet full.
     ;;
    #_public
    (§ method Integer getCountAtOrAbove(#_final long version))
    (ß
        (§ if (versionsStored < versionWindow.length))
            (§ return nil)

        (§ var int count = 0)
        (§ for (int versionIdx = 0 :for versionIdx < versionWindow.length :for versionIdx = versionIdx + 1))
            (§ if (version <= versionWindow[versionIdx]))
                (§ ass count = count + 1)

        (§ return count)
    )

    ;;;
     ; Initialize the version tally from the block store.  Note this does not search backwards past
     ; the start of the block store, so if starting from a checkpoint this may not fill the window.
     ;
     ; @param blockStore Block store to load blocks from.
     ; @param chainHead Current chain tip.
     ;;
    #_public
    (§ method void initialize(#_final BlockStore blockStore, #_final StoredBlock chainHead))
        (§ throws BlockStoreException)
    (ß
        (§ var StoredBlock versionBlock = chainHead)
        #_final
        (§ var Stack<Long> versions = new Stack<>())

        ;; We don't know how many blocks back we can go, so load what we can first.
        (§ call versions.push(versionBlock.getHeader().getVersion()))
        (§ for (int headOffset = 0 :for headOffset < versionWindow.length :for headOffset = headOffset + 1))
        (ß
            (§ ass versionBlock = versionBlock.getPrev(blockStore))
            (§ if (versionBlock == nil))
                (§ break)
            (§ call versions.push(versionBlock.getHeader().getVersion()))
        )

        ;; Replay the versions into the tally.
        (§ while (!versions.isEmpty()))
            (§ call add(versions.pop()))
    )

    ;;;
     ; Get the size of the version window.
     ;;
    #_public
    (§ method int size())
    (ß
        (§ return versionWindow.length)
    )
)

#_(ns org.bitcoinj.wallet #_"AllRandomKeysRotating")

;;;
 ; Indicates that an attempt was made to upgrade a random wallet to deterministic, but there were no non-rotating
 ; random keys to use as source material for the seed.  Add a non-compromised key first!
 ;;
#_public
(§ class AllRandomKeysRotating extends RuntimeException)

#_(ns org.bitcoinj.wallet #_"AllowUnconfirmedCoinSelector"
  #_(:require [org.bitcoinj.core Transaction]))

;;;
 ; This coin selector will select any transaction at all, regardless of where it came from or whether it was
 ; confirmed yet.  However immature coinbases will not be included (would be a protocol violation).
 ;;
#_public
(§ class AllowUnconfirmedCoinSelector extends DefaultCoinSelector
    #_override
    #_protected
    (§ method boolean shouldSelect(Transaction tx))
    (ß
        (§ return true)
    )

    #_private
    #_static
    (§ field AllowUnconfirmedCoinSelector instance)

    ;;; Returns a global static instance of the selector. ;;
    #_public
    #_static
    (§ method AllowUnconfirmedCoinSelector get())
    (ß
        ;; This doesn't have to be thread safe as the object has no state, so discarded duplicates are harmless.
        (§ if (instance == nil))
            (§ ass instance = new AllowUnconfirmedCoinSelector())
        (§ return instance)
    )
)

#_(ns org.bitcoinj.wallet #_"BasicKeyChain"
    (:import #_[java.util *]
             [java.util.concurrent CopyOnWriteArrayList Executor]
             [java.util.concurrent.locks ReentrantLock])
    (:import [com.google.common.base Preconditions]
             [com.google.common.collect ImmutableList Lists]
             [com.google.protobuf ByteString]
             [org.spongycastle.crypto.params KeyParameter])
  #_(:require [org.bitcoinj.core BloomFilter ECKey]
             #_[org.bitcoinj.crypto *]
             [org.bitcoinj.utils ListenerRegistration Threading]
             [org.bitcoinj.wallet.listeners KeyChainEventListener]))

;;;
 ; A {@link KeyChain} that implements the simplest model possible: it can have keys imported into it, and just
 ; acts as a dumb bag of keys.  It will, left to its own devices, always return the same key for usage by the wallet,
 ; although it will automatically add one to itself if it's empty or if encryption is requested.
 ;;
#_public
(§ class BasicKeyChain implements EncryptableKeyChain
    #_private
    #_final
    (§ field ReentrantLock lock = Threading.lock("BasicKeyChain"))

    ;; Maps used to let us quickly look up a key given data we find in transcations or the block chain.
    #_private
    #_final
    (§ field LinkedHashMap<ByteString, ECKey> hashToKeys)
    #_private
    #_final
    (§ field LinkedHashMap<ByteString, ECKey> pubkeyToKeys)
    #_nilable
    #_private
    #_final
    (§ field KeyCrypter keyCrypter)
    #_private
    (§ field boolean isWatching)

    #_private
    #_final
    (§ field CopyOnWriteArrayList<ListenerRegistration<KeyChainEventListener>> listeners)

    #_public
    (§ constructor BasicKeyChain())
    (ß
        (§ this (nil))
    )

    #_public
    (§ constructor BasicKeyChain(#_nilable KeyCrypter crypter))
    (ß
        (§ ass this.keyCrypter = crypter)
        (§ ass hashToKeys = new LinkedHashMap<>())
        (§ ass pubkeyToKeys = new LinkedHashMap<>())
        (§ ass listeners = new CopyOnWriteArrayList<>())
    )

    ;;; Returns the {@link KeyCrypter} in use or null if the key chain is not encrypted. ;;
    #_override
    #_nilable
    #_public
    (§ method KeyCrypter getKeyCrypter())
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ return keyCrypter)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    #_override
    #_public
    (§ method ECKey getKey(#_nilable KeyPurpose ignored))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ if (hashToKeys.isEmpty()))
            (ß
                ;; We will refuse to encrypt an empty key chain.
                (§ call Preconditions.checkState(keyCrypter == nil))

                #_final
                (§ var ECKey key = new ECKey())
                (§ call importKeyLocked(key))
                (§ call queueOnKeysAdded(ImmutableList.of(key)))
            )
            (§ return hashToKeys.values().iterator().next())
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    #_override
    #_public
    (§ method List<ECKey> getKeys(#_nilable KeyPurpose purpose, int numberOfKeys))
    (ß
        (§ call Preconditions.checkArgument(0 < numberOfKeys))

        (§ call lock.lock())
        (§ try)
        (ß
            (§ if (hashToKeys.size() < numberOfKeys))
            (ß
                (§ call Preconditions.checkState(keyCrypter == nil))

                (§ var List<ECKey> keys = new ArrayList<>())
                (§ for (int i = 0 :for i < numberOfKeys - hashToKeys.size() :for i = i + 1))
                    (§ call keys.add(new ECKey()))

                (§ var ImmutableList<ECKey> immutableKeys = ImmutableList.copyOf(keys))
                (§ call importKeysLocked(immutableKeys))
                (§ call queueOnKeysAdded(immutableKeys))
            )

            (§ var List<ECKey> keysToReturn = new ArrayList<>())
            (§ var int count = 0)
            (§ while (hashToKeys.values().iterator().hasNext() && numberOfKeys != count))
            (ß
                (§ call keysToReturn.add(hashToKeys.values().iterator().next()))
                (§ ass count = count + 1)
            )
            (§ return keysToReturn)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;; Returns a copy of the list of keys that this chain is managing. ;;
    #_public
    (§ method List<ECKey> getKeys())
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ return new ArrayList<>(hashToKeys.values()))
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    #_public
    (§ method int importKeys(ECKey... keys))
    (ß
        (§ return importKeys(ImmutableList.copyOf(keys)))
    )

    #_public
    (§ method int importKeys(List<? extends ECKey> keys))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            ;; Check that if we're encrypted, the keys are all encrypted, and if we're not, that none are.
            ;; We are NOT checking that the actual password matches here because we don't have access to the
            ;; password at this point: if you screw up and import keys with mismatched passwords, you lose!
            ;; So make sure the password is checked first.
            (§ for (ECKey key :for keys))
                (§ call checkKeyEncryptionStateMatches(key))

            (§ var List<ECKey> actuallyAdded = new ArrayList<>(keys.size()))
            (§ for (#_final ECKey key :for keys))
            (ß
                (§ if (!hasKey(key)))
                (ß
                    (§ call actuallyAdded.add(key))
                    (§ call importKeyLocked(key))
                )
            )
            (§ if (0 < actuallyAdded.size()))
                (§ call queueOnKeysAdded(actuallyAdded))
            (§ return actuallyAdded.size())
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    #_private
    (§ method void checkKeyEncryptionStateMatches(ECKey key))
    (ß
        (§ if (keyCrypter == nil && key.isEncrypted()))
            (§ throw new KeyCrypterException("Key is encrypted but chain is not"))
        (§ if (keyCrypter != nil && !key.isEncrypted()))
            (§ throw new KeyCrypterException("Key is not encrypted but chain is"))
        (§ if (keyCrypter != nil && key.getKeyCrypter() != nil && !key.getKeyCrypter().equals(keyCrypter)))
            (§ throw new KeyCrypterException("Key encrypted under different parameters to chain"))
    )

    #_private
    (§ method void importKeyLocked(ECKey key))
    (ß
        (§ if (hashToKeys.isEmpty()))
        (ß
            (§ ass isWatching = key.isWatching())
        )
        (§ else)
        (ß
            (§ if (key.isWatching() && !isWatching))
                (§ throw new IllegalArgumentException("Key is watching but chain is not"))
            (§ if (!key.isWatching() && isWatching))
                (§ throw new IllegalArgumentException("Key is not watching but chain is"))
        )
        (§ var ECKey previousKey = pubkeyToKeys.put(ByteString.copyFrom(key.getPubKey()), key))
        (§ call hashToKeys.put(ByteString.copyFrom(key.getPubKeyHash()), key))
        (§ call Preconditions.checkState(previousKey == nil))
    )

    #_private
    (§ method void importKeysLocked(List<ECKey> keys))
    (ß
        (§ for (ECKey key :for keys))
            (§ call importKeyLocked(key))
    )

    ;;;
     ; Imports a key to the key chain.  If key is present in the key chain, ignore it.
     ;;
    #_public
    (§ method void importKey(ECKey key))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ call checkKeyEncryptionStateMatches(key))
            (§ if (hasKey(key)))
                (§ return)

            (§ call importKeyLocked(key))
            (§ call queueOnKeysAdded(ImmutableList.of(key)))
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    #_public
    (§ method ECKey findKeyFromPubHash(byte[] pubkeyHash))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ return hashToKeys.get(ByteString.copyFrom(pubkeyHash)))
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    #_public
    (§ method ECKey findKeyFromPubKey(byte[] pubkey))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ return pubkeyToKeys.get(ByteString.copyFrom(pubkey)))
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    #_override
    #_public
    (§ method boolean hasKey(ECKey key))
    (ß
        (§ return (findKeyFromPubKey(key.getPubKey()) != nil))
    )

    #_override
    #_public
    (§ method int numKeys())
    (ß
        (§ return pubkeyToKeys.size())
    )

    ;;; Whether this basic key chain is empty, full of regular (usable for signing) keys, or full of watching keys. ;;
    #_public
    (§ enum State
        (§ item EMPTY)
        (§ item WATCHING)
        (§ item REGULAR)
    )

    ;;;
     ; Returns whether this chain consists of pubkey only (watching) keys, regular keys (usable for signing),
     ; or has no keys in it yet at all (thus we cannot tell).
     ;;
    #_public
    (§ method State isWatching())
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ return hashToKeys.isEmpty() ? State.EMPTY :else isWatching ? State.WATCHING :else State.REGULAR)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Removes the given key from the keychain.  Be very careful with this - losing a private key
     ; <b>destroys the money associated with it</b>.
     ; @return whether the key was removed or not.
     ;;
    #_public
    (§ method boolean removeKey(ECKey key))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ var boolean a = (hashToKeys.remove(ByteString.copyFrom(key.getPubKeyHash())) != nil))
            (§ var boolean b = (pubkeyToKeys.remove(ByteString.copyFrom(key.getPubKey())) != nil))
            (§ call Preconditions.checkState(a == b)) ;; Should be in both maps or neither.
            (§ return a)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    #_override
    #_public
    (§ method long getEarliestKeyCreationTime())
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ var long time = Long.MAX_VALUE)
            (§ for (ECKey key :for hashToKeys.values()))
                (§ ass time = Math.min(key.getCreationTimeSeconds(), time))
            (§ return time)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    #_public
    (§ method List<ListenerRegistration<KeyChainEventListener>> getListeners())
    (ß
        (§ return new ArrayList<>(listeners))
    )

    (§ method Map<ECKey, Protos.Key.Builder> serializeToEditableProtobufs())
    (ß
        (§ var Map<ECKey, Protos.Key.Builder> result = new LinkedHashMap<>())
        (§ for (ECKey ecKey :for hashToKeys.values()))
        (ß
            (§ var Protos.Key.Builder protoKey = serializeEncryptableItem(ecKey))
            (§ call protoKey.setPublicKey(ByteString.copyFrom(ecKey.getPubKey())))
            (§ call result.put(ecKey, protoKey))
        )
        (§ return result)
    )

    #_override
    #_public
    (§ method List<Protos.Key> serializeToProtobuf())
    (ß
        (§ var Collection<Protos.Key.Builder> builders = serializeToEditableProtobufs().values())
        (§ var List<Protos.Key> result = new ArrayList<>(builders.size()))
        (§ for (Protos.Key.Builder builder :for builders))
            (§ call result.add(builder.build()))
        (§ return result)
    )

    #_static
    (§ method Protos.Key.Builder serializeEncryptableItem(EncryptableItem item))
    (ß
        (§ var Protos.Key.Builder proto = Protos.Key.newBuilder())
        (§ call proto.setCreationTimestamp(item.getCreationTimeSeconds() * 1000))
        (§ if (item.isEncrypted() && item.getEncryptedData() != nil))
        (ß
            ;; The encrypted data can be missing for an "encrypted" key in the case of a deterministic wallet
            ;; for which the leaf keys chain to an encrypted parent and rederive their private keys on the fly.
            ;; In that case the caller in DeterministicKeyChain will take care of setting the type.
            (§ var EncryptedData data = item.getEncryptedData())
            (§ call proto.getEncryptedDataBuilder().setEncryptedPrivateKey(ByteString.copyFrom(data.encryptedBytes)).setInitialisationVector(ByteString.copyFrom(data.initialisationVector)))
            ;; We don't allow mixing of encryption types at the moment.
            (§ call Preconditions.checkState(item.getEncryptionType() == Protos.Wallet.EncryptionType.ENCRYPTED_SCRYPT_AES))
            (§ call proto.setType(Protos.Key.Type.ENCRYPTED_SCRYPT_AES))
        )
        (§ else)
        (ß
            #_final
            (§ var byte[] secret = item.getSecretBytes())
            ;; The secret might be missing in the case of a watching wallet, or a key for which the private key
            ;; is expected to be rederived on the fly from its parent.
            (§ if (secret != nil))
                (§ call proto.setSecretBytes(ByteString.copyFrom(secret)))
            (§ call proto.setType(Protos.Key.Type.ORIGINAL))
        )
        (§ return proto)
    )

    ;;;
     ; Returns a new BasicKeyChain that contains all basic, ORIGINAL type keys extracted from the list.
     ; Unrecognised key types are ignored.
     ;;
    #_public
    #_static
    (§ method BasicKeyChain fromProtobufUnencrypted(List<Protos.Key> keys))
        (§ throws UnreadableWalletException)
    (ß
        (§ var BasicKeyChain chain = new BasicKeyChain())
        (§ call chain.deserializeFromProtobuf(keys))
        (§ return chain)
    )

    ;;;
     ; Returns a new BasicKeyChain that contains all basic, ORIGINAL type keys and also any encrypted keys
     ; extracted from the list.  Unrecognised key types are ignored.
     ; @throws org.bitcoinj.wallet.UnreadableWalletException.BadPassword if the password doesn't seem to match.
     ; @throws org.bitcoinj.wallet.UnreadableWalletException if the data structures are corrupted/inconsistent.
     ;;
    #_public
    #_static
    (§ method BasicKeyChain fromProtobufEncrypted(List<Protos.Key> keys, KeyCrypter crypter))
        (§ throws UnreadableWalletException)
    (ß
        (§ var BasicKeyChain chain = new BasicKeyChain(Preconditions.checkNotNull(crypter)))
        (§ call chain.deserializeFromProtobuf(keys))
        (§ return chain)
    )

    #_private
    (§ method void deserializeFromProtobuf(List<Protos.Key> keys))
        (§ throws UnreadableWalletException)
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ call Preconditions.checkState(hashToKeys.isEmpty(), "Tried to deserialize into a non-empty chain"))
            (§ for (Protos.Key key :for keys))
            (ß
                (§ if (key.getType() != Protos.Key.Type.ORIGINAL && key.getType() != Protos.Key.Type.ENCRYPTED_SCRYPT_AES))
                    (§ continue)

                (§ var boolean encrypted = (key.getType() == Protos.Key.Type.ENCRYPTED_SCRYPT_AES))
                (§ var byte[] priv = key.hasSecretBytes() ? key.getSecretBytes().toByteArray() :else nil)
                (§ if (!key.hasPublicKey()))
                    (§ throw new UnreadableWalletException("Public key missing"))

                (§ var byte[] pub = key.getPublicKey().toByteArray())
                (§ var ECKey ecKey)
                (§ if (encrypted))
                (ß
                    (§ call Preconditions.checkState(keyCrypter != nil, "This wallet is encrypted but encrypt() was not called prior to deserialization"))
                    (§ if (!key.hasEncryptedData()))
                        (§ throw new UnreadableWalletException("Encrypted private key data missing"))

                    (§ var Protos.EncryptedData proto = key.getEncryptedData())
                    (§ var EncryptedData e = new EncryptedData(proto.getInitialisationVector().toByteArray(), proto.getEncryptedPrivateKey().toByteArray()))
                    (§ ass ecKey = ECKey.fromEncrypted(e, keyCrypter, pub))
                )
                (§ else)
                (ß
                    (§ ass ecKey = (priv != nil) ? ECKey.fromPrivateAndPrecalculatedPublic(priv, pub) :else ECKey.fromPublicOnly(pub))
                )
                (§ call ecKey.setCreationTimeSeconds(key.getCreationTimestamp() / 1000))
                (§ call importKeyLocked(ecKey))
            )
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    #_override
    #_public
    (§ method void addEventListener(KeyChainEventListener listener))
    (ß
        (§ call addEventListener(listener, Threading.USER_THREAD))
    )

    #_override
    #_public
    (§ method void addEventListener(KeyChainEventListener listener, Executor executor))
    (ß
        (§ call listeners.add(new ListenerRegistration<>(listener, executor)))
    )

    #_override
    #_public
    (§ method boolean removeEventListener(KeyChainEventListener listener))
    (ß
        (§ return ListenerRegistration.removeFromList(listener, listeners))
    )

    #_private
    (§ method void queueOnKeysAdded(#_final List<ECKey> keys))
    (ß
        (§ call Preconditions.checkState(lock.isHeldByCurrentThread()))

        (§ for (#_final ListenerRegistration<KeyChainEventListener> registration :for listeners))
        (ß
            (§ call registration.executor.execute(new Runnable()
            (ß
                #_override
                #_public
                (§ method void run())
                (ß
                    (§ call registration.listener.onKeysAdded(keys))
                )
            )))
        )
    )

    ;;;
     ; Convenience wrapper around {@link #toEncrypted(org.bitcoinj.crypto.KeyCrypter, org.spongycastle.crypto.params.KeyParameter)}
     ; which uses the default Scrypt key derivation algorithm and parameters, derives a key from the given password and returns
     ; the created key.
     ;;
    #_override
    #_public
    (§ method BasicKeyChain toEncrypted(CharSequence password))
    (ß
        (§ call Preconditions.checkNotNull(password))
        (§ call Preconditions.checkArgument(0 < password.length()))

        (§ var KeyCrypter scrypt = new KeyCrypterScrypt())
        (§ var KeyParameter derivedKey = scrypt.deriveKey(password))
        (§ return toEncrypted(scrypt, derivedKey))
    )

    ;;;
     ; Encrypt the wallet using the KeyCrypter and the AES key.  A good default KeyCrypter to use is
     ; {@link org.bitcoinj.crypto.KeyCrypterScrypt}.
     ;
     ; @param keyCrypter The KeyCrypter that specifies how to encrypt/ decrypt a key.
     ; @param aesKey AES key to use (normally created using KeyCrypter#deriveKey and cached as it is time consuming
     ;               to create from a password).
     ; @throws KeyCrypterException if the wallet encryption fails.  If so, the wallet state is unchanged.
     ;;
    #_override
    #_public
    (§ method BasicKeyChain toEncrypted(KeyCrypter keyCrypter, KeyParameter aesKey))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ call Preconditions.checkNotNull(keyCrypter))
            (§ call Preconditions.checkState(this.keyCrypter == nil, "Key chain is already encrypted"))

            (§ var BasicKeyChain encrypted = new BasicKeyChain(keyCrypter))
            (§ for (ECKey key :for hashToKeys.values()))
            (ß
                (§ var ECKey encryptedKey = key.encrypt(keyCrypter, aesKey))
                ;; Check that the encrypted key can be successfully decrypted.
                ;; This is done as it is a critical failure if the private key cannot be decrypted successfully
                ;; (all bitcoin controlled by that private key is lost forever).
                ;; For a correctly constructed keyCrypter the encryption should always be reversible so it is just
                ;; being as cautious as possible.
                (§ if (!ECKey.encryptionIsReversible(key, encryptedKey, keyCrypter, aesKey)))
                    (§ throw new KeyCrypterException("The key " + key + " cannot be successfully decrypted after encryption so aborting wallet encryption."))
                (§ call encrypted.importKeyLocked(encryptedKey))
            )
            (§ return encrypted)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    #_override
    #_public
    (§ method BasicKeyChain toDecrypted(CharSequence password))
    (ß
        (§ call Preconditions.checkNotNull(keyCrypter, "Wallet is already decrypted"))

        (§ return toDecrypted(keyCrypter.deriveKey(password)))
    )

    #_override
    #_public
    (§ method BasicKeyChain toDecrypted(KeyParameter aesKey))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ call Preconditions.checkState(keyCrypter != nil, "Wallet is already decrypted"))

            ;; Do an up-front check.
            (§ if (0 < numKeys() && !checkAESKey(aesKey)))
                (§ throw new KeyCrypterException("Password/key was incorrect."))

            (§ var BasicKeyChain decrypted = new BasicKeyChain())
            (§ for (ECKey key :for hashToKeys.values()))
                (§ call decrypted.importKeyLocked(key.decrypt(aesKey)))
            (§ return decrypted)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Returns whether the given password is correct for this key chain.
     ; @throws IllegalStateException if the chain is not encrypted at all.
     ;;
    #_override
    #_public
    (§ method boolean checkPassword(CharSequence password))
    (ß
        (§ call Preconditions.checkNotNull(password))
        (§ call Preconditions.checkState(keyCrypter != nil, "Key chain not encrypted"))

        (§ return checkAESKey(keyCrypter.deriveKey(password)))
    )

    ;;;
     ; Check whether the AES key can decrypt the first encrypted key in the wallet.
     ;
     ; @return true if AES key supplied can decrypt the first encrypted private key in the wallet, false otherwise.
     ;;
    #_override
    #_public
    (§ method boolean checkAESKey(KeyParameter aesKey))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            ;; If no keys then cannot decrypt.
            (§ if (hashToKeys.isEmpty()))
                (§ return false)

            (§ call Preconditions.checkState(keyCrypter != nil, "Key chain is not encrypted"))

            ;; Find the first encrypted key in the wallet.
            (§ var ECKey first = nil)
            (§ for (ECKey key :for hashToKeys.values()))
            (ß
                (§ if (key.isEncrypted()))
                (ß
                    (§ ass first = key)
                    (§ break)
                )
            )
            (§ call Preconditions.checkState(first != nil, "No encrypted keys in the wallet"))

            (§ try)
            (ß
                (§ var ECKey rebornKey = first.decrypt(aesKey))
                (§ return Arrays.equals(first.getPubKey(), rebornKey.getPubKey()))
            )
            (§ catch (KeyCrypterException _))
            (ß
                ;; The AES key supplied is incorrect.
                (§ return false)
            )
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    #_override
    #_public
    (§ method BloomFilter getFilter(int size, double falsePositiveRate, long tweak))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ var BloomFilter filter = new BloomFilter(size, falsePositiveRate, tweak))
            (§ for (ECKey key :for hashToKeys.values()))
                (§ call filter.insert(key))
            (§ return filter)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    #_override
    #_public
    (§ method int numBloomFilterEntries())
    (ß
        (§ return numKeys() * 2)
    )

    ;;; Returns the first ECKey created after the given UNIX time, or null if there is none. ;;
    #_nilable
    #_public
    (§ method ECKey findOldestKeyAfter(long timeSecs))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ var ECKey oldest = nil)
            (§ for (ECKey key :for hashToKeys.values()))
            (ß
                #_final
                (§ var long keyTime = key.getCreationTimeSeconds())
                (§ if (timeSecs < keyTime && (oldest == nil || keyTime < oldest.getCreationTimeSeconds())))
                    (§ ass oldest = key)
            )
            (§ return oldest)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;; Returns a list of all ECKeys created after the given UNIX time. ;;
    #_public
    (§ method List<ECKey> findKeysBefore(long timeSecs))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ var List<ECKey> results = Lists.newLinkedList())
            (§ for (ECKey key :for hashToKeys.values()))
            (ß
                #_final
                (§ var long keyTime = key.getCreationTimeSeconds())
                (§ if (keyTime < timeSecs))
                    (§ call results.add(key))
            )
            (§ return results)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )
)

#_(ns org.bitcoinj.wallet #_"CoinSelection"
    (:import [java.util Collection])
  #_(:require [org.bitcoinj.core Coin TransactionOutput]))

;;;
 ; Represents the results of a {@link CoinSelector#select(Coin, java.util.List)} operation.
 ; A coin selection represents a list of spendable transaction outputs that sum together to give valueGathered.
 ; Different coin selections could be produced by different coin selectors from the same input set, according
 ; to their varying policies.
 ;;
#_public
(§ class CoinSelection
    #_public
    (§ field Coin valueGathered)
    #_public
    (§ field Collection<TransactionOutput> gathered)

    #_public
    (§ constructor CoinSelection(Coin valueGathered, Collection<TransactionOutput> gathered))
    (ß
        (§ ass this.valueGathered = valueGathered)
        (§ ass this.gathered = gathered)
    )
)

#_(ns org.bitcoinj.wallet #_"CoinSelector"
    (:import [java.util List])
  #_(:require [org.bitcoinj.core Coin TransactionOutput]))

;;;
 ; A CoinSelector is responsible for picking some outputs to spend, from the list of all possible outputs.
 ; It allows you to customize the policies for creation of transactions to suit your needs.  The select operation
 ; may return a {@link CoinSelection} that has a valueGathered lower than the requested target, if there's not
 ; enough money in the wallet.
 ;;
#_public
(§ interface CoinSelector
    ;;;
     ; Creates a CoinSelection that tries to meet the target amount of value.  The candidates list is given to
     ; this call and can be edited freely.  See the docs for CoinSelection to learn more, or look a the implementation
     ; of {@link DefaultCoinSelector}.
     ;;
    (§ method CoinSelection select(Coin target, List<TransactionOutput> candidates))
)

#_(ns org.bitcoinj.wallet #_"DecryptingKeyBag"
    (:import [java.util ArrayList List])
    (:import [com.google.common.base Preconditions]
             [org.spongycastle.crypto.params KeyParameter])
  #_(:require [org.bitcoinj.core ECKey]))

;;;
 ; A DecryptingKeyBag filters a pre-existing key bag, decrypting keys as they are requested using the provided AES key.
 ; If the keys are encrypted and no AES key provided, {@link org.bitcoinj.core.ECKey.KeyIsEncryptedException} will be thrown.
 ;;
#_public
(§ class DecryptingKeyBag implements KeyBag
    #_protected
    #_final
    (§ field KeyBag target)
    #_protected
    #_final
    (§ field KeyParameter aesKey)

    #_public
    (§ constructor DecryptingKeyBag(KeyBag target, #_nilable KeyParameter aesKey))
    (ß
        (§ ass this.target = Preconditions.checkNotNull(target))
        (§ ass this.aesKey = aesKey)
    )

    #_nilable
    #_private
    (§ method ECKey maybeDecrypt(ECKey key))
    (ß
        (§ if (key == nil))
            (§ return nil)

        (§ if (key.isEncrypted()))
        (ß
            (§ if (aesKey == nil))
                (§ throw new ECKey.KeyIsEncryptedException())
            (§ return key.decrypt(aesKey))
        )

        (§ return key)
    )

    #_private
    (§ method RedeemData maybeDecrypt(RedeemData redeemData))
    (ß
        (§ var List<ECKey> decryptedKeys = new ArrayList<>())
        (§ for (ECKey key :for redeemData.keys))
            (§ call decryptedKeys.add(maybeDecrypt(key)))
        (§ return RedeemData.of(decryptedKeys, redeemData.redeemScript))
    )

    #_nilable
    #_override
    #_public
    (§ method ECKey findKeyFromPubHash(byte[] pubkeyHash))
    (ß
        (§ return maybeDecrypt(target.findKeyFromPubHash(pubkeyHash)))
    )

    #_nilable
    #_override
    #_public
    (§ method ECKey findKeyFromPubKey(byte[] pubkey))
    (ß
        (§ return maybeDecrypt(target.findKeyFromPubKey(pubkey)))
    )

    #_nilable
    #_override
    #_public
    (§ method RedeemData findRedeemDataFromScriptHash(byte[] scriptHash))
    (ß
        (§ return maybeDecrypt(target.findRedeemDataFromScriptHash(scriptHash)))
    )
)

#_(ns org.bitcoinj.wallet #_"DefaultCoinSelector"
    (:import [java.math BigInteger]
             #_[java.util *])
    (:import [com.google.common.annotations VisibleForTesting])
  #_(:require [org.bitcoinj.core Coin NetworkParameters Transaction TransactionConfidence TransactionOutput]))

;;;
 ; This class implements a {@link CoinSelector} which attempts to get the highest priority possible.
 ; This means that the transaction is the most likely to get confirmed.  Note that this means we may end up
 ; "spending" more priority than would be required to get the transaction we are creating confirmed.
 ;;
#_public
(§ class DefaultCoinSelector implements CoinSelector
    #_override
    #_public
    (§ method CoinSelection select(Coin target, List<TransactionOutput> candidates))
    (ß
        (§ var ArrayList<TransactionOutput> selected = new ArrayList<>())
        ;; Sort the inputs by age * value, so we get the highest "coindays" spent.
        ;; TODO: Consider changing the wallets internal format to track just outputs and keep them ordered.
        (§ var ArrayList<TransactionOutput> sortedOutputs = new ArrayList<>(candidates))
        ;; When calculating the wallet balance, we may be asked to select all possible coins, if so, avoid
        ;; sorting them in order to improve performance.
        ;; TODO: Take in network parameters when instanatiated, and then test against the current network.
        ;; Or just have a boolean parameter for "give me everything".
        (§ if (!target.equals(NetworkParameters.MAX_MONEY)))
            (§ call sortOutputs(sortedOutputs))
        ;; Now iterate over the sorted outputs until we have got as close to the target as possible or
        ;; a little bit over (excessive value will be change).
        (§ var long total = 0)
        (§ for (TransactionOutput output :for sortedOutputs))
        (ß
            (§ if (target.value <= total))
                (§ break)
            ;; Only pick chain-included transactions, or transactions that are ours and pending.
            (§ if (shouldSelect(output.getParentTransaction())))
            (ß
                (§ call selected.add(output))
                (§ ass total = total + output.getValue().value)
            )
        )
        ;; Total may be lower than the target here if the given candidates were insufficient to create
        ;; the requested transaction.
        (§ return new CoinSelection(Coin.valueOf(total), selected))
    )

    #_testing
    #_static
    (§ method void sortOutputs(ArrayList<TransactionOutput> outputs))
    (ß
        (§ call Collections.sort(outputs, new Comparator<TransactionOutput>()
        (ß
            #_override
            #_public
            (§ method int compare(TransactionOutput a, TransactionOutput b))
            (ß
                (§ var int depth1 = a.getParentTransactionDepthInBlocks())
                (§ var int depth2 = b.getParentTransactionDepthInBlocks())
                (§ var Coin aValue = a.getValue())
                (§ var Coin bValue = b.getValue())
                (§ var BigInteger aCoinDepth = BigInteger.valueOf(aValue.value).multiply(BigInteger.valueOf(depth1)))
                (§ var BigInteger bCoinDepth = BigInteger.valueOf(bValue.value).multiply(BigInteger.valueOf(depth2)))
                (§ var int c1 = bCoinDepth.compareTo(aCoinDepth))
                (§ if (c1 != 0))
                    (§ return c1)

                ;; The "coin * days" destroyed are equal, sort by value alone to get the lowest transaction size.
                (§ var int c2 = bValue.compareTo(aValue))
                (§ if (c2 != 0))
                    (§ return c2)

                ;; They are entirely equivalent (possibly pending) so sort by hash to ensure a total ordering.
                (§ var BigInteger aHash = a.getParentTransactionHash().toBigInteger())
                (§ var BigInteger bHash = b.getParentTransactionHash().toBigInteger())
                (§ return aHash.compareTo(bHash))
            )
        )))
    )

    ;;; Sub-classes can override this to just customize whether transactions are usable, but keep age sorting. ;;
    #_protected
    (§ method boolean shouldSelect(Transaction tx))
    (ß
        (§ return (tx != nil) ? isSelectable(tx) :else true)
    )

    #_public
    #_static
    (§ method boolean isSelectable(Transaction tx))
    (ß
        ;; Only pick chain-included transactions, or transactions that are ours and pending.
        (§ var TransactionConfidence confidence = tx.getConfidence())
        (§ var TransactionConfidence.ConfidenceType type = confidence.getConfidenceType())
        ;; TODO: The value 1 below dates from a time when transactions we broadcast *to* were counted, set to 0.
        (§ return type.equals(TransactionConfidence.ConfidenceType.BUILDING) || (type.equals(TransactionConfidence.ConfidenceType.PENDING) && confidence.getSource().equals(TransactionConfidence.Source.SELF) && 1 < confidence.numBroadcastPeers()))
    )
)

#_(ns org.bitcoinj.wallet #_"DefaultKeyChainFactory"
  #_(:require #_[org.bitcoinj.crypto *]))

;;;
 ; Default factory for creating keychains while de-serializing.
 ;;
#_public
(§ class DefaultKeyChainFactory implements KeyChainFactory
    #_override
    #_public
    (§ method DeterministicKeyChain makeKeyChain(Protos.Key key, Protos.Key firstSubKey, DeterministicSeed seed, KeyCrypter crypter, boolean isMarried))
    (ß
        (§ return isMarried ? new MarriedKeyChain(seed, crypter) :else new DeterministicKeyChain(seed, crypter))
    )

    #_override
    #_public
    (§ method DeterministicKeyChain makeWatchingKeyChain(Protos.Key key, Protos.Key firstSubKey, DeterministicKey accountKey, boolean isFollowingKey, boolean isMarried))
        (§ throws UnreadableWalletException)
    (ß
        (§ if (!accountKey.getPath().equals(DeterministicKeyChain.ACCOUNT_ZERO_PATH)))
            (§ throw new UnreadableWalletException("Expecting account key but found key with path: " + HDUtils.formatPath(accountKey.getPath())))

        (§ return isMarried ? new MarriedKeyChain(accountKey) :else new DeterministicKeyChain(accountKey, isFollowingKey))
    )
)

#_(ns org.bitcoinj.wallet #_"DefaultRiskAnalysis"
    (:import [java.util List])
    (:import [com.google.common.base Preconditions]
             [org.slf4j Logger LoggerFactory])
  #_(:require [org.bitcoinj.core Coin ECKey]
             [org.bitcoinj.core.ECKey ECDSASignature]
             [org.bitcoinj.core NetworkParameters Transaction TransactionConfidence TransactionInput TransactionOutput]
             [org.bitcoinj.crypto TransactionSignature]
             [org.bitcoinj.script ScriptChunk]))

;;;
 ; <p>The default risk analysis.  Currently, it only is concerned with whether a tx/dependency is non-final or not,
 ; and whether a tx/dependency violates the dust rules.  Outside of specialised protocols you should not encounter
 ; non-final transactions.</p>
 ;;
#_public
(§ class DefaultRiskAnalysis implements RiskAnalysis
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(DefaultRiskAnalysis.class))

    ;;;
     ; Any standard output smaller than this value (in satoshis) will be considered risky, as it's most likely
     ; be rejected by the network.  This is usually the same as {@link Transaction#MIN_NONDUST_OUTPUT} but can
     ; be different when the fee is about to change in Bitcoin Core.
     ;;
    #_public
    #_static
    #_final
    (§ field Coin MIN_ANALYSIS_NONDUST_OUTPUT = Transaction.MIN_NONDUST_OUTPUT)

    #_protected
    #_final
    (§ field Transaction tx)
    #_protected
    #_final
    (§ field List<Transaction> dependencies)
    #_nilable
    #_protected
    #_final
    (§ field Wallet wallet)

    #_private
    (§ field Transaction nonStandard)
    #_protected
    (§ field Transaction nonFinal)
    #_protected
    (§ field boolean analyzed)

    #_private
    (§ constructor DefaultRiskAnalysis(Wallet wallet, Transaction tx, List<Transaction> dependencies))
    (ß
        (§ ass this.tx = tx)
        (§ ass this.dependencies = dependencies)
        (§ ass this.wallet = wallet)
    )

    #_override
    #_public
    (§ method Result analyze())
    (ß
        (§ call Preconditions.checkState(!analyzed))
        (§ ass analyzed = true)

        (§ var Result result = analyzeIsFinal())
        (§ if (result != nil && result != Result.OK))
            (§ return result)

        (§ return analyzeIsStandard())
    )

    #_nilable
    #_private
    (§ method Result analyzeIsFinal())
    (ß
        ;; Transactions we create ourselves are, by definition, not at risk of double spending against us.
        (§ if (tx.getConfidence().getSource() == TransactionConfidence.Source.SELF))
            (§ return Result.OK)

        ;; We consider transactions that opt into replace-by-fee at risk of double spending.
        (§ if (tx.isOptInFullRBF()))
        (ß
            (§ ass nonFinal = tx)
            (§ return Result.NON_FINAL)
        )

        (§ if (wallet == nil))
            (§ return nil)

        #_final
        (§ var int height = wallet.getLastBlockSeenHeight())
        #_final
        (§ var long time = wallet.getLastBlockSeenTimeSecs())
        ;; If the transaction has a lock time specified in blocks, we consider that if the tx would become final
        ;; in the next block, it is not risky (as it would confirm normally).
        #_final
        (§ var int adjustedHeight = height + 1)

        (§ if (!tx.isFinal(adjustedHeight, time)))
        (ß
            (§ ass nonFinal = tx)
            (§ return Result.NON_FINAL)
        )

        (§ for (Transaction dep :for dependencies))
        (ß
            (§ if (!dep.isFinal(adjustedHeight, time)))
            (ß
                (§ ass nonFinal = dep)
                (§ return Result.NON_FINAL)
            )
        )

        (§ return Result.OK)
    )

    ;;;
     ; The reason a transaction is considered non-standard, returned by {@link #isStandard(org.bitcoinj.core.Transaction)}.
     ;;
    #_public
    (§ enum RuleViolation
        (§ item NONE)
        (§ item VERSION)
        (§ item DUST)
        (§ item SHORTEST_POSSIBLE_PUSHDATA)
        (§ item NONEMPTY_STACK) ;; Not yet implemented (for post 0.12)
        (§ item SIGNATURE_CANONICAL_ENCODING)
    )

    ;;;
     ; <p>Checks if a transaction is considered "standard" by Bitcoin Core's IsStandardTx and AreInputsStandard functions.</p>
     ;
     ; <p>Note that this method currently only implements a minimum of checks.  More to be added later.</p>
     ;;
    #_public
    #_static
    (§ method RuleViolation isStandard(Transaction tx))
    (ß
        ;; TODO: Finish this function off.
        (§ if (1 < tx.getVersion() || tx.getVersion() < 1))
        (ß
            (§ call log.warn("TX considered non-standard due to unknown version number {}", tx.getVersion()))
            (§ return RuleViolation.VERSION)
        )

        #_final
        (§ var List<TransactionOutput> outputs = tx.getOutputs())
        (§ for (int i = 0 :for i < outputs.size() :for i = i + 1))
        (ß
            (§ var TransactionOutput output = outputs.get(i))
            (§ var RuleViolation violation = isOutputStandard(output))
            (§ if (violation != RuleViolation.NONE))
            (ß
                (§ call log.warn("TX considered non-standard due to output {} violating rule {}", i, violation))
                (§ return violation)
            )
        )

        #_final
        (§ var List<TransactionInput> inputs = tx.getInputs())
        (§ for (int i = 0 :for i < inputs.size() :for i = i + 1))
        (ß
            (§ var TransactionInput input = inputs.get(i))
            (§ var RuleViolation violation = isInputStandard(input))
            (§ if (violation != RuleViolation.NONE))
            (ß
                (§ call log.warn("TX considered non-standard due to input {} violating rule {}", i, violation))
                (§ return violation)
            )
        )

        (§ return RuleViolation.NONE)
    )

    ;;;
     ; Checks the output to see if the script violates a standardness rule.  Not complete.
     ;;
    #_public
    #_static
    (§ method RuleViolation isOutputStandard(TransactionOutput output))
    (ß
        (§ if (output.getValue().compareTo(MIN_ANALYSIS_NONDUST_OUTPUT) < 0))
            (§ return RuleViolation.DUST)

        (§ for (ScriptChunk chunk :for output.getScriptPubKey().getChunks()))
            (§ if (chunk.isPushData() && !chunk.isShortestPossiblePushData()))
                (§ return RuleViolation.SHORTEST_POSSIBLE_PUSHDATA)

        (§ return RuleViolation.NONE)
    )

    ;;; Checks if the given input passes some of the AreInputsStandard checks.  Not complete. ;;
    #_public
    #_static
    (§ method RuleViolation isInputStandard(TransactionInput input))
    (ß
        (§ for (ScriptChunk chunk :for input.getScriptSig().getChunks()))
        (ß
            (§ if (chunk.data != nil && !chunk.isShortestPossiblePushData()))
                (§ return RuleViolation.SHORTEST_POSSIBLE_PUSHDATA)

            (§ if (chunk.isPushData()))
            (ß
                (§ var ECDSASignature signature)
                (§ try)
                (ß
                    (§ ass signature = ECKey.ECDSASignature.decodeFromDER(chunk.data))
                )
                (§ catch (IllegalArgumentException _))
                (ß
                    ;; Doesn't look like a signature.
                    (§ ass signature = nil)
                )
                (§ if (signature != nil))
                (ß
                    (§ if (!TransactionSignature.isEncodingCanonical(chunk.data)))
                        (§ return RuleViolation.SIGNATURE_CANONICAL_ENCODING)
                    (§ if (!signature.isCanonical()))
                        (§ return RuleViolation.SIGNATURE_CANONICAL_ENCODING)
                )
            )
        )
        (§ return RuleViolation.NONE)
    )

    #_private
    (§ method Result analyzeIsStandard())
    (ß
        ;; The IsStandard rules don't apply on testnet, because they're just a safety mechanism and we don't
        ;; want to crush innovation with valueless test coins.
        (§ if (wallet != nil && !wallet.getNetworkParameters().getId().equals(NetworkParameters.ID_MAINNET)))
            (§ return Result.OK)

        (§ var RuleViolation ruleViolation = isStandard(tx))
        (§ if (ruleViolation != RuleViolation.NONE))
        (ß
            (§ ass nonStandard = tx)
            (§ return Result.NON_STANDARD)
        )

        (§ for (Transaction dep :for dependencies))
        (ß
            (§ ass ruleViolation = isStandard(dep))
            (§ if (ruleViolation != RuleViolation.NONE))
            (ß
                (§ ass nonStandard = dep)
                (§ return Result.NON_STANDARD)
            )
        )

        (§ return Result.OK)
    )

    ;;; Returns the transaction that was found to be non-standard, or null. ;;
    #_nilable
    #_public
    (§ method Transaction getNonStandard())
    (ß
        (§ return nonStandard)
    )

    ;;; Returns the transaction that was found to be non-final, or null. ;;
    #_nilable
    #_public
    (§ method Transaction getNonFinal())
    (ß
        (§ return nonFinal)
    )

    #_override
    #_public
    (§ method String toString())
    (ß
        (§ if (!analyzed))
            (§ return "Pending risk analysis for " + tx.getHashAsString())
        (§ if (nonFinal != nil))
            (§ return "Risky due to non-finality of " + nonFinal.getHashAsString())
        (§ if (nonStandard != nil))
            (§ return "Risky due to non-standard tx " + nonStandard.getHashAsString())

        (§ return "Non-risky")
    )

    #_public
    #_static
    (§ class Analyzer implements RiskAnalysis.Analyzer
        #_override
        #_public
        (§ method DefaultRiskAnalysis create(Wallet wallet, Transaction tx, List<Transaction> dependencies))
        (ß
            (§ return new DefaultRiskAnalysis(wallet, tx, dependencies))
        )
    )

    #_public
    #_static
    (§ field Analyzer FACTORY = new Analyzer())
)

#_(ns org.bitcoinj.wallet #_"DeterministicKeyChain"
    (:import [java.math BigInteger]
             [java.security SecureRandom]
             #_[java.util *]
             [java.util.concurrent Executor]
             [java.util.concurrent.locks ReentrantLock])
    (:import [com.google.common.base Preconditions Stopwatch]
             [com.google.common.collect ImmutableList Iterators]
             #_static #_[com.google.common.collect.Lists newArrayList]
             #_static #_[com.google.common.collect.Lists newLinkedList]
             [com.google.common.collect PeekingIterator]
             [com.google.protobuf ByteString]
             [org.slf4j Logger LoggerFactory]
             [org.spongycastle.crypto.params KeyParameter])
  #_(:require [org.bitcoinj.core BloomFilter ECKey NetworkParameters Utils]
             #_[org.bitcoinj.crypto *]
             [org.bitcoinj.script Script]
             [org.bitcoinj.utils Threading]
             [org.bitcoinj.wallet.listeners KeyChainEventListener]))

;;;
 ; <p>A deterministic key chain is a {@link KeyChain} that uses the
 ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">BIP 32 standard</a>, as implemented by
 ; {@link org.bitcoinj.crypto.DeterministicHierarchy}, to derive all the keys in the keychain from a master seed.
 ; This type of wallet is extremely convenient and flexible.  Although backing up full wallet files is always a good
 ; idea, to recover money only the root seed needs to be preserved and that is a number small enough that it can be
 ; written down on paper or, when represented using a BIP 39 {@link org.bitcoinj.crypto.MnemonicCode},
 ; dictated over the phone (possibly even memorized).</p>
 ;
 ; <p>Deterministic key chains have other advantages: parts of the key tree can be selectively revealed to allow
 ; for auditing, and new public keys can be generated without access to the private keys, yielding a highly secure
 ; configuration for web servers which can accept payments into a wallet but not spend from them.  This does not work
 ; quite how you would expect due to a quirk of elliptic curve mathematics and the techniques used to deal with it.
 ; A watching wallet is not instantiated using the public part of the master key as you may imagine.  Instead, you
 ; need to take the account key (first child of the master key) and provide the public part of that to the watching
 ; wallet instead.  You can do this by calling {@link #getWatchingKey()} and then serializing it with
 ; {@link org.bitcoinj.crypto.DeterministicKey#serializePubB58(org.bitcoinj.core.NetworkParameters)}.  The resulting
 ; "xpub..." string encodes sufficient information about the account key to create a watching chain via
 ; {@link org.bitcoinj.crypto.DeterministicKey#deserializeB58(org.bitcoinj.crypto.DeterministicKey, String, org.bitcoinj.core.NetworkParameters)}
 ; (with null as the first parameter) and then
 ; {@link DeterministicKeyChain#DeterministicKeyChain(org.bitcoinj.crypto.DeterministicKey)}.</p>
 ;
 ; <p>This class builds on {@link org.bitcoinj.crypto.DeterministicHierarchy} and {@link org.bitcoinj.crypto.DeterministicKey}
 ; by adding support for serialization to and from protobufs, and encryption of parts of the key tree.  Internally it
 ; arranges itself as per the BIP 32 spec, with the seed being used to derive a master key, which is then used to derive
 ; an account key, the account key is used to derive two child keys called the <i>internal</i> and <i>external</i> parent
 ; keys (for change and handing out addresses respectively) and finally the actual leaf keys that users use hanging off
 ; the end.  The leaf keys are special in that they don't internally store the private part at all, instead choosing to
 ; rederive the private key from the parent when needed for signing.  This simplifies the design for encrypted key chains.</p>
 ;
 ; <p>The key chain manages a <i>lookahead zone</i>.  This zone is required because when scanning the chain, you don't
 ; know exactly which keys might receive payments.  The user may have handed out several addresses and received payments
 ; on them, but for latency reasons the block chain is requested from remote peers in bulk, meaning you must
 ; "look ahead" when calculating keys to put in the Bloom filter.  The default lookahead zone is 100 keys, meaning
 ; if the user hands out more than 100 addresses and receives payment on them before the chain is next scanned, some
 ; transactions might be missed.  100 is a reasonable choice for consumer wallets running on CPU constrained devices.
 ; For industrial wallets that are receiving keys all the time, a higher value is more appropriate.  Ideally DKC and
 ; the wallet would know how to adjust this value automatically, but that's not implemented at the moment.</p>
 ;
 ; <p>In fact the real size of the lookahead zone is larger than requested, by default, it's one third larger.  This
 ; is because the act of deriving new keys means recalculating the Bloom filters and this is an expensive operation.
 ; Thus, to ensure we don't have to recalculate on every single new key/address requested or seen we add more buffer
 ; space and only extend the lookahead zone when that buffer is exhausted.  For example with a lookahead zone of 100
 ; keys, you can request 33 keys before more keys will be calculated and the Bloom filter rebuilt and rebroadcast.
 ; But even when you are requesting the 33rd key, you will still be looking 100 keys ahead.</p>
 ;
 ; @author Andreas Schildbach
 ;;
#_suppress(ß "PublicStaticCollectionField")
#_public
(§ class DeterministicKeyChain implements EncryptableKeyChain
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(DeterministicKeyChain.class))
    #_public
    #_static
    #_final
    (§ field String DEFAULT_PASSPHRASE_FOR_MNEMONIC = "")

    #_protected
    #_final
    (§ field ReentrantLock lock = Threading.lock("DeterministicKeyChain"))

    #_private
    (§ field DeterministicHierarchy hierarchy)
    #_nilable
    #_private
    (§ field DeterministicKey rootKey)
    #_nilable
    #_private
    (§ field DeterministicSeed seed)

    ;; Paths through the key tree.  External keys are ones that are communicated to other parties.  Internal keys are
    ;; keys created for change addresses, coinbases, mixing, etc - anything that isn't communicated.  The distinction
    ;; is somewhat arbitrary but can be useful for audits.  The first number is the "account number" but we don't use
    ;; that feature yet.  In future we might hand out different accounts for cases where we wish to hand payers
    ;; a payment request that can generate lots of addresses independently.
    ;; The account path may be overridden by subclasses.
    #_public
    #_static
    #_final
    (§ field ImmutableList<ChildNumber> ACCOUNT_ZERO_PATH = ImmutableList.of(ChildNumber.ZERO_HARDENED))
    #_public
    #_static
    #_final
    (§ field ImmutableList<ChildNumber> EXTERNAL_SUBPATH = ImmutableList.of(ChildNumber.ZERO))
    #_public
    #_static
    #_final
    (§ field ImmutableList<ChildNumber> INTERNAL_SUBPATH = ImmutableList.of(ChildNumber.ONE))
    #_public
    #_static
    #_final
    (§ field ImmutableList<ChildNumber> EXTERNAL_PATH = HDUtils.concat(ACCOUNT_ZERO_PATH, EXTERNAL_SUBPATH))
    #_public
    #_static
    #_final
    (§ field ImmutableList<ChildNumber> INTERNAL_PATH = HDUtils.concat(ACCOUNT_ZERO_PATH, INTERNAL_SUBPATH))
    ;; m / 44' / 0' / 0'
    #_public
    #_static
    #_final
    (§ field ImmutableList<ChildNumber> BIP44_ACCOUNT_ZERO_PATH = ImmutableList.of(new ChildNumber(44, true), ChildNumber.ZERO_HARDENED, ChildNumber.ZERO_HARDENED))

    ;; We try to ensure we have at least this many keys ready and waiting to be handed out via getKey().  See docs
    ;; for getLookaheadSize() for more info on what this is for.  The -1 value means it hasn't been calculated yet.
    ;; For new chains it's set to whatever the default is, unless overridden by setLookaheadSize.  For deserialized
    ;; chains, it will be calculated on demand from the number of loaded keys.
    #_private
    #_static
    #_final
    (§ field int LAZY_CALCULATE_LOOKAHEAD = -1)
    #_protected
    (§ field int lookaheadSize = 100)
    ;; The lookahead threshold causes us to batch up creation of new keys to minimize the frequency of Bloom filter
    ;; regenerations, which are expensive and will (in future) trigger chain download stalls/retries.  One third is
    ;; an efficiency tradeoff.
    #_protected
    (§ field int lookaheadThreshold = calcDefaultLookaheadThreshold())

    #_private
    (§ method int calcDefaultLookaheadThreshold())
    (ß
        (§ return lookaheadSize / 3)
    )

    ;; The parent keys for external keys (handed out to other people) and internal keys (used for change addresses).
    #_private
    (§ field DeterministicKey externalParentKey, internalParentKey)
    ;; How many keys on each path have actually been used.  This may be fewer than the number that have been
    ;; deserialized or held in memory, because of the lookahead zone.
    #_private
    (§ field int issuedExternalKeys, issuedInternalKeys)
    ;; A counter that is incremented each time a key in the lookahead threshold zone is marked as used and lookahead
    ;; is triggered.  The Wallet/KCG reads these counters and combines them so it can tell the Peer whether to throw
    ;; away the current block (and any future blocks in the same download batch) and restart chain sync once a new filter
    ;; has been calculated.  This field isn't persisted to the wallet as it's only relevant within a network session.
    #_private
    (§ field int keyLookaheadEpoch)

    ;; We simplify by wrapping a basic key chain and that way we get some functionality like key lookup and event
    ;; listeners "for free".  All keys in the key tree appear here, even if they aren't meant to be used for
    ;; receiving money.
    #_private
    #_final
    (§ field BasicKeyChain basicKeyChain)

    ;; If set this chain is following another chain in a married KeyChainGroup.
    #_private
    (§ field boolean isFollowing)

    ;; Holds a number of signatures required to spend.  It's the N from N-of-M CHECKMULTISIG script for P2SH transactions
    ;; and always 1 for other transaction types.
    #_protected
    (§ field int sigsRequiredToSpend = 1)

    #_public
    #_static
    (§ class Builder<T extends Builder<T>>
        #_protected
        (§ field SecureRandom random)
        #_protected
        (§ field int bits = 128)
        #_protected
        (§ field String passphrase)
        #_protected
        (§ field long seedCreationTimeSecs)
        #_protected
        (§ field byte[] entropy)
        #_protected
        (§ field DeterministicSeed seed)
        #_protected
        (§ field DeterministicKey watchingKey)

        #_protected
        (§ constructor Builder())
        (ß
        )

        #_suppress(ß "unchecked")
        #_protected
        (§ method T self())
        (ß
            (§ return (T)this)
        )

        ;;;
         ; Creates a deterministic key chain starting from the given entropy.  All keys yielded by this chain will be the
         ; same if the starting entropy is the same.  You should provide the creation time in seconds since the UNIX epoch
         ; for the seed: this lets us know from what part of the chain we can expect to see derived keys appear.
         ;;
        #_public
        (§ method T entropy(byte[] entropy))
        (ß
            (§ ass this.entropy = entropy)
            (§ return self())
        )

        ;;;
         ; Creates a deterministic key chain starting from the given seed.  All keys yielded by this chain will be the same
         ; if the starting seed is the same.
         ;;
        #_public
        (§ method T seed(DeterministicSeed seed))
        (ß
            (§ ass this.seed = seed)
            (§ return self())
        )

        ;;;
         ; Generates a new key chain with entropy selected randomly from the given {@link java.security.SecureRandom} object
         ; and of the requested size in bits.  The derived seed is further protected with a user selected passphrase (see BIP 39).
         ; @param random The random number generator - use new SecureRandom().
         ; @param bits The number of bits of entropy to use when generating entropy.  Either 128 (default), 192 or 256.
         ;;
        #_public
        (§ method T random(SecureRandom random, int bits))
        (ß
            (§ ass this.random = random)
            (§ ass this.bits = bits)
            (§ return self())
        )

        ;;;
         ; Generates a new key chain with 128 bits of entropy selected randomly from the given {@link java.security.SecureRandom}
         ; object.  The derived seed is further protected with a user selected passphrase (see BIP 39).
         ; @param random The random number generator - use new SecureRandom().
         ;;
        #_public
        (§ method T random(SecureRandom random))
        (ß
            (§ ass this.random = random)
            (§ return self())
        )

        #_public
        (§ method T watchingKey(DeterministicKey watchingKey))
        (ß
            (§ ass this.watchingKey = watchingKey)
            (§ return self())
        )

        #_public
        (§ method T seedCreationTimeSecs(long seedCreationTimeSecs))
        (ß
            (§ ass this.seedCreationTimeSecs = seedCreationTimeSecs)
            (§ return self())
        )

        ;;;
         ; The passphrase to use with the generated mnemonic, or null if you would like to use the default empty string.
         ; Currently must be the empty string.
         ;;
        #_public
        (§ method T passphrase(String passphrase))
        (ß
            ;; FIXME support non-empty passphrase
            (§ ass this.passphrase = passphrase)
            (§ return self())
        )

        #_public
        (§ method DeterministicKeyChain build())
        (ß
            (§ call Preconditions.checkState(random != nil || entropy != nil || seed != nil || watchingKey!= nil, "Must provide either entropy or random or seed or watchingKey"))
            (§ call Preconditions.checkState(passphrase == nil || seed == nil, "Passphrase must not be specified with seed"))

            ;; Default passphrase to "" if not specified.
            (§ if (random != nil))
                (§ return new DeterministicKeyChain(random, bits, getPassphrase(), seedCreationTimeSecs))

            (§ if (entropy != nil))
                (§ return new DeterministicKeyChain(entropy, getPassphrase(), seedCreationTimeSecs))

            (§ if (seed != nil))
            (ß
                (§ call seed.setCreationTimeSeconds(seedCreationTimeSecs))
                (§ return new DeterministicKeyChain(seed))
            )

            (§ call watchingKey.setCreationTimeSeconds(seedCreationTimeSecs))
            (§ return new DeterministicKeyChain(watchingKey))
        )

        #_protected
        (§ method String getPassphrase())
        (ß
            (§ return (passphrase != nil) ? passphrase :else DEFAULT_PASSPHRASE_FOR_MNEMONIC)
        )
    )

    #_public
    #_static
    (§ method Builder<?> builder())
    (ß
        (§ return new Builder())
    )

    ;;;
     ; Generates a new key chain with entropy selected randomly from the given {@link java.security.SecureRandom}
     ; object and the default entropy size.
     ;;
    #_public
    (§ constructor DeterministicKeyChain(SecureRandom random))
    (ß
        (§ this (random, DeterministicSeed.DEFAULT_SEED_ENTROPY_BITS, DEFAULT_PASSPHRASE_FOR_MNEMONIC, Utils.currentTimeSeconds()))
    )

    ;;;
     ; Generates a new key chain with entropy selected randomly from the given {@link java.security.SecureRandom}
     ; object and of the requested size in bits.
     ;;
    #_public
    (§ constructor DeterministicKeyChain(SecureRandom random, int bits))
    (ß
        (§ this (random, bits, DEFAULT_PASSPHRASE_FOR_MNEMONIC, Utils.currentTimeSeconds()))
    )

    ;;;
     ; Generates a new key chain with entropy selected randomly from the given {@link java.security.SecureRandom}
     ; object and of the requested size in bits.  The derived seed is further protected with a user selected passphrase
     ; (see BIP 39).
     ;;
    #_public
    (§ constructor DeterministicKeyChain(SecureRandom random, int bits, String passphrase, long seedCreationTimeSecs))
    (ß
        (§ this (new DeterministicSeed(random, bits, passphrase, seedCreationTimeSecs)))
    )

    ;;;
     ; Creates a deterministic key chain starting from the given entropy.  All keys yielded by this chain will be the
     ; same if the starting seed is the same.  You should provide the creation time in seconds since the UNIX epoch
     ; for the seed: this lets us know from what part of the chain we can expect to see derived keys appear.
     ;;
    #_public
    (§ constructor DeterministicKeyChain(byte[] entropy, String passphrase, long seedCreationTimeSecs))
    (ß
        (§ this (new DeterministicSeed(entropy, passphrase, seedCreationTimeSecs)))
    )

    ;;;
     ; Creates a deterministic key chain starting from the given seed.  All keys yielded by this chain will be the
     ; same if the starting seed is the same.
     ;;
    #_protected
    (§ constructor DeterministicKeyChain(DeterministicSeed seed))
    (ß
        (§ this (seed, nil))
    )

    ;;;
     ; Creates a deterministic key chain that watches the given (public only) root key.  You can use this to calculate
     ; balances and generally follow along, but spending is not possible with such a chain.  Currently you can't use
     ; this method to watch an arbitrary fragment of some other tree, this limitation may be removed in future.
     ;;
    #_public
    (§ constructor DeterministicKeyChain(DeterministicKey watchingKey))
    (ß
        (§ call Preconditions.checkArgument(watchingKey.isPubKeyOnly(), "Private subtrees not currently supported: if you got this key from DKC.getWatchingKey() then use .dropPrivate().dropParent() on it first."))
        (§ call Preconditions.checkArgument(watchingKey.getPath().size() == getAccountPath().size(), "You can only watch an account key currently"))

        (§ ass basicKeyChain = new BasicKeyChain())
        (§ ass this.seed = nil)
        (§ ass this.rootKey = nil)
        (§ call basicKeyChain.importKey(watchingKey))
        (§ ass hierarchy = new DeterministicHierarchy(watchingKey))
        (§ call initializeHierarchyUnencrypted(watchingKey))
    )

    ;;;
     ; <p>Creates a deterministic key chain with the given watch key.  If <code>isFollowing</code> flag is set then this
     ; keychain follows some other keychain.  In a married wallet following keychain represents "spouse's" keychain.</p>
     ; <p>Watch key has to be an account key.</p>
     ;;
    #_protected
    (§ constructor DeterministicKeyChain(DeterministicKey watchKey, boolean isFollowing))
    (ß
        (§ this (watchKey))
        (§ ass this.isFollowing = isFollowing)
    )

    ;;;
     ; Creates a deterministic key chain with the given watch key and that follows some other keychain.
     ; In a married wallet following keychain represents "spouse".
     ; Watch key has to be an account key.
     ;;
    #_public
    #_static
    (§ method DeterministicKeyChain watchAndFollow(DeterministicKey watchKey))
    (ß
        (§ return new DeterministicKeyChain(watchKey, true))
    )

    ;;;
     ; Creates a key chain that watches the given account key.
     ;;
    #_public
    #_static
    (§ method DeterministicKeyChain watch(DeterministicKey accountKey))
    (ß
        (§ return new DeterministicKeyChain(accountKey))
    )

    ;;;
     ; For use in {@link KeyChainFactory} during deserialization.
     ;;
    #_protected
    (§ constructor DeterministicKeyChain(DeterministicSeed seed, #_nilable KeyCrypter crypter))
    (ß
        (§ ass this.seed = seed)
        (§ ass basicKeyChain = new BasicKeyChain(crypter))
        (§ if (!seed.isEncrypted()))
        (ß
            (§ ass rootKey = HDKeyDerivation.createMasterPrivateKey(Preconditions.checkNotNull(seed.getSeedBytes())))
            (§ call rootKey.setCreationTimeSeconds(seed.getCreationTimeSeconds()))
            (§ call basicKeyChain.importKey(rootKey))
            (§ ass hierarchy = new DeterministicHierarchy(rootKey))
            (§ for (int i = 1 :for i <= getAccountPath().size() :for i = i + 1))
                (§ call basicKeyChain.importKey(hierarchy.get(getAccountPath().subList(0, i), false, true)))
            (§ call initializeHierarchyUnencrypted(rootKey))
        )
        ;; Else...
        ;; We can't initialize ourselves with just an encrypted seed, so we expected deserialization code
        ;; to do the rest of the setup (loading the root key).
    )

    ;;;
     ; For use in encryption when {@link #toEncrypted(KeyCrypter, KeyParameter)} is called,
     ; so that subclasses can override that method and create an instance of the right class.
     ;
     ; See also {@link #makeKeyChainFromSeed(DeterministicSeed)}.
     ;;
    #_protected
    (§ constructor DeterministicKeyChain(KeyCrypter crypter, KeyParameter aesKey, DeterministicKeyChain chain))
    (ß
        ;; Can't encrypt a watching chain.
        (§ call Preconditions.checkNotNull(chain.rootKey))
        (§ call Preconditions.checkNotNull(chain.seed))

        (§ call Preconditions.checkArgument(!chain.rootKey.isEncrypted(), "Chain already encrypted"))

        (§ ass this.issuedExternalKeys = chain.issuedExternalKeys)
        (§ ass this.issuedInternalKeys = chain.issuedInternalKeys)

        (§ ass this.lookaheadSize = chain.lookaheadSize)
        (§ ass this.lookaheadThreshold = chain.lookaheadThreshold)

        (§ ass this.seed = chain.seed.encrypt(crypter, aesKey))
        (§ ass basicKeyChain = new BasicKeyChain(crypter))
        ;; The first number is the "account number" but we don't use that feature.
        (§ ass rootKey = chain.rootKey.encrypt(crypter, aesKey, nil))
        (§ ass hierarchy = new DeterministicHierarchy(rootKey))
        (§ call basicKeyChain.importKey(rootKey))

        (§ for (int i = 1 :for i < getAccountPath().size() :for i = i + 1))
            (§ call encryptNonLeaf(aesKey, chain, rootKey, getAccountPath().subList(0, i)))

        (§ var DeterministicKey account = encryptNonLeaf(aesKey, chain, rootKey, getAccountPath()))
        (§ ass externalParentKey = encryptNonLeaf(aesKey, chain, account, HDUtils.concat(getAccountPath(), EXTERNAL_SUBPATH)))
        (§ ass internalParentKey = encryptNonLeaf(aesKey, chain, account, HDUtils.concat(getAccountPath(), INTERNAL_SUBPATH)))

        ;; Now copy the (pubkey only) leaf keys across to avoid rederiving them.  The private key bytes are missing
        ;; anyway so there's nothing to encrypt.
        (§ for (ECKey eckey :for chain.basicKeyChain.getKeys()))
        (ß
            (§ var DeterministicKey key = (DeterministicKey)eckey)
            (§ if (key.getPath().size() != getAccountPath().size() + 2))
                (§ continue) ;; Not a leaf key.

            (§ var DeterministicKey parent = hierarchy.get(Preconditions.checkNotNull(key.getParent()).getPath(), false, false))
            ;; Clone the key to the new encrypted hierarchy.
            (§ ass key = new DeterministicKey(key.dropPrivateBytes(), parent))
            (§ call hierarchy.putKey(key))
            (§ call basicKeyChain.importKey(key))
        )
    )

    ;;; Override in subclasses to use a different account derivation path. ;;
    #_protected
    (§ method ImmutableList<ChildNumber> getAccountPath())
    (ß
        (§ return ACCOUNT_ZERO_PATH)
    )

    #_private
    (§ method DeterministicKey encryptNonLeaf(KeyParameter aesKey, DeterministicKeyChain chain, DeterministicKey parent, ImmutableList<ChildNumber> path))
    (ß
        (§ var DeterministicKey key = chain.hierarchy.get(path, false, false))
        (§ ass key = key.encrypt(Preconditions.checkNotNull(basicKeyChain.getKeyCrypter()), aesKey, parent))
        (§ call hierarchy.putKey(key))
        (§ call basicKeyChain.importKey(key))
        (§ return key)
    )

    ;; Derives the account path keys and inserts them into the basic key chain.
    ;; This is important to preserve their order for serialization, amongst other things.
    #_private
    (§ method void initializeHierarchyUnencrypted(DeterministicKey baseKey))
    (ß
        (§ ass externalParentKey = hierarchy.deriveChild(getAccountPath(), false, false, ChildNumber.ZERO))
        (§ ass internalParentKey = hierarchy.deriveChild(getAccountPath(), false, false, ChildNumber.ONE))
        (§ call basicKeyChain.importKey(externalParentKey))
        (§ call basicKeyChain.importKey(internalParentKey))
    )

    ;;; Returns a freshly derived key that has not been returned by this method before. ;;
    #_override
    #_public
    (§ method DeterministicKey getKey(KeyPurpose purpose))
    (ß
        (§ return getKeys(purpose, 1).get(0))
    )

    ;;; Returns freshly derived key/s that have not been returned by this method before. ;;
    #_override
    #_public
    (§ method List<DeterministicKey> getKeys(KeyPurpose purpose, int numberOfKeys))
    (ß
        (§ call Preconditions.checkArgument(0 < numberOfKeys))
        (§ call lock.lock())
        (§ try)
        (ß
            (§ var DeterministicKey parentKey)
            (§ var int index)
            (§ switch (purpose))
            (ß
                ;; Map both REFUND and RECEIVE_KEYS to the same branch for now.  Refunds are a feature of the BIP 70
                ;; payment protocol.  Later we may wish to map it to a different branch (in a new wallet version?).
                ;; This would allow a watching wallet to only be able to see inbound payments, but not change
                ;; (i.e. spends) or refunds.  Might be useful for auditing ...
                (§ case RECEIVE_FUNDS)
                (§ case REFUND)
                    (§ ass issuedExternalKeys = issuedExternalKeys + numberOfKeys)
                    (§ ass index = issuedExternalKeys)
                    (§ ass parentKey = externalParentKey)
                    (§ break)
                (§ case AUTHENTICATION)
                (§ case CHANGE)
                    (§ ass issuedInternalKeys = issuedInternalKeys + numberOfKeys)
                    (§ ass index = issuedInternalKeys)
                    (§ ass parentKey = internalParentKey)
                    (§ break)
                (§ default)
                    (§ throw new UnsupportedOperationException())
            )
            ;; Optimization: potentially do a very quick key generation for just the number of keys we need if we
            ;; didn't already create them, ignoring the configured lookahead size.  This ensures we'll be able to
            ;; retrieve the keys in the following loop, but if we're totally fresh and didn't get a chance to
            ;; calculate the lookahead keys yet, this will not block waiting to calculate 100+ EC point multiplies.
            ;; On slow/crappy Android phones looking ahead 100 keys can take ~5 seconds but the OS will kill us
            ;; if we block for just one second on the UI thread.  Because UI threads may need an address in order
            ;; to render the screen, we need getKeys to be fast even if the wallet is totally brand new and lookahead
            ;; didn't happen yet.
            ;;
            ;; It's safe to do this because when a network thread tries to calculate a Bloom filter, we'll go ahead
            ;; and calculate the full lookahead zone there, so network requests will always use the right amount.
            (§ var List<DeterministicKey> lookahead = maybeLookAhead(parentKey, index, 0, 0))
            (§ call basicKeyChain.importKeys(lookahead))
            (§ var List<DeterministicKey> keys = new ArrayList<>(numberOfKeys))
            (§ for (int i = 0 :for i < numberOfKeys :for i = i + 1))
            (ß
                (§ var ImmutableList<ChildNumber> path = HDUtils.append(parentKey.getPath(), new ChildNumber(index - numberOfKeys + i, false)))
                (§ var DeterministicKey k = hierarchy.get(path, false, false))
                ;; Just a last minute sanity check before we hand the key out to the app for usage.  This isn't
                ;; inspired by any real problem reports from bitcoinj users, but I've heard of cases via the grapevine
                ;; of places that lost money due to bitflips causing addresses to not match keys.  Of course in an
                ;; environment with flaky RAM there's no real way to always win: bitflips could be introduced at any
                ;; other layer.  But as we're potentially retrieving from long term storage here, check anyway.
                (§ call checkForBitFlip(k))
                (§ call keys.add(k))
            )
            (§ return keys)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    #_private
    (§ method void checkForBitFlip(DeterministicKey k))
    (ß
        (§ var DeterministicKey parent = Preconditions.checkNotNull(k.getParent()))
        (§ var byte[] rederived = HDKeyDerivation.deriveChildKeyBytesFromPublic(parent, k.getChildNumber(), HDKeyDerivation.PublicDeriveMode.WITH_INVERSION).keyBytes)
        (§ var byte[] actual = k.getPubKey())
        (§ if (!Arrays.equals(rederived, actual)))
            (§ throw new IllegalStateException(String.format(Locale.US, "Bit-flip check failed: %s vs %s", Arrays.toString(rederived), Arrays.toString(actual))))
    )

    ;;;
     ; Mark the DeterministicKey as used.
     ; Also correct the issued{Internal|External}Keys counter, because all lower children seem to be requested already.
     ; If the counter was updated, we also might trigger lookahead.
     ;;
    #_public
    (§ method DeterministicKey markKeyAsUsed(DeterministicKey k))
    (ß
        (§ var int numChildren = k.getChildNumber().i() + 1)

        (§ if (k.getParent() == internalParentKey))
        (ß
            (§ if (issuedInternalKeys < numChildren))
            (ß
                (§ ass issuedInternalKeys = numChildren)
                (§ call maybeLookAhead())
            )
        )
        (§ elseif (k.getParent() == externalParentKey))
        (ß
            (§ if (issuedExternalKeys < numChildren))
            (ß
                (§ ass issuedExternalKeys = numChildren)
                (§ call maybeLookAhead())
            )
        )
        (§ return k)
    )

    #_public
    (§ method DeterministicKey findKeyFromPubHash(byte[] pubkeyHash))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ return (DeterministicKey)basicKeyChain.findKeyFromPubHash(pubkeyHash))
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    #_public
    (§ method DeterministicKey findKeyFromPubKey(byte[] pubkey))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ return (DeterministicKey)basicKeyChain.findKeyFromPubKey(pubkey))
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Mark the DeterministicKeys as used, if they match the pubkeyHash.
     ; See {@link DeterministicKeyChain#markKeyAsUsed(DeterministicKey)} for more info on this.
     ;;
    #_nilable
    #_public
    (§ method DeterministicKey markPubHashAsUsed(byte[] pubkeyHash))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ var DeterministicKey k = (DeterministicKey)basicKeyChain.findKeyFromPubHash(pubkeyHash))
            (§ if (k != nil))
                (§ call markKeyAsUsed(k))
            (§ return k)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Mark the DeterministicKeys as used, if they match the pubkey.
     ; See {@link DeterministicKeyChain#markKeyAsUsed(DeterministicKey)} for more info on this.
     ;;
    #_nilable
    #_public
    (§ method DeterministicKey markPubKeyAsUsed(byte[] pubkey))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ var DeterministicKey k = (DeterministicKey)basicKeyChain.findKeyFromPubKey(pubkey))
            (§ if (k != nil))
                (§ call markKeyAsUsed(k))
            (§ return k)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    #_override
    #_public
    (§ method boolean hasKey(ECKey key))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ return basicKeyChain.hasKey(key))
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;; Returns the deterministic key for the given absolute path in the hierarchy. ;;
    #_protected
    (§ method DeterministicKey getKeyByPath(ChildNumber... path))
    (ß
        (§ return getKeyByPath(ImmutableList.copyOf(path)))
    )

    ;;; Returns the deterministic key for the given absolute path in the hierarchy. ;;
    #_protected
    (§ method DeterministicKey getKeyByPath(List<ChildNumber> path))
    (ß
        (§ return getKeyByPath(path, false))
    )

    ;;; Returns the deterministic key for the given absolute path in the hierarchy, optionally creating it. ;;
    #_public
    (§ method DeterministicKey getKeyByPath(List<ChildNumber> path, boolean create))
    (ß
        (§ return hierarchy.get(path, false, create))
    )

    ;;;
     ; <p>An alias for <code>getKeyByPath(getAccountPath())</code>.</p>
     ;
     ; <p>Use this when you would like to create a watching key chain that follows this one, but can't spend money from it.
     ; The returned key can be serialized and then passed into {@link #watch(org.bitcoinj.crypto.DeterministicKey)}
     ; on another system to watch the hierarchy.</p>
     ;
     ; <p>Note that the returned key is not pubkey only unless this key chain already is: the returned key can still
     ; be used for signing etc if the private key bytes are available.</p>
     ;;
    #_public
    (§ method DeterministicKey getWatchingKey())
    (ß
        (§ return getKeyByPath(getAccountPath()))
    )

    ;;; Returns true if this chain is watch only, meaning it has public keys but no private key. ;;
    #_public
    (§ method boolean isWatching())
    (ß
        (§ return getWatchingKey().isWatching())
    )

    #_override
    #_public
    (§ method int numKeys())
    (ß
        ;; We need to return here the total number of keys including the lookahead zone, not the number
        ;; of keys we have issued via getKey/freshReceiveKey.
        (§ call lock.lock())
        (§ try)
        (ß
            (§ call maybeLookAhead())
            (§ return basicKeyChain.numKeys())
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Returns number of leaf keys used including both internal and external paths.  This may be fewer
     ; than the number that have been deserialized or held in memory, because of the lookahead zone.
     ;;
    #_public
    (§ method int numLeafKeysIssued())
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ return issuedExternalKeys + issuedInternalKeys)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    #_override
    #_public
    (§ method long getEarliestKeyCreationTime())
    (ß
        (§ return (seed != nil) ? seed.getCreationTimeSeconds() :else getWatchingKey().getCreationTimeSeconds())
    )

    #_override
    #_public
    (§ method void addEventListener(KeyChainEventListener listener))
    (ß
        (§ call basicKeyChain.addEventListener(listener))
    )

    #_override
    #_public
    (§ method void addEventListener(KeyChainEventListener listener, Executor executor))
    (ß
        (§ call basicKeyChain.addEventListener(listener, executor))
    )

    #_override
    #_public
    (§ method boolean removeEventListener(KeyChainEventListener listener))
    (ß
        (§ return basicKeyChain.removeEventListener(listener))
    )

    ;;; Returns a list of words that represent the seed or null if this chain is a watching chain. ;;
    #_nilable
    #_public
    (§ method List<String> getMnemonicCode())
    (ß
        (§ if (seed == nil))
            (§ return nil)

        (§ call lock.lock())
        (§ try)
        (ß
            (§ return seed.getMnemonicCode())
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Return true if this keychain is following another keychain.
     ;;
    #_public
    (§ method boolean isFollowing())
    (ß
        (§ return isFollowing)
    )

    #_override
    #_public
    (§ method List<Protos.Key> serializeToProtobuf())
    (ß
        (§ var List<Protos.Key> result = newArrayList())
        (§ call lock.lock())
        (§ try)
        (ß
            (§ call result.addAll(serializeMyselfToProtobuf()))
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
        (§ return result)
    )

    #_protected
    (§ method List<Protos.Key> serializeMyselfToProtobuf())
    (ß
        ;; Most of the serialization work is delegated to the basic key chain, which will serialize the bulk of the
        ;; data (handling encryption along the way), and letting us patch it up with the extra data we care about.
        (§ var LinkedList<Protos.Key> entries = newLinkedList())
        (§ if (seed != nil))
        (ß
            (§ var Protos.Key.Builder mnemonicEntry = BasicKeyChain.serializeEncryptableItem(seed))
            (§ call mnemonicEntry.setType(Protos.Key.Type.DETERMINISTIC_MNEMONIC))
            (§ call serializeSeedEncryptableItem(seed, mnemonicEntry))
            (§ call entries.add(mnemonicEntry.build()))
        )
        (§ var Map<ECKey, Protos.Key.Builder> keys = basicKeyChain.serializeToEditableProtobufs())
        (§ for (Map.Entry<ECKey, Protos.Key.Builder> entry :for keys.entrySet()))
        (ß
            (§ var DeterministicKey key = (DeterministicKey)entry.getKey())
            (§ var Protos.Key.Builder proto = entry.getValue())
            (§ call proto.setType(Protos.Key.Type.DETERMINISTIC_KEY))
            #_final
            (§ var Protos.DeterministicKey.Builder detKey = proto.getDeterministicKeyBuilder())
            (§ call detKey.setChainCode(ByteString.copyFrom(key.getChainCode())))
            (§ for (ChildNumber num :for key.getPath()))
                (§ call detKey.addPath(num.i()))
            (§ if (key.equals(externalParentKey)))
            (ß
                (§ call detKey.setIssuedSubkeys(issuedExternalKeys))
                (§ call detKey.setLookaheadSize(lookaheadSize))
                (§ call detKey.setSigsRequiredToSpend(getSigsRequiredToSpend()))
            )
            (§ elseif (key.equals(internalParentKey)))
            (ß
                (§ call detKey.setIssuedSubkeys(issuedInternalKeys))
                (§ call detKey.setLookaheadSize(lookaheadSize))
                (§ call detKey.setSigsRequiredToSpend(getSigsRequiredToSpend()))
            )
            ;; Flag the very first key of following keychain.
            (§ if (entries.isEmpty() && isFollowing()))
                (§ call detKey.setIsFollowing(true))
            ;; HD keys inherit the timestamp of their parent if they have one, so no need to serialize it.
            (§ if (key.getParent() != nil))
                (§ call proto.clearCreationTimestamp())
            (§ call entries.add(proto.build()))
        )
        (§ return entries)
    )

    #_static
    (§ method List<DeterministicKeyChain> fromProtobuf(List<Protos.Key> keys, #_nilable KeyCrypter crypter))
        (§ throws UnreadableWalletException)
    (ß
        (§ return fromProtobuf(keys, crypter, new DefaultKeyChainFactory()))
    )

    ;;;
     ; Returns all the key chains found in the given list of keys.  Typically there will only be one,
     ; but in the case of key rotation it can happen that there are multiple chains found.
     ;;
    #_public
    #_static
    (§ method List<DeterministicKeyChain> fromProtobuf(List<Protos.Key> keys, #_nilable KeyCrypter crypter, KeyChainFactory factory))
        (§ throws UnreadableWalletException)
    (ß
        (§ var List<DeterministicKeyChain> chains = newLinkedList())
        (§ var DeterministicSeed seed = nil)
        (§ var DeterministicKeyChain chain = nil)

        (§ var int lookaheadSize = -1)
        (§ var int sigsRequiredToSpend = 1)

        (§ var PeekingIterator<Protos.Key> iter = Iterators.peekingIterator(keys.iterator()))
        (§ while (iter.hasNext()))
        (ß
            (§ var Protos.Key key = iter.next())
            #_final
            (§ var Protos.Key.Type t = key.getType())
            (§ if (t == Protos.Key.Type.DETERMINISTIC_MNEMONIC))
            (ß
                (§ if (chain != nil))
                (ß
                    (§ call Preconditions.checkState(0 <= lookaheadSize))

                    (§ call chain.setLookaheadSize(lookaheadSize))
                    (§ call chain.setSigsRequiredToSpend(sigsRequiredToSpend))
                    (§ call chain.maybeLookAhead())
                    (§ call chains.add(chain))
                    (§ ass chain = nil)
                )
                (§ var long timestamp = key.getCreationTimestamp() / 1000)
                (§ var String passphrase = DEFAULT_PASSPHRASE_FOR_MNEMONIC) ;; FIXME allow non-empty passphrase
                (§ if (key.hasSecretBytes()))
                (ß
                    (§ if (key.hasEncryptedDeterministicSeed()))
                        (§ throw new UnreadableWalletException("Malformed key proto: " + key))

                    (§ var byte[] seedBytes = nil)
                    (§ if (key.hasDeterministicSeed()))
                        (§ ass seedBytes = key.getDeterministicSeed().toByteArray())
                    (§ ass seed = new DeterministicSeed(key.getSecretBytes().toStringUtf8(), seedBytes, passphrase, timestamp))
                )
                (§ elseif (key.hasEncryptedData()))
                (ß
                    (§ if (key.hasDeterministicSeed()))
                        (§ throw new UnreadableWalletException("Malformed key proto: " + key))

                    (§ var EncryptedData data = new EncryptedData(key.getEncryptedData().getInitialisationVector().toByteArray(), key.getEncryptedData().getEncryptedPrivateKey().toByteArray()))
                    (§ var EncryptedData encryptedSeedBytes = nil)
                    (§ if (key.hasEncryptedDeterministicSeed()))
                    (ß
                        (§ var Protos.EncryptedData encryptedSeed = key.getEncryptedDeterministicSeed())
                        (§ ass encryptedSeedBytes = new EncryptedData(encryptedSeed.getInitialisationVector().toByteArray(), encryptedSeed.getEncryptedPrivateKey().toByteArray()))
                    )
                    (§ ass seed = new DeterministicSeed(data, encryptedSeedBytes, timestamp))
                )
                (§ else)
                    (§ throw new UnreadableWalletException("Malformed key proto: " + key))

                (§ if (log.isDebugEnabled()))
                    (§ call log.debug("Deserializing: DETERMINISTIC_MNEMONIC: {}", seed))
            )
            (§ elseif (t == Protos.Key.Type.DETERMINISTIC_KEY))
            (ß
                (§ if (!key.hasDeterministicKey()))
                    (§ throw new UnreadableWalletException("Deterministic key missing extra data: " + key))

                (§ var byte[] chainCode = key.getDeterministicKey().getChainCode().toByteArray())
                ;; Deserialize the path through the tree.
                (§ var LinkedList<ChildNumber> path = newLinkedList())
                (§ for (int i :for key.getDeterministicKey().getPathList()))
                    (§ call path.add(new ChildNumber(i)))

                ;; Deserialize the public key and path.
                (§ var LazyECPoint pubkey = new LazyECPoint(ECKey.CURVE.getCurve(), key.getPublicKey().toByteArray()))
                #_final
                (§ var ImmutableList<ChildNumber> immutablePath = ImmutableList.copyOf(path))
                ;; Possibly create the chain, if we didn't already do so yet.
                (§ var boolean isWatchingAccountKey = false)
                (§ var boolean isFollowingKey = false)
                ;; Save previous chain if any if the key is marked as following.  Current key and the next ones
                ;; are to be placed in new following key chain.
                (§ if (key.getDeterministicKey().getIsFollowing()))
                (ß
                    (§ if (chain != nil))
                    (ß
                        (§ call Preconditions.checkState(0 <= lookaheadSize))

                        (§ call chain.setLookaheadSize(lookaheadSize))
                        (§ call chain.setSigsRequiredToSpend(sigsRequiredToSpend))
                        (§ call chain.maybeLookAhead())
                        (§ call chains.add(chain))
                        (§ ass chain = nil)
                        (§ ass seed = nil)
                    )
                    (§ ass isFollowingKey = true)
                )

                (§ if (chain == nil))
                (ß
                    ;; If this is not a following chain and previous was, this must be married.
                    (§ var boolean isMarried = (!isFollowingKey && !chains.isEmpty() && chains.get(chains.size() - 1).isFollowing()))
                    (§ if (seed == nil))
                    (ß
                        (§ var DeterministicKey accountKey = new DeterministicKey(immutablePath, chainCode, pubkey, nil, nil))
                        (§ call accountKey.setCreationTimeSeconds(key.getCreationTimestamp() / 1000))
                        (§ ass chain = factory.makeWatchingKeyChain(key, iter.peek(), accountKey, isFollowingKey, isMarried))
                        (§ ass isWatchingAccountKey = true)
                    )
                    (§ else)
                    (ß
                        (§ ass chain = factory.makeKeyChain(key, iter.peek(), seed, crypter, isMarried))
                        (§ ass chain.lookaheadSize = LAZY_CALCULATE_LOOKAHEAD)
                        ;; If the seed is encrypted, then the chain is incomplete at this point.  However, we will load
                        ;; it up below as we parse in the keys.  We just need to check at the end that we've loaded
                        ;; everything afterwards.
                    )
                )
                ;; Find the parent key assuming this is not the root key, and not an account key for a watching chain.
                (§ var DeterministicKey parent = nil)
                (§ if (!path.isEmpty() && !isWatchingAccountKey))
                (ß
                    (§ var ChildNumber index = path.removeLast())
                    (§ ass parent = chain.hierarchy.get(path, false, false))
                    (§ call path.add(index))
                )
                (§ var DeterministicKey detkey)
                (§ if (key.hasSecretBytes()))
                (ß
                    ;; Not encrypted: private key is available.
                    #_final
                    (§ var BigInteger priv = new BigInteger(1, key.getSecretBytes().toByteArray()))
                    (§ ass detkey = new DeterministicKey(immutablePath, chainCode, pubkey, priv, parent))
                )
                (§ else)
                (ß
                    (§ if (key.hasEncryptedData()))
                    (ß
                        (§ var Protos.EncryptedData proto = key.getEncryptedData())
                        (§ var EncryptedData data = new EncryptedData(proto.getInitialisationVector().toByteArray(), proto.getEncryptedPrivateKey().toByteArray()))
                        (§ call Preconditions.checkNotNull(crypter, "Encountered an encrypted key but no key crypter provided"))
                        (§ ass detkey = new DeterministicKey(immutablePath, chainCode, crypter, pubkey, data, parent))
                    )
                    (§ else)
                    (ß
                        ;; No secret key bytes and key is not encrypted: either a watching key or private key bytes
                        ;; will be rederived on the fly from the parent.
                        (§ ass detkey = new DeterministicKey(immutablePath, chainCode, pubkey, nil, parent))
                    )
                )
                (§ if (key.hasCreationTimestamp()))
                    (§ call detkey.setCreationTimeSeconds(key.getCreationTimestamp() / 1000))
                (§ if (log.isDebugEnabled()))
                    (§ call log.debug("Deserializing: DETERMINISTIC_KEY: {}", detkey))
                (§ if (!isWatchingAccountKey))
                (ß
                    ;; If the non-encrypted case, the non-leaf keys (account, internal, external) have already
                    ;; been rederived and inserted at this point.  In the encrypted case though, we can't
                    ;; rederive and we must reinsert, potentially building the heirarchy object if need be.
                    (§ if (path.size() == 0))
                    (ß
                        ;; Master key.
                        (§ if (chain.rootKey == nil))
                        (ß
                            (§ ass chain.rootKey = detkey)
                            (§ ass chain.hierarchy = new DeterministicHierarchy(detkey))
                        )
                    )
                    (§ elseif (path.size() == chain.getAccountPath().size() + 1))
                    (ß
                        (§ if (detkey.getChildNumber().num() == 0))
                        (ß
                            (§ ass chain.externalParentKey = detkey)
                            (§ ass chain.issuedExternalKeys = key.getDeterministicKey().getIssuedSubkeys())
                            (§ ass lookaheadSize = Math.max(lookaheadSize, key.getDeterministicKey().getLookaheadSize()))
                            (§ ass sigsRequiredToSpend = key.getDeterministicKey().getSigsRequiredToSpend())
                        )
                        (§ elseif (detkey.getChildNumber().num() == 1))
                        (ß
                            (§ ass chain.internalParentKey = detkey)
                            (§ ass chain.issuedInternalKeys = key.getDeterministicKey().getIssuedSubkeys())
                        )
                    )
                )
                (§ call chain.hierarchy.putKey(detkey))
                (§ call chain.basicKeyChain.importKey(detkey))
            )
        )
        (§ if (chain != nil))
        (ß
            (§ call Preconditions.checkState(lookaheadSize >= 0))
            (§ call chain.setLookaheadSize(lookaheadSize))
            (§ call chain.setSigsRequiredToSpend(sigsRequiredToSpend))
            (§ call chain.maybeLookAhead())
            (§ call chains.add(chain))
        )
        (§ return chains)
    )

    #_override
    #_public
    (§ method DeterministicKeyChain toEncrypted(CharSequence password))
    (ß
        (§ call Preconditions.checkNotNull(password))
        (§ call Preconditions.checkArgument(0 < password.length()))
        (§ call Preconditions.checkState(seed != nil, "Attempt to encrypt a watching chain."))
        (§ call Preconditions.checkState(!seed.isEncrypted()))

        (§ var KeyCrypter scrypt = new KeyCrypterScrypt())
        (§ var KeyParameter derivedKey = scrypt.deriveKey(password))
        (§ return toEncrypted(scrypt, derivedKey))
    )

    #_override
    #_public
    (§ method DeterministicKeyChain toEncrypted(KeyCrypter keyCrypter, KeyParameter aesKey))
    (ß
        (§ return new DeterministicKeyChain(keyCrypter, aesKey, this))
    )

    #_override
    #_public
    (§ method DeterministicKeyChain toDecrypted(CharSequence password))
    (ß
        (§ call Preconditions.checkNotNull(password))
        (§ call Preconditions.checkArgument(0 < password.length()))

        (§ var KeyCrypter crypter = getKeyCrypter())
        (§ call Preconditions.checkState(crypter != nil, "Chain not encrypted"))
        (§ var KeyParameter derivedKey = crypter.deriveKey(password))
        (§ return toDecrypted(derivedKey))
    )

    #_override
    #_public
    (§ method DeterministicKeyChain toDecrypted(KeyParameter aesKey))
    (ß
        (§ call Preconditions.checkState(getKeyCrypter() != nil, "Key chain not encrypted"))
        (§ call Preconditions.checkState(seed != nil, "Can't decrypt a watching chain"))
        (§ call Preconditions.checkState(seed.isEncrypted()))

        (§ var String passphrase = DEFAULT_PASSPHRASE_FOR_MNEMONIC) ;; FIXME allow non-empty passphrase
        (§ var DeterministicSeed decSeed = seed.decrypt(getKeyCrypter(), passphrase, aesKey))
        (§ var DeterministicKeyChain chain = makeKeyChainFromSeed(decSeed))
        ;; Now double check that the keys match to catch the case where the key is wrong but padding didn't catch it.
        (§ if (!chain.getWatchingKey().getPubKeyPoint().equals(getWatchingKey().getPubKeyPoint())))
            (§ throw new KeyCrypterException("Provided AES key is wrong"))

        (§ ass chain.lookaheadSize = lookaheadSize)
        ;; Now copy the (pubkey only) leaf keys across to avoid rederiving them.  The private key bytes are missing
        ;; anyway so there's nothing to decrypt.
        (§ for (ECKey eckey :for basicKeyChain.getKeys()))
        (ß
            (§ var DeterministicKey key = (DeterministicKey)eckey)
            (§ if (key.getPath().size() != getAccountPath().size() + 2))
                (§ continue) ;; Not a leaf key.

            (§ call Preconditions.checkState(key.isEncrypted()))
            (§ var DeterministicKey parent = chain.hierarchy.get(Preconditions.checkNotNull(key.getParent()).getPath(), false, false))
            ;; Clone the key to the new decrypted hierarchy.
            (§ ass key = new DeterministicKey(key.dropPrivateBytes(), parent))
            (§ call chain.hierarchy.putKey(key))
            (§ call chain.basicKeyChain.importKey(key))
        )
        (§ ass chain.issuedExternalKeys = issuedExternalKeys)
        (§ ass chain.issuedInternalKeys = issuedInternalKeys)
        (§ return chain)
    )

    ;;;
     ; Factory method to create a key chain from a seed.
     ; Subclasses should override this to create an instance of the subclass instead of a plain DKC.
     ; This is used in encryption/decryption.
     ;;
    #_protected
    (§ method DeterministicKeyChain makeKeyChainFromSeed(DeterministicSeed seed))
    (ß
        (§ return new DeterministicKeyChain(seed))
    )

    #_override
    #_public
    (§ method boolean checkPassword(CharSequence password))
    (ß
        (§ call Preconditions.checkNotNull(password))
        (§ call Preconditions.checkState(getKeyCrypter() != nil, "Key chain not encrypted"))

        (§ return checkAESKey(getKeyCrypter().deriveKey(password)))
    )

    #_override
    #_public
    (§ method boolean checkAESKey(KeyParameter aesKey))
    (ß
        (§ call Preconditions.checkState(rootKey != nil, "Can't check password for a watching chain"))
        (§ call Preconditions.checkNotNull(aesKey))
        (§ call Preconditions.checkState(getKeyCrypter() != nil, "Key chain not encrypted"))

        (§ try)
        (ß
            (§ return rootKey.decrypt(aesKey).getPubKeyPoint().equals(rootKey.getPubKeyPoint()))
        )
        (§ catch (KeyCrypterException _))
        (ß
            (§ return false)
        )
    )

    #_nilable
    #_override
    #_public
    (§ method KeyCrypter getKeyCrypter())
    (ß
        (§ return basicKeyChain.getKeyCrypter())
    )

    #_override
    #_public
    (§ method int numBloomFilterEntries())
    (ß
        (§ return numKeys() * 2)
    )

    #_override
    #_public
    (§ method BloomFilter getFilter(int size, double falsePositiveRate, long tweak))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ call Preconditions.checkArgument(numBloomFilterEntries() <= size))
            (§ call maybeLookAhead())
            (§ return basicKeyChain.getFilter(size, falsePositiveRate, tweak))
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; <p>The number of public keys we should pre-generate on each path before they are requested by the app.  This is
     ; required so that when scanning through the chain given only a seed, we can give enough keys to the remote node
     ; via the Bloom filter such that we see transactions that are "from the future", for example transactions created
     ; by a different app that's sharing the same seed, or transactions we made before but we're replaying the chain
     ; given just the seed. The default is 100.</p>
     ;;
    #_public
    (§ method int getLookaheadSize())
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ return lookaheadSize)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Sets a new lookahead size.  See {@link #getLookaheadSize()} for details on what this is.  Setting a new size
     ; that's larger than the current size will return immediately and the new size will only take effect next time
     ; a fresh filter is requested (e.g. due to a new peer being connected).  So you should set this before starting
     ; to sync the chain, if you want to modify it.  If you haven't modified the lookahead threshold manually then
     ; it will be automatically set to be a third of the new size.
     ;;
    #_public
    (§ method void setLookaheadSize(int lookaheadSize))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ var boolean readjustThreshold = (this.lookaheadThreshold == calcDefaultLookaheadThreshold()))
            (§ ass this.lookaheadSize = lookaheadSize)
            (§ if (readjustThreshold))
                (§ ass this.lookaheadThreshold = calcDefaultLookaheadThreshold())
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Sets the threshold for the key pre-generation.  This is used to avoid adding new keys and thus re-calculating
     ; Bloom filters every time a new key is calculated.  Without a lookahead threshold, every time we received
     ; a relevant transaction, we'd extend the lookahead zone and generate a new filter, which is inefficient.
     ;;
    #_public
    (§ method void setLookaheadThreshold(int num))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ if (lookaheadSize <= num))
                (§ throw new IllegalArgumentException("Threshold larger or equal to the lookaheadSize"))

            (§ ass this.lookaheadThreshold = num)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Gets the threshold for the key pre-generation.  See {@link #setLookaheadThreshold(int)} for details on what
     ; this is.  The default is a third of the lookahead size (100 / 3 == 33).  If you don't modify it explicitly,
     ; then this value will always be one third of the lookahead size.
     ;;
    #_public
    (§ method int getLookaheadThreshold())
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ return (lookaheadThreshold < lookaheadSize) ? lookaheadThreshold :else 0)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Pre-generate enough keys to reach the lookahead size.  You can call this if you need to explicitly invoke
     ; the lookahead procedure, but it's normally unnecessary as it will be done automatically when needed.
     ;;
    #_public
    (§ method void maybeLookAhead())
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ var List<DeterministicKey> keys = maybeLookAhead(externalParentKey, issuedExternalKeys))
            (§ call keys.addAll(maybeLookAhead(internalParentKey, issuedInternalKeys)))
            (§ if (keys.isEmpty()))
                (§ return)

            (§ ass keyLookaheadEpoch = keyLookaheadEpoch + 1)
            ;; Batch add all keys at once so there's only one event listener invocation, as this will be listened to
            ;; by the wallet and used to rebuild/broadcast the Bloom filter.  That's expensive so we don't want to do
            ;; it more often than necessary.
            (§ call basicKeyChain.importKeys(keys))
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    #_private
    (§ method List<DeterministicKey> maybeLookAhead(DeterministicKey parent, int issued))
    (ß
        (§ call Preconditions.checkState(lock.isHeldByCurrentThread()))

        (§ return maybeLookAhead(parent, issued, getLookaheadSize(), getLookaheadThreshold()))
    )

    ;;;
     ; Pre-generate enough keys to reach the lookahead size, but only if there are more than the lookaheadThreshold
     ; to be generated, so that the Bloom filter does not have to be regenerated that often.
     ;
     ; The returned mutable list of keys must be inserted into the basic key chain.
     ;;
    #_private
    (§ method List<DeterministicKey> maybeLookAhead(DeterministicKey parent, int issued, int lookaheadSize, int lookaheadThreshold))
    (ß
        (§ call Preconditions.checkState(lock.isHeldByCurrentThread()))

        #_final
        (§ var int numChildren = hierarchy.getNumChildren(parent.getPath()))
        #_final
        (§ var int needed = issued + lookaheadSize + lookaheadThreshold - numChildren)

        (§ if (needed <= lookaheadThreshold))
            (§ return new ArrayList<>())

        (§ call log.info("{} keys needed for {} = {} issued + {} lookahead size + {} lookahead threshold - {} num children", needed, parent.getPathAsString(), issued, lookaheadSize, lookaheadThreshold, numChildren))

        (§ var List<DeterministicKey> result  = new ArrayList<>(needed))
        #_final
        (§ var Stopwatch watch = Stopwatch.createStarted())
        (§ var int nextChild = numChildren)
        (§ for (int i = 0 :for i < needed :for i = i + 1))
        (ß
            (§ var DeterministicKey key = HDKeyDerivation.deriveThisOrNextChildKey(parent, nextChild))
            (§ ass key = key.dropPrivateBytes())
            (§ call hierarchy.putKey(key))
            (§ call result.add(key))
            (§ ass nextChild = key.getChildNumber().num() + 1)
        )
        (§ call watch.stop())
        (§ call log.info("Took {}", watch))
        (§ return result)
    )

    ;;; Housekeeping call to call when lookahead might be needed.  Normally called automatically by KeychainGroup. ;;
    #_public
    (§ method void maybeLookAheadScripts())
    (ß
    )

    ;;;
     ; Returns number of keys used on external path.  This may be fewer than the number that have been deserialized
     ; or held in memory, because of the lookahead zone.
     ;;
    #_public
    (§ method int getIssuedExternalKeys())
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ return issuedExternalKeys)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Returns number of keys used on internal path.  This may be fewer than the number that have been deserialized
     ; or held in memory, because of the lookahead zone.
     ;;
    #_public
    (§ method int getIssuedInternalKeys())
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ return issuedInternalKeys)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;; Returns the seed or null if this chain is a watching chain. ;;
    #_nilable
    #_public
    (§ method DeterministicSeed getSeed())
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ return seed)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;; For internal usage only.
    (§ method List<ECKey> getKeys(boolean includeLookahead, boolean includeParents))
    (ß
        (§ var List<ECKey> keys = basicKeyChain.getKeys())
        (§ if (!includeLookahead))
        (ß
            (§ var int treeSize = internalParentKey.getPath().size())
            (§ var List<ECKey> issuedKeys = new LinkedList<>())
            (§ for (ECKey key :for keys))
            (ß
                (§ var DeterministicKey detkey = (DeterministicKey)key)
                (§ var DeterministicKey parent = detkey.getParent())
                (§ if (!includeParents && parent == nil))
                    (§ continue)
                (§ if (!includeParents && detkey.getPath().size() <= treeSize))
                    (§ continue)
                (§ if (internalParentKey.equals(parent) && issuedInternalKeys <= detkey.getChildNumber().i()))
                    (§ continue)
                (§ if (externalParentKey.equals(parent) && issuedExternalKeys <= detkey.getChildNumber().i()))
                    (§ continue)
                (§ call issuedKeys.add(detkey))
            )
            (§ return issuedKeys)
        )
        (§ return keys)
    )

    ;;;
     ; Returns only the external keys that have been issued by this chain, lookahead not included.
     ;;
    #_public
    (§ method List<ECKey> getIssuedReceiveKeys())
    (ß
        #_final
        (§ var List<ECKey> keys = new ArrayList<>(getKeys(false, false)))
        (§ for (Iterator<ECKey> i = keys.iterator() :for i.hasNext() :for ))
        (ß
            (§ var DeterministicKey parent = ((DeterministicKey)i.next()).getParent())
            (§ if (parent == nil || !externalParentKey.equals(parent)))
                (§ call i.remove())
        )
        (§ return keys)
    )

    ;;;
     ; Returns leaf keys issued by this chain (including lookahead zone).
     ;;
    #_public
    (§ method List<DeterministicKey> getLeafKeys())
    (ß
        (§ var ImmutableList.Builder<DeterministicKey> keys = ImmutableList.builder())
        (§ for (ECKey key :for getKeys(true, false)))
        (ß
            (§ var DeterministicKey dKey = (DeterministicKey)key)
            (§ if (dKey.getPath().size() == getAccountPath().size() + 2))
                (§ call keys.add(dKey))
        )
        (§ return keys.build())
    )

    #_static
    (§ method void serializeSeedEncryptableItem(DeterministicSeed seed, Protos.Key.Builder proto))
    (ß
        ;; The seed can be missing if we have not derived it yet from the mnemonic.
        ;; This will not normally happen once all the wallets are on the latest code that caches the seed.
        (§ if (seed.isEncrypted() && seed.getEncryptedSeedData() != nil))
        (ß
            (§ var EncryptedData data = seed.getEncryptedSeedData())
            (§ call proto.getEncryptedDeterministicSeedBuilder().setEncryptedPrivateKey(ByteString.copyFrom(data.encryptedBytes)).setInitialisationVector(ByteString.copyFrom(data.initialisationVector)))
            ;; We don't allow mixing of encryption types at the moment.
            (§ call Preconditions.checkState(seed.getEncryptionType() == Protos.Wallet.EncryptionType.ENCRYPTED_SCRYPT_AES))
        )
        (§ else)
        (ß
            #_final
            (§ var byte[] secret = seed.getSeedBytes())
            (§ if (secret != nil))
                (§ call proto.setDeterministicSeed(ByteString.copyFrom(secret)))
        )
    )

    ;;;
     ; Returns a counter that is incremented each time new keys are generated due to lookahead.
     ; Used by the network code to learn whether to discard the current block and await calculation
     ; of a new filter.
     ;;
    #_public
    (§ method int getKeyLookaheadEpoch())
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ return keyLookaheadEpoch)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Whether the keychain is married.  A keychain is married when it vends P2SH addresses from
     ; multiple keychains in a multisig relationship.
     ; @see org.bitcoinj.wallet.MarriedKeyChain
     ;;
    #_public
    (§ method boolean isMarried())
    (ß
        (§ return false)
    )

    ;;; Get redeem data for a key.  Only applicable to married keychains. ;;
    #_public
    (§ method RedeemData getRedeemData(DeterministicKey followedKey))
    (ß
        (§ throw new UnsupportedOperationException())
    )

    ;;; Create a new key and return the matching output script.  Only applicable to married keychains. ;;
    #_public
    (§ method Script freshOutputScript(KeyPurpose purpose))
    (ß
        (§ throw new UnsupportedOperationException())
    )

    #_public
    (§ method String toString(boolean includePrivateKeys, NetworkParameters params))
    (ß
        #_final
        (§ var DeterministicKey watchingKey = getWatchingKey())
        #_final
        (§ var StringBuilder sb = new StringBuilder())
        (§ if (seed != nil))
        (ß
            (§ if (seed.isEncrypted()))
            (ß
                (§ call sb.append("Seed is encrypted\n"))
            )
            (§ elseif (includePrivateKeys))
            (ß
                #_final
                (§ var List<String> words = seed.getMnemonicCode())
                (§ call sb.append("Seed as words: ").append(Utils.SPACE_JOINER.join(words)).append("\n"))
                (§ call sb.append("Seed as hex:   ").append(seed.toHexString()).append("\n"))
            )
            (§ call sb.append("Seed birthday: ").append(seed.getCreationTimeSeconds()).append("  [").append(Utils.dateTimeFormat(seed.getCreationTimeSeconds() * 1000)).append("]\n"))
        )
        (§ else)
        (ß
            (§ call sb.append("Key birthday:  ").append(watchingKey.getCreationTimeSeconds()).append("  [").append(Utils.dateTimeFormat(watchingKey.getCreationTimeSeconds() * 1000)).append("]\n"))
        )
        (§ call sb.append("Key to watch:  ").append(watchingKey.serializePubB58(params)).append("\n"))
        (§ call formatAddresses(includePrivateKeys, params, sb))
        (§ return sb.toString())
    )

    #_protected
    (§ method void formatAddresses(boolean includePrivateKeys, NetworkParameters params, StringBuilder builder))
    (ß
        (§ for (ECKey key :for getKeys(false, true)))
            (§ call key.formatKeyWithAddress(includePrivateKeys, builder, params))
    )

    ;;; The number of signatures required to spend coins received by this keychain. ;;
    #_public
    (§ method void setSigsRequiredToSpend(int sigsRequiredToSpend))
    (ß
        (§ ass this.sigsRequiredToSpend = sigsRequiredToSpend)
    )

    ;;;
     ; Returns the number of signatures required to spend transactions for this KeyChain.
     ; It's the N from N-of-M CHECKMULTISIG script for P2SH transactions and always 1 for other transaction types.
     ;;
    #_public
    (§ method int getSigsRequiredToSpend())
    (ß
        (§ return sigsRequiredToSpend)
    )

    ;;; Returns the redeem script by its hash or null if this keychain did not generate the script. ;;
    #_nilable
    #_public
    (§ method RedeemData findRedeemDataByScriptHash(ByteString bytes))
    (ß
        (§ return nil)
    )
)

#_(ns org.bitcoinj.wallet #_"DeterministicSeed"
    (:import [java.security SecureRandom]
             [java.util List])
    (:import [com.google.common.base Charsets Objects Preconditions Splitter]
             [org.spongycastle.crypto.params KeyParameter])
  #_(:require [org.bitcoinj.core Utils]
             #_static #_[org.bitcoinj.core.Utils HEX]
             #_[org.bitcoinj.crypto *]))

;;;
 ; Holds the seed bytes for the BIP32 deterministic wallet algorithm, inside a {@link DeterministicKeyChain}.
 ; The purpose of this wrapper is to simplify the encryption code.
 ;;
#_public
(§ class DeterministicSeed implements EncryptableItem
    ;; It would take more than 10^12 years to brute-force a 128 bit seed using $1B worth of computing equipment.
    #_public
    #_static
    #_final
    (§ field int DEFAULT_SEED_ENTROPY_BITS = 128)
    #_public
    #_static
    #_final
    (§ field int MAX_SEED_ENTROPY_BITS = 512)

    #_nilable
    #_private
    #_final
    (§ field byte[] seed)
    #_nilable
    #_private
    #_final
    (§ field List<String> mnemonicCode) ;; only one of mnemonicCode/encryptedMnemonicCode will be set
    #_nilable
    #_private
    #_final
    (§ field EncryptedData encryptedMnemonicCode)
    #_nilable
    #_private
    (§ field EncryptedData encryptedSeed)
    #_private
    (§ field long creationTimeSeconds)

    #_public
    (§ constructor DeterministicSeed(String mnemonicCode, byte[] seed, String passphrase, long creationTimeSeconds))
        (§ throws UnreadableWalletException)
    (ß
        (§ this (decodeMnemonicCode(mnemonicCode), seed, passphrase, creationTimeSeconds))
    )

    #_public
    (§ constructor DeterministicSeed(byte[] seed, List<String> mnemonic, long creationTimeSeconds))
    (ß
        (§ ass this.seed = Preconditions.checkNotNull(seed))
        (§ ass this.mnemonicCode = Preconditions.checkNotNull(mnemonic))
        (§ ass this.encryptedMnemonicCode = nil)
        (§ ass this.creationTimeSeconds = creationTimeSeconds)
    )

    #_public
    (§ constructor DeterministicSeed(EncryptedData encryptedMnemonic, #_nilable EncryptedData encryptedSeed, long creationTimeSeconds))
    (ß
        (§ ass this.seed = nil)
        (§ ass this.mnemonicCode = nil)
        (§ ass this.encryptedMnemonicCode = Preconditions.checkNotNull(encryptedMnemonic))
        (§ ass this.encryptedSeed = encryptedSeed)
        (§ ass this.creationTimeSeconds = creationTimeSeconds)
    )

    ;;;
     ; Constructs a seed from a BIP 39 mnemonic code.
     ; See {@link org.bitcoinj.crypto.MnemonicCode} for more details on this scheme.
     ; @param mnemonicCode A list of words.
     ; @param seed The derived seed, or pass null to derive it from mnemonicCode (slow).
     ; @param passphrase A user supplied passphrase, or an empty string if there is no passphrase.
     ; @param creationTimeSeconds When the seed was originally created, UNIX time.
     ;;
    #_public
    (§ constructor DeterministicSeed(List<String> mnemonicCode, #_nilable byte[] seed, String passphrase, long creationTimeSeconds))
    (ß
        (§ this ((seed != nil) ? seed :else MnemonicCode.toSeed(mnemonicCode, Preconditions.checkNotNull(passphrase)), mnemonicCode, creationTimeSeconds))
    )

    ;;;
     ; Constructs a seed from a BIP 39 mnemonic code.
     ; See {@link org.bitcoinj.crypto.MnemonicCode} for more details on this scheme.
     ; @param random Entropy source.
     ; @param bits Number of bits, must be divisible by 32.
     ; @param passphrase A user supplied passphrase, or an empty string if there is no passphrase.
     ; @param creationTimeSeconds When the seed was originally created, UNIX time.
     ;;
    #_public
    (§ constructor DeterministicSeed(SecureRandom random, int bits, String passphrase, long creationTimeSeconds))
    (ß
        (§ this (getEntropy(random, bits), Preconditions.checkNotNull(passphrase), creationTimeSeconds))
    )

    ;;;
     ; Constructs a seed from a BIP 39 mnemonic code.
     ; See {@link org.bitcoinj.crypto.MnemonicCode} for more details on this scheme.
     ; @param entropy Entropy bits, length must be divisible by 32.
     ; @param passphrase A user supplied passphrase, or an empty string if there is no passphrase.
     ; @param creationTimeSeconds When the seed was originally created, UNIX time.
     ;;
    #_public
    (§ constructor DeterministicSeed(byte[] entropy, String passphrase, long creationTimeSeconds))
    (ß
        (§ call Preconditions.checkArgument(entropy.length % 4 == 0, "entropy size in bits not divisible by 32"))
        (§ call Preconditions.checkArgument(DEFAULT_SEED_ENTROPY_BITS <= entropy.length * 8, "entropy size too small"))
        (§ call Preconditions.checkNotNull(passphrase))

        (§ try)
        (ß
            (§ ass this.mnemonicCode = MnemonicCode.INSTANCE.toMnemonic(entropy))
        )
        (§ catch (MnemonicException.MnemonicLengthException e))
        (ß
            (§ throw new RuntimeException(e)) ;; Cannot happen.
        )
        (§ ass this.seed = MnemonicCode.toSeed(mnemonicCode, passphrase))
        (§ ass this.encryptedMnemonicCode = nil)
        (§ ass this.creationTimeSeconds = creationTimeSeconds)
    )

    #_private
    #_static
    (§ method byte[] getEntropy(SecureRandom random, int bits))
    (ß
        (§ call Preconditions.checkArgument(bits <= MAX_SEED_ENTROPY_BITS, "requested entropy size too large"))

        (§ var byte[] seed = new byte[bits / 8])
        (§ call random.nextBytes(seed))
        (§ return seed)
    )

    #_override
    #_public
    (§ method boolean isEncrypted())
    (ß
        (§ call Preconditions.checkState(mnemonicCode != nil || encryptedMnemonicCode != nil))
        (§ return (encryptedMnemonicCode != nil))
    )

    #_override
    #_public
    (§ method String toString())
    (ß
        (§ return isEncrypted() ? "DeterministicSeed [encrypted]" :else "DeterministicSeed " + toHexString() + " " + Utils.SPACE_JOINER.join(mnemonicCode))
    )

    ;;; Returns the seed as hex or null if encrypted. ;;
    #_nilable
    #_public
    (§ method String toHexString())
    (ß
        (§ return (seed != nil) ? HEX.encode(seed) :else nil)
    )

    #_nilable
    #_override
    #_public
    (§ method byte[] getSecretBytes())
    (ß
        (§ return getMnemonicAsBytes())
    )

    #_nilable
    #_public
    (§ method byte[] getSeedBytes())
    (ß
        (§ return seed)
    )

    #_nilable
    #_override
    #_public
    (§ method EncryptedData getEncryptedData())
    (ß
        (§ return encryptedMnemonicCode)
    )

    #_override
    #_public
    (§ method Protos.Wallet.EncryptionType getEncryptionType())
    (ß
        (§ return Protos.Wallet.EncryptionType.ENCRYPTED_SCRYPT_AES)
    )

    #_nilable
    #_public
    (§ method EncryptedData getEncryptedSeedData())
    (ß
        (§ return encryptedSeed)
    )

    #_override
    #_public
    (§ method long getCreationTimeSeconds())
    (ß
        (§ return creationTimeSeconds)
    )

    #_public
    (§ method void setCreationTimeSeconds(long creationTimeSeconds))
    (ß
        (§ ass this.creationTimeSeconds = creationTimeSeconds)
    )

    #_public
    (§ method DeterministicSeed encrypt(KeyCrypter keyCrypter, KeyParameter aesKey))
    (ß
        (§ call Preconditions.checkState(encryptedMnemonicCode == nil, "Trying to encrypt seed twice"))
        (§ call Preconditions.checkState(mnemonicCode != nil, "Mnemonic missing so cannot encrypt"))

        (§ var EncryptedData encryptedMnemonic = keyCrypter.encrypt(getMnemonicAsBytes(), aesKey))
        (§ var EncryptedData encryptedSeed = keyCrypter.encrypt(seed, aesKey))
        (§ return new DeterministicSeed(encryptedMnemonic, encryptedSeed, creationTimeSeconds))
    )

    #_private
    (§ method byte[] getMnemonicAsBytes())
    (ß
        (§ return Utils.SPACE_JOINER.join(mnemonicCode).getBytes(Charsets.UTF_8))
    )

    #_public
    (§ method DeterministicSeed decrypt(KeyCrypter crypter, String passphrase, KeyParameter aesKey))
    (ß
        (§ call Preconditions.checkState(isEncrypted()))
        (§ call Preconditions.checkNotNull(encryptedMnemonicCode))

        (§ var List<String> mnemonic = decodeMnemonicCode(crypter.decrypt(encryptedMnemonicCode, aesKey)))
        (§ var byte[] seed = (encryptedSeed != nil) ? crypter.decrypt(encryptedSeed, aesKey) :else nil)
        (§ return new DeterministicSeed(mnemonic, seed, passphrase, creationTimeSeconds))
    )

    #_override
    #_public
    (§ method boolean equals(Object o))
    (ß
        (§ if (this == o))
            (§ return true)
        (§ if (o == nil || getClass() != o.getClass()))
            (§ return false)
        (§ var DeterministicSeed other = (DeterministicSeed)o)
        (§ return (creationTimeSeconds == other.creationTimeSeconds && Objects.equal(encryptedMnemonicCode, other.encryptedMnemonicCode) && Objects.equal(mnemonicCode, other.mnemonicCode)))
    )

    #_override
    #_public
    (§ method int hashCode())
    (ß
        (§ return Objects.hashCode(creationTimeSeconds, encryptedMnemonicCode, mnemonicCode))
    )

    ;;;
     ; Check if our mnemonic is a valid mnemonic phrase for our word list.
     ; Does nothing if we are encrypted.
     ;
     ; @throws org.bitcoinj.crypto.MnemonicException if check fails.
     ;;
    #_public
    (§ method void check())
        (§ throws MnemonicException)
    (ß
        (§ if (mnemonicCode != nil))
            (§ call MnemonicCode.INSTANCE.check(mnemonicCode))
    )

    (§ method byte[] getEntropyBytes())
        (§ throws MnemonicException)
    (ß
        (§ return MnemonicCode.INSTANCE.toEntropy(mnemonicCode))
    )

    ;;; Get the mnemonic code, or null if unknown. ;;
    #_nilable
    #_public
    (§ method List<String> getMnemonicCode())
    (ß
        (§ return mnemonicCode)
    )

    #_private
    #_static
    (§ method List<String> decodeMnemonicCode(byte[] mnemonicCode))
    (ß
        (§ return decodeMnemonicCode(Utils.toString(mnemonicCode, "UTF-8")))
    )

    #_private
    #_static
    (§ method List<String> decodeMnemonicCode(String mnemonicCode))
    (ß
        (§ return Splitter.on(" ").splitToList(mnemonicCode))
    )
)

#_(ns org.bitcoinj.wallet #_"DeterministicUpgradeRequiredException")

;;;
 ; Indicates that an attempt was made to use HD wallet features on a wallet that was deserialized from an old,
 ; pre-HD random wallet without calling upgradeToDeterministic() beforehand.
 ;;
#_public
(§ class DeterministicUpgradeRequiredException extends RuntimeException)

#_(ns org.bitcoinj.wallet #_"DeterministicUpgradeRequiresPassword")

;;;
 ; Indicates that the pre-HD random wallet is encrypted, so you should try the upgrade again after getting the
 ; users password.  This is required because HD wallets are upgraded from random using the private key bytes of
 ; the oldest non-rotating key, in order to make the upgrade process itself deterministic.
 ;;
#_public
(§ class DeterministicUpgradeRequiresPassword extends RuntimeException)

#_(ns org.bitcoinj.wallet #_"EncryptableKeyChain"
    (:import [org.spongycastle.crypto.params KeyParameter])
  #_(:require [org.bitcoinj.crypto KeyCrypter KeyCrypterException]))

;;;
 ; An encryptable key chain is a key-chain that can be encrypted with a user-provided password or AES key.
 ;;
#_public
(§ interface EncryptableKeyChain extends KeyChain
    ;;;
     ; Takes the given password, which should be strong, derives a key from it and then invokes
     ; {@link #toEncrypted(org.bitcoinj.crypto.KeyCrypter, org.spongycastle.crypto.params.KeyParameter)}
     ; with {@link org.bitcoinj.crypto.KeyCrypterScrypt} as the crypter.
     ;
     ; @return the derived key, in case you wish to cache it for future use.
     ;;
    (§ method EncryptableKeyChain toEncrypted(CharSequence password))

    ;;;
     ; Returns a new keychain holding identical/cloned keys to this chain, but encrypted under the given key.
     ; Old keys and keychains remain valid and so you should ensure you don't accidentally hold references to them.
     ;;
    (§ method EncryptableKeyChain toEncrypted(KeyCrypter keyCrypter, KeyParameter aesKey))

    ;;;
     ; Decrypts the key chain with the given password.
     ; See {@link #toDecrypted(org.spongycastle.crypto.params.KeyParameter)} for details.
     ;;
    (§ method EncryptableKeyChain toDecrypted(CharSequence password))

    ;;;
     ; Decrypt the key chain with the given AES key and whatever {@link KeyCrypter} is already set.  Note that
     ; if you just want to spend money from an encrypted wallet, don't decrypt the whole thing first.  Instead,
     ; set the {@link org.bitcoinj.wallet.SendRequest#aesKey} field before asking the wallet to build the send.
     ;
     ; @param aesKey AES key to use (normally created using KeyCrypter#deriveKey and cached as it is time
     ;               consuming to create from a password).
     ; @throws KeyCrypterException if the wallet decryption fails.  If so, the wallet state is unchanged.
     ;;
    (§ method EncryptableKeyChain toDecrypted(KeyParameter aesKey))

    (§ method boolean checkPassword(CharSequence password))
    (§ method boolean checkAESKey(KeyParameter aesKey))

    ;;; Returns the key crypter used by this key chain, or null if it's not encrypted. ;;
    #_nilable
    (§ method KeyCrypter getKeyCrypter())
)

#_(ns org.bitcoinj.wallet #_"FilteringCoinSelector"
    (:import [java.util HashSet Iterator List])
  #_(:require #_[org.bitcoinj.core *]))

;;;
 ; A filtering coin selector delegates to another coin selector, but won't select outputs spent by the given transactions.
 ;;
#_public
(§ class FilteringCoinSelector implements CoinSelector
    #_protected
    (§ field CoinSelector delegate)
    #_protected
    (§ field HashSet<TransactionOutPoint> spent = new HashSet<>())

    #_public
    (§ constructor FilteringCoinSelector(CoinSelector delegate))
    (ß
        (§ ass this.delegate = delegate)
    )

    #_public
    (§ method void excludeOutputsSpentBy(Transaction tx))
    (ß
        (§ for (TransactionInput input :for tx.getInputs()))
            (§ call spent.add(input.getOutpoint()))
    )

    #_override
    #_public
    (§ method CoinSelection select(Coin target, List<TransactionOutput> candidates))
    (ß
        (§ var Iterator<TransactionOutput> iter = candidates.iterator())
        (§ while (iter.hasNext()))
        (ß
            (§ var TransactionOutput output = iter.next())
            (§ if (spent.contains(output.getOutPointFor())))
                (§ call iter.remove())
        )
        (§ return delegate.select(target, candidates))
    )
)

#_(ns org.bitcoinj.wallet #_"KeyBag"
  #_(:require [org.bitcoinj.core ECKey]))

;;;
 ; A KeyBag is simply an object that can map public keys, their 160-bit hashes and script hashes to ECKey
 ; and {@link RedeemData} objects.
 ;;
#_public
(§ interface KeyBag
    ;;;
     ; Locates a keypair from the keychain given the hash of the public key.  This is needed when finding out
     ; which key we need to use to redeem a transaction output.
     ;
     ; @return ECKey object or null if no such key was found.
     ;;
    #_nilable
    (§ method ECKey findKeyFromPubHash(byte[] pubkeyHash))

    ;;;
     ; Locates a keypair from the keychain given the raw public key bytes.
     ;
     ; @return ECKey or null if no such key was found.
     ;;
    #_nilable
    (§ method ECKey findKeyFromPubKey(byte[] pubkey))

    ;;;
     ; Locates a redeem data (redeem script and keys) from the keychain given the hash of the script.
     ; This is needed when finding out which key and script we need to use to locally sign a P2SH transaction input.
     ; It is assumed that wallet should not have more than one private key for a single P2SH tx for security reasons.
     ;
     ; @return RedeemData object or null if no such data was found.
     ;;
    #_nilable
    (§ method RedeemData findRedeemDataFromScriptHash(byte[] scriptHash))
)

#_(ns org.bitcoinj.wallet #_"KeyChain"
    (:import [java.util List]
             [java.util.concurrent Executor])
  #_(:require [org.bitcoinj.core BloomFilter ECKey]
             [org.bitcoinj.wallet.listeners KeyChainEventListener]))

;;;
 ; <p>A KeyChain is a class that stores a collection of keys for a {@link org.bitcoinj.wallet.Wallet}.  Key chains
 ; are expected to be able to look up keys given a hash (i.e. address) or pubkey bytes, and provide keys on request
 ; for a given purpose.  They can inform event listeners about new keys being added.</p>
 ;
 ; <p>However it is important to understand what this interface does <i>not</i> provide.  It cannot encrypt or decrypt
 ; keys, for instance you need an implementor of {@link EncryptableKeyChain}.  It cannot have keys imported into it,
 ; that you to use a method of a specific key chain instance, such as {@link BasicKeyChain}.  The reason for these
 ; restrictions is to support key chains that may be handled by external hardware or software, or which are derived
 ; deterministically from a seed (and thus the notion of importing a key is meaningless).</p>
 ;;
#_public
(§ interface KeyChain
    ;;; Returns true if the given key is in the chain. ;;
    (§ method boolean hasKey(ECKey key))

    (§ enum KeyPurpose
        (§ item RECEIVE_FUNDS)
        (§ item CHANGE)
        (§ item REFUND)
        (§ item AUTHENTICATION)
    )

    ;;;
     ; Obtains a number of key/s intended for the given purpose.
     ; The chain may create new key/s, derive, or re-use an old one.
     ;;
    (§ method List<? extends ECKey> getKeys(KeyPurpose purpose, int numberOfKeys))

    ;;;
     ; Obtains a key intended for the given purpose.
     ; The chain may create a new key, derive one, or re-use an old one.
     ;;
    (§ method ECKey getKey(KeyPurpose purpose))

    ;;; Returns a list of keys serialized to the bitcoinj protobuf format. ;;
    (§ method List<Protos.Key> serializeToProtobuf())

    ;;; Adds a listener for events that are run when keys are added, on the user thread. ;;
    (§ method void addEventListener(KeyChainEventListener listener))

    ;;; Adds a listener for events that are run when keys are added, on the given executor. ;;
    (§ method void addEventListener(KeyChainEventListener listener, Executor executor))

    ;;; Removes a listener for events that are run when keys are added. ;;
    (§ method boolean removeEventListener(KeyChainEventListener listener))

    ;;; Returns the number of keys this key chain manages. ;;
    (§ method int numKeys())

    ;;;
     ; Returns the number of elements this chain wishes to insert into the Bloom filter.
     ; The size passed to {@link #getFilter(int, double, long)} should be at least this large.
     ;;
    (§ method int numBloomFilterEntries())

    ;;;
     ; Returns the earliest creation time of keys in this chain, in seconds since the epoch.  This can return
     ; zero if at least one key does not have that data (was created before key timestamping was implemented).
     ; If there are no keys in the wallet, {@link Long#MAX_VALUE} is returned.
     ;;
    (§ method long getEarliestKeyCreationTime())

    ;;;
     ; <p>Gets a bloom filter that contains all of the public keys from this chain, and which will provide the given
     ; false-positive rate if it has size elements.  Keep in mind that you will get 2 elements in the bloom filter for
     ; each key in the key chain, for the public key and the hash of the public key (address form).  For this reason
     ; size should be <i>at least</i> 2x the result of {@link #numKeys()}.</p>
     ;
     ; <p>This is used to generate a {@link BloomFilter} which can be {@link BloomFilter#merge(BloomFilter)}d with
     ; another.  It could also be used if you have a specific target for the filter's size.</p>
     ;
     ; <p>See the docs for {@link org.bitcoinj.core.BloomFilter#BloomFilter(int, double, long)} for a brief
     ; explanation of anonymity when using bloom filters, and for the meaning of these parameters.</p>
     ;;
    (§ method BloomFilter getFilter(int size, double falsePositiveRate, long tweak))
)

#_(ns org.bitcoinj.wallet #_"KeyChainFactory"
  #_(:require [org.bitcoinj.crypto DeterministicKey KeyCrypter]))

;;;
 ; Factory interface for creation keychains while de-serializing a wallet.
 ;;
#_public
(§ interface KeyChainFactory
    ;;;
     ; Make a keychain (but not a watching one).
     ;
     ; @param key The protobuf for the root key.
     ; @param firstSubKey The protobuf for the first child key (normally the parent of the external subchain).
     ; @param seed The seed.
     ; @param crypter The encrypted/decrypter.
     ; @param isMarried Whether the keychain is leading in a marriage.
     ;;
    (§ method DeterministicKeyChain makeKeyChain(Protos.Key key, Protos.Key firstSubKey, DeterministicSeed seed, KeyCrypter crypter, boolean isMarried))

    ;;;
     ; Make a watching keychain.
     ;
     ; isMarried and isFollowingKey must not be true at the same time.
     ;
     ; @param key The protobuf for the account key.
     ; @param firstSubKey The protobuf for the first child key (normally the parent of the external subchain).
     ; @param accountKey The account extended public key.
     ; @param isFollowingKey Whether the keychain is following in a marriage.
     ; @param isMarried Whether the keychain is leading in a marriage.
     ;;
    (§ method DeterministicKeyChain makeWatchingKeyChain(Protos.Key key, Protos.Key firstSubKey, DeterministicKey accountKey, boolean isFollowingKey, boolean isMarried))
        (§ throws UnreadableWalletException)
)

#_(ns org.bitcoinj.wallet #_"KeyChainGroup"
    (:import #_[java.security *]
             #_[java.util *]
             #_[java.util.concurrent *])
    (:import [com.google.common.base Preconditions]
             #_[com.google.common.collect *]
             #_[com.google.protobuf *]
             #_[org.slf4j *]
             #_[org.spongycastle.crypto.params *])
  #_(:require #_[org.bitcoinj.core *]
             #_[org.bitcoinj.crypto *]
             #_[org.bitcoinj.script *]
             #_[org.bitcoinj.utils *]
             [org.bitcoinj.wallet.listeners KeyChainEventListener]))

;;;
 ; <p>A KeyChainGroup is used by the {@link org.bitcoinj.wallet.Wallet} and manages: a {@link BasicKeyChain} object
 ; (which will normally be empty), and zero or more {@link DeterministicKeyChain}s.  A deterministic key chain will be
 ; created lazily/on demand when a fresh or current key is requested, possibly being initialized from the private key
 ; bytes of the earliest non rotating key in the basic key chain if one is available, or from a fresh random seed if not.</p>
 ;
 ; <p>If a key rotation time is set, it may be necessary to add a new DeterministicKeyChain with a fresh seed and
 ; also preserve the old one, so funds can be swept from the rotating keys.  In this case, there may be more than
 ; one deterministic chain.  The latest chain is called the active chain and is where new keys are served from.</p>
 ;
 ; <p>The wallet delegates most key management tasks to this class.  It is <b>not</b> thread safe and requires external
 ; locking, i.e. by the wallet lock.  The group then in turn delegates most operations to the key chain objects,
 ; combining their responses together when necessary.</p>
 ;
 ; <p>Deterministic key chains have a concept of a lookahead size and threshold.  Please see the discussion in the
 ; class docs for {@link DeterministicKeyChain} for more information on this topic.</p>
 ;;
#_public
(§ class KeyChainGroup implements KeyBag
    #_static
    (ß
        ;; Init proper random number generator, as some old Android installations have bugs that make it unsecure.
        (§ if (Utils.isAndroidRuntime()))
            (§ call new LinuxSecureRandom())
    )

    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(KeyChainGroup.class))

    #_private
    (§ field BasicKeyChain basic)
    #_private
    (§ field NetworkParameters params)
    #_protected
    #_final
    (§ field LinkedList<DeterministicKeyChain> chains)
    ;; currentKeys is used for normal, non-multisig/married wallets.
    ;; currentAddresses is used when we're handing out P2SH addresses.
    ;; They're mutually exclusive.
    #_private
    #_final
    (§ field EnumMap<KeyChain.KeyPurpose, DeterministicKey> currentKeys)
    #_private
    #_final
    (§ field EnumMap<KeyChain.KeyPurpose, Address> currentAddresses)

    #_nilable
    #_private
    (§ field KeyCrypter keyCrypter)
    #_private
    (§ field int lookaheadSize = -1)
    #_private
    (§ field int lookaheadThreshold = -1)

    ;;; Creates a keychain group with no basic chain, and a single, lazily created HD chain. ;;
    #_public
    (§ constructor KeyChainGroup(NetworkParameters params))
    (ß
        (§ this (params, nil, new ArrayList<DeterministicKeyChain>(1), nil, nil))
    )

    ;;; Creates a keychain group with no basic chain, and an HD chain initialized from the given seed. ;;
    #_public
    (§ constructor KeyChainGroup(NetworkParameters params, DeterministicSeed seed))
    (ß
        (§ this (params, nil, ImmutableList.of(new DeterministicKeyChain(seed)), nil, nil))
    )

    ;;;
     ; Creates a keychain group with no basic chain, and an HD chain that is watching the given watching key.
     ; This HAS to be an account key as returned by {@link DeterministicKeyChain#getWatchingKey()}.
     ;;
    #_public
    (§ constructor KeyChainGroup(NetworkParameters params, DeterministicKey watchKey))
    (ß
        (§ this (params, nil, ImmutableList.of(DeterministicKeyChain.watch(watchKey)), nil, nil))
    )

    ;; Used for deserialization.
    #_private
    (§ constructor KeyChainGroup(NetworkParameters params, #_nilable BasicKeyChain basicKeyChain, List<DeterministicKeyChain> chains, #_nilable EnumMap<KeyChain.KeyPurpose, DeterministicKey> currentKeys, #_nilable KeyCrypter crypter))
    (ß
        (§ ass this.params = params)
        (§ ass this.basic = (basicKeyChain == nil) ? new BasicKeyChain() :else basicKeyChain)
        (§ ass this.chains = new LinkedList<>(Preconditions.checkNotNull(chains)))
        (§ ass this.keyCrypter = crypter)
        (§ ass this.currentKeys = (currentKeys == nil) ? new EnumMap<KeyChain.KeyPurpose, DeterministicKey>(KeyChain.KeyPurpose.class) :else currentKeys)
        (§ ass this.currentAddresses = new EnumMap<>(KeyChain.KeyPurpose.class))
        (§ call maybeLookaheadScripts())

        (§ if (isMarried()))
        (ß
            (§ for (Map.Entry<KeyChain.KeyPurpose, DeterministicKey> entry :for this.currentKeys.entrySet()))
            (ß
                (§ var Address address = makeP2SHOutputScript(entry.getValue(), getActiveKeyChain()).getToAddress(params))
                (§ call currentAddresses.put(entry.getKey(), address))
            )
        )
    )

    ;; This keeps married redeem data in sync with the number of keys issued.
    #_private
    (§ method void maybeLookaheadScripts())
    (ß
        (§ for (DeterministicKeyChain chain :for chains))
            (§ call chain.maybeLookAheadScripts())
    )

    ;;; Adds a new HD chain to the chains list, and make it the default chain (from which keys are issued). ;;
    #_public
    (§ method void createAndActivateNewHDChain())
    (ß
        ;; We can't do auto upgrade here because we don't know the rotation time, if any.
        #_final
        (§ var DeterministicKeyChain chain = new DeterministicKeyChain(new SecureRandom()))
        (§ call addAndActivateHDChain(chain))
    )

    ;;;
     ; Adds an HD chain to the chains list, and make it the default chain (from which keys are issued).
     ; Useful for adding a complex pre-configured keychain, such as a married wallet.
     ;;
    #_public
    (§ method void addAndActivateHDChain(DeterministicKeyChain chain))
    (ß
        (§ call log.info("Creating and activating a new HD chain: {}", chain))
        (§ for (ListenerRegistration<KeyChainEventListener> registration :for basic.getListeners()))
            (§ call chain.addEventListener(registration.listener, registration.executor))
        (§ if (0 <= lookaheadSize))
            (§ call chain.setLookaheadSize(lookaheadSize))
        (§ if (0 <= lookaheadThreshold))
            (§ call chain.setLookaheadThreshold(lookaheadThreshold))
        (§ call chains.add(chain))
    )

    ;;;
     ; Returns a key that hasn't been seen in a transaction yet, and which is suitable for displaying in a wallet
     ; user interface as "a convenient key to receive funds on" when the purpose parameter is
     ; {@link KeyChain.KeyPurpose#RECEIVE_FUNDS}.  The returned key is stable until it's actually seen in a pending
     ; or confirmed transaction, at which point this method will start returning a different key (for each purpose
     ; independently).
     ;
     ; <p>This method is not supposed to be used for married keychains and will throw UnsupportedOperationException
     ; if the active chain is married.
     ; For married keychains use {@link #currentAddress(KeyChain.KeyPurpose)} to get a proper P2SH address.</p>
     ;;
    #_public
    (§ method DeterministicKey currentKey(KeyChain.KeyPurpose purpose))
    (ß
        (§ var DeterministicKeyChain chain = getActiveKeyChain())
        (§ if (chain.isMarried()))
            (§ throw new UnsupportedOperationException("Key is not suitable to receive coins for married keychains. Use freshAddress to get P2SH address instead."))

        (§ var DeterministicKey current = currentKeys.get(purpose))
        (§ if (current == nil))
        (ß
            (§ ass current = freshKey(purpose))
            (§ call currentKeys.put(purpose, current))
        )
        (§ return current)
    )

    ;;;
     ; Returns address for a {@link #currentKey(KeyChain.KeyPurpose)}.
     ;;
    #_public
    (§ method Address currentAddress(KeyChain.KeyPurpose purpose))
    (ß
        (§ var DeterministicKeyChain chain = getActiveKeyChain())
        (§ if (chain.isMarried()))
        (ß
            (§ var Address current = currentAddresses.get(purpose))
            (§ if (current == nil))
            (ß
                (§ ass current = freshAddress(purpose))
                (§ call currentAddresses.put(purpose, current))
            )
            (§ return current)
        )

        (§ return currentKey(purpose).toAddress(params))
    )

    ;;;
     ; Returns a key that has not been returned by this method before (fresh).  You can think of this as being a newly
     ; created key, although the notion of "create" is not really valid for a {@link DeterministicKeyChain}.  When the
     ; parameter is {@link KeyChain.KeyPurpose#RECEIVE_FUNDS}, the returned key is suitable for being put into a receive
     ; coins wizard type UI.  You should use this when the user is definitely going to hand this key out to someone who
     ; wishes to send money.
     ; <p>This method is not supposed to be used for married keychains and will throw UnsupportedOperationException if
     ; the active chain is married.
     ; For married keychains use {@link #freshAddress(KeyChain.KeyPurpose)} to get a proper P2SH address.</p>
     ;;
    #_public
    (§ method DeterministicKey freshKey(KeyChain.KeyPurpose purpose))
    (ß
        (§ return freshKeys(purpose, 1).get(0))
    )

    ;;;
     ; Returns a key/s that have not been returned by this method before (fresh).  You can think of this as being newly
     ; created key/s, although the notion of "create" is not really valid for a {@link DeterministicKeyChain}.  When the
     ; parameter is {@link KeyChain.KeyPurpose#RECEIVE_FUNDS}, the returned key is suitable for being put into a receive
     ; coins wizard type UI.  You should use this when the user is definitely going to hand this key out to someone who
     ; wishes to send money.
     ; <p>This method is not supposed to be used for married keychains and will throw UnsupportedOperationException if
     ; the active chain is married.
     ; For married keychains use {@link #freshAddress(KeyChain.KeyPurpose)} to get a proper P2SH address.</p>
     ;;
    #_public
    (§ method List<DeterministicKey> freshKeys(KeyChain.KeyPurpose purpose, int numberOfKeys))
    (ß
        (§ var DeterministicKeyChain chain = getActiveKeyChain())
        (§ if (chain.isMarried()))
            (§ throw new UnsupportedOperationException("Key is not suitable to receive coins for married keychains. Use freshAddress to get P2SH address instead."))

        (§ return chain.getKeys(purpose, numberOfKeys)) ;; Always returns the next key along the key chain.
    )

    ;;;
     ; Returns address for a {@link #freshKey(KeyChain.KeyPurpose)}.
     ;;
    #_public
    (§ method Address freshAddress(KeyChain.KeyPurpose purpose))
    (ß
        (§ var DeterministicKeyChain chain = getActiveKeyChain())
        (§ if (chain.isMarried()))
        (ß
            (§ var Script outputScript = chain.freshOutputScript(purpose))
            (§ call Preconditions.checkState(outputScript.isPayToScriptHash())) ;; Only handle P2SH for now.
            (§ var Address freshAddress = Address.fromP2SHScript(params, outputScript))
            (§ call maybeLookaheadScripts())
            (§ call currentAddresses.put(purpose, freshAddress))
            (§ return freshAddress)
        )

        (§ return freshKey(purpose).toAddress(params))
    )

    ;;; Returns the key chain that's used for generation of fresh/current keys.  This is always the newest HD chain. ;;
    #_public
    #_final
    (§ method DeterministicKeyChain getActiveKeyChain())
    (ß
        (§ if (chains.isEmpty()))
        (ß
            (§ if (0 < basic.numKeys()))
            (ß
                (§ call log.warn("No HD chain present but random keys are: you probably deserialized an old wallet."))
                ;; If called from the wallet (most likely) it'll try to upgrade us, as it knows the rotation time but not the password.
                (§ throw new DeterministicUpgradeRequiredException())
            )
            ;; Otherwise we have no HD chains and no random keys: we are a new born!  So a random seed is fine.
            (§ call createAndActivateNewHDChain())
        )
        (§ return chains.get(chains.size() - 1))
    )

    ;;;
     ; Sets the lookahead buffer size for ALL deterministic key chains as well as for following key chains if any exist.
     ; See {@link DeterministicKeyChain#setLookaheadSize(int)} for more information.
     ;;
    #_public
    (§ method void setLookaheadSize(int lookaheadSize))
    (ß
        (§ ass this.lookaheadSize = lookaheadSize)
        (§ for (DeterministicKeyChain chain :for chains))
            (§ call chain.setLookaheadSize(lookaheadSize))
    )

    ;;;
     ; Gets the current lookahead size being used for ALL deterministic key chains.
     ; See {@link DeterministicKeyChain#setLookaheadSize(int)} for more information.
     ;;
    #_public
    (§ method int getLookaheadSize())
    (ß
        (§ return (lookaheadSize == -1) ? getActiveKeyChain().getLookaheadSize() :else lookaheadSize)
    )

    ;;;
     ; Sets the lookahead buffer threshold for ALL deterministic key chains.
     ; See {@link DeterministicKeyChain#setLookaheadThreshold(int)} for more information.
     ;;
    #_public
    (§ method void setLookaheadThreshold(int num))
    (ß
        (§ for (DeterministicKeyChain chain :for chains))
            (§ call chain.setLookaheadThreshold(num))
    )

    ;;;
     ; Gets the current lookahead threshold being used for ALL deterministic key chains.
     ; See {@link DeterministicKeyChain#setLookaheadThreshold(int)} for more information.
     ;;
    #_public
    (§ method int getLookaheadThreshold())
    (ß
        (§ return (lookaheadThreshold == -1) ? getActiveKeyChain().getLookaheadThreshold() :else lookaheadThreshold)
    )

    ;;; Imports the given keys into the basic chain, creating it if necessary. ;;
    #_public
    (§ method int importKeys(List<ECKey> keys))
    (ß
        (§ return basic.importKeys(keys))
    )

    ;;; Imports the given keys into the basic chain, creating it if necessary. ;;
    #_public
    (§ method int importKeys(ECKey... keys))
    (ß
        (§ return importKeys(ImmutableList.copyOf(keys)))
    )

    #_public
    (§ method boolean checkPassword(CharSequence password))
    (ß
        (§ call Preconditions.checkState(keyCrypter != nil, "Not encrypted"))

        (§ return checkAESKey(keyCrypter.deriveKey(password)))
    )

    #_public
    (§ method boolean checkAESKey(KeyParameter aesKey))
    (ß
        (§ call Preconditions.checkState(keyCrypter != nil, "Not encrypted"))

        (§ return (0 < basic.numKeys()) ? basic.checkAESKey(aesKey) :else getActiveKeyChain().checkAESKey(aesKey))
    )

    ;;; Imports the given unencrypted keys into the basic chain, encrypting them along the way with the given key. ;;
    #_public
    (§ method int importKeysAndEncrypt(#_final List<ECKey> keys, KeyParameter aesKey))
    (ß
        ;; TODO: Firstly check if the aes key can decrypt any of the existing keys successfully.
        (§ call Preconditions.checkState(keyCrypter != nil, "Not encrypted"))

        (§ var LinkedList<ECKey> encryptedKeys = Lists.newLinkedList())
        (§ for (ECKey key :for keys))
        (ß
            (§ if (key.isEncrypted()))
                (§ throw new IllegalArgumentException("Cannot provide already encrypted keys"))

            (§ call encryptedKeys.add(key.encrypt(keyCrypter, aesKey)))
        )
        (§ return importKeys(encryptedKeys))
    )

    #_override
    #_nilable
    #_public
    (§ method RedeemData findRedeemDataFromScriptHash(byte[] scriptHash))
    (ß
        ;; Iterate in reverse order, since the active keychain is the one most likely to have the hit.
        (§ for (Iterator<DeterministicKeyChain> iter = chains.descendingIterator() :for iter.hasNext() :for ))
        (ß
            (§ var DeterministicKeyChain chain = iter.next())
            (§ var RedeemData redeemData = chain.findRedeemDataByScriptHash(ByteString.copyFrom(scriptHash)))
            (§ if (redeemData != nil))
                (§ return redeemData)
        )
        (§ return nil)
    )

    #_public
    (§ method void markP2SHAddressAsUsed(Address address))
    (ß
        (§ call Preconditions.checkArgument(address.isP2SHAddress()))

        (§ var RedeemData data = findRedeemDataFromScriptHash(address.getHash160()))
        (§ if (data == nil))
            (§ return) ;; Not our P2SH address.

        (§ for (ECKey key :for data.keys))
        (ß
            (§ for (DeterministicKeyChain chain :for chains))
            (ß
                (§ var DeterministicKey k = chain.findKeyFromPubKey(key.getPubKey()))
                (§ if (k != nil))
                (ß
                    (§ call chain.markKeyAsUsed(k))
                    (§ call maybeMarkCurrentAddressAsUsed(address))
                )
            )
        )
    )

    #_nilable
    #_override
    #_public
    (§ method ECKey findKeyFromPubHash(byte[] pubkeyHash))
    (ß
        (§ var ECKey result = basic.findKeyFromPubHash(pubkeyHash))
        (§ if (result != nil))
            (§ return result)

        (§ for (DeterministicKeyChain chain :for chains))
        (ß
            (§ ass result = chain.findKeyFromPubHash(pubkeyHash))
            (§ if (result != nil))
                (§ return result)
        )

        (§ return nil)
    )

    ;;;
     ; Mark the DeterministicKeys as used, if they match the pubkeyHash.
     ; See {@link DeterministicKeyChain#markKeyAsUsed(DeterministicKey)} for more info on this.
     ;;
    #_public
    (§ method void markPubKeyHashAsUsed(byte[] pubkeyHash))
    (ß
        (§ for (DeterministicKeyChain chain :for chains))
        (ß
            (§ var DeterministicKey key = chain.markPubHashAsUsed(pubkeyHash))
            (§ if (key != nil))
            (ß
                (§ call maybeMarkCurrentKeyAsUsed(key))
                (§ return)
            )
        )
    )

    ;;; If the given P2SH address is "current", advance it to a new one. ;;
    #_private
    (§ method void maybeMarkCurrentAddressAsUsed(Address address))
    (ß
        (§ call Preconditions.checkArgument(address.isP2SHAddress()))

        (§ for (Map.Entry<KeyChain.KeyPurpose, Address> entry :for currentAddresses.entrySet()))
        (ß
            (§ if (entry.getValue() != nil && entry.getValue().equals(address)))
            (ß
                (§ call log.info("Marking P2SH address as used: {}", address))
                (§ call currentAddresses.put(entry.getKey(), freshAddress(entry.getKey())))
                (§ return)
            )
        )
    )

    ;;; If the given key is "current", advance the current key to a new one. ;;
    #_private
    (§ method void maybeMarkCurrentKeyAsUsed(DeterministicKey key))
    (ß
        ;; It's OK for currentKeys to be empty here: it means we're a married wallet and the key may be a part of a rotating chain.
        (§ for (Map.Entry<KeyChain.KeyPurpose, DeterministicKey> entry :for currentKeys.entrySet()))
        (ß
            (§ if (entry.getValue() != nil && entry.getValue().equals(key)))
            (ß
                (§ call log.info("Marking key as used: {}", key))
                (§ call currentKeys.put(entry.getKey(), freshKey(entry.getKey())))
                (§ return)
            )
        )
    )

    #_public
    (§ method boolean hasKey(ECKey key))
    (ß
        (§ if (basic.hasKey(key)))
            (§ return true)
        (§ for (DeterministicKeyChain chain :for chains))
            (§ if (chain.hasKey(key)))
                (§ return true)
        (§ return false)
    )

    #_nilable
    #_override
    #_public
    (§ method ECKey findKeyFromPubKey(byte[] pubkey))
    (ß
        (§ var ECKey result = basic.findKeyFromPubKey(pubkey))
        (§ if (result != nil))
            (§ return result)

        (§ for (DeterministicKeyChain chain :for chains))
        (ß
            (§ ass result = chain.findKeyFromPubKey(pubkey))
            (§ if (result != nil))
                (§ return result)
        )

        (§ return nil)
    )

    ;;;
     ; Mark the DeterministicKeys as used, if they match the pubkey.
     ; See {@link DeterministicKeyChain#markKeyAsUsed(DeterministicKey)} for more info on this.
     ;;
    #_public
    (§ method void markPubKeyAsUsed(byte[] pubkey))
    (ß
        (§ for (DeterministicKeyChain chain :for chains))
        (ß
            (§ var DeterministicKey key = chain.markPubKeyAsUsed(pubkey))
            (§ if (key != nil))
            (ß
                (§ call maybeMarkCurrentKeyAsUsed(key))
                (§ return)
            )
        )
    )

    ;;; Returns the number of keys managed by this group, including the lookahead buffers. ;;
    #_public
    (§ method int numKeys())
    (ß
        (§ var int result = basic.numKeys())
        (§ for (DeterministicKeyChain chain :for chains))
            (§ ass result = result + chain.numKeys())
        (§ return result)
    )

    ;;;
     ; Removes a key that was imported into the basic key chain.  You cannot remove deterministic keys.
     ; @throws java.lang.IllegalArgumentException if the key is deterministic.
     ;;
    #_public
    (§ method boolean removeImportedKey(ECKey key))
    (ß
        (§ call Preconditions.checkNotNull(key))
        (§ call Preconditions.checkArgument(!(key instanceof DeterministicKey)))

        (§ return basic.removeKey(key))
    )

    ;;;
     ; Whether the active keychain is married.  A keychain is married when it vends P2SH addresses
     ; from multiple keychains in a multisig relationship.
     ; @see org.bitcoinj.wallet.MarriedKeyChain
     ;;
    #_public
    #_final
    (§ method boolean isMarried())
    (ß
        (§ return !chains.isEmpty() && getActiveKeyChain().isMarried())
    )

    ;;;
     ; Encrypt the keys in the group using the KeyCrypter and the AES key.
     ; A good default KeyCrypter to use is {@link org.bitcoinj.crypto.KeyCrypterScrypt}.
     ;
     ; @throws org.bitcoinj.crypto.KeyCrypterException if the wallet encryption fails for some reason,
     ;         leaving the group unchanged.
     ; @throws DeterministicUpgradeRequiredException if there are random keys but no HD chain.
     ;;
    #_public
    (§ method void encrypt(KeyCrypter keyCrypter, KeyParameter aesKey))
    (ß
        (§ call Preconditions.checkNotNull(keyCrypter))
        (§ call Preconditions.checkNotNull(aesKey))

        ;; This code must be exception safe.
        (§ var BasicKeyChain newBasic = basic.toEncrypted(keyCrypter, aesKey))
        (§ var List<DeterministicKeyChain> newChains = new ArrayList<>(chains.size()))
        (§ if (chains.isEmpty() && basic.numKeys() == 0))
        (ß
            ;; No HD chains and no random keys: encrypting an entirely empty keychain group.
            ;; But we can't do that, we must have something to encrypt: so instantiate a new HD chain here.
            (§ call createAndActivateNewHDChain())
        )
        (§ for (DeterministicKeyChain chain :for chains))
            (§ call newChains.add(chain.toEncrypted(keyCrypter, aesKey)))
        (§ ass this.keyCrypter = keyCrypter)
        (§ ass basic = newBasic)
        (§ call chains.clear())
        (§ call chains.addAll(newChains))
    )

    ;;;
     ; Decrypt the keys in the group using the previously given key crypter and the AES key.
     ; A good default KeyCrypter to use is {@link org.bitcoinj.crypto.KeyCrypterScrypt}.
     ;
     ; @throws org.bitcoinj.crypto.KeyCrypterException if the wallet decryption fails for some reason, leaving the group unchanged.
     ;;
    #_public
    (§ method void decrypt(KeyParameter aesKey))
    (ß
        ;; This code must be exception safe.
        (§ call Preconditions.checkNotNull(aesKey))

        (§ var BasicKeyChain newBasic = basic.toDecrypted(aesKey))
        (§ var List<DeterministicKeyChain> newChains = new ArrayList<>(chains.size()))
        (§ for (DeterministicKeyChain chain :for chains))
            (§ call newChains.add(chain.toDecrypted(aesKey)))

        (§ ass this.keyCrypter = nil)
        (§ ass basic = newBasic)
        (§ call chains.clear())
        (§ call chains.addAll(newChains))
    )

    ;;; Returns true if the group is encrypted. ;;
    #_public
    (§ method boolean isEncrypted())
    (ß
        (§ return (keyCrypter != nil))
    )

    ;;;
     ; Returns whether this chain has only watching keys (unencrypted keys with no private part).
     ; Mixed chains are forbidden.
     ;
     ; @throws IllegalStateException if there are no keys, or if there is a mix between watching and non-watching keys.
     ;;
    #_public
    (§ method boolean isWatching())
    (ß
        (§ var BasicKeyChain.State activeState = BasicKeyChain.State.EMPTY)
        (§ if (!chains.isEmpty()))
            (§ ass activeState = getActiveKeyChain().isWatching() ? BasicKeyChain.State.WATCHING :else BasicKeyChain.State.REGULAR)

        (§ var BasicKeyChain.State basicState = basic.isWatching())
        (§ if (basicState == BasicKeyChain.State.EMPTY))
        (ß
            (§ if (activeState == BasicKeyChain.State.EMPTY))
                (§ throw new IllegalStateException("Empty key chain group: cannot answer isWatching() query"))

            (§ return (activeState == BasicKeyChain.State.WATCHING))
        )

        (§ if (activeState == BasicKeyChain.State.EMPTY))
            (§ return (basicState == BasicKeyChain.State.WATCHING))

        (§ if (activeState != basicState))
            (§ throw new IllegalStateException("Mix of watching and non-watching keys in wallet"))

        (§ return (activeState == BasicKeyChain.State.WATCHING))
    )

    ;;; Returns the key crypter or null if the group is not encrypted. ;;
    #_nilable
    #_public
    (§ method KeyCrypter getKeyCrypter())
    (ß
        (§ return keyCrypter)
    )

    ;;;
     ; Returns a list of the non-deterministic keys that have been imported into the wallet, or the empty list if none.
     ;;
    #_public
    (§ method List<ECKey> getImportedKeys())
    (ß
        (§ return basic.getKeys())
    )

    #_public
    (§ method long getEarliestKeyCreationTime())
    (ß
        (§ var long time = basic.getEarliestKeyCreationTime()) ;; Long.MAX_VALUE if empty.
        (§ for (DeterministicKeyChain chain :for chains))
            (§ ass time = Math.min(time, chain.getEarliestKeyCreationTime()))
        (§ return time)
    )

    #_public
    (§ method int getBloomFilterElementCount())
    (ß
        (§ var int result = basic.numBloomFilterEntries())
        (§ for (DeterministicKeyChain chain :for chains))
            (§ ass result = result + chain.numBloomFilterEntries())
        (§ return result)
    )

    #_public
    (§ method BloomFilter getBloomFilter(int size, double falsePositiveRate, long nTweak))
    (ß
        (§ var BloomFilter filter = new BloomFilter(size, falsePositiveRate, nTweak))
        (§ if (0 < basic.numKeys()))
            (§ call filter.merge(basic.getFilter(size, falsePositiveRate, nTweak)))

        (§ for (DeterministicKeyChain chain :for chains))
            (§ call filter.merge(chain.getFilter(size, falsePositiveRate, nTweak)))
        (§ return filter)
    )

    #_private
    (§ method Script makeP2SHOutputScript(DeterministicKey followedKey, DeterministicKeyChain chain))
    (ß
        (§ return ScriptBuilder.createP2SHOutputScript(chain.getRedeemData(followedKey).redeemScript))
    )

    ;;; Adds a listener for events that are run when keys are added, on the user thread. ;;
    #_public
    (§ method void addEventListener(KeyChainEventListener listener))
    (ß
        (§ call addEventListener(listener, Threading.USER_THREAD))
    )

    ;;; Adds a listener for events that are run when keys are added, on the given executor. ;;
    #_public
    (§ method void addEventListener(KeyChainEventListener listener, Executor executor))
    (ß
        (§ call Preconditions.checkNotNull(listener))
        (§ call Preconditions.checkNotNull(executor))

        (§ call basic.addEventListener(listener, executor))
        (§ for (DeterministicKeyChain chain :for chains))
            (§ call chain.addEventListener(listener, executor))
    )

    ;;; Removes a listener for events that are run when keys are added. ;;
    #_public
    (§ method boolean removeEventListener(KeyChainEventListener listener))
    (ß
        (§ call Preconditions.checkNotNull(listener))

        (§ for (DeterministicKeyChain chain :for chains))
            (§ call chain.removeEventListener(listener))
        (§ return basic.removeEventListener(listener))
    )

    ;;; Returns a list of key protobufs obtained by merging the chains. ;;
    #_public
    (§ method List<Protos.Key> serializeToProtobuf())
    (ß
        (§ var List<Protos.Key> result = (basic != nil) ? basic.serializeToProtobuf() :else Lists.newArrayList())

        (§ for (DeterministicKeyChain chain :for chains))
        (ß
            (§ var List<Protos.Key> protos = chain.serializeToProtobuf())
            (§ call result.addAll(protos))
        )
        (§ return result)
    )

    #_static
    (§ method KeyChainGroup fromProtobufUnencrypted(NetworkParameters params, List<Protos.Key> keys))
        (§ throws UnreadableWalletException)
    (ß
        (§ return fromProtobufUnencrypted(params, keys, new DefaultKeyChainFactory()))
    )

    #_public
    #_static
    (§ method KeyChainGroup fromProtobufUnencrypted(NetworkParameters params, List<Protos.Key> keys, KeyChainFactory factory))
        (§ throws UnreadableWalletException)
    (ß
        (§ var BasicKeyChain basicKeyChain = BasicKeyChain.fromProtobufUnencrypted(keys))
        (§ var List<DeterministicKeyChain> chains = DeterministicKeyChain.fromProtobuf(keys, nil, factory))
        (§ var EnumMap<KeyChain.KeyPurpose, DeterministicKey> currentKeys = nil)
        (§ if (!chains.isEmpty()))
            (§ ass currentKeys = createCurrentKeysMap(chains))
        (§ call extractFollowingKeychains(chains))
        (§ return new KeyChainGroup(params, basicKeyChain, chains, currentKeys, nil))
    )

    #_static
    (§ method KeyChainGroup fromProtobufEncrypted(NetworkParameters params, List<Protos.Key> keys, KeyCrypter crypter))
        (§ throws UnreadableWalletException)
    (ß
        (§ return fromProtobufEncrypted(params, keys, crypter, new DefaultKeyChainFactory()))
    )

    #_public
    #_static
    (§ method KeyChainGroup fromProtobufEncrypted(NetworkParameters params, List<Protos.Key> keys, KeyCrypter crypter, KeyChainFactory factory))
        (§ throws UnreadableWalletException)
    (ß
        (§ call Preconditions.checkNotNull(crypter))

        (§ var BasicKeyChain basicKeyChain = BasicKeyChain.fromProtobufEncrypted(keys, crypter))
        (§ var List<DeterministicKeyChain> chains = DeterministicKeyChain.fromProtobuf(keys, crypter, factory))
        (§ var EnumMap<KeyChain.KeyPurpose, DeterministicKey> currentKeys = nil)
        (§ if (!chains.isEmpty()))
            (§ ass currentKeys = createCurrentKeysMap(chains))
        (§ call extractFollowingKeychains(chains))
        (§ return new KeyChainGroup(params, basicKeyChain, chains, currentKeys, crypter))
    )

    ;;;
     ; If the key chain contains only random keys and no deterministic key chains, this method will create a chain
     ; based on the oldest non-rotating private key (i.e. the seed is derived from the old wallet).
     ;
     ; @param keyRotationTimeSecs If non-zero, UNIX time for which keys created before this are assumed to be
     ;                            compromised or weak, those keys will not be used for deterministic upgrade.
     ; @param aesKey If non-null, the encryption key the keychain is encrypted under.  If the keychain is encrypted
     ;               and this is not supplied, an exception is thrown letting you know you should ask the user for
     ;               their password, turn it into a key, and then try again.
     ; @throws java.lang.IllegalStateException if there is already a deterministic key chain present or if there are
     ;                                         no random keys (i.e. this is not an upgrade scenario), or if aesKey is
     ;                                         provided but the wallet is not encrypted.
     ; @throws java.lang.IllegalArgumentException if the rotation time specified excludes all keys.
     ; @throws DeterministicUpgradeRequiresPassword if the key chain group is encrypted
     ;         and you should provide the users encryption key.
     ; @return the DeterministicKeyChain that was created by the upgrade.
     ;;
    #_public
    (§ method DeterministicKeyChain upgradeToDeterministic(long keyRotationTimeSecs, #_nilable KeyParameter aesKey))
        (§ throws DeterministicUpgradeRequiresPassword, AllRandomKeysRotating)
    (ß
        (§ call Preconditions.checkState(0 < basic.numKeys()))
        (§ call Preconditions.checkArgument(0 <= keyRotationTimeSecs))

        ;; Subtract one because the key rotation time might have been set to the creation time of the first known
        ;; good key, in which case, that's the one we want to find.
        (§ var ECKey keyToUse = basic.findOldestKeyAfter(keyRotationTimeSecs - 1))
        (§ if (keyToUse == nil))
            (§ throw new AllRandomKeysRotating())

        (§ if (keyToUse.isEncrypted()))
        (ß
            (§ if (aesKey == nil))
            (ß
                ;; We can't auto upgrade because we don't know the users password at this point.  We throw an exception
                ;; so the calling code knows to abort the load and ask the user for their password, they can then try
                ;; loading the wallet again passing in the AES key.
                ;;
                ;; There are a few different approaches we could have used here, but they all suck.  The most obvious
                ;; is to try and be as lazy as possible, running in the old random-wallet mode until the user enters
                ;; their password for some other reason and doing the upgrade then.  But this could result in strange
                ;; and unexpected UI flows for the user, as well as complicating the job of wallet developers who then
                ;; have to support both "old" and "new" UI modes simultaneously, switching them on the fly.  Given that
                ;; this is a one-off transition, it seems more reasonable to just ask the user for their password
                ;; on startup, and then the wallet app can have all the widgets for accessing seed words etc active
                ;; all the time.
                (§ throw new DeterministicUpgradeRequiresPassword())
            )
            (§ ass keyToUse = keyToUse.decrypt(aesKey))
        )
        (§ elseif (aesKey != nil))
        (ß
            (§ throw new IllegalStateException("AES Key was provided but wallet is not encrypted."))
        )

        (§ if (chains.isEmpty()))
            (§ call log.info("Auto-upgrading pre-HD wallet to HD!"))
        (§ else)
            (§ call log.info("Wallet with existing HD chain is being re-upgraded due to change in key rotation time."))

        (§ call log.info("Instantiating new HD chain using oldest non-rotating private key (address: {})", keyToUse.toAddress(params)))
        (§ var byte[] entropy = Preconditions.checkNotNull(keyToUse.getSecretBytes()))
        ;; Private keys should be at least 128 bits long.
        (§ call Preconditions.checkState(DeterministicSeed.DEFAULT_SEED_ENTROPY_BITS / 8 <= entropy.length))
        ;; We reduce the entropy here to 128 bits because people like to write their seeds down on paper,
        ;; and 128 bits should be sufficient forever unless the laws of the universe change or ECC is broken;
        ;; in either case we all have bigger problems.
        (§ ass entropy = Arrays.copyOfRange(entropy, 0, DeterministicSeed.DEFAULT_SEED_ENTROPY_BITS / 8)) ;; Final argument is exclusive range.
        (§ call Preconditions.checkState(entropy.length == DeterministicSeed.DEFAULT_SEED_ENTROPY_BITS / 8))
        (§ var String passphrase = "") ;; FIXME allow non-empty passphrase
        (§ var DeterministicKeyChain chain = new DeterministicKeyChain(entropy, passphrase, keyToUse.getCreationTimeSeconds()))
        (§ if (aesKey != nil))
            (§ ass chain = chain.toEncrypted(Preconditions.checkNotNull(basic.getKeyCrypter()), aesKey))
        (§ call chains.add(chain))
        (§ return chain)
    )

    ;;; Returns true if the group contains random keys but no HD chains. ;;
    #_public
    (§ method boolean isDeterministicUpgradeRequired())
    (ß
        (§ return (0 < basic.numKeys() && chains.isEmpty()))
    )

    #_private
    #_static
    (§ method EnumMap<KeyChain.KeyPurpose, DeterministicKey> createCurrentKeysMap(List<DeterministicKeyChain> chains))
    (ß
        (§ var DeterministicKeyChain activeChain = chains.get(chains.size() - 1))

        (§ var EnumMap<KeyChain.KeyPurpose, DeterministicKey> currentKeys = new EnumMap<>(KeyChain.KeyPurpose.class))

        ;; Assuming that only RECEIVE and CHANGE keys are being used at the moment, we will treat the latest issued
        ;; external key as current RECEIVE key and latest issued internal key as CHANGE key.  This should be changed
        ;; as soon as other kinds of KeyPurpose are introduced.
        (§ if (0 < activeChain.getIssuedExternalKeys()))
        (ß
            (§ var DeterministicKey currentExternalKey = activeChain.getKeyByPath(HDUtils.append(HDUtils.concat(activeChain.getAccountPath(), DeterministicKeyChain.EXTERNAL_SUBPATH), new ChildNumber(activeChain.getIssuedExternalKeys() - 1))))
            (§ call currentKeys.put(KeyChain.KeyPurpose.RECEIVE_FUNDS, currentExternalKey))
        )

        (§ if (0 < activeChain.getIssuedInternalKeys()))
        (ß
            (§ var DeterministicKey currentInternalKey = activeChain.getKeyByPath(HDUtils.append(HDUtils.concat(activeChain.getAccountPath(), DeterministicKeyChain.INTERNAL_SUBPATH), new ChildNumber(activeChain.getIssuedInternalKeys() - 1))))
            (§ call currentKeys.put(KeyChain.KeyPurpose.CHANGE, currentInternalKey))
        )

        (§ return currentKeys)
    )

    #_private
    #_static
    (§ method void extractFollowingKeychains(List<DeterministicKeyChain> chains))
    (ß
        ;; Look for following key chains and map them to the watch keys of followed keychains.
        (§ var List<DeterministicKeyChain> followingChains = Lists.newArrayList())
        (§ for (Iterator<DeterministicKeyChain> it = chains.iterator() :for it.hasNext() :for ))
        (ß
            (§ var DeterministicKeyChain chain = it.next())
            (§ if (chain.isFollowing()))
            (ß
                (§ call followingChains.add(chain))
                (§ call it.remove())
            )
            (§ elseif (!followingChains.isEmpty()))
            (ß
                (§ if (!(chain instanceof MarriedKeyChain)))
                    (§ throw new IllegalStateException())

                (§ call ((MarriedKeyChain)chain).setFollowingKeyChains(followingChains))
                (§ ass followingChains = Lists.newArrayList())
            )
        )
    )

    #_public
    (§ method String toString(boolean includePrivateKeys))
    (ß
        #_final
        (§ var StringBuilder sb = new StringBuilder())
        (§ if (basic != nil))
        (ß
            (§ var List<ECKey> keys = basic.getKeys())
            (§ call Collections.sort(keys, ECKey.AGE_COMPARATOR))
            (§ for (ECKey key :for keys))
                (§ call key.formatKeyWithAddress(includePrivateKeys, sb, params))
        )
        (§ for (DeterministicKeyChain chain :for chains))
            (§ call sb.append(chain.toString(includePrivateKeys, params)).append("\n"))
        (§ return sb.toString())
    )

    ;;; Returns a copy of the current list of chains. ;;
    #_public
    (§ method List<DeterministicKeyChain> getDeterministicKeyChains())
    (ß
        (§ return new ArrayList<>(chains))
    )

    ;;;
     ; Returns a counter that increases (by an arbitrary amount) each time new keys have been calculated
     ; due to lookahead and thus the Bloom filter that was previously calculated has become stale.
     ;;
    #_public
    (§ method int getCombinedKeyLookaheadEpochs())
    (ß
        (§ var int epoch = 0)
        (§ for (DeterministicKeyChain chain :for chains))
            (§ ass epoch = epoch + chain.getKeyLookaheadEpoch())
        (§ return epoch)
    )
)

#_(ns org.bitcoinj.wallet #_"KeyTimeCoinSelector"
    (:import [java.util LinkedList List])
    (:import [com.google.common.base Preconditions]
             [com.google.common.collect Lists]
             [org.slf4j Logger LoggerFactory])
  #_(:require #_[org.bitcoinj.core *]
             [org.bitcoinj.script Script]))

;;;
 ; A coin selector that takes all coins assigned to keys created before the given timestamp.
 ; Used as part of the implementation of {@link Wallet#setKeyRotationTime(java.util.Date)}.
 ;;
#_public
(§ class KeyTimeCoinSelector implements CoinSelector
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(KeyTimeCoinSelector.class))

    ;;; A number of inputs chosen to avoid hitting {@link org.bitcoinj.core.Transaction#MAX_STANDARD_TX_SIZE}. ;;
    #_public
    #_static
    #_final
    (§ field int MAX_SIMULTANEOUS_INPUTS = 600)

    #_private
    #_final
    (§ field long unixTimeSeconds)
    #_private
    #_final
    (§ field Wallet wallet)
    #_private
    #_final
    (§ field boolean ignorePending)

    #_public
    (§ constructor KeyTimeCoinSelector(Wallet wallet, long unixTimeSeconds, boolean ignorePending))
    (ß
        (§ ass this.unixTimeSeconds = unixTimeSeconds)
        (§ ass this.wallet = wallet)
        (§ ass this.ignorePending = ignorePending)
    )

    #_override
    #_public
    (§ method CoinSelection select(Coin target, List<TransactionOutput> candidates))
    (ß
        (§ try)
        (ß
            (§ var LinkedList<TransactionOutput> gathered = Lists.newLinkedList())
            (§ var Coin valueGathered = Coin.ZERO)
            (§ for (TransactionOutput output :for candidates))
            (ß
                (§ if (ignorePending && !isConfirmed(output)))
                    (§ continue)

                ;; Find the key that controls output, assuming it's a regular pay-to-pubkey or pay-to-address output.
                ;; We ignore any other kind of exotic output on the assumption we can't spend it ourselves.
                #_final
                (§ var Script scriptPubKey = output.getScriptPubKey())
                (§ var ECKey controllingKey)
                (§ if (scriptPubKey.isSentToRawPubKey()))
                    (§ ass controllingKey = wallet.findKeyFromPubKey(scriptPubKey.getPubKey()))
                (§ elseif (scriptPubKey.isSentToAddress()))
                    (§ ass controllingKey = wallet.findKeyFromPubHash(scriptPubKey.getPubKeyHash()))
                (§ else)
                (ß
                    (§ call log.info("Skipping tx output {} because it's not of simple form.", output))
                    (§ continue)
                )

                (§ call Preconditions.checkNotNull(controllingKey, "Coin selector given output as candidate for which we lack the key"))
                (§ if (unixTimeSeconds <= controllingKey.getCreationTimeSeconds()))
                    (§ continue)

                ;; It's older than the cutoff time so select.
                (§ ass valueGathered = valueGathered.add(output.getValue()))
                (§ call gathered.push(output))
                (§ if (MAX_SIMULTANEOUS_INPUTS <= gathered.size()))
                (ß
                    (§ call log.warn("Reached {} inputs, going further would yield a tx that is too large, stopping here.", gathered.size()))
                    (§ break)
                )
            )
            (§ return new CoinSelection(valueGathered, gathered))
        )
        (§ catch (ScriptException e))
        (ß
            (§ throw new RuntimeException(e)) ;; We should never have problems understanding scripts in our wallet.
        )
    )

    #_private
    (§ method boolean isConfirmed(TransactionOutput output))
    (ß
        (§ return output.getParentTransaction().getConfidence().getConfidenceType().equals(TransactionConfidence.ConfidenceType.BUILDING))
    )
)

#_(ns org.bitcoinj.wallet #_"MarriedKeyChain"
    (:import [java.security SecureRandom]
             [java.util LinkedHashMap List Map])
    (:import [com.google.common.base Preconditions]
             [com.google.common.collect ImmutableList Lists]
             #_static #_[com.google.common.collect.Lists newArrayList]
             [com.google.protobuf ByteString])
  #_(:require [org.bitcoinj.core BloomFilter ECKey NetworkParameters Utils]
             [org.bitcoinj.crypto DeterministicKey KeyCrypter]
             [org.bitcoinj.script Script ScriptBuilder]))

;;;
 ; <p>A multi-signature keychain using synchronized HD keys (a.k.a HDM).</p>
 ;
 ; <p>This keychain keeps track of following keychains that follow the account key of this keychain.  You can get P2SH
 ; addresses to receive coins to from this chain.  The threshold - sigsRequiredToSpend specifies how many signatures
 ; required to spend transactions for this married keychain.  This value should not exceed the total number of keys
 ; involved (one followed key plus number of following keys), otherwise IllegalArgumentException will be thrown.</p>
 ;
 ; <p>IMPORTANT: As of Bitcoin Core 0.9 all multisig transactions which require more than 3 public keys are non-standard and
 ; such spends won't be processed by peers with default settings, essentially making such transactions almost nonspendable.</p>
 ;
 ; <p>This method will throw an IllegalStateException, if the keychain is already married or already has leaf keys issued.</p>
 ;;
#_public
(§ class MarriedKeyChain extends DeterministicKeyChain
    ;; The map holds P2SH redeem script and corresponding ECKeys issued by this KeyChainGroup (including lookahead)
    ;; mapped to redeem script hashes.
    #_private
    (§ field LinkedHashMap<ByteString, RedeemData> marriedKeysRedeemData = new LinkedHashMap<>())

    #_private
    (§ field List<DeterministicKeyChain> followingKeyChains)

    ;;; Builds a {@link MarriedKeyChain}. ;;
    #_public
    #_static
    (§ class Builder<T extends Builder<T>> extends DeterministicKeyChain.Builder<T>
        #_private
        (§ field List<DeterministicKey> followingKeys)
        #_private
        (§ field int threshold)

        #_protected
        (§ constructor Builder())
        (ß
        )

        #_public
        (§ method T followingKeys(List<DeterministicKey> followingKeys))
        (ß
            (§ ass this.followingKeys = followingKeys)
            (§ return self())
        )

        #_public
        (§ method T followingKeys(DeterministicKey followingKey, DeterministicKey ...followingKeys))
        (ß
            (§ ass this.followingKeys = Lists.asList(followingKey, followingKeys))
            (§ return self())
        )

        ;;;
         ; Threshold, or <code>(followingKeys.size() + 1) / 2 + 1)</code> (majority) if unspecified.
         ;
         ; IMPORTANT: As of Bitcoin Core 0.9 all multisig transactions which require more than 3 public keys are non-standard and
         ; such spends won't be processed by peers with default settings, essentially making such transactions almost nonspendable.
         ;;
        #_public
        (§ method T threshold(int threshold))
        (ß
            (§ ass this.threshold = threshold)
            (§ return self())
        )

        #_override
        #_public
        (§ method MarriedKeyChain build())
        (ß
            (§ call Preconditions.checkState(random != nil || entropy != nil || seed != nil || watchingKey!= nil, "Must provide either entropy or random or seed or watchingKey"))
            (§ call Preconditions.checkNotNull(followingKeys, "followingKeys must be provided"))

            (§ var MarriedKeyChain chain)
            (§ if (threshold == 0))
                (§ ass threshold = (followingKeys.size() + 1) / 2 + 1)

            (§ if (random != nil))
            (ß
                (§ ass chain = new MarriedKeyChain(random, bits, getPassphrase(), seedCreationTimeSecs))
            )
            (§ elseif (entropy != nil))
            (ß
                (§ ass chain = new MarriedKeyChain(entropy, getPassphrase(), seedCreationTimeSecs))
            )
            (§ elseif (seed != nil))
            (ß
                (§ call seed.setCreationTimeSeconds(seedCreationTimeSecs))
                (§ ass chain = new MarriedKeyChain(seed))
            )
            (§ else)
            (ß
                (§ call watchingKey.setCreationTimeSeconds(seedCreationTimeSecs))
                (§ ass chain = new MarriedKeyChain(watchingKey))
            )

            (§ call chain.addFollowingAccountKeys(followingKeys, threshold))
            (§ return chain)
        )
    )

    #_public
    #_static
    (§ method Builder<?> builder())
    (ß
        (§ return new Builder())
    )

    ;; Protobuf deserialization constructors.
    (§ constructor MarriedKeyChain(DeterministicKey accountKey))
    (ß
        (§ super (accountKey, false))
    )

    (§ constructor MarriedKeyChain(DeterministicSeed seed, KeyCrypter crypter))
    (ß
        (§ super (seed, crypter))
    )

    ;; Builder constructors.
    #_private
    (§ constructor MarriedKeyChain(SecureRandom random, int bits, String passphrase, long seedCreationTimeSecs))
    (ß
        (§ super (random, bits, passphrase, seedCreationTimeSecs))
    )

    #_private
    (§ constructor MarriedKeyChain(byte[] entropy, String passphrase, long seedCreationTimeSecs))
    (ß
        (§ super (entropy, passphrase, seedCreationTimeSecs))
    )

    #_private
    (§ constructor MarriedKeyChain(DeterministicSeed seed))
    (ß
        (§ super (seed))
    )

    (§ method void setFollowingKeyChains(List<DeterministicKeyChain> followingKeyChains))
    (ß
        (§ call Preconditions.checkArgument(!followingKeyChains.isEmpty()))
        (§ ass this.followingKeyChains = followingKeyChains)
    )

    #_override
    #_public
    (§ method boolean isMarried())
    (ß
        (§ return true)
    )

    ;;; Create a new married key and return the matching output script. ;;
    #_override
    #_public
    (§ method Script freshOutputScript(KeyPurpose purpose))
    (ß
        (§ var DeterministicKey followedKey = getKey(purpose))
        (§ var ImmutableList.Builder<ECKey> keys = ImmutableList.<ECKey>builder().add(followedKey))
        (§ for (DeterministicKeyChain keyChain :for followingKeyChains))
        (ß
            (§ var DeterministicKey followingKey = keyChain.getKey(purpose))
            (§ call Preconditions.checkState(followedKey.getChildNumber().equals(followingKey.getChildNumber()), "Following keychains should be in sync"))
            (§ call keys.add(followingKey))
        )
        (§ var List<ECKey> marriedKeys = keys.build())
        (§ var Script redeemScript = ScriptBuilder.createRedeemScript(sigsRequiredToSpend, marriedKeys))
        (§ return ScriptBuilder.createP2SHOutputScript(redeemScript))
    )

    #_private
    (§ method List<ECKey> getMarriedKeysWithFollowed(DeterministicKey followedKey))
    (ß
        (§ var ImmutableList.Builder<ECKey> keys = ImmutableList.builder())
        (§ for (DeterministicKeyChain keyChain :for followingKeyChains))
        (ß
            (§ call keyChain.maybeLookAhead())
            (§ call keys.add(keyChain.getKeyByPath(followedKey.getPath())))
        )
        (§ call keys.add(followedKey))
        (§ return keys.build())
    )

    ;;; Get the redeem data for a key in this married chain. ;;
    #_override
    #_public
    (§ method RedeemData getRedeemData(DeterministicKey followedKey))
    (ß
        (§ var List<ECKey> marriedKeys = getMarriedKeysWithFollowed(followedKey))
        (§ var Script redeemScript = ScriptBuilder.createRedeemScript(sigsRequiredToSpend, marriedKeys))
        (§ return RedeemData.of(marriedKeys, redeemScript))
    )

    #_private
    (§ method void addFollowingAccountKeys(List<DeterministicKey> followingAccountKeys, int sigsRequiredToSpend))
    (ß
        (§ call Preconditions.checkArgument(sigsRequiredToSpend <= followingAccountKeys.size() + 1, "Multisig threshold can't exceed total number of keys"))
        (§ call Preconditions.checkState(numLeafKeysIssued() == 0, "Active keychain already has keys in use"))
        (§ call Preconditions.checkState(followingKeyChains == nil))

        (§ var List<DeterministicKeyChain> followingKeyChains = Lists.newArrayList())

        (§ for (DeterministicKey key :for followingAccountKeys))
        (ß
            (§ call Preconditions.checkArgument(key.getPath().size() == getAccountPath().size(), "Following keys have to be account keys"))

            (§ var DeterministicKeyChain chain = DeterministicKeyChain.watchAndFollow(key))
            (§ if (0 <= lookaheadSize))
                (§ call chain.setLookaheadSize(lookaheadSize))
            (§ if (0 <= lookaheadThreshold))
                (§ call chain.setLookaheadThreshold(lookaheadThreshold))
            (§ call followingKeyChains.add(chain))
        )

        (§ ass this.sigsRequiredToSpend = sigsRequiredToSpend)
        (§ ass this.followingKeyChains = followingKeyChains)
    )

    #_override
    #_public
    (§ method void setLookaheadSize(int lookaheadSize))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ call super.setLookaheadSize(lookaheadSize))

            (§ if (followingKeyChains != nil))
                (§ for (DeterministicKeyChain followingChain :for followingKeyChains))
                    (§ call followingChain.setLookaheadSize(lookaheadSize))
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    #_override
    #_public
    (§ method List<Protos.Key> serializeToProtobuf())
    (ß
        (§ var List<Protos.Key> result = newArrayList())
        (§ call lock.lock())
        (§ try)
        (ß
            (§ for (DeterministicKeyChain chain :for followingKeyChains))
                (§ call result.addAll(chain.serializeMyselfToProtobuf()))
            (§ call result.addAll(serializeMyselfToProtobuf()))
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
        (§ return result)
    )

    #_override
    #_protected
    (§ method void formatAddresses(boolean includePrivateKeys, NetworkParameters params, StringBuilder sb))
    (ß
        (§ for (DeterministicKeyChain followingChain :for followingKeyChains))
            (§ call sb.append("Following chain:  ").append(followingChain.getWatchingKey().serializePubB58(params)).append("\n"))
        (§ call sb.append("\n"))
        (§ for (RedeemData redeemData :for marriedKeysRedeemData.values()))
            (§ call formatScript(ScriptBuilder.createP2SHOutputScript(redeemData.redeemScript), sb, params))
    )

    #_private
    (§ method void formatScript(Script script, StringBuilder sb, NetworkParameters params))
    (ß
        (§ call sb.append("  addr:").append(script.getToAddress(params)))
        (§ call sb.append("  hash160:").append(Utils.HEX.encode(script.getPubKeyHash())))
        (§ if (0 < script.getCreationTimeSeconds()))
            (§ call sb.append("  creationTimeSeconds:").append(script.getCreationTimeSeconds()))
        (§ call sb.append("\n"))
    )

    #_override
    #_public
    (§ method void maybeLookAheadScripts())
    (ß
        (§ call super.maybeLookAheadScripts())

        (§ var int numLeafKeys = getLeafKeys().size())
        (§ call Preconditions.checkState(marriedKeysRedeemData.size() <= numLeafKeys, "Number of scripts is greater than number of leaf keys"))

        (§ if (marriedKeysRedeemData.size() != numLeafKeys))
        (ß
            (§ call maybeLookAhead())
            (§ for (DeterministicKey followedKey :for getLeafKeys()))
            (ß
                (§ var RedeemData redeemData = getRedeemData(followedKey))
                (§ var Script scriptPubKey = ScriptBuilder.createP2SHOutputScript(redeemData.redeemScript))
                (§ call marriedKeysRedeemData.put(ByteString.copyFrom(scriptPubKey.getPubKeyHash()), redeemData))
            )
        )
    )

    #_nilable
    #_override
    #_public
    (§ method RedeemData findRedeemDataByScriptHash(ByteString bytes))
    (ß
        (§ return marriedKeysRedeemData.get(bytes))
    )

    #_override
    #_public
    (§ method BloomFilter getFilter(int size, double falsePositiveRate, long tweak))
    (ß
        (§ call lock.lock())
        (§ var BloomFilter filter)
        (§ try)
        (ß
            (§ ass filter = new BloomFilter(size, falsePositiveRate, tweak))
            (§ for (Map.Entry<ByteString, RedeemData> entry :for marriedKeysRedeemData.entrySet()))
            (ß
                (§ call filter.insert(entry.getKey().toByteArray()))
                (§ call filter.insert(entry.getValue().redeemScript.getProgram()))
            )
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
        (§ return filter)
    )

    #_override
    #_public
    (§ method int numBloomFilterEntries())
    (ß
        (§ call maybeLookAhead())
        (§ return getLeafKeys().size() * 2)
    )
)

#_(ns org.bitcoinj.wallet #_"RedeemData"
    (:import [java.util ArrayList Collections List])
    (:import [com.google.common.base Preconditions])
  #_(:require [org.bitcoinj.core ECKey]
             [org.bitcoinj.script Script]))

;;;
 ; This class aggregates data required to spend transaction output.
 ;
 ; For pay-to-address and pay-to-pubkey transactions it will have only a single key and CHECKSIG program as redeemScript.
 ; For multisignature transactions there will be multiple keys one of which will be a full key and the rest are watch only,
 ; redeem script will be a CHECKMULTISIG program.  Keys will be sorted in the same order they appear in
 ; a program (lexicographical order).
 ;;
#_public
(§ class RedeemData
    #_public
    #_final
    (§ field Script redeemScript)
    #_public
    #_final
    (§ field List<ECKey> keys)

    #_private
    (§ constructor RedeemData(List<ECKey> keys, Script redeemScript))
    (ß
        (§ ass this.redeemScript = redeemScript)
        (§ var List<ECKey> sortedKeys = new ArrayList<>(keys))
        (§ call Collections.sort(sortedKeys, ECKey.PUBKEY_COMPARATOR))
        (§ ass this.keys = sortedKeys)
    )

    #_public
    #_static
    (§ method RedeemData of(List<ECKey> keys, Script redeemScript))
    (ß
        (§ return new RedeemData(keys, redeemScript))
    )

    ;;;
     ; Creates RedeemData for pay-to-address or pay-to-pubkey input.  Provided key is a single private key
     ; needed to spend such inputs and provided program should be a proper CHECKSIG program.
     ;;
    #_public
    #_static
    (§ method RedeemData of(ECKey key, Script program))
    (ß
        (§ call Preconditions.checkArgument(program.isSentToAddress() || program.isSentToRawPubKey()))

        (§ return (key != nil) ? new RedeemData(Collections.singletonList(key), program) :else nil)
    )

    ;;;
     ; Returns the first key that has private bytes.
     ;;
    #_public
    (§ method ECKey getFullKey())
    (ß
        (§ for (ECKey key :for keys))
            (§ if (key.hasPrivKey()))
                (§ return key)
        (§ return nil)
    )
)

#_(ns org.bitcoinj.wallet #_"RiskAnalysis"
    (:import [java.util List])
  #_(:require [org.bitcoinj.core Transaction]))

;;;
 ; <p>A RiskAnalysis represents an analysis of how likely it is that a transaction (and its dependencies)
 ; represents a possible double spending attack.  The wallet will create these to decide whether or not to accept
 ; a pending transaction.  Look at {@link DefaultRiskAnalysis} to see what is currently considered risky.</p>
 ;
 ; <p>The intention here is that implementing classes can expose more information and detail about the result,
 ; for app developers.  The core code needs only to know whether it's OK or not.</p>
 ;
 ; <p>A factory interface is provided.  The wallet will use this to analyze new pending transactions.</p>
 ;;
#_public
(§ interface RiskAnalysis
    (§ enum Result
        (§ item OK)
        (§ item NON_FINAL)
        (§ item NON_STANDARD)
    )

    (§ method Result analyze())

    (§ interface Analyzer
        (§ method RiskAnalysis create(Wallet wallet, Transaction tx, List<Transaction> dependencies))
    )
)

#_(ns org.bitcoinj.wallet #_"SendRequest"
    (:import [java.math BigInteger]
             [java.util Date])
    (:import [com.google.common.base MoreObjects Preconditions]
             [org.spongycastle.crypto.params KeyParameter])
  #_(:require [org.bitcoinj.core Address Coin Context ECKey NetworkParameters Transaction TransactionOutput]
             [org.bitcoinj.script Script ScriptBuilder]
             [org.bitcoinj.utils ExchangeRate]
             [org.bitcoinj.wallet.KeyChain KeyPurpose]
             [org.bitcoinj.wallet.Wallet MissingSigsMode]))

;;;
 ; A SendRequest gives the wallet information about precisely how to send money to a recipient or set of recipients.
 ; Static methods are provided to help you create SendRequests and there are a few helper methods on the wallet that
 ; just simplify the most common use cases.  You may wish to customize a SendRequest if you want to attach a fee or
 ; modify the change address.
 ;;
#_public
(§ class SendRequest
    ;;;
     ; <p>A transaction, probably incomplete, that describes the outline of what you want to do.  This typically
     ; will mean it has some outputs to the intended destinations, but no inputs or change address (and therefore
     ; no fees) - the wallet will calculate all that for you and update tx later.</p>
     ;
     ; <p>Be careful when adding outputs that you check the min output value
     ; ({@link TransactionOutput#getMinNonDustValue(Coin)}) to avoid the whole transaction being rejected
     ; because one output is dust.</p>
     ;
     ; <p>If there are already inputs to the transaction, make sure their out point has a connected output,
     ; otherwise their value will be added to fee.  Also ensure they are either signed or are spendable by
     ; a wallet key, otherwise the behavior of {@link Wallet#completeTx(Wallet.SendRequest)} is undefined
     ; (likely RuntimeException).</p>
     ;;
    #_public
    (§ field Transaction tx)

    ;;;
     ; When emptyWallet is set, all coins selected by the coin selector are sent to the first output in tx
     ; (its value is ignored and set to {@link org.bitcoinj.wallet.Wallet#getBalance()} - the fees required
     ; for the transaction).  Any additional outputs are removed.
     ;;
    #_public
    (§ field boolean emptyWallet = false)

    ;;;
     ; "Change" means the difference between the value gathered by a transactions inputs (the size of which you
     ; don't really control as it depends on who sent you money), and the value being sent somewhere else.  The
     ; change address should be selected from this wallet, normally.  <b>If null this will be chosen for you.</b>
     ;;
    #_public
    (§ field Address changeAddress = nil)

    ;;;
     ; <p>A transaction can have a fee attached, which is defined as the difference between the input values
     ; and output values.  Any value taken in that is not provided to an output can be claimed by a miner.  This
     ; is how mining is incentivized in later years of the Bitcoin system when inflation drops.  It also provides
     ; a way for people to prioritize their transactions over others and is used as a way to make denial of service
     ; attacks expensive.</p>
     ;
     ; <p>This is a dynamic fee (in satoshis) which will be added to the transaction for each kilobyte in size
     ; including the first.  This is useful as as miners usually sort pending transactions by their fee per unit size
     ; when choosing which transactions to add to a block.  Note that, to keep this equivalent to Bitcoin Core
     ; definition, a kilobyte is defined as 1000 bytes, not 1024.</p>
     ;;
    #_public
    (§ field Coin feePerKb = Context.get().getFeePerKb())

    ;;;
     ; <p>Requires that there be enough fee for a default Bitcoin Core to at least relay the transaction.
     ; (i.e. ensure the transaction will not be outright rejected by the network).  Defaults to true,
     ; you should only set this to false if you know what you're doing.</p>
     ;
     ; <p>Note that this does not enforce certain fee rules that only apply to transactions which are larger
     ; than 26,000 bytes.  If you get a transaction which is that large, you should set a feePerKb of at least
     ; {@link Transaction#REFERENCE_DEFAULT_MIN_TX_FEE}.</p>
     ;;
    #_public
    (§ field boolean ensureMinRequiredFee = Context.get().isEnsureMinRequiredFee())

    ;;;
     ; If true (the default), the inputs will be signed.
     ;;
    #_public
    (§ field boolean signInputs = true)

    ;;;
     ; The AES key to use to decrypt the private keys before signing.
     ; If null then no decryption will be performed and if decryption is required an exception will be thrown.
     ; You can get this from a password by doing wallet.getKeyCrypter().deriveKey(password).
     ;;
    #_public
    (§ field KeyParameter aesKey = nil)

    ;;;
     ; If not null, the {@link org.bitcoinj.wallet.CoinSelector} to use instead of the wallets default.
     ; Coin selectors are responsible for choosing which transaction outputs (coins) in a wallet to use given
     ; the desired send value amount.
     ;;
    #_public
    (§ field CoinSelector coinSelector = nil)

    ;;;
     ; If true (the default), the outputs will be shuffled during completion to randomize the location
     ; of the change output, if any.  This is normally what you want for privacy reasons but in unit tests
     ; it can be annoying, so it can be disabled here.
     ;;
    #_public
    (§ field boolean shuffleOutputs = true)

    ;;;
     ; Specifies what to do with missing signatures left after completing this request.  Default strategy is
     ; to throw an exception on missing signature ({@link MissingSigsMode#THROW}).
     ; @see MissingSigsMode
     ;;
    #_public
    (§ field MissingSigsMode missingSigsMode = MissingSigsMode.THROW)

    ;;;
     ; If not null, this exchange rate is recorded with the transaction during completion.
     ;;
    #_public
    (§ field ExchangeRate exchangeRate = nil)

    ;;;
     ; If not null, this memo is recorded with the transaction during completion.  It can be used to record
     ; the memo of the payment request that initiated the transaction.
     ;;
    #_public
    (§ field String memo = nil)

    ;;;
     ; If false (default value), tx fee is paid by the sender.  If true, tx fee is paid by the recipient/s.
     ; If there is more than one recipient, the tx fee is split equally between them regardless of output
     ; value and size.
     ;;
    #_public
    (§ field boolean recipientsPayFees = false)

    ;; Tracks if this has been passed to wallet.completeTx already: just a safety check.
    (§ field boolean completed)

    #_private
    (§ constructor SendRequest())
    (ß
    )

    ;;;
     ; <p>Creates a new SendRequest to the given address for the given value.</p>
     ;
     ; <p>Be very careful when value is smaller than {@link Transaction#MIN_NONDUST_OUTPUT} as the transaction
     ; will likely be rejected by the network in this case.</p>
     ;;
    #_public
    #_static
    (§ method SendRequest to(Address destination, Coin value))
    (ß
        (§ var SendRequest req = new SendRequest())
        #_final
        (§ var NetworkParameters parameters = destination.getParameters())

        (§ call Preconditions.checkNotNull(parameters, "Address is for an unknown network"))

        (§ ass req.tx = new Transaction(parameters))
        (§ call req.tx.addOutput(value, destination))
        (§ return req)
    )

    ;;;
     ; <p>Creates a new SendRequest to the given pubkey for the given value.</p>
     ;
     ; <p>Be careful to check the output's value is reasonable using
     ; {@link TransactionOutput#getMinNonDustValue(Coin)} afterwards or you risk having the transaction
     ; rejected by the network.  Note that using {@link SendRequest#to(Address, Coin)} will result
     ; in a smaller output, and thus the ability to use a smaller output value without rejection.</p>
     ;;
    #_public
    #_static
    (§ method SendRequest to(NetworkParameters params, ECKey destination, Coin value))
    (ß
        (§ var SendRequest req = new SendRequest())
        (§ ass req.tx = new Transaction(params))
        (§ call req.tx.addOutput(value, destination))
        (§ return req)
    )

    ;;; Simply wraps a pre-built incomplete transaction provided by you. ;;
    #_public
    #_static
    (§ method SendRequest forTx(Transaction tx))
    (ß
        (§ var SendRequest req = new SendRequest())
        (§ ass req.tx = tx)
        (§ return req)
    )

    #_public
    #_static
    (§ method SendRequest emptyWallet(Address destination))
    (ß
        (§ var SendRequest req = new SendRequest())
        #_final
        (§ var NetworkParameters parameters = destination.getParameters())

        (§ call Preconditions.checkNotNull(parameters, "Address is for an unknown network"))

        (§ ass req.tx = new Transaction(parameters))
        (§ call req.tx.addOutput(Coin.ZERO, destination))
        (§ ass req.emptyWallet = true)
        (§ return req)
    )

    ;;;
     ; Construct a SendRequest for a CPFP (child-pays-for-parent) transaction.  The resulting transaction is
     ; already completed, so you should directly proceed to signing and broadcasting/committing the transaction.
     ; CPFP is currently only supported by a few miners, so use with care.
     ;;
    #_public
    #_static
    (§ method SendRequest childPaysForParent(Wallet wallet, Transaction parentTransaction, Coin feeRaise))
    (ß
        (§ var TransactionOutput outputToSpend = nil)
        (§ for (#_final TransactionOutput output :for parentTransaction.getOutputs()))
        (ß
            (§ if (output.isMine(wallet) && output.isAvailableForSpending() && output.getValue().isGreaterThan(feeRaise)))
            (ß
                (§ ass outputToSpend = output)
                (§ break)
            )
        )
        ;; TODO: Spend another confirmed output of own wallet if needed.
        (§ call Preconditions.checkNotNull(outputToSpend, "Can't find adequately sized output that spends to us"))

        #_final
        (§ var Transaction tx = new Transaction(parentTransaction.getParams()))
        (§ call tx.addInput(outputToSpend))
        (§ call tx.addOutput(outputToSpend.getValue().subtract(feeRaise), wallet.freshAddress(KeyPurpose.CHANGE)))
        (§ call tx.setPurpose(Transaction.Purpose.RAISE_FEE))
        #_final
        (§ var SendRequest req = forTx(tx))
        (§ ass req.completed = true)
        (§ return req)
    )

    #_public
    #_static
    (§ method SendRequest toCLTVPaymentChannel(NetworkParameters params, Date releaseTime, ECKey from, ECKey to, Coin value))
    (ß
        (§ var long time = releaseTime.getTime() / 1000)

        (§ call Preconditions.checkArgument(Transaction.LOCKTIME_THRESHOLD <= time, "Release time was too small"))

        (§ return toCLTVPaymentChannel(params, BigInteger.valueOf(time), from, to, value))
    )

    #_public
    #_static
    (§ method SendRequest toCLTVPaymentChannel(NetworkParameters params, int releaseBlock, ECKey from, ECKey to, Coin value))
    (ß
        (§ call Preconditions.checkArgument(0 <= releaseBlock && releaseBlock < Transaction.LOCKTIME_THRESHOLD, "Block number was too large"))

        (§ return toCLTVPaymentChannel(params, BigInteger.valueOf(releaseBlock), from, to, value))
    )

    #_public
    #_static
    (§ method SendRequest toCLTVPaymentChannel(NetworkParameters params, BigInteger time, ECKey from, ECKey to, Coin value))
    (ß
        (§ var SendRequest req = new SendRequest())
        (§ var Script output = ScriptBuilder.createCLTVPaymentChannelOutput(time, from, to))
        (§ ass req.tx = new Transaction(params))
        (§ call req.tx.addOutput(value, output))
        (§ return req)
    )

    #_override
    #_public
    (§ method String toString())
    (ß
        ;; Print only the user-settable fields.
        (§ var MoreObjects.ToStringHelper helper = MoreObjects.toStringHelper(this).omitNullValues())
        (§ call helper.add("emptyWallet", emptyWallet))
        (§ call helper.add("changeAddress", changeAddress))
        (§ call helper.add("feePerKb", feePerKb))
        (§ call helper.add("ensureMinRequiredFee", ensureMinRequiredFee))
        (§ call helper.add("signInputs", signInputs))
        (§ call helper.add("aesKey", (aesKey != nil) ? "set" :else nil)) ;; Careful to not leak the key.
        (§ call helper.add("coinSelector", coinSelector))
        (§ call helper.add("shuffleOutputs", shuffleOutputs))
        (§ call helper.add("recipientsPayFees", recipientsPayFees))
        (§ return helper.toString())
    )
)

#_(ns org.bitcoinj.wallet #_"UnreadableWalletException")

;;;
 ; Thrown by the {@link WalletProtobufSerializer} when the serialized protocol buffer is either corrupted,
 ; internally inconsistent or appears to be from the future.
 ;;
#_public
(§ class UnreadableWalletException extends Exception
    #_public
    (§ constructor UnreadableWalletException(String s))
    (ß
        (§ super (s))
    )

    #_public
    (§ constructor UnreadableWalletException(String s, Throwable t))
    (ß
        (§ super (s, t))
    )

    #_public
    #_static
    (§ class BadPassword extends UnreadableWalletException
        #_public
        (§ constructor BadPassword())
        (ß
            (§ super ("Password incorrect"))
        )
    )

    #_public
    #_static
    (§ class FutureVersion extends UnreadableWalletException
        #_public
        (§ constructor FutureVersion())
        (ß
            (§ super ("Unknown wallet version from the future."))
        )
    )

    #_public
    #_static
    (§ class WrongNetwork extends UnreadableWalletException
        #_public
        (§ constructor WrongNetwork())
        (ß
            (§ super ("Mismatched network ID"))
        )
    )
)

#_(ns org.bitcoinj.wallet #_"Wallet"
    (:import #_[java.io *]
             [java.math BigInteger]
             #_[java.util *]
             #_[java.util.concurrent *]
             #_[java.util.concurrent.atomic *]
             #_[java.util.concurrent.locks *])
    (:import #_[com.google.common.annotations *]
             #_[com.google.common.base *]
             #_[com.google.common.collect *]
             #_[com.google.common.primitives *]
             #_[com.google.common.util.concurrent *]
             #_[com.google.protobuf *]
             #_[net.jcip.annotations *]
             #_[org.slf4j *]
             #_[org.spongycastle.crypto.params *])
  #_(:require [org.bitcoinj.core AbstractBlockChain Address BlockChain BloomFilter Coin Context ECKey FilteredBlock InsufficientMoneyException Message NetworkParameters Peer PeerFilterProvider PeerGroup ScriptException Sha256Hash StoredBlock Transaction TransactionBag TransactionBroadcast TransactionBroadcaster TransactionConfidence TransactionInput TransactionOutPoint TransactionOutput UTXO Utils VarInt VerificationException]
             #_[org.bitcoinj.core.TransactionConfidence *]
             #_[org.bitcoinj.core.listeners *]
             #_[org.bitcoinj.crypto *]
             #_[org.bitcoinj.script *]
             #_[org.bitcoinj.signers *]
             #_[org.bitcoinj.utils *]
             #_[org.bitcoinj.wallet.Protos.Wallet *]
             #_[org.bitcoinj.wallet.WalletTransaction *]
             [org.bitcoinj.wallet.listeners KeyChainEventListener WalletChangeEventListener WalletCoinsReceivedEventListener WalletCoinsSentEventListener WalletReorganizeEventListener]))

;; To do list:
;;
;; - Take all wallet-relevant data out of Transaction and put it into WalletTransaction.  Make Transaction immutable.
;; - Only store relevant transaction outputs, don't bother storing the rest of the data.  Big RAM saving.
;; - Split block chain and tx output tracking into a superclass that doesn't have any key or spending related code.
;; - Simplify how transactions are tracked and stored: in particular, have the wallet maintain positioning information
;;   for transactions independent of the transactions themselves, so the timeline can be walked without having to
;;   process and sort every single transaction.
;; - Split data persistence out into a backend class and make the wallet transactional, so we can store a wallet
;;   in a database not just in RAM.
;; - Make clearing of transactions able to only rewind the wallet a certain distance instead of all blocks.
;; - Make it scale:
;;     - eliminate all the algorithms with quadratic complexity (or worse).
;;     - don't require everything to be held in RAM at once.
;;     - consider allowing eviction of no longer re-orgable transactions or keys that were used up.
;;
;; Finally, find more ways to break the class up and decompose it.  Currently every time we move code out, other code
;; fills up the lines saved!

;;;
 ; <p>A Wallet stores keys and a record of transactions that send and receive value from those keys.  Using these,
 ; it is able to create new transactions that spend the recorded transactions, and this is the fundamental operation
 ; of the Bitcoin protocol.</p>
 ;
 ; <p>To learn more about this class, read <b><a href="https://bitcoinj.github.io/working-with-the-wallet">working with the wallet.</a></b></p>
 ;
 ; <p>To fill up a Wallet with transactions, you need to use it in combination with a {@link BlockChain} and various
 ; other objects, see the <a href="https://bitcoinj.github.io/getting-started">Getting started</a> tutorial
 ; on the website to learn more about how to set everything up.</p>
 ;
 ; <p>Wallets can be serialized using protocol buffers.  You need to save the wallet whenever it changes, there is an
 ; auto-save feature that simplifies this for you although you're still responsible for manually triggering a save when
 ; your app is about to quit because the auto-save feature waits a moment before actually committing to disk to avoid IO
 ; thrashing when the wallet is changing very fast (e.g. due to a block chain sync).  See
 ; {@link Wallet#autosaveToFile(java.io.File, long, java.util.concurrent.TimeUnit, org.bitcoinj.wallet.WalletFiles.Listener)}
 ; for more information about this.</p>
 ;;
#_public
(§ class Wallet implements NewBestBlockListener, TransactionReceivedInBlockListener, PeerFilterProvider, KeyBag, TransactionBag, ReorganizeListener
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(Wallet.class))
    #_private
    #_static
    #_final
    (§ field int MINIMUM_BLOOM_DATA_LENGTH = 8)

    ;; Ordering: lock > keyChainGroupLock.  KeyChainGroup is protected separately to allow fast querying of current receive
    ;; address even if the wallet itself is busy e.g. saving or processing a big reorg.  Useful for reducing UI latency.
    #_protected
    #_final
    (§ field ReentrantLock lock = Threading.lock("wallet"))
    #_protected
    #_final
    (§ field ReentrantLock keyChainGroupLock = Threading.lock("wallet-keychaingroup"))

    ;; The various pools below give quick access to wallet-relevant transactions by the state they're in:
    ;;
    ;; Pending:  Transactions that didn't make it into the best chain yet.  Pending transactions can be killed if a
    ;;           double spend against them appears in the best chain, in which case they move to the dead pool.
    ;;           If a double spend appears in the pending state as well, we update the confidence type
    ;;           of all txns in conflict to IN_CONFLICT and wait for the miners to resolve the race.
    ;; Unspent:  Transactions that appeared in the best chain and have outputs we can spend.  Note that we store the
    ;;           entire transaction in memory even though for spending purposes we only really need the outputs, the
    ;;           reason being that this simplifies handling of re-orgs.  It would be worth fixing this in future.
    ;; Spent:    Transactions that appeared in the best chain but don't have any spendable outputs.  They're stored
    ;;           here for history browsing/auditing reasons only and in future will probably be flushed out to some
    ;;           other kind of cold storage or just removed.
    ;; Dead:     Transactions that we believe will never confirm get moved here, out of pending.  Note that Bitcoin
    ;;           Core has no notion of dead-ness: the assumption is that double spends won't happen so there's no
    ;;           need to notify the user about them.  We take a more pessimistic approach and try to track the fact
    ;;           that transactions have been double spent so applications can do something intelligent (cancel orders,
    ;;           show to the user in the UI, etc).  A transaction can leave dead and move into spent/unspent if there
    ;;           is a re-org to a chain that doesn't include the double spend.

    #_private
    #_final
    (§ field Map<Sha256Hash, Transaction> pending)
    #_private
    #_final
    (§ field Map<Sha256Hash, Transaction> unspent)
    #_private
    #_final
    (§ field Map<Sha256Hash, Transaction> spent)
    #_private
    #_final
    (§ field Map<Sha256Hash, Transaction> dead)

    ;; All transactions together.
    #_protected
    #_final
    (§ field Map<Sha256Hash, Transaction> transactions)

    ;; All the TransactionOutput objects that we could spend (ignoring whether we have the private key or not).
    ;; Used to speed up various calculations.
    #_protected
    #_final
    (§ field HashSet<TransactionOutput> myUnspents = Sets.newHashSet())

    ;; Transactions that were dropped by the risk analysis system.  These are not in any pools and not serialized
    ;; to disk.  We have to keep them around because if we ignore a tx because we think it will never confirm, but
    ;; then it actually does confirm and does so within the same network session, remote peers will not resend us
    ;; the tx data along with the Bloom filtered block, as they know we already received it once before
    ;; (so it would be wasteful to repeat).  Thus we keep them around here for a while.  If we drop our network
    ;; connections then the remote peers will forget that we were sent the tx data previously and send it again
    ;; when relaying a filtered merkleblock.
    #_private
    #_final
    (§ field LinkedHashMap<Sha256Hash, Transaction> riskDropped = new LinkedHashMap<Sha256Hash, Transaction>()
        (ß
            #_override
            #_protected
            (§ method boolean removeEldestEntry(Map.Entry<Sha256Hash, Transaction> eldest))
            (ß
                (§ return (1000 < size()))
            )
        ))

    ;; The key chain group is not thread safe, and generally the whole hierarchy of objects should not be mutated
    ;; outside the wallet lock.  So don't expose this object directly via any accessors!
    #_guarded-by(ß "keyChainGroupLock")
    #_private
    (§ field KeyChainGroup keyChainGroup)

    #_protected
    #_final
    (§ field Context context)
    #_protected
    #_final
    (§ field NetworkParameters params)

    #_nilable
    #_private
    (§ field Sha256Hash lastBlockSeenHash)
    #_private
    (§ field int lastBlockSeenHeight)
    #_private
    (§ field long lastBlockSeenTimeSecs)

    #_private
    #_final
    (§ field CopyOnWriteArrayList<ListenerRegistration<WalletChangeEventListener>> changeListeners = new CopyOnWriteArrayList<>())
    #_private
    #_final
    (§ field CopyOnWriteArrayList<ListenerRegistration<WalletCoinsReceivedEventListener>> coinsReceivedListeners = new CopyOnWriteArrayList<>())
    #_private
    #_final
    (§ field CopyOnWriteArrayList<ListenerRegistration<WalletCoinsSentEventListener>> coinsSentListeners = new CopyOnWriteArrayList<>())
    #_private
    #_final
    (§ field CopyOnWriteArrayList<ListenerRegistration<WalletReorganizeEventListener>> reorganizeListeners = new CopyOnWriteArrayList<>())
    #_private
    #_final
    (§ field CopyOnWriteArrayList<ListenerRegistration<TransactionConfidenceEventListener>> transactionConfidenceListeners = new CopyOnWriteArrayList<>())

    ;; A listener that relays confidence changes from the transaction confidence object to the wallet event listener,
    ;; as a convenience to API users so they don't have to register on every transaction themselves.
    #_private
    (§ field TransactionConfidence.Listener txConfidenceListener)

    ;; If a TX hash appears in this set then notifyNewBestBlock will ignore it, as its confidence was already set up
    ;; in receive() via Transaction.setBlockAppearance().  As the BlockChain always calls notifyNewBestBlock even if
    ;; it sent transactions to the wallet, without this we'd double count.
    #_private
    (§ field HashSet<Sha256Hash> ignoreNextNewBlock)
    ;; Whether or not to ignore pending transactions that are considered risky by the configured risk analyzer.
    #_private
    (§ field boolean acceptRiskyTransactions)
    ;; Object that performs risk analysis of pending transactions.  We might reject transactions that seem like
    ;; a high risk of being a double spending attack.
    #_private
    (§ field RiskAnalysis.Analyzer riskAnalyzer = DefaultRiskAnalysis.FACTORY)

    ;; Stuff for notifying transaction objects that we changed their confidences.  The purpose of this is to avoid
    ;; spuriously sending lots of repeated notifications to listeners that API users aren't really interested in as
    ;; a side effect of how the code is written (e.g. during re-orgs confidence data gets adjusted multiple times).
    #_private
    (§ field int onWalletChangedSuppressions)
    #_private
    (§ field boolean insideReorg)
    #_private
    (§ field Map<Transaction, TransactionConfidence.Listener.ChangeReason> confidenceChanged)
    #_protected
    #_volatile
    (§ field WalletFiles vFileManager)
    ;; Object that is used to send transactions asynchronously when the wallet requires it.
    #_protected
    #_volatile
    (§ field TransactionBroadcaster vTransactionBroadcaster)
    ;; UNIX time in seconds.  Money controlled by keys created before this time will be automatically respent to
    ;; a key that was created after it.  Useful when you believe some keys have been compromised.
    #_private
    #_volatile
    (§ field long vKeyRotationTimestamp)

    #_protected
    (§ field CoinSelector coinSelector = new DefaultCoinSelector())

    ;; The wallet version.  This is an int that can be used to track breaking changes in the wallet format.
    ;; You can also use it to detect wallets that come from the future (i.e. they contain features you
    ;; do not know how to deal with).
    #_private
    (§ field int version)
    ;; User-provided description that may help people keep track of what a wallet is for.
    #_private
    (§ field String description)

    ;; Objects that perform transaction signing.  Applied subsequently one after another.
    #_guarded-by(ß "lock")
    #_private
    (§ field List<TransactionSigner> signers)

    ;;;
     ; Creates a new, empty wallet with a randomly chosen seed and no transactions.  Make sure to provide for
     ; sufficient backup!  Any keys will be derived from the seed.  If you want to restore a wallet from disk
     ; instead, see {@link #loadFromFile}.
     ;;
    #_public
    (§ constructor Wallet(NetworkParameters params))
    (ß
        (§ this (Context.getOrCreate(params)))
    )

    ;;;
     ; Creates a new, empty wallet with a randomly chosen seed and no transactions.  Make sure to provide for
     ; sufficient backup!  Any keys will be derived from the seed.  If you want to restore a wallet from disk
     ; instead, see {@link #loadFromFile}.
     ;;
    #_public
    (§ constructor Wallet(Context context))
    (ß
        (§ this (context, new KeyChainGroup(context.getParams())))
    )

    #_public
    #_static
    (§ method Wallet fromSeed(NetworkParameters params, DeterministicSeed seed))
    (ß
        (§ return new Wallet(params, new KeyChainGroup(params, seed)))
    )

    ;;;
     ; Creates a wallet that tracks payments to and from the HD key hierarchy rooted by the given watching key.
     ; A watching key corresponds to account zero in the recommended BIP32 key hierarchy.
     ;;
    #_public
    #_static
    (§ method Wallet fromWatchingKey(NetworkParameters params, DeterministicKey watchKey))
    (ß
        (§ return new Wallet(params, new KeyChainGroup(params, watchKey)))
    )

    ;;;
     ; Creates a wallet that tracks payments to and from the HD key hierarchy rooted by the given watching key.
     ; A watching key corresponds to account zero in the recommended BIP32 key hierarchy.  The key is specified
     ; in base58 notation and the creation time of the key.  If you don't know the creation time, you can pass
     ; {@link DeterministicHierarchy#BIP32_STANDARDISATION_TIME_SECS}.
     ;;
    #_public
    #_static
    (§ method Wallet fromWatchingKeyB58(NetworkParameters params, String watchKeyB58, long creationTimeSeconds))
    (ß
        #_final
        (§ var DeterministicKey watchKey = DeterministicKey.deserializeB58(nil, watchKeyB58, params))
        (§ call watchKey.setCreationTimeSeconds(creationTimeSeconds))
        (§ return fromWatchingKey(params, watchKey))
    )

    ;;;
     ; Creates a wallet containing a given set of keys.  All further keys will be derived from the oldest key.
     ;;
    #_public
    #_static
    (§ method Wallet fromKeys(NetworkParameters params, List<ECKey> keys))
    (ß
        (§ for (ECKey key :for keys))
            (§ call Preconditions.checkArgument(!(key instanceof DeterministicKey)))

        (§ var KeyChainGroup group = new KeyChainGroup(params))
        (§ call group.importKeys(keys))
        (§ return new Wallet(params, group))
    )

    #_public
    (§ constructor Wallet(NetworkParameters params, KeyChainGroup keyChainGroup))
    (ß
        (§ this (Context.getOrCreate(params), keyChainGroup))
    )

    #_private
    (§ constructor Wallet(Context context, KeyChainGroup keyChainGroup))
    (ß
        (§ ass this.context = context)
        (§ ass this.params = context.getParams())
        (§ ass this.keyChainGroup = Preconditions.checkNotNull(keyChainGroup))
        (§ if (params.getId().equals(NetworkParameters.ID_UNITTESTNET)))
            (§ call this.keyChainGroup.setLookaheadSize(5)) ;; Cut down excess computation for unit tests.
        ;; If this keyChainGroup was created fresh just now (new wallet), make HD so a backup can be made immediately
        ;; without having to call current/freshReceiveKey.  If there are already keys in the chain of any kind then
        ;; we're probably being deserialized so leave things alone: the API user can upgrade later.
        (§ if (this.keyChainGroup.numKeys() == 0))
            (§ call this.keyChainGroup.createAndActivateNewHDChain())
        (§ ass unspent = new HashMap<>())
        (§ ass spent = new HashMap<>())
        (§ ass pending = new HashMap<>())
        (§ ass dead = new HashMap<>())
        (§ ass transactions = new HashMap<>())
        ;; Use a linked hash map to ensure ordering of event listeners is correct.
        (§ ass confidenceChanged = new LinkedHashMap<>())
        (§ ass signers = new ArrayList<>())
        (§ call addTransactionSigner(new LocalTransactionSigner()))
        (§ call createTransientState())
    )

    #_private
    (§ method void createTransientState())
    (ß
        (§ ass ignoreNextNewBlock = new HashSet<>())
        (§ ass txConfidenceListener = new TransactionConfidence.Listener()
        (ß
            #_override
            #_public
            (§ method void onConfidenceChanged(TransactionConfidence confidence, TransactionConfidence.Listener.ChangeReason reason))
            (ß
                ;; This will run on the user code thread so we shouldn't do anything too complicated here.
                ;; We only want to queue a wallet changed event and auto-save if the number of peers announcing
                ;; the transaction has changed, as that confidence change is made by the networking code which
                ;; doesn't necessarily know at that point which wallets contain which transactions, so it's up
                ;; to us to listen for that.  Other types of confidence changes (type, etc.) are triggered by us,
                ;; so we'll queue up a wallet change event in other parts of the code.
                (§ if (reason == ChangeReason.SEEN_PEERS))
                (ß
                    (§ call lock.lock())
                    (§ try)
                    (ß
                        (§ call checkBalanceFuturesLocked(nil))
                        (§ var Transaction tx = getTransaction(confidence.getTransactionHash()))
                        (§ call queueOnTransactionConfidenceChanged(tx))
                        (§ call maybeQueueOnWalletChanged())
                    )
                    (§ finally)
                    (ß
                        (§ call lock.unlock())
                    )
                )
            )
        ))
        (§ ass acceptRiskyTransactions = false)
    )

    #_public
    (§ method NetworkParameters getNetworkParameters())
    (ß
        (§ return params)
    )

    ;;;
     ; Gets the active keychain via {@link KeyChainGroup#getActiveKeyChain()}.
     ;;
    #_public
    (§ method DeterministicKeyChain getActiveKeyChain())
    (ß
        (§ return keyChainGroup.getActiveKeyChain())
    )

    ;;;
     ; <p>Adds given transaction signer to the list of signers.  It will be added to the end of the signers list,
     ; so if this wallet already has some signers added, given signer will be executed after all of them.</p>
     ; <p>Transaction signer should be fully initialized before adding to the wallet, otherwise
     ; {@link IllegalStateException} will be thrown</p>
     ;;
    #_public
    #_final
    (§ method void addTransactionSigner(TransactionSigner signer))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ if (signer.isReady()))
                (§ call signers.add(signer))
            (§ else)
                (§ throw new IllegalStateException("Signer instance is not ready to be added into Wallet: " + signer.getClass()))
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    #_public
    (§ method List<TransactionSigner> getTransactionSigners())
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ return ImmutableList.copyOf(signers))
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Returns a key that hasn't been seen in a transaction yet, and which is suitable for displaying
     ; in a wallet user interface as "a convenient key to receive funds on" when the purpose parameter
     ; is {@link org.bitcoinj.wallet.KeyChain.KeyPurpose#RECEIVE_FUNDS}.  The returned key is stable
     ; until it's actually seen in a pending or confirmed transaction, at which point this method will
     ; start returning a different key (for each purpose independently).
     ;;
    #_public
    (§ method DeterministicKey currentKey(KeyChain.KeyPurpose purpose))
    (ß
        (§ call keyChainGroupLock.lock())
        (§ try)
        (ß
            (§ call maybeUpgradeToHD())
            (§ return keyChainGroup.currentKey(purpose))
        )
        (§ finally)
        (ß
            (§ call keyChainGroupLock.unlock())
        )
    )

    ;;;
     ; An alias for calling {@link #currentKey(org.bitcoinj.wallet.KeyChain.KeyPurpose)} with
     ; {@link org.bitcoinj.wallet.KeyChain.KeyPurpose#RECEIVE_FUNDS} as the parameter.
     ;;
    #_public
    (§ method DeterministicKey currentReceiveKey())
    (ß
        (§ return currentKey(KeyChain.KeyPurpose.RECEIVE_FUNDS))
    )

    ;;;
     ; Returns address for a {@link #currentKey(org.bitcoinj.wallet.KeyChain.KeyPurpose)}.
     ;;
    #_public
    (§ method Address currentAddress(KeyChain.KeyPurpose purpose))
    (ß
        (§ call keyChainGroupLock.lock())
        (§ try)
        (ß
            (§ call maybeUpgradeToHD())
            (§ return keyChainGroup.currentAddress(purpose))
        )
        (§ finally)
        (ß
            (§ call keyChainGroupLock.unlock())
        )
    )

    ;;;
     ; An alias for calling {@link #currentAddress(org.bitcoinj.wallet.KeyChain.KeyPurpose)} with
     ; {@link org.bitcoinj.wallet.KeyChain.KeyPurpose#RECEIVE_FUNDS} as the parameter.
     ;;
    #_public
    (§ method Address currentReceiveAddress())
    (ß
        (§ return currentAddress(KeyChain.KeyPurpose.RECEIVE_FUNDS))
    )

    ;;;
     ; Returns a key that has not been returned by this method before (fresh).  You can think of this
     ; as being a newly created key, although the notion of "create" is not really valid for a
     ; {@link org.bitcoinj.wallet.DeterministicKeyChain}.  When the parameter is
     ; {@link org.bitcoinj.wallet.KeyChain.KeyPurpose#RECEIVE_FUNDS} the returned key is suitable for
     ; being put into a receive coins wizard type UI.  You should use this when the user is definitely
     ; going to hand this key out to someone who wishes to send money.
     ;;
    #_public
    (§ method DeterministicKey freshKey(KeyChain.KeyPurpose purpose))
    (ß
        (§ return freshKeys(purpose, 1).get(0))
    )

    ;;;
     ; Returns a key/s that has not been returned by this method before (fresh).  You can think of this
     ; as being a newly created key/s, although the notion of "create" is not really valid for a
     ; {@link org.bitcoinj.wallet.DeterministicKeyChain}.  When the parameter is
     ; {@link org.bitcoinj.wallet.KeyChain.KeyPurpose#RECEIVE_FUNDS} the returned key is suitable for
     ; being put into a receive coins wizard type UI. You should use this when the user is definitely
     ; going to hand this key/s out to someone who wishes to send money.
     ;;
    #_public
    (§ method List<DeterministicKey> freshKeys(KeyChain.KeyPurpose purpose, int numberOfKeys))
    (ß
        (§ var List<DeterministicKey> keys)
        (§ call keyChainGroupLock.lock())
        (§ try)
        (ß
            (§ call maybeUpgradeToHD())
            (§ ass keys = keyChainGroup.freshKeys(purpose, numberOfKeys))
        )
        (§ finally)
        (ß
            (§ call keyChainGroupLock.unlock())
        )
        ;; Do we really need an immediate hard save?  Arguably all this is doing is saving the 'current' key
        ;; and that's not quite so important, so we could coalesce for more performance.
        (§ call saveNow())
        (§ return keys)
    )

    ;;;
     ; An alias for calling {@link #freshKey(org.bitcoinj.wallet.KeyChain.KeyPurpose)} with
     ; {@link org.bitcoinj.wallet.KeyChain.KeyPurpose#RECEIVE_FUNDS} as the parameter.
     ;;
    #_public
    (§ method DeterministicKey freshReceiveKey())
    (ß
        (§ return freshKey(KeyChain.KeyPurpose.RECEIVE_FUNDS))
    )

    ;;;
     ; Returns address for a {@link #freshKey(org.bitcoinj.wallet.KeyChain.KeyPurpose)}.
     ;;
    #_public
    (§ method Address freshAddress(KeyChain.KeyPurpose purpose))
    (ß
        (§ var Address key)
        (§ call keyChainGroupLock.lock())
        (§ try)
        (ß
            (§ ass key = keyChainGroup.freshAddress(purpose))
        )
        (§ finally)
        (ß
            (§ call keyChainGroupLock.unlock())
        )
        (§ call saveNow())
        (§ return key)
    )

    ;;;
     ; An alias for calling {@link #freshAddress(org.bitcoinj.wallet.KeyChain.KeyPurpose)} with
     ; {@link org.bitcoinj.wallet.KeyChain.KeyPurpose#RECEIVE_FUNDS} as the parameter.
     ;;
    #_public
    (§ method Address freshReceiveAddress())
    (ß
        (§ return freshAddress(KeyChain.KeyPurpose.RECEIVE_FUNDS))
    )

    ;;;
     ; Returns only the keys that have been issued by {@link #freshReceiveKey()}, {@link #freshReceiveAddress()},
     ; {@link #currentReceiveKey()} or {@link #currentReceiveAddress()}.
     ;;
    #_public
    (§ method List<ECKey> getIssuedReceiveKeys())
    (ß
        (§ call keyChainGroupLock.lock())
        (§ try)
        (ß
            (§ return keyChainGroup.getActiveKeyChain().getIssuedReceiveKeys())
        )
        (§ finally)
        (ß
            (§ call keyChainGroupLock.unlock())
        )
    )

    ;;;
     ; Returns only the addresses that have been issued by {@link #freshReceiveKey()}, {@link #freshReceiveAddress()},
     ; {@link #currentReceiveKey()} or {@link #currentReceiveAddress()}.
     ;;
    #_public
    (§ method List<Address> getIssuedReceiveAddresses())
    (ß
        #_final
        (§ var List<ECKey> keys = getIssuedReceiveKeys())
        (§ var List<Address> addresses = new ArrayList<>(keys.size()))
        (§ for (ECKey key :for keys))
            (§ call addresses.add(key.toAddress(getParams())))
        (§ return addresses)
    )

    ;;;
     ; Upgrades the wallet to be deterministic (BIP32).  You should call this, possibly providing the users encryption
     ; key, after loading a wallet produced by previous versions of bitcoinj.  If the wallet is encrypted the key
     ; <b>must</b> be provided, due to the way the seed is derived deterministically from private key bytes: failing
     ; to do this will result in an exception being thrown.  For non-encrypted wallets, the upgrade will be done for
     ; you automatically the first time a new key is requested (this happens when spending due to the change address).
     ;;
    #_public
    (§ method void upgradeToDeterministic(#_nilable KeyParameter aesKey))
        (§ throws DeterministicUpgradeRequiresPassword)
    (ß
        (§ call keyChainGroupLock.lock())
        (§ try)
        (ß
            (§ call keyChainGroup.upgradeToDeterministic(vKeyRotationTimestamp, aesKey))
        )
        (§ finally)
        (ß
            (§ call keyChainGroupLock.unlock())
        )
    )

    ;;;
     ; Returns true if the wallet contains random keys and no HD chains, in which case you should call
     ; {@link #upgradeToDeterministic(org.spongycastle.crypto.params.KeyParameter)} before attempting
     ; to do anything that would require a new address or key.
     ;;
    #_public
    (§ method boolean isDeterministicUpgradeRequired())
    (ß
        (§ call keyChainGroupLock.lock())
        (§ try)
        (ß
            (§ return keyChainGroup.isDeterministicUpgradeRequired())
        )
        (§ finally)
        (ß
            (§ call keyChainGroupLock.unlock())
        )
    )

    #_private
    (§ method void maybeUpgradeToHD())
        (§ throws DeterministicUpgradeRequiresPassword)
    (ß
        (§ call maybeUpgradeToHD(nil))
    )

    #_guarded-by(ß "keyChainGroupLock")
    #_private
    (§ method void maybeUpgradeToHD(#_nilable KeyParameter aesKey))
        (§ throws DeterministicUpgradeRequiresPassword)
    (ß
        (§ call Preconditions.checkState(keyChainGroupLock.isHeldByCurrentThread()))
        (§ if (keyChainGroup.isDeterministicUpgradeRequired()))
        (ß
            (§ call log.info("Upgrade to HD wallets is required, attempting to do so."))
            (§ try)
            (ß
                (§ call upgradeToDeterministic(aesKey))
            )
            (§ catch (DeterministicUpgradeRequiresPassword e))
            (ß
                (§ call log.error("Failed to auto upgrade due to encryption. You should call wallet.upgradeToDeterministic with the users AES key to avoid this error."))
                (§ throw e)
            )
        )
    )

    ;;;
     ; Removes the given key from the basicKeyChain.  Be very careful with this - losing a private key
     ; <b>destroys the money associated with it</b>.
     ; @return whether the key was removed or not.
     ;;
    #_public
    (§ method boolean removeKey(ECKey key))
    (ß
        (§ call keyChainGroupLock.lock())
        (§ try)
        (ß
            (§ return keyChainGroup.removeImportedKey(key))
        )
        (§ finally)
        (ß
            (§ call keyChainGroupLock.unlock())
        )
    )

    ;;;
     ; Returns the number of keys in the key chain group, including lookahead keys.
     ;;
    #_public
    (§ method int getKeyChainGroupSize())
    (ß
        (§ call keyChainGroupLock.lock())
        (§ try)
        (ß
            (§ return keyChainGroup.numKeys())
        )
        (§ finally)
        (ß
            (§ call keyChainGroupLock.unlock())
        )
    )

    #_testing
    #_public
    (§ method int getKeyChainGroupCombinedKeyLookaheadEpochs())
    (ß
        (§ call keyChainGroupLock.lock())
        (§ try)
        (ß
            (§ return keyChainGroup.getCombinedKeyLookaheadEpochs())
        )
        (§ finally)
        (ß
            (§ call keyChainGroupLock.unlock())
        )
    )

    ;;;
     ; Returns a list of the non-deterministic keys that have been imported into the wallet, or the empty list if none.
     ;;
    #_public
    (§ method List<ECKey> getImportedKeys())
    (ß
        (§ call keyChainGroupLock.lock())
        (§ try)
        (ß
            (§ return keyChainGroup.getImportedKeys())
        )
        (§ finally)
        (ß
            (§ call keyChainGroupLock.unlock())
        )
    )

    ;;; Returns the address used for change outputs.  Note: this will probably go away in future. ;;
    #_public
    (§ method Address currentChangeAddress())
    (ß
        (§ return currentAddress(KeyChain.KeyPurpose.CHANGE))
    )

    ;;;
     ; <p>Imports the given ECKey to the wallet.</p>
     ;
     ; <p>If the wallet is configured to auto save to a file, triggers a save immediately.  Runs the onKeysAdded event
     ; handler.  If the key already exists in the wallet, does nothing and returns false.</p>
     ;;
    #_public
    (§ method boolean importKey(ECKey key))
    (ß
        (§ return (importKeys(Lists.newArrayList(key)) == 1))
    )

    ;;;
     ; Imports the given keys to the wallet.
     ; If {@link Wallet#autosaveToFile(java.io.File, long, java.util.concurrent.TimeUnit, org.bitcoinj.wallet.WalletFiles.Listener)}
     ; has been called, triggers an auto save bypassing the normal coalescing delay and event handlers.
     ; Returns the number of keys added, after duplicates are ignored.  The onKeyAdded event will be called
     ; for each key in the list that was not already present.
     ;;
    #_public
    (§ method int importKeys(#_final List<ECKey> keys))
    (ß
        ;; API usage check.
        (§ call checkNoDeterministicKeys(keys))
        (§ var int result)
        (§ call keyChainGroupLock.lock())
        (§ try)
        (ß
            (§ ass result = keyChainGroup.importKeys(keys))
        )
        (§ finally)
        (ß
            (§ call keyChainGroupLock.unlock())
        )
        (§ call saveNow())
        (§ return result)
    )

    #_private
    (§ method void checkNoDeterministicKeys(List<ECKey> keys))
    (ß
        ;; Watch out for someone doing wallet.importKey(wallet.freshReceiveKey()); or equivalent: we never tested this.
        (§ for (ECKey key :for keys))
            (§ if (key instanceof DeterministicKey))
                (§ throw new IllegalArgumentException("Cannot import HD keys back into the wallet"))
    )

    ;;; Takes a list of keys and a password, then encrypts and imports them in one step using the current keycrypter. ;;
    #_public
    (§ method int importKeysAndEncrypt(#_final List<ECKey> keys, CharSequence password))
    (ß
        (§ call keyChainGroupLock.lock())
        (§ try)
        (ß
            (§ call Preconditions.checkNotNull(getKeyCrypter(), "Wallet is not encrypted"))
            (§ return importKeysAndEncrypt(keys, getKeyCrypter().deriveKey(password)))
        )
        (§ finally)
        (ß
            (§ call keyChainGroupLock.unlock())
        )
    )

    ;;; Takes a list of keys and an AES key, then encrypts and imports them in one step using the current keycrypter. ;;
    #_public
    (§ method int importKeysAndEncrypt(#_final List<ECKey> keys, KeyParameter aesKey))
    (ß
        (§ call keyChainGroupLock.lock())
        (§ try)
        (ß
            (§ call checkNoDeterministicKeys(keys))
            (§ return keyChainGroup.importKeysAndEncrypt(keys, aesKey))
        )
        (§ finally)
        (ß
            (§ call keyChainGroupLock.unlock())
        )
    )

    ;;;
     ; Add a pre-configured keychain to the wallet.  Useful for setting up a complex keychain,
     ; such as for a married wallet.  For example:
     ; <pre>
     ; MarriedKeyChain chain = MarriedKeyChain.builder()
     ;     .random(new SecureRandom())
     ;     .followingKeys(followingKeys)
     ;     .threshold(2).build();
     ; wallet.addAndActivateHDChain(chain);
     ; </p>
     ;;
    #_public
    (§ method void addAndActivateHDChain(DeterministicKeyChain chain))
    (ß
        (§ call keyChainGroupLock.lock())
        (§ try)
        (ß
            (§ call keyChainGroup.addAndActivateHDChain(chain))
        )
        (§ finally)
        (ß
            (§ call keyChainGroupLock.unlock())
        )
    )

    ;;; See {@link org.bitcoinj.wallet.DeterministicKeyChain#setLookaheadSize(int)} for more info on this. ;;
    #_public
    (§ method void setKeyChainGroupLookaheadSize(int lookaheadSize))
    (ß
        (§ call keyChainGroupLock.lock())
        (§ try)
        (ß
            (§ call keyChainGroup.setLookaheadSize(lookaheadSize))
        )
        (§ finally)
        (ß
            (§ call keyChainGroupLock.unlock())
        )
    )

    ;;; See {@link org.bitcoinj.wallet.DeterministicKeyChain#setLookaheadSize(int)} for more info on this. ;;
    #_public
    (§ method int getKeyChainGroupLookaheadSize())
    (ß
        (§ call keyChainGroupLock.lock())
        (§ try)
        (ß
            (§ return keyChainGroup.getLookaheadSize())
        )
        (§ finally)
        (ß
            (§ call keyChainGroupLock.unlock())
        )
    )

    ;;; See {@link org.bitcoinj.wallet.DeterministicKeyChain#setLookaheadThreshold(int)} for more info on this. ;;
    #_public
    (§ method void setKeyChainGroupLookaheadThreshold(int num))
    (ß
        (§ call keyChainGroupLock.lock())
        (§ try)
        (ß
            (§ call maybeUpgradeToHD())
            (§ call keyChainGroup.setLookaheadThreshold(num))
        )
        (§ finally)
        (ß
            (§ call keyChainGroupLock.unlock())
        )
    )

    ;;; See {@link org.bitcoinj.wallet.DeterministicKeyChain#setLookaheadThreshold(int)} for more info on this. ;;
    #_public
    (§ method int getKeyChainGroupLookaheadThreshold())
    (ß
        (§ call keyChainGroupLock.lock())
        (§ try)
        (ß
            (§ call maybeUpgradeToHD())
            (§ return keyChainGroup.getLookaheadThreshold())
        )
        (§ finally)
        (ß
            (§ call keyChainGroupLock.unlock())
        )
    )

    ;;;
     ; Returns a public-only DeterministicKey that can be used to set up a watching wallet: that is, a wallet that
     ; can import transactions from the block chain just as the normal wallet can, but which cannot spend.  Watching
     ; wallets are very useful for things like web servers that accept payments.  This key corresponds to the account
     ; zero key in the recommended BIP32 hierarchy.
     ;;
    #_public
    (§ method DeterministicKey getWatchingKey())
    (ß
        (§ call keyChainGroupLock.lock())
        (§ try)
        (ß
            (§ call maybeUpgradeToHD())
            (§ return keyChainGroup.getActiveKeyChain().getWatchingKey())
        )
        (§ finally)
        (ß
            (§ call keyChainGroupLock.unlock())
        )
    )

    ;;;
     ; Returns whether this wallet consists entirely of watching keys (unencrypted keys with no private part).
     ; Mixed wallets are forbidden.
     ;
     ; @throws IllegalStateException if there are no keys, or if there is a mix between watching and non-watching keys.
     ;;
    #_public
    (§ method boolean isWatching())
    (ß
        (§ call keyChainGroupLock.lock())
        (§ try)
        (ß
            (§ call maybeUpgradeToHD())
            (§ return keyChainGroup.isWatching())
        )
        (§ finally)
        (ß
            (§ call keyChainGroupLock.unlock())
        )
    )

    ;;;
     ; Locates a keypair from the basicKeyChain given the hash of the public key.  This is needed when finding out
     ; which key we need to use to redeem a transaction output.
     ;
     ; @return ECKey object or null if no such key was found.
     ;;
    #_override
    #_nilable
    #_public
    (§ method ECKey findKeyFromPubHash(byte[] pubkeyHash))
    (ß
        (§ call keyChainGroupLock.lock())
        (§ try)
        (ß
            (§ return keyChainGroup.findKeyFromPubHash(pubkeyHash))
        )
        (§ finally)
        (ß
            (§ call keyChainGroupLock.unlock())
        )
    )

    ;;; Returns true if the given key is in the wallet, false otherwise.  Currently an O(N) operation. ;;
    #_public
    (§ method boolean hasKey(ECKey key))
    (ß
        (§ call keyChainGroupLock.lock())
        (§ try)
        (ß
            (§ return keyChainGroup.hasKey(key))
        )
        (§ finally)
        (ß
            (§ call keyChainGroupLock.unlock())
        )
    )

    ;;; {@inheritDoc} ;;
    #_override
    #_public
    (§ method boolean isPubKeyHashMine(byte[] pubkeyHash))
    (ß
        (§ return (findKeyFromPubHash(pubkeyHash) != nil))
    )

    ;;;
     ; Locates a keypair from the basicKeyChain given the raw public key bytes.
     ; @return ECKey or null if no such key was found.
     ;;
    #_override
    #_nilable
    #_public
    (§ method ECKey findKeyFromPubKey(byte[] pubkey))
    (ß
        (§ call keyChainGroupLock.lock())
        (§ try)
        (ß
            (§ return keyChainGroup.findKeyFromPubKey(pubkey))
        )
        (§ finally)
        (ß
            (§ call keyChainGroupLock.unlock())
        )
    )

    ;;; {@inheritDoc} ;;
    #_override
    #_public
    (§ method boolean isPubKeyMine(byte[] pubkey))
    (ß
        (§ return (findKeyFromPubKey(pubkey) != nil))
    )

    ;;;
     ; Locates a redeem data (redeem script and keys) from the keyChainGroup given the hash of the script.
     ; @return RedeemData object or null if no such data was found.
     ;;
    #_nilable
    #_override
    #_public
    (§ method RedeemData findRedeemDataFromScriptHash(byte[] payToScriptHash))
    (ß
        (§ call keyChainGroupLock.lock())
        (§ try)
        (ß
            (§ return keyChainGroup.findRedeemDataFromScriptHash(payToScriptHash))
        )
        (§ finally)
        (ß
            (§ call keyChainGroupLock.unlock())
        )
    )

    ;;; {@inheritDoc} ;;
    #_override
    #_public
    (§ method boolean isPayToScriptHashMine(byte[] payToScriptHash))
    (ß
        (§ return (findRedeemDataFromScriptHash(payToScriptHash) != nil))
    )

    ;;;
     ; Marks all keys used in the transaction output as used in the wallet.
     ; See {@link org.bitcoinj.wallet.DeterministicKeyChain#markKeyAsUsed(DeterministicKey)} for more info on this.
     ;;
    #_private
    (§ method void markKeysAsUsed(Transaction tx))
    (ß
        (§ call keyChainGroupLock.lock())
        (§ try)
        (ß
            (§ for (TransactionOutput o :for tx.getOutputs()))
            (ß
                (§ try)
                (ß
                    (§ var Script script = o.getScriptPubKey())
                    (§ if (script.isSentToRawPubKey()))
                    (ß
                        (§ var byte[] pubkey = script.getPubKey())
                        (§ call keyChainGroup.markPubKeyAsUsed(pubkey))
                    )
                    (§ elseif (script.isSentToAddress()))
                    (ß
                        (§ var byte[] pubkeyHash = script.getPubKeyHash())
                        (§ call keyChainGroup.markPubKeyHashAsUsed(pubkeyHash))
                    )
                    (§ elseif (script.isPayToScriptHash()))
                    (ß
                        (§ var Address a = Address.fromP2SHScript(tx.getParams(), script))
                        (§ call keyChainGroup.markP2SHAddressAsUsed(a))
                    )
                )
                (§ catch (ScriptException e))
                (ß
                    ;; Just means we didn't understand the output of this transaction: ignore it.
                    (§ call log.warn("Could not parse tx output script: {}", e.toString()))
                )
            )
        )
        (§ finally)
        (ß
            (§ call keyChainGroupLock.unlock())
        )
    )

    ;;;
     ; Returns the immutable seed for the current active HD chain.
     ; @throws org.bitcoinj.core.ECKey.MissingPrivateKeyException if the seed is unavailable (watching wallet).
     ;;
    #_public
    (§ method DeterministicSeed getKeyChainSeed())
    (ß
        (§ call keyChainGroupLock.lock())
        (§ try)
        (ß
            (§ var DeterministicSeed seed = keyChainGroup.getActiveKeyChain().getSeed())
            (§ if (seed == nil))
                (§ throw new ECKey.MissingPrivateKeyException())
            (§ return seed)
        )
        (§ finally)
        (ß
            (§ call keyChainGroupLock.unlock())
        )
    )

    ;;;
     ; Returns a key for the given HD path, assuming it's already been derived.  You normally shouldn't use this:
     ; use currentReceiveKey/freshReceiveKey instead.
     ;;
    #_public
    (§ method DeterministicKey getKeyByPath(List<ChildNumber> path))
    (ß
        (§ call keyChainGroupLock.lock())
        (§ try)
        (ß
            (§ call maybeUpgradeToHD())
            (§ return keyChainGroup.getActiveKeyChain().getKeyByPath(path, false))
        )
        (§ finally)
        (ß
            (§ call keyChainGroupLock.unlock())
        )
    )

    ;;;
     ; Convenience wrapper around
     ; {@link Wallet#encrypt(org.bitcoinj.crypto.KeyCrypter, org.spongycastle.crypto.params.KeyParameter)}
     ; which uses the default Scrypt key derivation algorithm and parameters to derive a key from the given password.
     ;;
    #_public
    (§ method void encrypt(CharSequence password))
    (ß
        (§ call keyChainGroupLock.lock())
        (§ try)
        (ß
            #_final
            (§ var KeyCrypterScrypt scrypt = new KeyCrypterScrypt())
            (§ call keyChainGroup.encrypt(scrypt, scrypt.deriveKey(password)))
        )
        (§ finally)
        (ß
            (§ call keyChainGroupLock.unlock())
        )
        (§ call saveNow())
    )

    ;;;
     ; Encrypt the wallet using the KeyCrypter and the AES key.
     ; A good default KeyCrypter to use is {@link org.bitcoinj.crypto.KeyCrypterScrypt}.
     ;
     ; @param keyCrypter The KeyCrypter that specifies how to encrypt/ decrypt a key.
     ; @param aesKey AES key to use (normally created using KeyCrypter#deriveKey and cached as it is time consuming to create from a password).
     ; @throws KeyCrypterException if the wallet encryption fails.  If so, the wallet state is unchanged.
     ;;
    #_public
    (§ method void encrypt(KeyCrypter keyCrypter, KeyParameter aesKey))
    (ß
        (§ call keyChainGroupLock.lock())
        (§ try)
        (ß
            (§ call keyChainGroup.encrypt(keyCrypter, aesKey))
        )
        (§ finally)
        (ß
            (§ call keyChainGroupLock.unlock())
        )
        (§ call saveNow())
    )

    ;;;
     ; Decrypt the wallet with the wallets keyCrypter and password.
     ; @throws KeyCrypterException if the wallet decryption fails.  If so, the wallet state is unchanged.
     ;;
    #_public
    (§ method void decrypt(CharSequence password))
    (ß
        (§ call keyChainGroupLock.lock())
        (§ try)
        (ß
            #_final
            (§ var KeyCrypter crypter = keyChainGroup.getKeyCrypter())
            (§ call Preconditions.checkState(crypter != nil, "Not encrypted"))
            (§ call keyChainGroup.decrypt(crypter.deriveKey(password)))
        )
        (§ finally)
        (ß
            (§ call keyChainGroupLock.unlock())
        )
        (§ call saveNow())
    )

    ;;;
     ; Decrypt the wallet with the wallets keyCrypter and AES key.
     ;
     ; @param aesKey AES key to use (normally created using KeyCrypter#deriveKey and cached as it is time consuming to create from a password).
     ; @throws KeyCrypterException if the wallet decryption fails. If so, the wallet state is unchanged.
     ;;
    #_public
    (§ method void decrypt(KeyParameter aesKey))
    (ß
        (§ call keyChainGroupLock.lock())
        (§ try)
        (ß
            (§ call keyChainGroup.decrypt(aesKey))
        )
        (§ finally)
        (ß
            (§ call keyChainGroupLock.unlock())
        )
        (§ call saveNow())
    )

    ;;;
     ;  Check whether the password can decrypt the first key in the wallet.
     ;  This can be used to check the validity of an entered password.
     ;
     ;  @return true if the password supplied can decrypt the first private key in the wallet, false otherwise.
     ;  @throws IllegalStateException if the wallet is not encrypted.
     ;;
    #_public
    (§ method boolean checkPassword(CharSequence password))
    (ß
        (§ call keyChainGroupLock.lock())
        (§ try)
        (ß
            (§ return keyChainGroup.checkPassword(password))
        )
        (§ finally)
        (ß
            (§ call keyChainGroupLock.unlock())
        )
    )

    ;;;
     ;  Check whether the AES key can decrypt the first encrypted key in the wallet.
     ;
     ;  @return true if AES key supplied can decrypt the first encrypted private key in the wallet, false otherwise.
     ;;
    #_public
    (§ method boolean checkAESKey(KeyParameter aesKey))
    (ß
        (§ call keyChainGroupLock.lock())
        (§ try)
        (ß
            (§ return keyChainGroup.checkAESKey(aesKey))
        )
        (§ finally)
        (ß
            (§ call keyChainGroupLock.unlock())
        )
    )

    ;;;
     ; Get the wallet's KeyCrypter, or null if the wallet is not encrypted.
     ; (Used in encrypting/decrypting an ECKey).
     ;;
    #_nilable
    #_public
    (§ method KeyCrypter getKeyCrypter())
    (ß
        (§ call keyChainGroupLock.lock())
        (§ try)
        (ß
            (§ return keyChainGroup.getKeyCrypter())
        )
        (§ finally)
        (ß
            (§ call keyChainGroupLock.unlock())
        )
    )

    ;;;
     ; Get the type of encryption used for this wallet.
     ;
     ; (This is a convenience method - the encryption type is actually stored in the keyCrypter).
     ;;
    #_public
    (§ method EncryptionType getEncryptionType())
    (ß
        (§ call keyChainGroupLock.lock())
        (§ try)
        (ß
            (§ var KeyCrypter crypter = keyChainGroup.getKeyCrypter())
            (§ return (crypter != nil) ? crypter.getUnderstoodEncryptionType() :else EncryptionType.UNENCRYPTED)
        )
        (§ finally)
        (ß
            (§ call keyChainGroupLock.unlock())
        )
    )

    ;;; Returns true if the wallet is encrypted using any scheme, false if not. ;;
    #_public
    (§ method boolean isEncrypted())
    (ß
        (§ return (getEncryptionType() != EncryptionType.UNENCRYPTED))
    )

    ;;; Changes wallet encryption password, this is atomic operation. ;;
    #_public
    (§ method void changeEncryptionPassword(CharSequence currentPassword, CharSequence newPassword))
    (ß
        (§ call keyChainGroupLock.lock())
        (§ try)
        (ß
            (§ call decrypt(currentPassword))
            (§ call encrypt(newPassword))
        )
        (§ finally)
        (ß
            (§ call keyChainGroupLock.unlock())
        )
    )

    ;;; Changes wallet AES encryption key, this is atomic operation. ;;
    #_public
    (§ method void changeEncryptionKey(KeyCrypter keyCrypter, KeyParameter currentAesKey, KeyParameter newAesKey))
    (ß
        (§ call keyChainGroupLock.lock())
        (§ try)
        (ß
            (§ call decrypt(currentAesKey))
            (§ call encrypt(keyCrypter, newAesKey))
        )
        (§ finally)
        (ß
            (§ call keyChainGroupLock.unlock())
        )
    )

    ;; TODO: Make this package private once the classes finish moving around.
    ;;; Internal use only. ;;
    #_public
    (§ method List<Protos.Key> serializeKeyChainGroupToProtobuf())
    (ß
        (§ call keyChainGroupLock.lock())
        (§ try)
        (ß
            (§ return keyChainGroup.serializeToProtobuf())
        )
        (§ finally)
        (ß
            (§ call keyChainGroupLock.unlock())
        )
    )

    ;;; Saves the wallet first to the given temp file, then renames to the dest file. ;;
    #_public
    (§ method void saveToFile(File temp, File destFile))
        (§ throws IOException)
    (ß
        (§ var FileOutputStream stream = nil)
        (§ call lock.lock())
        (§ try)
        (ß
            (§ ass stream = new FileOutputStream(temp))
            (§ call saveToFileStream(stream))
            ;; Attempt to force the bits to hit the disk.  In reality the OS or hard disk itself may still decide
            ;; to not write through to physical media for at least a few seconds, but this is the best we can do.
            (§ call stream.flush())
            (§ call stream.getFD().sync())
            (§ call stream.close())
            (§ ass stream = nil)
            (§ if (Utils.isWindows()))
            (ß
                ;; Work around an issue on Windows whereby you can't rename over existing files.
                (§ var File canonical = destFile.getCanonicalFile())
                (§ if (canonical.exists() && !canonical.delete()))
                    (§ throw new IOException("Failed to delete canonical wallet file for replacement with autosave"))
                (§ if (temp.renameTo(canonical)))
                    (§ return) ;; else fall through
                (§ throw new IOException("Failed to rename " + temp + " to " + canonical))
            )
            (§ elseif (!temp.renameTo(destFile)))
            (ß
                (§ throw new IOException("Failed to rename " + temp + " to " + destFile))
            )
        )
        (§ catch (RuntimeException e))
        (ß
            (§ call log.error("Failed whilst saving wallet", e))
            (§ throw e)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
            (§ if (stream != nil))
                (§ call stream.close())
            (§ if (temp.exists()))
                (§ call log.warn("Temp file still exists after failed save."))
        )
    )

    ;;;
     ; Uses protobuf serialization to save the wallet to the given file.  To learn more about this file format, see
     ; {@link WalletProtobufSerializer}.  Writes out first to a temporary file in the same directory and then renames
     ; once written.
     ;;
    #_public
    (§ method void saveToFile(File f))
        (§ throws IOException)
    (ß
        (§ var File directory = f.getAbsoluteFile().getParentFile())
        (§ var File temp = File.createTempFile("wallet", nil, directory))
        (§ call saveToFile(temp, f))
    )

    ;;;
     ; <p>Whether or not the wallet will ignore pending transactions that fail the selected {@link RiskAnalysis}.
     ; By default, if a transaction is considered risky then it won't enter the wallet and won't trigger any event
     ; listeners.  If you set this property to true, then all transactions will be allowed in regardless of risk.
     ; For example, the {@link DefaultRiskAnalysis} checks for non-finality of transactions.</p>
     ;
     ; <p>Note that this property is not serialized.  You have to set it each time a Wallet object is constructed,
     ; even if it's loaded from a protocol buffer.</p>
     ;;
    #_public
    (§ method void setAcceptRiskyTransactions(boolean acceptRiskyTransactions))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ ass this.acceptRiskyTransactions = acceptRiskyTransactions)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; See {@link Wallet#setAcceptRiskyTransactions(boolean)} for an explanation of this property.
     ;;
    #_public
    (§ method boolean isAcceptRiskyTransactions())
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ return acceptRiskyTransactions)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Sets the {@link RiskAnalysis} implementation to use for deciding whether received pending transactions are
     ; risky or not.  If the analyzer says a transaction is risky, by default it will be dropped. You can customize
     ; this behaviour with {@link #setAcceptRiskyTransactions(boolean)}.
     ;;
    #_public
    (§ method void setRiskAnalyzer(RiskAnalysis.Analyzer analyzer))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ ass this.riskAnalyzer = Preconditions.checkNotNull(analyzer))
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Gets the current {@link RiskAnalysis} implementation.  The default is {@link DefaultRiskAnalysis}.
     ;;
    #_public
    (§ method RiskAnalysis.Analyzer getRiskAnalyzer())
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ return riskAnalyzer)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; <p>Sets up the wallet to auto-save itself to the given file, using temp files with atomic renames to ensure
     ; consistency.  After connecting to a file, you no longer need to save the wallet manually, it will do it
     ; whenever necessary.  Protocol buffer serialization will be used.</p>
     ;
     ; <p>If delayTime is set, a background thread will be created and the wallet will only be saved to disk
     ; every so many time units.  If no changes have occurred for the given time period, nothing will be written.
     ; In this way disk IO can be rate limited.  It's a good idea to set this as otherwise the wallet can change very
     ; frequently, e.g. if there are a lot of transactions in it or during block sync, and there will be a lot of redundant
     ; writes.  Note that when a new key is added, that always results in an immediate save regardless of delayTime.
     ; <b>You should still save the wallet manually when your program is about to shut down as the JVM will not
     ; wait for the background thread.</b></p>
     ;
     ; <p>An event listener can be provided.  If a delay >0 was specified, it will be called on a background thread
     ; with the wallet locked when an auto-save occurs.  If delay is zero or you do something that always triggers
     ; an immediate save, like adding a key, the event listener will be invoked on the calling threads.</p>
     ;
     ; @param f The destination file to save to.
     ; @param delayTime How many time units to wait until saving the wallet on a background thread.
     ; @param timeUnit The unit of measurement for delayTime.
     ; @param eventListener Callback to be informed when the auto-save thread does things, or null.
     ;;
    #_public
    (§ method WalletFiles autosaveToFile(File f, long delayTime, TimeUnit timeUnit, #_nilable WalletFiles.Listener eventListener))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ call Preconditions.checkState(vFileManager == nil, "Already auto saving this wallet."))
            (§ var WalletFiles manager = new WalletFiles(this, f, delayTime, timeUnit))
            (§ if (eventListener != nil))
                (§ call manager.setListener(eventListener))
            (§ ass vFileManager = manager)
            (§ return manager)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Disables auto-saving, after it had been enabled with
     ; {@link Wallet#autosaveToFile(java.io.File, long, java.util.concurrent.TimeUnit, org.bitcoinj.wallet.WalletFiles.Listener)}
     ; before.  This method blocks until finished.
     ;;
    #_public
    (§ method void shutdownAutosaveAndWait())
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ var WalletFiles files = vFileManager)
            (§ ass vFileManager = nil)
            (§ call Preconditions.checkState(files != nil, "Auto saving not enabled."))
            (§ call files.shutdownAndWait())
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;; Requests an asynchronous save on a background thread. ;;
    #_protected
    (§ method void saveLater())
    (ß
        (§ var WalletFiles files = vFileManager)
        (§ if (files != nil))
            (§ call files.saveLater())
    )

    ;;; If auto saving is enabled, do an immediate sync write to disk ignoring any delays. ;;
    #_protected
    (§ method void saveNow())
    (ß
        (§ var WalletFiles files = vFileManager)
        (§ if (files != nil))
        (ß
            (§ try)
            (ß
                (§ call files.saveNow()) ;; This calls back into saveToFile().
            )
            (§ catch (IOException e))
            (ß
                ;; Can't really do much at this point, just let the API user know.
                (§ call log.error("Failed to save wallet to disk!", e))
                (§ var Thread.UncaughtExceptionHandler handler = Threading.uncaughtExceptionHandler)
                (§ if (handler != nil))
                    (§ call handler.uncaughtException(Thread.currentThread(), e))
            )
        )
    )

    ;;;
     ; Uses protobuf serialization to save the wallet to the given file stream.
     ; To learn more about this file format, see {@link WalletProtobufSerializer}.
     ;;
    #_public
    (§ method void saveToFileStream(OutputStream f))
        (§ throws IOException)
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ call new WalletProtobufSerializer().writeWallet(this, f))
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;; Returns the parameters this wallet was created with. ;;
    #_public
    (§ method NetworkParameters getParams())
    (ß
        (§ return params)
    )

    ;;; Returns the API context that this wallet was created with. ;;
    #_public
    (§ method Context getContext())
    (ß
        (§ return context)
    )

    ;;;
     ; Returns a wallet deserialized from the given file.
     ;
     ; @param file The wallet file to be read.
     ;;
    #_public
    #_static
    (§ method Wallet loadFromFile(File file))
        (§ throws UnreadableWalletException)
    (ß
        (§ try)
        (ß
            (§ var FileInputStream stream = nil)
            (§ try)
            (ß
                (§ ass stream = new FileInputStream(file))
                (§ return loadFromFileStream(stream))
            )
            (§ finally)
            (ß
                (§ if (stream != nil))
                    (§ call stream.close())
            )
        )
        (§ catch (IOException e))
        (ß
            (§ throw new UnreadableWalletException("Could not open file", e))
        )
    )

    ;;;
     ; Returns if this wallet is structurally consistent, so e.g. no duplicate transactions.
     ; First inconsistency and a dump of the wallet will be logged.
     ;;
    #_public
    (§ method boolean isConsistent())
    (ß
        (§ try)
        (ß
            (§ call isConsistentOrThrow())
            (§ return true)
        )
        (§ catch (IllegalStateException e1))
        (ß
            (§ call log.error(e1.getMessage()))
            (§ try)
            (ß
                (§ call log.error(toString()))
            )
            (§ catch (RuntimeException e2))
            (ß
                (§ call log.error("Printing inconsistent wallet failed", e2))
            )
            (§ return false)
        )
    )

    ;;;
     ; Variant of {@link Wallet#isConsistent()} that throws an {@link IllegalStateException} describing
     ; the first inconsistency.
     ;;
    #_public
    (§ method void isConsistentOrThrow())
        (§ throws IllegalStateException)
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ var Set<Transaction> transactions = getTransactions(true))

            (§ var Set<Sha256Hash> hashes = new HashSet<>())
            (§ for (Transaction tx :for transactions))
                (§ call hashes.add(tx.getHash()))

            (§ var int size1 = transactions.size())
            (§ if (size1 != hashes.size()))
                (§ throw new IllegalStateException("Two transactions with same hash"))

            (§ var int size2 = unspent.size() + spent.size() + pending.size() + dead.size())
            (§ if (size1 != size2))
                (§ throw new IllegalStateException("Inconsistent wallet sizes: " + size1 + ", " + size2))

            (§ for (Transaction tx :for unspent.values()))
            (ß
                (§ if (!isTxConsistent(tx, false)))
                    (§ throw new IllegalStateException("Inconsistent unspent tx: " + tx.getHashAsString()))
            )

            (§ for (Transaction tx :for spent.values()))
            (ß
                (§ if (!isTxConsistent(tx, true)))
                    (§ throw new IllegalStateException("Inconsistent spent tx: " + tx.getHashAsString()))
            )
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;; If isSpent, check that all my outputs spent, otherwise check that there at least one unspent.
    #_testing
    (§ method boolean isTxConsistent(#_final Transaction tx, #_final boolean isSpent))
    (ß
        (§ var boolean isActuallySpent = true)
        (§ for (TransactionOutput o :for tx.getOutputs()))
        (ß
            (§ if (o.isAvailableForSpending()))
            (ß
                (§ if (o.isMine(this)))
                    (§ ass isActuallySpent = false)
                (§ if (o.getSpentBy() != nil))
                (ß
                    (§ call log.error("isAvailableForSpending != spentBy"))
                    (§ return false)
                )
            )
            (§ else)
            (ß
                (§ if (o.getSpentBy() == nil))
                (ß
                    (§ call log.error("isAvailableForSpending != spentBy"))
                    (§ return false)
                )
            )
        )
        (§ return (isActuallySpent == isSpent))
    )

    ;;; Returns a wallet deserialized from the given input stream. ;;
    #_public
    #_static
    (§ method Wallet loadFromFileStream(InputStream stream))
        (§ throws UnreadableWalletException)
    (ß
        (§ var Wallet wallet = new WalletProtobufSerializer().readWallet(stream))
        (§ if (!wallet.isConsistent()))
            (§ call log.error("Loaded an inconsistent wallet"))
        (§ return wallet)
    )

    ;;;
     ; Called by the {@link BlockChain} when we receive a new filtered block that contains a transactions previously
     ; received by a call to {@link #receivePending}.
     ;
     ; This is necessary for the internal book-keeping Wallet does.  When a transaction is received that sends us
     ; coins it is added to a pool so we can use it later to create spends.  When a transaction is received that
     ; consumes outputs they are marked as spent so they won't be used in future.
     ;
     ; A transaction that spends our own coins can be received either because a spend we created was accepted by
     ; the network and thus made it into a block, or because our keys are being shared between multiple instances
     ; and some other node spent the coins instead.  We still have to know about that to avoid accidentally trying
     ; to double spend.
     ;
     ; A transaction may be received multiple times if is included into blocks in parallel chains.  The blockType
     ; parameter describes whether the containing block is on the main/best chain or whether it's on a presently
     ; inactive side chain.  We must still record these transactions and the blocks they appear in because a future
     ; block might change which chain is best causing a reorganize.  A re-org can totally change our balance!
     ;;
    #_override
    #_public
    (§ method boolean notifyTransactionIsInBlock(Sha256Hash txHash, StoredBlock block, BlockChain.NewBlockType blockType, int relativityOffset))
        (§ throws VerificationException)
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ var Transaction tx = transactions.get(txHash))
            (§ if (tx == nil))
            (ß
                (§ ass tx = riskDropped.get(txHash))
                (§ if (tx != nil))
                (ß
                    ;; If this happens our risk analysis is probably wrong and should be improved.
                    (§ call log.info("Risk analysis dropped tx {} but was included in block anyway", tx.getHash()))
                )
                (§ else)
                (ß
                    ;; False positive that was broadcast to us and ignored by us because it was irrelevant to our keys.
                    (§ return false)
                )
            )
            (§ call receive(tx, block, blockType, relativityOffset))
            (§ return true)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; <p>Called when we have found a transaction (via network broadcast or otherwise) that is relevant to this wallet
     ; and want to record it.  Note that we <b>cannot verify these transactions at all</b>, they may spend fictional
     ; coins or be otherwise invalid.  They are useful to inform the user about coins they can expect to receive soon,
     ; and if you trust the sender of the transaction you can choose to assume they are in fact valid and will not
     ; be double spent as an optimization.</p>
     ;
     ; <p>This is the same as {@link Wallet#receivePending(Transaction, java.util.List)} but allows you to override the
     ; {@link Wallet#isPendingTransactionRelevant(Transaction)} sanity-check to keep track of transactions that are not
     ; spendable or spend our coins.  This can be useful when you want to keep track of transaction confidence on
     ; arbitrary transactions.  Note that transactions added in this way will still be relayed to peers and appear in
     ; transaction lists like any other pending transaction (even when not relevant).</p>
     ;;
    #_public
    (§ method void receivePending(Transaction tx, #_nilable List<Transaction> dependencies, boolean overrideIsRelevant))
        (§ throws VerificationException)
    (ß
        ;; Can run in a peer thread.  This method will only be called if a prior call to isPendingTransactionRelevant
        ;; returned true, so we already know by this point that it sends coins to or from our wallet, or is a double
        ;; spend against one of our other pending transactions.
        (§ call lock.lock())
        (§ try)
        (ß
            (§ call tx.verify())
            ;; Ignore it if we already know about this transaction.  Receiving a pending transaction never moves it
            ;; between pools.
            (§ var EnumSet<Pool> containingPools = getContainingPools(tx))
            (§ if (!containingPools.equals(EnumSet.noneOf(Pool.class))))
            (ß
                (§ call log.debug("Received tx we already saw in a block or created ourselves: " + tx.getHashAsString()))
                (§ return)
            )
            ;; Repeat the check of relevancy here, even though the caller may have already done so - this is to avoid
            ;; race conditions where receivePending may be being called in parallel.
            (§ if (!overrideIsRelevant && !isPendingTransactionRelevant(tx)))
                (§ return)

            (§ if (isTransactionRisky(tx, dependencies) && !acceptRiskyTransactions))
            (ß
                ;; isTransactionRisky already logged the reason.
                (§ call riskDropped.put(tx.getHash(), tx))
                (§ call log.warn("There are now {} risk dropped transactions being kept in memory", riskDropped.size()))
                (§ return)
            )

            (§ var Coin valueSentToMe = tx.getValueSentToMe(this))
            (§ var Coin valueSentFromMe = tx.getValueSentFromMe(this))
            (§ if (log.isInfoEnabled()))
            (ß
                (§ call log.info(String.format(Locale.US, "Received a pending transaction %s that spends %s from our own wallet, and sends us %s", tx.getHashAsString(), valueSentFromMe.toFriendlyString(), valueSentToMe.toFriendlyString())))
            )
            (§ if (tx.getConfidence().getSource().equals(TransactionConfidence.Source.UNKNOWN)))
            (ß
                (§ call log.warn("Wallet received transaction with an unknown source. Consider tagging it!"))
            )
            ;; If this tx spends any of our unspent outputs, mark them as spent now, then add to the pending pool.  This
            ;; ensures that if some other client that has our keys broadcasts a spend we stay in sync.  Also updates the
            ;; timestamp on the transaction and registers/runs event listeners.
            (§ call commitTx(tx))
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
        ;; maybeRotateKeys() will ignore pending transactions, so we don't bother calling it here (see the comments
        ;; in that function for an explanation of why).
    )

    ;;;
     ; Given a transaction and an optional list of dependencies (recursive/flattened), returns true if the given
     ; transaction would be rejected by the analyzer, or false otherwise.  The result of this call is independent
     ; of the value of {@link #isAcceptRiskyTransactions()}.  Risky transactions yield a logged warning.  If you
     ; want to know the reason why a transaction is risky, create an instance of the {@link RiskAnalysis} yourself
     ; using the factory returned by {@link #getRiskAnalyzer()} and use it directly.
     ;;
    #_public
    (§ method boolean isTransactionRisky(Transaction tx, #_nilable List<Transaction> dependencies))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ if (dependencies == nil))
                (§ ass dependencies = ImmutableList.of())
            (§ var RiskAnalysis analysis = riskAnalyzer.create(this, tx, dependencies))
            (§ var RiskAnalysis.Result result = analysis.analyze())
            (§ if (result != RiskAnalysis.Result.OK))
            (ß
                (§ call log.warn("Pending transaction was considered risky: {}\n{}", analysis, tx))
                (§ return true)
            )
            (§ return false)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; <p>Called when we have found a transaction (via network broadcast or otherwise) that is relevant to this wallet
     ; and want to record it.  Note that we <b>cannot verify these transactions at all</b>, they may spend fictional
     ; coins or be otherwise invalid.  They are useful to inform the user about coins they can expect to receive soon,
     ; and if you trust the sender of the transaction you can choose to assume they are in fact valid and will not
     ; be double spent as an optimization.</p>
     ;
     ; <p>Before this method is called, {@link Wallet#isPendingTransactionRelevant(Transaction)} should have been
     ; called to decide whether the wallet cares about the transaction - if it does, then this method expects the
     ; transaction and any dependencies it has which are still in the memory pool.</p>
     ;;
    #_public
    (§ method void receivePending(Transaction tx, #_nilable List<Transaction> dependencies))
        (§ throws VerificationException)
    (ß
        (§ call receivePending(tx, dependencies, false))
    )

    ;;;
     ; This method is used by a {@link Peer} to find out if a transaction that has been announced is interesting,
     ; that is, whether we should bother downloading its dependencies and exploring the transaction to decide how
     ; risky it is.  If this method returns true then {@link Wallet#receivePending(Transaction, java.util.List)}
     ; will soon be called with the transactions dependencies as well.
     ;;
    #_public
    (§ method boolean isPendingTransactionRelevant(Transaction tx))
        (§ throws ScriptException)
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            ;; Ignore it if we already know about this transaction.  Receiving a pending transaction never moves it
            ;; between pools.
            (§ var EnumSet<Pool> containingPools = getContainingPools(tx))
            (§ if (!containingPools.equals(EnumSet.noneOf(Pool.class))))
            (ß
                (§ call log.debug("Received tx we already saw in a block or created ourselves: " + tx.getHashAsString()))
                (§ return false)
            )

            ;; We only care about transactions that:
            ;;   - Send us coins.
            ;;   - Spend our coins.
            ;;   - Double spend a tx in our wallet.
            (§ if (!isTransactionRelevant(tx)))
            (ß
                (§ call log.debug("Received tx that isn't relevant to this wallet, discarding."))
                (§ return false)
            )
            (§ return true)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; <p>Returns true if the given transaction sends coins to any of our keys, or has inputs spending any of our outputs,
     ; and also returns true if tx has inputs that are spending outputs which are
     ; not ours but which are spent by pending transactions.</p>
     ;
     ; <p>Note that if the tx has inputs containing one of our keys, but the connected transaction is not in the wallet,
     ; it will not be considered relevant.</p>
     ;;
    #_public
    (§ method boolean isTransactionRelevant(Transaction tx))
        (§ throws ScriptException)
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ return (0 < tx.getValueSentFromMe(this).signum() || 0 < tx.getValueSentToMe(this).signum() || !findDoubleSpendsAgainst(tx, transactions).isEmpty()))
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Finds transactions in the specified candidates that double spend "tx".  Not a general check, but it can work even
     ; if the double spent inputs are not ours.
     ; @return the set of transactions that double spend "tx".
     ;;
    #_private
    (§ method Set<Transaction> findDoubleSpendsAgainst(Transaction tx, Map<Sha256Hash, Transaction> candidates))
    (ß
        (§ call Preconditions.checkState(lock.isHeldByCurrentThread()))
        (§ if (tx.isCoinBase()))
            (§ return Sets.newHashSet())

        ;; Compile a set of outpoints that are spent by tx.
        (§ var HashSet<TransactionOutPoint> outpoints = new HashSet<>())
        (§ for (TransactionInput input :for tx.getInputs()))
            (§ call outpoints.add(input.getOutpoint()))

        ;; Now for each pending transaction, see if it shares any outpoints with this tx.
        (§ var Set<Transaction> doubleSpendTxns = Sets.newHashSet())
        (§ for (Transaction p :for candidates.values()))
        (ß
            (§ if (p.equals(tx)))
                (§ continue)

            (§ for (TransactionInput input :for p.getInputs()))
            (ß
                ;; This relies on the fact that TransactionOutPoint equality is defined at the protocol not object
                ;; level - outpoints from two different inputs that point to the same output compare the same.
                (§ var TransactionOutPoint outpoint = input.getOutpoint())
                ;; If does, it's a double spend against the candidates, which makes it relevant.
                (§ if (outpoints.contains(outpoint)))
                    (§ call doubleSpendTxns.add(p))
            )
        )
        (§ return doubleSpendTxns)
    )

    ;;;
     ; Adds to txSet all the txns in txPool spending outputs of txns in txSet,
     ; and all txns spending the outputs of those txns, recursively.
     ;;
    (§ method void addTransactionsDependingOn(Set<Transaction> txSet, Set<Transaction> txPool))
    (ß
        (§ var Map<Sha256Hash, Transaction> txQueue = new LinkedHashMap<>())
        (§ for (Transaction tx :for txSet))
            (§ call txQueue.put(tx.getHash(), tx))

        (§ while (!txQueue.isEmpty()))
        (ß
            (§ var Transaction tx = txQueue.remove(txQueue.keySet().iterator().next()))
            (§ for (Transaction anotherTx :for txPool))
            (ß
                (§ if (anotherTx.equals(tx)))
                    (§ continue)

                (§ for (TransactionInput input :for anotherTx.getInputs()))
                    (§ if (input.getOutpoint().getHash().equals(tx.getHash())))
                        (§ if (txQueue.get(anotherTx.getHash()) == nil))
                        (ß
                            (§ call txQueue.put(anotherTx.getHash(), anotherTx))
                            (§ call txSet.add(anotherTx))
                        )
            )
        )
    )

    ;;;
     ; Called by the {@link BlockChain} when we receive a new block that sends coins to one of our addresses or
     ; spends coins from one of our addresses (note that a single transaction can do both).
     ;
     ; This is necessary for the internal book-keeping Wallet does.  When a transaction is received that sends us
     ; coins it is added to a pool so we can use it later to create spends.  When a transaction is received that
     ; consumes outputs they are marked as spent so they won't be used in future.
     ;
     ; A transaction that spends our own coins can be received either because a spend we created was accepted by
     ; the network and thus made it into a block, or because our keys are being shared between multiple instances
     ; and some other node spent the coins instead.  We still have to know about that to avoid accidentally trying
     ; to double spend.
     ;
     ; A transaction may be received multiple times if is included into blocks in parallel chains.  The blockType
     ; parameter describes whether the containing block is on the main/best chain or whether it's on a presently
     ; inactive side chain.  We must still record these transactions and the blocks they appear in because a future
     ; block might change which chain is best causing a reorganize.  A re-org can totally change our balance!
     ;;
    #_override
    #_public
    (§ method void receiveFromBlock(Transaction tx, StoredBlock block, BlockChain.NewBlockType blockType, int relativityOffset))
        (§ throws VerificationException)
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ if (isTransactionRelevant(tx)))
                (§ call receive(tx, block, blockType, relativityOffset))
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;; Whether to do a saveNow or saveLater when we are notified of the next best block.
    #_private
    (§ field boolean hardSaveOnNextBlock = false)

    #_private
    (§ method void receive(Transaction tx, StoredBlock block, BlockChain.NewBlockType blockType, int relativityOffset))
        (§ throws VerificationException)
    (ß
        ;; Runs in a peer thread.
        (§ call Preconditions.checkState(lock.isHeldByCurrentThread()))

        (§ var Coin prevBalance = getBalance())
        (§ var Sha256Hash txHash = tx.getHash())
        (§ var boolean bestChain = (blockType == BlockChain.NewBlockType.BEST_CHAIN))
        (§ var boolean sideChain = (blockType == BlockChain.NewBlockType.SIDE_CHAIN))

        (§ var Coin valueSentFromMe = tx.getValueSentFromMe(this))
        (§ var Coin valueSentToMe = tx.getValueSentToMe(this))
        (§ var Coin valueDifference = valueSentToMe.subtract(valueSentFromMe))

        (§ call log.info("Received tx{} for {}: {} [{}] in block {}", sideChain ? " on a side chain" :for "", valueDifference.toFriendlyString(), tx.getHashAsString(), relativityOffset, (block != nil) ? block.getHeader().getHash() :else "(unit test)"))

        ;; Inform the key chains that the issued keys were observed in a transaction, so they know to
        ;; calculate more keys for the next Bloom filters.
        (§ call markKeysAsUsed(tx))

        (§ ass onWalletChangedSuppressions = onWalletChangedSuppressions + 1)

        ;; If this transaction is already in the wallet, we may need to move it into a different pool.
        ;; At the very least we need to ensure we're manipulating the canonical object rather than a duplicate.
        (ß
            (§ var Transaction tmp = transactions.get(tx.getHash()))
            (§ if (tmp != nil))
                (§ ass tx = tmp)
        )

        (§ var boolean wasPending = (pending.remove(txHash) != nil))
        (§ if (wasPending))
            (§ call log.info("  <-pending"))

        (§ if (bestChain))
        (ß
            (§ var boolean wasDead = (dead.remove(txHash) != nil))
            (§ if (wasDead))
                (§ call log.info("  <-dead"))
            (§ if (wasPending))
            (ß
                ;; Was pending and is now confirmed.  Disconnect the outputs in case we spent any already:
                ;; they will be re-connected by processTxFromBestChain below.
                (§ for (TransactionOutput output :for tx.getOutputs()))
                (ß
                    #_final
                    (§ var TransactionInput spentBy = output.getSpentBy())
                    (§ if (spentBy != nil))
                    (ß
                        (§ call Preconditions.checkState(myUnspents.add(output)))
                        (§ call spentBy.disconnect())
                    )
                )
            )
            (§ call processTxFromBestChain(tx, wasPending || wasDead))
        )
        (§ else)
        (ß
            (§ call Preconditions.checkState(sideChain))
            ;; Transactions that appear in a side chain will have that appearance recorded below - we assume
            ;; that some miners are also trying to include the transaction into the current best chain too,
            ;; so let's treat it as pending, except we don't need to do any risk analysis on it.
            (§ if (wasPending))
            (ß
                ;; Just put it back in without touching the connections or confidence.
                (§ call addWalletTransaction(Pool.PENDING, tx))
                (§ call log.info("  ->pending"))
            )
            (§ else)
            (ß
                ;; Ignore the case where a tx appears on a side chain at the same time as the best chain
                ;; (this is quite normal and expected).
                (§ var Sha256Hash hash = tx.getHash())
                (§ if (!unspent.containsKey(hash) && !spent.containsKey(hash) && !dead.containsKey(hash)))
                (ß
                    ;; Otherwise put it (possibly back) into pending.
                    ;; Committing it updates the spent flags and inserts into the pool as well.
                    (§ call commitTx(tx))
                )
            )
        )

        (§ if (block != nil))
        (ß
            ;; Mark the tx as appearing in this block so we can find it later after a re-org.  This also tells
            ;; the tx confidence object about the block and sets its depth appropriately.
            (§ call tx.setBlockAppearance(block, bestChain, relativityOffset))
            (§ if (bestChain))
            (ß
                ;; Don't notify this tx of work done in notifyNewBestBlock which will be called immediately
                ;; after this method has been called by BlockChain for all relevant transactions.  Otherwise
                ;; we'd double count.
                (§ call ignoreNextNewBlock.add(txHash))

                ;; When a tx is received from the best chain, if other txns that spend this tx are IN_CONFLICT,
                ;; change its confidence to PENDING (Unless they are also spending other txns IN_CONFLICT).
                ;; Consider dependency chains.
                (§ var Set<Transaction> currentTxDependencies = Sets.newHashSet(tx))
                (§ call addTransactionsDependingOn(currentTxDependencies, getTransactions(true)))
                (§ call currentTxDependencies.remove(tx))
                (§ var List<Transaction> currentTxDependenciesSorted = sortTxnsByDependency(currentTxDependencies))
                (§ for (Transaction txDependency :for currentTxDependenciesSorted))
                    (§ if (txDependency.getConfidence().getConfidenceType().equals(ConfidenceType.IN_CONFLICT)))
                        (§ if (isNotSpendingTxnsInConfidenceType(txDependency, ConfidenceType.IN_CONFLICT)))
                        (ß
                            (§ call txDependency.getConfidence().setConfidenceType(ConfidenceType.PENDING))
                            (§ call confidenceChanged.put(txDependency, TransactionConfidence.Listener.ChangeReason.TYPE))
                        )
            )
        )

        (§ ass onWalletChangedSuppressions = onWalletChangedSuppressions - 1)

        ;; Side chains don't affect confidence.
        (§ if (bestChain))
        (ß
            ;; notifyNewBestBlock will be invoked next and will then call maybeQueueOnWalletChanged for us.
            (§ call confidenceChanged.put(tx, TransactionConfidence.Listener.ChangeReason.TYPE))
        )
        (§ else)
        (ß
            (§ call maybeQueueOnWalletChanged())
        )

        ;; Inform anyone interested that we have received or sent coins but only if:
        ;;  - This is not due to a re-org.
        ;;  - The coins appeared on the best chain.
        ;;  - We did in fact receive some new money.
        ;;  - We have not already informed the user about the coins when we received the tx broadcast,
        ;;    or for our own spends.  If users want to know when a broadcast tx becomes confirmed,
        ;;    they need to use tx confidence listeners.
        (§ if (!insideReorg && bestChain))
        (ß
            (§ var Coin newBalance = getBalance()) ;; This is slow.
            (§ call log.info("Balance is now: " + newBalance.toFriendlyString()))
            (§ if (!wasPending))
            (ß
                (§ var int diff = valueDifference.signum())
                ;; We pick one callback based on the value difference, though a tx can of course both
                ;; send and receive coins from the wallet.
                (§ if (0 < diff))
                (ß
                    (§ call queueOnCoinsReceived(tx, prevBalance, newBalance))
                )
                (§ elseif (diff < 0))
                (ß
                    (§ call queueOnCoinsSent(tx, prevBalance, newBalance))
                )
            )
            (§ call checkBalanceFuturesLocked(newBalance))
        )

        (§ call informConfidenceListenersIfNotReorganizing())
        (§ call isConsistentOrThrow())
        ;; Optimization for the case where a block has tons of relevant transactions.
        (§ call saveLater())
        (§ ass hardSaveOnNextBlock = true)
    )

    ;;; Finds if tx is NOT spending other txns which are in the specified confidence type. ;;
    #_private
    (§ method boolean isNotSpendingTxnsInConfidenceType(Transaction tx, ConfidenceType confidenceType))
    (ß
        (§ for (TransactionInput txInput :for tx.getInputs()))
        (ß
            (§ var Transaction connectedTx = this.getTransaction(txInput.getOutpoint().getHash()))
            (§ if (connectedTx != nil && connectedTx.getConfidence().getConfidenceType().equals(confidenceType)))
                (§ return false)
        )
        (§ return true)
    )

    ;;;
     ; Creates and returns a new List with the same txns as inputSet, but txns are sorted by depencency
     ; (a topological sort).  If tx B spends tx A, then tx A should be before tx B on the returned List.
     ; Several invocations to this method with the same inputSet could result in lists with txns in different
     ; order, as there is no guarantee on the order of the returned txns besides what was already stated.
     ;;
    (§ method List<Transaction> sortTxnsByDependency(Set<Transaction> inputSet))
    (ß
        (§ var ArrayList<Transaction> result = new ArrayList<>(inputSet))
        (§ for (int i = 0 :for i < result.size() - 1 :for i = i + 1))
        (ß
            (§ var boolean txAtISpendsOtherTxInTheList)
            (§ do)
            (ß
                (§ ass txAtISpendsOtherTxInTheList = false)
                (§ for (int j = i + 1 :for j < result.size() :for j = j + 1))
                (ß
                    (§ if (spends(result.get(i), result.get(j))))
                    (ß
                        (§ var Transaction transactionAtI = result.remove(i))
                        (§ call result.add(j, transactionAtI))
                        (§ ass txAtISpendsOtherTxInTheList = true)
                        (§ break)
                    )
                )
            )
            (§ again (txAtISpendsOtherTxInTheList))
        )
        (§ return result)
    )

    ;;; Finds whether txA spends txB. ;;
    (§ method boolean spends(Transaction txA, Transaction txB))
    (ß
        (§ for (TransactionInput txInput :for txA.getInputs()))
            (§ if (txInput.getOutpoint().getHash().equals(txB.getHash())))
                (§ return true)

        (§ return false)
    )

    #_private
    (§ method void informConfidenceListenersIfNotReorganizing())
    (ß
        (§ if (insideReorg))
            (§ return)

        (§ for (Map.Entry<Transaction, TransactionConfidence.Listener.ChangeReason> entry :for confidenceChanged.entrySet()))
        (ß
            #_final
            (§ var Transaction tx = entry.getKey())
            (§ call tx.getConfidence().queueListeners(entry.getValue()))
            (§ call queueOnTransactionConfidenceChanged(tx))
        )
        (§ call confidenceChanged.clear())
    )

    ;;;
     ; Called by the {@link BlockChain} when a new block on the best chain is seen, AFTER relevant wallet
     ; transactions are extracted and sent to us UNLESS the new block caused a re-org, in which case this will
     ; not be called (the {@link Wallet#reorganize(StoredBlock, java.util.List, java.util.List)} method will
     ; call this one in that case).
     ;
     ; Used to update confidence data in each transaction and last seen block hash.  Triggers auto saving.
     ; Invokes the onWalletChanged event listener if there were any affected transactions.
     ;;
    #_override
    #_public
    (§ method void notifyNewBestBlock(StoredBlock block))
        (§ throws VerificationException)
    (ß
        ;; Check to see if this block has been seen before.
        (§ var Sha256Hash newBlockHash = block.getHeader().getHash())
        (§ if (newBlockHash.equals(getLastBlockSeenHash())))
            (§ return)

        (§ call lock.lock())
        (§ try)
        (ß
            ;; Store the new block hash.
            (§ call setLastBlockSeenHash(newBlockHash))
            (§ call setLastBlockSeenHeight(block.getHeight()))
            (§ call setLastBlockSeenTimeSecs(block.getHeader().getTimeSeconds()))
            ;; Notify all the BUILDING transactions of the new block.
            ;; This is so that they can update their depth.
            (§ var Set<Transaction> transactions = getTransactions(true))
            (§ for (Transaction tx :for transactions))
            (ß
                (§ if (ignoreNextNewBlock.contains(tx.getHash())))
                (ß
                    ;; tx was already processed in receive() due to it appearing in this block, so we don't want
                    ;; to increment the tx confidence depth twice, it'd result in miscounting.
                    (§ call ignoreNextNewBlock.remove(tx.getHash()))
                )
                (§ else)
                (ß
                    (§ var TransactionConfidence confidence = tx.getConfidence())
                    (§ if (confidence.getConfidenceType() == ConfidenceType.BUILDING))
                    (ß
                        ;; Erase the set of seen peers once the tx is so deep that it seems unlikely to ever go
                        ;; pending again.  We could clear this data the moment a tx is seen in the block chain,
                        ;; but in cases where the chain re-orgs, this would mean that wallets would perceive a
                        ;; newly pending tx has zero confidence at all, which would not be right: we expect it to
                        ;; be included once again.  We could have a separate was-in-chain-and-now-isn't confidence
                        ;; type, but this way is backwards compatible with existing software, and the new state
                        ;; probably wouldn't mean anything different to just remembering peers anyway.
                        (§ if (context.getEventHorizon() < confidence.incrementDepthInBlocks()))
                            (§ call confidence.clearBroadcastBy())
                        (§ call confidenceChanged.put(tx, TransactionConfidence.Listener.ChangeReason.DEPTH))
                    )
                )
            )

            (§ call informConfidenceListenersIfNotReorganizing())
            (§ call maybeQueueOnWalletChanged())

            (§ if (hardSaveOnNextBlock))
            (ß
                (§ call saveNow())
                (§ ass hardSaveOnNextBlock = false)
            )
            (§ else)
            (ß
                ;; Coalesce writes to avoid throttling on disk access when catching up with the chain.
                (§ call saveLater())
            )
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Handle when a transaction becomes newly active on the best chain, either due to receiving a new block or a
     ; re-org.  Places the tx into the right pool, handles coinbase transactions, handles double-spends and so on.
     ;;
    #_private
    (§ method void processTxFromBestChain(Transaction tx, boolean forceAddToPool))
        (§ throws VerificationException)
    (ß
        (§ call Preconditions.checkState(lock.isHeldByCurrentThread()))
        (§ call Preconditions.checkState(!pending.containsKey(tx.getHash())))

        ;; This TX may spend our existing outputs even though it was not pending.  This can happen in unit tests,
        ;; if keys are moved between wallets, if we're catching up to the chain given only a set of keys,
        ;; or if a dead coinbase transaction has moved back onto the main chain.
        (§ var boolean isDeadCoinbase = (tx.isCoinBase() && dead.containsKey(tx.getHash())))
        (§ if (isDeadCoinbase))
        (ß
            ;; There is a dead coinbase tx being received on the best chain.  A coinbase tx is made dead when it moves
            ;; to a side chain but it can be switched back on a reorg and resurrected back to spent or unspent.
            ;; So take it out of the dead pool.  Note that we don't resurrect dependent transactions here, even though
            ;; we could.  Bitcoin Core nodes on the network have deleted the dependent transactions from their mempools
            ;; entirely by this point.  We could and maybe should rebroadcast them so the network remembers and tries
            ;; to confirm them again.  But this is a deeply unusual edge case that due to the maturity rule should never
            ;; happen in practice, thus for simplicities sake we ignore it here.
            (§ call log.info("  coinbase tx <-dead: confidence {}", tx.getHashAsString(), tx.getConfidence().getConfidenceType().name()))
            (§ call dead.remove(tx.getHash()))
        )

        ;; Update tx and other unspent/pending transactions by connecting inputs/outputs.
        (§ call updateForSpends(tx, true))

        ;; Now make sure it ends up in the right pool.  Also, handle the case where this TX is double-spending
        ;; against our pending transactions.  Note that a tx may double spend our pending transactions and also
        ;; send us money/spend our money.
        (§ var boolean hasOutputsToMe = (0 < tx.getValueSentToMe(this).signum()))
        (§ var boolean hasOutputsFromMe = false)
        (§ if (hasOutputsToMe))
        (ß
            ;; Needs to go into either unspent or spent (if the outputs were already spent by a pending tx).
            (§ if (tx.isEveryOwnedOutputSpent(this)))
            (ß
                (§ call log.info("  tx {} ->spent (by pending)", tx.getHashAsString()))
                (§ call addWalletTransaction(Pool.SPENT, tx))
            )
            (§ else)
            (ß
                (§ call log.info("  tx {} ->unspent", tx.getHashAsString()))
                (§ call addWalletTransaction(Pool.UNSPENT, tx))
            )
        )
        (§ elseif (0 < tx.getValueSentFromMe(this).signum()))
        (ß
            (§ ass hasOutputsFromMe = true)
            ;; Didn't send us any money, but did spend some.  Keep it around for record keeping purposes.
            (§ call log.info("  tx {} ->spent", tx.getHashAsString()))
            (§ call addWalletTransaction(Pool.SPENT, tx))
        )
        (§ elseif (forceAddToPool))
        (ß
            ;; Was manually added to pending, so we should keep it to notify the user of confidence information.
            (§ call log.info("  tx {} ->spent (manually added)", tx.getHashAsString()))
            (§ call addWalletTransaction(Pool.SPENT, tx))
        )

        ;; Kill txns in conflict with this tx.
        (§ var Set<Transaction> doubleSpendTxns = findDoubleSpendsAgainst(tx, pending))
        (§ if (!doubleSpendTxns.isEmpty()))
        (ß
            ;; No need to addTransactionsDependingOn(doubleSpendTxns), because killTxns() already kills dependencies.
            (§ call killTxns(doubleSpendTxns, tx))
        )
        (§ if (!hasOutputsToMe && !hasOutputsFromMe && !forceAddToPool && !findDoubleSpendsAgainst(tx, transactions).isEmpty()))
        (ß
            ;; Disconnect irrelevant inputs (otherwise might cause protobuf serialization issue).
            (§ for (TransactionInput input :for tx.getInputs()))
            (ß
                (§ var TransactionOutput output = input.getConnectedOutput())
                (§ if (output != nil && !output.isMine(this)))
                    (§ call input.disconnect())
            )
        )
    )

    ;;;
     ; <p>Updates the wallet by checking if this TX spends any of our outputs, and marking them as spent if so.
     ; If fromChain is true, also checks to see if any pending transaction spends outputs of this transaction and marks
     ; the spent flags appropriately.</p>
     ;
     ; <p>It can be called in two contexts.  One is when we receive a transaction on the best chain but it wasn't pending,
     ; this most commonly happens when we have a set of keys but the wallet transactions were wiped and we are catching
     ; up with the block chain.  It can also happen if a block includes a transaction we never saw at broadcast time.
     ; If this tx double spends, it takes precedence over our pending transactions and the pending tx goes dead.</p>
     ;
     ; <p>The other context it can be called is from {@link Wallet#receivePending(Transaction, java.util.List)},
     ; i.e. we saw a tx be broadcast or one was submitted directly that spends our own coins.  If this tx double spends,
     ; it does NOT take precedence because the winner will be resolved by the miners - we assume that our version will
     ; win, if we are wrong then when a block appears the tx will go dead.</p>
     ;
     ; @param tx The transaction which is being updated.
     ; @param fromChain If true, the tx appeared on the current best chain, if false it was pending.
     ;;
    #_private
    (§ method void updateForSpends(Transaction tx, boolean fromChain))
        (§ throws VerificationException)
    (ß
        (§ call Preconditions.checkState(lock.isHeldByCurrentThread()))
        (§ if (fromChain))
            (§ call Preconditions.checkState(!pending.containsKey(tx.getHash())))

        (§ for (TransactionInput input :for tx.getInputs()))
        (ß
            (§ var TransactionInput.ConnectionResult result = input.connect(unspent, TransactionInput.ConnectMode.ABORT_ON_CONFLICT))
            (§ if (result == TransactionInput.ConnectionResult.NO_SUCH_TX))
            (ß
                ;; Not found in the unspent map.  Try again with the spent map.
                (§ ass result = input.connect(spent, TransactionInput.ConnectMode.ABORT_ON_CONFLICT))
                (§ if (result == TransactionInput.ConnectionResult.NO_SUCH_TX))
                (ß
                    ;; Not found in the unspent and spent maps.  Try again with the pending map.
                    (§ ass result = input.connect(pending, TransactionInput.ConnectMode.ABORT_ON_CONFLICT))
                    (§ if (result == TransactionInput.ConnectionResult.NO_SUCH_TX))
                    (ß
                        ;; Doesn't spend any of our outputs or is coinbase.
                        (§ continue)
                    )
                )
            )

            (§ var TransactionOutput output = Preconditions.checkNotNull(input.getConnectedOutput()))
            (§ if (result == TransactionInput.ConnectionResult.ALREADY_SPENT))
            (ß
                (§ if (fromChain))
                (ß
                    ;; Can be:
                    ;; (1) We already marked this output as spent when we saw the pending transaction (most likely).
                    ;;     Now it's being confirmed of course, we cannot mark it as spent again.
                    ;; (2) A double spend from chain: this will be handled later by findDoubleSpendsAgainst()/killTxns().
                    ;;
                    ;; In any case, nothing to do here.
                )
                (§ else)
                (ß
                    ;; We saw two pending transactions that double spend each other.  We don't know which will win.
                    ;; This can happen in the case of bad network nodes that mutate transactions.  Do a hex dump
                    ;; so the exact nature of the mutation can be examined.
                    (§ call log.warn("Saw two pending transactions double spend each other"))
                    (§ call log.warn("  offending input is input {}", tx.getInputs().indexOf(input)))
                    (§ call log.warn("{}: {}", tx.getHash(), Utils.HEX.encode(tx.unsafeBitcoinSerialize())))
                    (§ var Transaction other = output.getSpentBy().getParentTransaction())
                    (§ call log.warn("{}: {}", other.getHash(), Utils.HEX.encode(other.unsafeBitcoinSerialize())))
                )
            )
            (§ elseif (result == TransactionInput.ConnectionResult.SUCCESS))
            (ß
                ;; Otherwise we saw a transaction spend our coins, but we didn't try and spend them ourselves yet.
                ;; The outputs are already marked as spent by the connect call above, so check if there are any more for
                ;; us to use.  Move if not.
                (§ var Transaction connected = Preconditions.checkNotNull(input.getConnectedTransaction()))
                (§ call log.info("  marked {} as spent by {}", input.getOutpoint(), tx.getHashAsString()))
                (§ call maybeMovePool(connected, "prevtx"))
                ;; Just because it's connected, doesn't mean it's actually ours: sometimes we have total visibility.
                (§ if (output.isMine(this)))
                    (§ call Preconditions.checkState(myUnspents.remove(output)))
            )
        )

        ;; Now check each output and see if there is a pending transaction which spends it.  This shouldn't normally
        ;; ever occur because we expect transactions to arrive in temporal order, but this assumption can be violated
        ;; when we receive a pending transaction from the mempool that is relevant to us, which spends coins that we
        ;; didn't see arrive on the best chain yet.  For instance, because of a chain replay or because of our keys were
        ;; used by another wallet somewhere else.  Also, unconfirmed transactions can arrive from the mempool in more
        ;; or less random order.
        (§ for (Transaction pendingTx :for pending.values()))
        (ß
            (§ for (TransactionInput input :for pendingTx.getInputs()))
            (ß
                (§ var TransactionInput.ConnectionResult result = input.connect(tx, TransactionInput.ConnectMode.ABORT_ON_CONFLICT))
                (§ if (fromChain))
                (ß
                    ;; This TX is supposed to have just appeared on the best chain, so its outputs should not be marked
                    ;; as spent yet.  If they are, it means something is happening out of order.
                    (§ call Preconditions.checkState(result != TransactionInput.ConnectionResult.ALREADY_SPENT))
                )
                (§ if (result == TransactionInput.ConnectionResult.SUCCESS))
                (ß
                    (§ call log.info("Connected pending tx input {}:{}", pendingTx.getHashAsString(), pendingTx.getInputs().indexOf(input)))
                    ;; The unspents map might not have it if we never saw this tx until it was included in the chain
                    ;; and thus becomes spent the moment we become aware of it.
                    (§ if (myUnspents.remove(input.getConnectedOutput())))
                        (§ call log.info("Removed from UNSPENTS: {}", input.getConnectedOutput()))
                )
            )
        )
        (§ if (!fromChain))
        (ß
            (§ call maybeMovePool(tx, "pendingtx"))
        )
        (§ else)
        (ß
            ;; If the transactions outputs are now all spent, it will be moved into the spent pool by the
            ;; processTxFromBestChain method.
        )
    )

    ;; Updates the wallet when a double spend occurs.  overridingTx can be null for the case of coinbases.
    #_private
    (§ method void killTxns(Set<Transaction> txnsToKill, #_nilable Transaction overridingTx))
    (ß
        (§ var LinkedList<Transaction> work = new LinkedList<>(txnsToKill))
        (§ while (!work.isEmpty()))
        (ß
            #_final
            (§ var Transaction tx = work.poll())
            (§ call log.warn("TX {} killed{}", tx.getHashAsString(), (overridingTx != nil) ? " by " + overridingTx.getHashAsString() :else ""))
            (§ call log.warn("Disconnecting each input and moving connected transactions."))
            ;; TX could be pending (finney attack), or in unspent/spent (coinbase killed by reorg).
            (§ call pending.remove(tx.getHash()))
            (§ call unspent.remove(tx.getHash()))
            (§ call spent.remove(tx.getHash()))
            (§ call addWalletTransaction(Pool.DEAD, tx))
            (§ for (TransactionInput deadInput :for tx.getInputs()))
            (ß
                (§ var Transaction connected = deadInput.getConnectedTransaction())
                (§ if (connected == nil))
                    (§ continue)
                (§ if (connected.getConfidence().getConfidenceType() != ConfidenceType.DEAD && deadInput.getConnectedOutput().getSpentBy() != nil && deadInput.getConnectedOutput().getSpentBy().equals(deadInput)))
                (ß
                    (§ call Preconditions.checkState(myUnspents.add(deadInput.getConnectedOutput())))
                    (§ call log.info("Added to UNSPENTS: {} in {}", deadInput.getConnectedOutput(), deadInput.getConnectedOutput().getParentTransaction().getHash()))
                )
                (§ call deadInput.disconnect())
                (§ call maybeMovePool(connected, "kill"))
            )
            (§ call tx.getConfidence().setOverridingTransaction(overridingTx))
            (§ call confidenceChanged.put(tx, TransactionConfidence.Listener.ChangeReason.TYPE))
            ;; Now kill any transactions we have that depended on this one.
            (§ for (TransactionOutput deadOutput :for tx.getOutputs()))
            (ß
                (§ if (myUnspents.remove(deadOutput)))
                    (§ call log.info("XX Removed from UNSPENTS: {}", deadOutput))
                (§ var TransactionInput connected = deadOutput.getSpentBy())
                (§ if (connected == nil))
                    (§ continue)
                #_final
                (§ var Transaction parentTransaction = connected.getParentTransaction())
                (§ call log.info("This death invalidated dependent tx {}", parentTransaction.getHash()))
                (§ call work.push(parentTransaction))
            )
        )
        (§ if (overridingTx == nil))
            (§ return)

        (§ call log.warn("Now attempting to connect the inputs of the overriding transaction."))
        (§ for (TransactionInput input :for overridingTx.getInputs()))
        (ß
            (§ var TransactionInput.ConnectionResult result = input.connect(unspent, TransactionInput.ConnectMode.DISCONNECT_ON_CONFLICT))
            (§ if (result == TransactionInput.ConnectionResult.SUCCESS))
            (ß
                (§ call maybeMovePool(input.getConnectedTransaction(), "kill"))
                (§ call myUnspents.remove(input.getConnectedOutput()))
                (§ call log.info("Removing from UNSPENTS: {}", input.getConnectedOutput()))
            )
            (§ else)
            (ß
                (§ ass result = input.connect(spent, TransactionInput.ConnectMode.DISCONNECT_ON_CONFLICT))
                (§ if (result == TransactionInput.ConnectionResult.SUCCESS))
                (ß
                    (§ call maybeMovePool(input.getConnectedTransaction(), "kill"))
                    (§ call myUnspents.remove(input.getConnectedOutput()))
                    (§ call log.info("Removing from UNSPENTS: {}", input.getConnectedOutput()))
                )
            )
        )
    )

    ;;;
     ; If the transactions outputs are all marked as spent, and it's in the unspent map, move it.
     ; If the owned transactions outputs are not all marked as spent, and it's in the spent map, move it.
     ;;
    #_private
    (§ method void maybeMovePool(Transaction tx, String context))
    (ß
        (§ call Preconditions.checkState(lock.isHeldByCurrentThread()))

        (§ if (tx.isEveryOwnedOutputSpent(this)))
        (ß
            ;; There's nothing left I can spend in this transaction.
            (§ if (unspent.remove(tx.getHash()) != nil))
            (ß
                (§ if (log.isInfoEnabled()))
                    (§ call log.info("  {} {} <-unspent ->spent", tx.getHashAsString(), context))
                (§ call spent.put(tx.getHash(), tx))
            )
        )
        (§ else)
        (ß
            (§ if (spent.remove(tx.getHash()) != nil))
            (ß
                (§ if (log.isInfoEnabled()))
                    (§ call log.info("  {} {} <-spent ->unspent", tx.getHashAsString(), context))
                (§ call unspent.put(tx.getHash(), tx))
            )
        )
    )

    ;;;
     ; Calls {@link Wallet#commitTx} if tx is not already in the pending pool.
     ;
     ; @return true if the tx was added to the wallet, or false if it was already in the pending pool.
     ;;
    #_public
    (§ method boolean maybeCommitTx(Transaction tx))
        (§ throws VerificationException)
    (ß
        (§ call tx.verify())
        (§ call lock.lock())
        (§ try)
        (ß
            (§ if (pending.containsKey(tx.getHash())))
                (§ return false)

            (§ call log.info("commitTx of {}", tx.getHashAsString()))
            (§ var Coin balance = getBalance())
            (§ call tx.setUpdateTime(Utils.now()))
            ;; Put any outputs that are sending money back to us into the unspents map, and calculate their total value.
            (§ var Coin valueSentToMe = Coin.ZERO)
            (§ for (TransactionOutput o :for tx.getOutputs()))
            (ß
                (§ if (o.isMine(this)))
                    (§ ass valueSentToMe = valueSentToMe.add(o.getValue()))
            )
            ;; Mark the outputs we're spending as spent so we won't try and use them in future creations.  This will also
            ;; move any transactions that are now fully spent to the spent map so we can skip them when creating future
            ;; spends.
            (§ call updateForSpends(tx, false))

            (§ var Set<Transaction> doubleSpendPendingTxns = findDoubleSpendsAgainst(tx, pending))
            (§ var Set<Transaction> doubleSpendUnspentTxns = findDoubleSpendsAgainst(tx, unspent))
            (§ var Set<Transaction> doubleSpendSpentTxns = findDoubleSpendsAgainst(tx, spent))

            (§ if (!doubleSpendUnspentTxns.isEmpty() || !doubleSpendSpentTxns.isEmpty() || !isNotSpendingTxnsInConfidenceType(tx, ConfidenceType.DEAD)))
            (ß
                ;; tx is a double spend against a tx already in the best chain or spends outputs of a DEAD tx.
                ;; Add tx to the dead pool and schedule confidence listener notifications.
                (§ call log.info("->dead: {}", tx.getHashAsString()))
                (§ call tx.getConfidence().setConfidenceType(ConfidenceType.DEAD))
                (§ call confidenceChanged.put(tx, TransactionConfidence.Listener.ChangeReason.TYPE))
                (§ call addWalletTransaction(Pool.DEAD, tx))
            )
            (§ elseif (!doubleSpendPendingTxns.isEmpty() || !isNotSpendingTxnsInConfidenceType(tx, ConfidenceType.IN_CONFLICT)))
            (ß
                ;; tx is a double spend against a pending tx or spends outputs of a tx already IN_CONFLICT.
                ;; Add tx to the pending pool.  Update the confidence type of tx, the txns in conflict with tx
                ;; and all their dependencies to IN_CONFLICT and schedule confidence listener notifications.
                (§ call log.info("->pending (IN_CONFLICT): {}", tx.getHashAsString()))
                (§ call addWalletTransaction(Pool.PENDING, tx))
                (§ call doubleSpendPendingTxns.add(tx))
                (§ call addTransactionsDependingOn(doubleSpendPendingTxns, getTransactions(true)))
                (§ for (Transaction doubleSpendTx :for doubleSpendPendingTxns))
                (ß
                    (§ call doubleSpendTx.getConfidence().setConfidenceType(ConfidenceType.IN_CONFLICT))
                    (§ call confidenceChanged.put(doubleSpendTx, TransactionConfidence.Listener.ChangeReason.TYPE))
                )
            )
            (§ else)
            (ß
                ;; No conflict detected.
                ;; Add to the pending pool and schedule confidence listener notifications.
                (§ call log.info("->pending: {}", tx.getHashAsString()))
                (§ call tx.getConfidence().setConfidenceType(ConfidenceType.PENDING))
                (§ call confidenceChanged.put(tx, TransactionConfidence.Listener.ChangeReason.TYPE))
                (§ call addWalletTransaction(Pool.PENDING, tx))
            )
            (§ if (log.isInfoEnabled()))
                (§ call log.info("Estimated balance is now: {}", getBalance(BalanceType.ESTIMATED).toFriendlyString()))

            ;; Mark any keys used in the outputs as "used", this allows wallet UI's to auto-advance the current key
            ;; they are showing to the user in qr codes etc.
            (§ call markKeysAsUsed(tx))
            (§ try)
            (ß
                (§ var Coin valueSentFromMe = tx.getValueSentFromMe(this))
                (§ var Coin newBalance = balance.add(valueSentToMe).subtract(valueSentFromMe))
                (§ if (0 < valueSentToMe.signum()))
                (ß
                    (§ call checkBalanceFuturesLocked(nil))
                    (§ call queueOnCoinsReceived(tx, balance, newBalance))
                )
                (§ if (0 < valueSentFromMe.signum()))
                    (§ call queueOnCoinsSent(tx, balance, newBalance))

                (§ call maybeQueueOnWalletChanged())
            )
            (§ catch (ScriptException e))
            (ß
                ;; Cannot happen as we just created this transaction ourselves.
                (§ throw new RuntimeException(e))
            )

            (§ call isConsistentOrThrow())
            (§ call informConfidenceListenersIfNotReorganizing())
            (§ call saveNow())
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
        (§ return true)
    )

    ;;;
     ; <p>Updates the wallet with the given transaction: puts it into the pending pool, sets the spent flags
     ; and runs the onCoinsSent/onCoinsReceived event listener.  Used in two situations:</p>
     ;
     ; <ol>
     ;     <li>When we have just successfully transmitted the tx we created to the network.</li>
     ;     <li>When we receive a pending transaction that didn't appear in the chain yet, and we did not create it.</li>
     ; </ol>
     ;
     ; <p>Triggers an auto save.</p>
     ;;
    #_public
    (§ method void commitTx(Transaction tx))
        (§ throws VerificationException)
    (ß
        (§ call Preconditions.checkArgument(maybeCommitTx(tx), "commitTx called on the same transaction twice"))
    )

    ;;;
     ; Adds an event listener object.  Methods on this object are called when something interesting happens,
     ; like receiving money.  Runs the listener methods in the user thread.
     ;;
    #_public
    (§ method void addChangeEventListener(WalletChangeEventListener listener))
    (ß
        (§ call addChangeEventListener(Threading.USER_THREAD, listener))
    )

    ;;;
     ; Adds an event listener object.  Methods on this object are called when something interesting happens,
     ; like receiving money.  The listener is executed by the given executor.
     ;;
    #_public
    (§ method void addChangeEventListener(Executor executor, WalletChangeEventListener listener))
    (ß
        ;; This is thread safe, so we don't need to take the lock.
        (§ call changeListeners.add(new ListenerRegistration<>(listener, executor)))
    )

    ;;;
     ; Adds an event listener object called when coins are received.
     ; Runs the listener methods in the user thread.
     ;;
    #_public
    (§ method void addCoinsReceivedEventListener(WalletCoinsReceivedEventListener listener))
    (ß
        (§ call addCoinsReceivedEventListener(Threading.USER_THREAD, listener))
    )

    ;;;
     ; Adds an event listener object called when coins are received.
     ; The listener is executed by the given executor.
     ;;
    #_public
    (§ method void addCoinsReceivedEventListener(Executor executor, WalletCoinsReceivedEventListener listener))
    (ß
        ;; This is thread safe, so we don't need to take the lock.
        (§ call coinsReceivedListeners.add(new ListenerRegistration<>(listener, executor)))
    )

    ;;;
     ; Adds an event listener object called when coins are sent.
     ; Runs the listener methods in the user thread.
     ;;
    #_public
    (§ method void addCoinsSentEventListener(WalletCoinsSentEventListener listener))
    (ß
        (§ call addCoinsSentEventListener(Threading.USER_THREAD, listener))
    )

    ;;;
     ; Adds an event listener object called when coins are sent.
     ; The listener is executed by the given executor.
     ;;
    #_public
    (§ method void addCoinsSentEventListener(Executor executor, WalletCoinsSentEventListener listener))
    (ß
        ;; This is thread safe, so we don't need to take the lock.
        (§ call coinsSentListeners.add(new ListenerRegistration<>(listener, executor)))
    )

    ;;;
     ; Adds an event listener object.  Methods on this object are called when keys are
     ; added.  The listener is executed in the user thread.
     ;;
    #_public
    (§ method void addKeyChainEventListener(KeyChainEventListener listener))
    (ß
        (§ call keyChainGroup.addEventListener(listener, Threading.USER_THREAD))
    )

    ;;;
     ; Adds an event listener object.  Methods on this object are called when keys are
     ; added.  The listener is executed by the given executor.
     ;;
    #_public
    (§ method void addKeyChainEventListener(Executor executor, KeyChainEventListener listener))
    (ß
        (§ call keyChainGroup.addEventListener(listener, executor))
    )

    ;;;
     ; Adds an event listener object.  Methods on this object are called when something interesting happens,
     ; like receiving money.  Runs the listener methods in the user thread.
     ;;
    #_public
    (§ method void addReorganizeEventListener(WalletReorganizeEventListener listener))
    (ß
        (§ call addReorganizeEventListener(Threading.USER_THREAD, listener))
    )

    ;;;
     ; Adds an event listener object.  Methods on this object are called when something interesting happens,
     ; like receiving money.  The listener is executed by the given executor.
     ;;
    #_public
    (§ method void addReorganizeEventListener(Executor executor, WalletReorganizeEventListener listener))
    (ß
        ;; This is thread safe, so we don't need to take the lock.
        (§ call reorganizeListeners.add(new ListenerRegistration<>(listener, executor)))
    )

    ;;;
     ; Adds an event listener object.  Methods on this object are called when confidence
     ; of a transaction changes.  Runs the listener methods in the user thread.
     ;;
    #_public
    (§ method void addTransactionConfidenceEventListener(TransactionConfidenceEventListener listener))
    (ß
        (§ call addTransactionConfidenceEventListener(Threading.USER_THREAD, listener))
    )

    ;;;
     ; Adds an event listener object.  Methods on this object are called when confidence
     ; of a transaction changes.  The listener is executed by the given executor.
     ;;
    #_public
    (§ method void addTransactionConfidenceEventListener(Executor executor, TransactionConfidenceEventListener listener))
    (ß
        ;; This is thread safe, so we don't need to take the lock.
        (§ call transactionConfidenceListeners.add(new ListenerRegistration<>(listener, executor)))
    )

    ;;;
     ; Removes the given event listener object.  Returns true if the listener was removed,
     ; false if that listener was never added.
     ;;
    #_public
    (§ method boolean removeChangeEventListener(WalletChangeEventListener listener))
    (ß
        (§ return ListenerRegistration.removeFromList(listener, changeListeners))
    )

    ;;;
     ; Removes the given event listener object.  Returns true if the listener was removed,
     ; false if that listener was never added.
     ;;
    #_public
    (§ method boolean removeCoinsReceivedEventListener(WalletCoinsReceivedEventListener listener))
    (ß
        (§ return ListenerRegistration.removeFromList(listener, coinsReceivedListeners))
    )

    ;;;
     ; Removes the given event listener object.  Returns true if the listener was removed,
     ; false if that listener was never added.
     ;;
    #_public
    (§ method boolean removeCoinsSentEventListener(WalletCoinsSentEventListener listener))
    (ß
        (§ return ListenerRegistration.removeFromList(listener, coinsSentListeners))
    )

    ;;;
     ; Removes the given event listener object.  Returns true if the listener was removed,
     ; false if that listener was never added.
     ;;
    #_public
    (§ method boolean removeKeyChainEventListener(KeyChainEventListener listener))
    (ß
        (§ return keyChainGroup.removeEventListener(listener))
    )

    ;;;
     ; Removes the given event listener object.  Returns true if the listener was removed,
     ; false if that listener was never added.
     ;;
    #_public
    (§ method boolean removeReorganizeEventListener(WalletReorganizeEventListener listener))
    (ß
        (§ return ListenerRegistration.removeFromList(listener, reorganizeListeners))
    )

    ;;;
     ; Removes the given event listener object.  Returns true if the listener was removed,
     ; false if that listener was never added.
     ;;
    #_public
    (§ method boolean removeTransactionConfidenceEventListener(TransactionConfidenceEventListener listener))
    (ß
        (§ return ListenerRegistration.removeFromList(listener, transactionConfidenceListeners))
    )

    #_private
    (§ method void queueOnTransactionConfidenceChanged(#_final Transaction tx))
    (ß
        (§ call Preconditions.checkState(lock.isHeldByCurrentThread()))

        (§ for (#_final ListenerRegistration<TransactionConfidenceEventListener> registration :for transactionConfidenceListeners))
        (ß
            (§ if (registration.executor == Threading.SAME_THREAD))
            (ß
                (§ call registration.listener.onTransactionConfidenceChanged(this, tx))
            )
            (§ else)
            (ß
                (§ call registration.executor.execute(new Runnable()
                (ß
                    #_override
                    #_public
                    (§ method void run())
                    (ß
                        (§ call registration.listener.onTransactionConfidenceChanged(Wallet.this, tx))
                    )
                )))
            )
        )
    )

    #_protected
    (§ method void maybeQueueOnWalletChanged())
    (ß
        ;; Don't invoke the callback in some circumstances, e.g. whilst we are re-organizing or fiddling
        ;; with transactions due to a new block arriving.  It will be called later instead.
        (§ call Preconditions.checkState(lock.isHeldByCurrentThread()))
        (§ call Preconditions.checkState(0 <= onWalletChangedSuppressions))

        (§ if (0 < onWalletChangedSuppressions))
            (§ return)

        (§ for (#_final ListenerRegistration<WalletChangeEventListener> registration :for changeListeners))
        (ß
            (§ call registration.executor.execute(new Runnable()
            (ß
                #_override
                #_public
                (§ method void run())
                (ß
                    (§ call registration.listener.onWalletChanged(Wallet.this))
                )
            )))
        )
    )

    #_protected
    (§ method void queueOnCoinsReceived(#_final Transaction tx, #_final Coin balance, #_final Coin newBalance))
    (ß
        (§ call Preconditions.checkState(lock.isHeldByCurrentThread()))

        (§ for (#_final ListenerRegistration<WalletCoinsReceivedEventListener> registration :for coinsReceivedListeners))
        (ß
            (§ call registration.executor.execute(new Runnable()
            (ß
                #_override
                #_public
                (§ method void run())
                (ß
                    (§ call registration.listener.onCoinsReceived(Wallet.this, tx, balance, newBalance))
                )
            )))
        )
    )

    #_protected
    (§ method void queueOnCoinsSent(#_final Transaction tx, #_final Coin prevBalance, #_final Coin newBalance))
    (ß
        (§ call Preconditions.checkState(lock.isHeldByCurrentThread()))

        (§ for (#_final ListenerRegistration<WalletCoinsSentEventListener> registration :for coinsSentListeners))
        (ß
            (§ call registration.executor.execute(new Runnable()
            (ß
                #_override
                #_public
                (§ method void run())
                (ß
                    (§ call registration.listener.onCoinsSent(Wallet.this, tx, prevBalance, newBalance))
                )
            )))
        )
    )

    #_protected
    (§ method void queueOnReorganize())
    (ß
        (§ call Preconditions.checkState(lock.isHeldByCurrentThread()))
        (§ call Preconditions.checkState(insideReorg))

        (§ for (#_final ListenerRegistration<WalletReorganizeEventListener> registration :for reorganizeListeners))
        (ß
            (§ call registration.executor.execute(new Runnable()
            (ß
                #_override
                #_public
                (§ method void run())
                (ß
                    (§ call registration.listener.onReorganize(Wallet.this))
                )
            )))
        )
    )

    ;;;
     ; Returns a set of all transactions in the wallet.
     ; @param includeDead If true, transactions that were overridden by a double spend are included.
     ;;
    #_public
    (§ method Set<Transaction> getTransactions(boolean includeDead))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ var Set<Transaction> all = new HashSet<>())
            (§ call all.addAll(unspent.values()))
            (§ call all.addAll(spent.values()))
            (§ call all.addAll(pending.values()))
            (§ if (includeDead))
                (§ call all.addAll(dead.values()))
            (§ return all)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Returns a set of all WalletTransactions in the wallet.
     ;;
    #_public
    (§ method Iterable<WalletTransaction> getWalletTransactions())
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ var Set<WalletTransaction> all = new HashSet<>())
            (§ call addWalletTransactionsToSet(all, Pool.UNSPENT, unspent.values()))
            (§ call addWalletTransactionsToSet(all, Pool.SPENT, spent.values()))
            (§ call addWalletTransactionsToSet(all, Pool.DEAD, dead.values()))
            (§ call addWalletTransactionsToSet(all, Pool.PENDING, pending.values()))
            (§ return all)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    #_private
    #_static
    (§ method void addWalletTransactionsToSet(Set<WalletTransaction> txns, Pool poolType, Collection<Transaction> pool))
    (ß
        (§ for (Transaction tx :for pool))
            (§ call txns.add(new WalletTransaction(poolType, tx)))
    )

    ;;;
     ; Adds a transaction that has been associated with a particular wallet pool.  This is intended for usage by
     ; deserialization code, such as the {@link WalletProtobufSerializer} class.  It isn't normally useful for
     ; applications.  It does not trigger auto saving.
     ;;
    #_public
    (§ method void addWalletTransaction(WalletTransaction wtx))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ call addWalletTransaction(wtx.getPool(), wtx.getTransaction()))
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Adds the given transaction to the given pools and registers a confidence change listener on it.
     ;;
    #_private
    (§ method void addWalletTransaction(Pool pool, Transaction tx))
    (ß
        (§ call Preconditions.checkState(lock.isHeldByCurrentThread()))

        (§ call transactions.put(tx.getHash(), tx))
        (§ switch (pool))
        (ß
        (§ case UNSPENT)
            (§ call Preconditions.checkState(unspent.put(tx.getHash(), tx) == nil))
            (§ break)
        (§ case SPENT)
            (§ call Preconditions.checkState(spent.put(tx.getHash(), tx) == nil))
            (§ break)
        (§ case PENDING)
            (§ call Preconditions.checkState(pending.put(tx.getHash(), tx) == nil))
            (§ break)
        (§ case DEAD)
            (§ call Preconditions.checkState(dead.put(tx.getHash(), tx) == nil))
            (§ break)
        (§ default)
            (§ throw new RuntimeException("Unknown wallet transaction type " + pool))
        )

        (§ if (pool == Pool.UNSPENT || pool == Pool.PENDING))
        (ß
            (§ for (TransactionOutput output :for tx.getOutputs()))
                (§ if (output.isAvailableForSpending() && output.isMine(this)))
                    (§ call myUnspents.add(output))
        )
        ;; This is safe even if the listener has been added before, as TransactionConfidence ignores duplicate
        ;; registration requests.  That makes the code in the wallet simpler.
        (§ call tx.getConfidence().addEventListener(Threading.SAME_THREAD, txConfidenceListener))
    )

    ;;;
     ; Returns all non-dead, active transactions ordered by recency.
     ;;
    #_public
    (§ method List<Transaction> getTransactionsByTime())
    (ß
        (§ return getRecentTransactions(0, false))
    )

    ;;;
     ; Returns an list of N transactions, ordered by increasing age.  Transactions on side chains are not included.
     ; Dead transactions (overridden by double spends) are optionally included.
     ;
     ; Note: the current implementation is O(num transactions in wallet).  Regardless of how many transactions are
     ; requested, the cost is always the same.  In future, requesting smaller numbers of transactions may be faster
     ; depending on how the wallet is implemented (e.g. if backed by a database).
     ;;
    #_public
    (§ method List<Transaction> getRecentTransactions(int numTransactions, boolean includeDead))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ call Preconditions.checkArgument(0 <= numTransactions))

            ;; Firstly, put all transactions into an array.
            (§ var int size = unspent.size() + spent.size() + pending.size())
            (§ if (size < numTransactions || numTransactions == 0))
                (§ ass numTransactions = size)

            (§ var ArrayList<Transaction> all = new ArrayList<>(getTransactions(includeDead)))
            ;; Order by update time.
            (§ call Collections.sort(all, Transaction.SORT_TX_BY_UPDATE_TIME))
            (§ if (numTransactions == all.size()))
                (§ return all)

            (§ call all.subList(numTransactions, all.size()).clear())
            (§ return all)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Returns a transaction object given its hash, if it exists in this wallet, or null otherwise.
     ;;
    #_nilable
    #_public
    (§ method Transaction getTransaction(Sha256Hash hash))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ return transactions.get(hash))
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;; {@inheritDoc} ;;
    #_override
    #_public
    (§ method Map<Sha256Hash, Transaction> getTransactionPool(Pool pool))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ switch (pool))
            (ß
                (§ case UNSPENT)
                    (§ return unspent)
                (§ case SPENT)
                    (§ return spent)
                (§ case PENDING)
                    (§ return pending)
                (§ case DEAD)
                    (§ return dead)
                (§ default)
                    (§ throw new RuntimeException("Unknown wallet transaction type " + pool))
            )
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Prepares the wallet for a blockchain replay.  Removes all transactions (as they would
     ; get in the way of the replay) and makes the wallet think it has never seen a block.
     ;;
    #_public
    (§ method void reset())
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ call clearTransactions())
            (§ ass lastBlockSeenHash = nil)
            (§ ass lastBlockSeenHeight = -1) ;; Magic value for 'never'.
            (§ ass lastBlockSeenTimeSecs = 0)
            (§ call saveLater())
            (§ call maybeQueueOnWalletChanged())
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Deletes transactions which appeared above the given block height from the wallet, but does not touch the keys.
     ; This is useful if you have some keys and wish to replay the block chain into the wallet in order to pick them up.
     ; Triggers auto saving.
     ;;
    #_public
    (§ method void clearTransactions(int fromHeight))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ if (fromHeight == 0))
            (ß
                (§ call clearTransactions())
                (§ call saveLater())
            )
            (§ else)
            (ß
                (§ throw new UnsupportedOperationException())
            )
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    #_private
    (§ method void clearTransactions())
    (ß
        (§ call unspent.clear())
        (§ call spent.clear())
        (§ call pending.clear())
        (§ call dead.clear())
        (§ call transactions.clear())
        (§ call myUnspents.clear())
    )

    ;;;
     ; Clean up the wallet.  Currently, it only removes risky pending transaction from the wallet and only
     ; if their outputs have not been spent.
     ;;
    #_public
    (§ method void cleanup())
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ var boolean dirty = false)
            (§ for (Iterator<Transaction> i = pending.values().iterator() :for i.hasNext() :for ))
            (ß
                (§ var Transaction tx = i.next())
                (§ if (isTransactionRisky(tx, nil) && !acceptRiskyTransactions))
                (ß
                    (§ call log.debug("Found risky transaction {} in wallet during cleanup.", tx.getHashAsString()))
                    (§ if (!tx.isAnyOutputSpent()))
                    (ß
                        ;; Sync myUnspents with the change.
                        (§ for (TransactionInput input :for tx.getInputs()))
                        (ß
                            (§ var TransactionOutput output = input.getConnectedOutput())
                            (§ if (output == nil))
                                (§ continue)
                            (§ if (output.isMine(this)))
                                (§ call Preconditions.checkState(myUnspents.add(output)))
                            (§ call input.disconnect())
                        )
                        (§ for (TransactionOutput output :for tx.getOutputs()))
                            (§ call myUnspents.remove(output))

                        (§ call i.remove())
                        (§ call transactions.remove(tx.getHash()))
                        (§ ass dirty = true)
                        (§ call log.info("Removed transaction {} from pending pool during cleanup.", tx.getHashAsString()))
                    )
                    (§ else)
                    (ß
                        (§ call log.info("Cannot remove transaction {} from pending pool during cleanup, as it's already spent partially.", tx.getHashAsString()))
                    )
                )
            )
            (§ if (dirty))
            (ß
                (§ call isConsistentOrThrow())
                (§ call saveLater())
                (§ if (log.isInfoEnabled()))
                    (§ call log.info("Estimated balance is now: {}", getBalance(BalanceType.ESTIMATED).toFriendlyString()))
            )
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    (§ method EnumSet<Pool> getContainingPools(Transaction tx))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ var EnumSet<Pool> result = EnumSet.noneOf(Pool.class))
            (§ var Sha256Hash txHash = tx.getHash())
            (§ if (unspent.containsKey(txHash)))
                (§ call result.add(Pool.UNSPENT))
            (§ if (spent.containsKey(txHash)))
                (§ call result.add(Pool.SPENT))
            (§ if (pending.containsKey(txHash)))
                (§ call result.add(Pool.PENDING))
            (§ if (dead.containsKey(txHash)))
                (§ call result.add(Pool.DEAD))
            (§ return result)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    #_testing
    #_public
    (§ method int getPoolSize(WalletTransaction.Pool pool))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ switch (pool))
            (ß
                (§ case UNSPENT)
                    (§ return unspent.size())
                (§ case SPENT)
                    (§ return spent.size())
                (§ case PENDING)
                    (§ return pending.size())
                (§ case DEAD)
                    (§ return dead.size())
            )
            (§ throw new RuntimeException("Unreachable"))
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    #_testing
    #_public
    (§ method boolean poolContainsTxHash(#_final WalletTransaction.Pool pool, #_final Sha256Hash txHash))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ switch (pool))
            (ß
                (§ case UNSPENT)
                    (§ return unspent.containsKey(txHash))
                (§ case SPENT)
                    (§ return spent.containsKey(txHash))
                (§ case PENDING)
                    (§ return pending.containsKey(txHash))
                (§ case DEAD)
                    (§ return dead.containsKey(txHash))
            )
            (§ throw new RuntimeException("Unreachable"))
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;; Returns a copy of the internal unspent outputs list. ;;
    #_public
    (§ method List<TransactionOutput> getUnspents())
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ return new ArrayList<>(myUnspents))
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    #_override
    #_public
    (§ method String toString())
    (ß
        (§ return toString(false, true, nil))
    )

    ;;;
     ; Formats the wallet as a human readable piece of text.  Intended for debugging, the format is
     ; not meant to be stable or human readable.
     ; @param includePrivateKeys Whether raw private key data should be included.
     ; @param includeTransactions Whether to print transaction data.
     ; @param chain If set, will be used to estimate lock times for block timelocked transactions.
     ;;
    #_public
    (§ method String toString(boolean includePrivateKeys, boolean includeTransactions, #_nilable AbstractBlockChain chain))
    (ß
        (§ call lock.lock())
        (§ call keyChainGroupLock.lock())
        (§ try)
        (ß
            (§ var StringBuilder sb = new StringBuilder())
            (§ var Coin estimatedBalance = getBalance(BalanceType.ESTIMATED))
            (§ var Coin availableBalance = getBalance(BalanceType.AVAILABLE_SPENDABLE))
            (§ call sb.append("Wallet containing ").append(estimatedBalance.toFriendlyString()).append(" (spendable: ").append(availableBalance.toFriendlyString()).append(") in:\n"))
            (§ call sb.append("  ").append(pending.size()).append(" pending transactions\n"))
            (§ call sb.append("  ").append(unspent.size()).append(" unspent transactions\n"))
            (§ call sb.append("  ").append(spent.size()).append(" spent transactions\n"))
            (§ call sb.append("  ").append(dead.size()).append(" dead transactions\n"))
            #_final
            (§ var Date lastBlockSeenTime = getLastBlockSeenTime())
            (§ call sb.append("Last seen best block: ").append(getLastBlockSeenHeight()).append(" (").append((lastBlockSeenTime == nil) ? "time unknown" :else Utils.dateTimeFormat(lastBlockSeenTime)).append("): ").append(getLastBlockSeenHash()).append("\n"))
            #_final
            (§ var KeyCrypter crypter = keyChainGroup.getKeyCrypter())
            (§ if (crypter != nil))
                (§ call sb.append("Encryption: ").append(crypter).append("\n"))
            (§ if (isWatching()))
                (§ call sb.append("Wallet is watching.\n"))

            ;; Do the keys.
            (§ call sb.append("\nKeys:\n"))
            (§ call sb.append("Earliest creation time: ").append(Utils.dateTimeFormat(getEarliestKeyCreationTime() * 1000)).append("\n"))
            #_final
            (§ var Date keyRotationTime = getKeyRotationTime())
            (§ if (keyRotationTime != nil))
                (§ call sb.append("Key rotation time:      ").append(Utils.dateTimeFormat(keyRotationTime)).append("\n"))
            (§ call sb.append(keyChainGroup.toString(includePrivateKeys)))

            (§ if (includeTransactions))
            (ß
                ;; Print the transactions themselves.
                (§ if (0 < pending.size()))
                (ß
                    (§ call sb.append("\n>>> PENDING:\n"))
                    (§ call toStringHelper(sb, pending, chain, Transaction.SORT_TX_BY_UPDATE_TIME))
                )
                (§ if (0 < unspent.size()))
                (ß
                    (§ call sb.append("\n>>> UNSPENT:\n"))
                    (§ call toStringHelper(sb, unspent, chain, Transaction.SORT_TX_BY_HEIGHT))
                )
                (§ if (0 < spent.size()))
                (ß
                    (§ call sb.append("\n>>> SPENT:\n"))
                    (§ call toStringHelper(sb, spent, chain, Transaction.SORT_TX_BY_HEIGHT))
                )
                (§ if (0 < dead.size()))
                (ß
                    (§ call sb.append("\n>>> DEAD:\n"))
                    (§ call toStringHelper(sb, dead, chain, Transaction.SORT_TX_BY_UPDATE_TIME))
                )
            )
            (§ return sb.toString())
        )
        (§ finally)
        (ß
            (§ call keyChainGroupLock.unlock())
            (§ call lock.unlock())
        )
    )

    #_private
    (§ method void toStringHelper(StringBuilder sb, Map<Sha256Hash, Transaction> transactionMap, #_nilable AbstractBlockChain chain, #_nilable Comparator<Transaction> sortOrder))
    (ß
        (§ call Preconditions.checkState(lock.isHeldByCurrentThread()))

        #_final
        (§ var Collection<Transaction> txns)
        (§ if (sortOrder != nil))
        (ß
            (§ ass txns = new TreeSet<>(sortOrder))
            (§ call txns.addAll(transactionMap.values()))
        )
        (§ else)
        (ß
            (§ ass txns = transactionMap.values())
        )

        (§ for (Transaction tx :for txns))
        (ß
            (§ try)
            (ß
                (§ call sb.append(tx.getValue(this).toFriendlyString()))
                (§ call sb.append(" total value (sends "))
                (§ call sb.append(tx.getValueSentFromMe(this).toFriendlyString()))
                (§ call sb.append(" and receives "))
                (§ call sb.append(tx.getValueSentToMe(this).toFriendlyString()))
                (§ call sb.append(")\n"))
            )
            (§ catch (ScriptException _))
            (ß
                ;; Ignore and don't print this line.
            )
            (§ if (tx.hasConfidence()))
                (§ call sb.append("  confidence: ").append(tx.getConfidence()).append("\n"))
            (§ call sb.append(tx.toString(chain)))
        )
    )

    ;;;
     ; Returns an immutable view of the transactions currently waiting for network confirmations.
     ;;
    #_public
    (§ method Collection<Transaction> getPendingTransactions())
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ return Collections.unmodifiableCollection(pending.values()))
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Returns the earliest creation time of keys or watched scripts in this wallet, in seconds since the epoch,
     ; i.e. the min of {@link org.bitcoinj.core.ECKey#getCreationTimeSeconds()}.  This can return zero if at least
     ; one key does not have that data (was created before key timestamping was implemented).
     ;
     ; This method is most often used in conjunction with {@link PeerGroup#setFastCatchupTimeSecs(long)} in order to
     ; optimize chain download for new users of wallet apps.  Backwards compatibility notice: if you get zero from this
     ; method, you can instead use the time of the first release of your software, as it's guaranteed no users will
     ; have wallets pre-dating this time.
     ;
     ; If there are no keys in the wallet, the current time is returned.
     ;;
    #_override
    #_public
    (§ method long getEarliestKeyCreationTime())
    (ß
        (§ call keyChainGroupLock.lock())
        (§ try)
        (ß
            (§ var long earliestTime = keyChainGroup.getEarliestKeyCreationTime())
            (§ return (earliestTime == Long.MAX_VALUE) ? Utils.currentTimeSeconds() :else earliestTime)
        )
        (§ finally)
        (ß
            (§ call keyChainGroupLock.unlock())
        )
    )

    ;;; Returns the hash of the last seen best-chain block, or null if the wallet is too old to store this data. ;;
    #_nilable
    #_public
    (§ method Sha256Hash getLastBlockSeenHash())
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ return lastBlockSeenHash)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    #_public
    (§ method void setLastBlockSeenHash(#_nilable Sha256Hash lastBlockSeenHash))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ ass this.lastBlockSeenHash = lastBlockSeenHash)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    #_public
    (§ method void setLastBlockSeenHeight(int lastBlockSeenHeight))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ ass this.lastBlockSeenHeight = lastBlockSeenHeight)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    #_public
    (§ method void setLastBlockSeenTimeSecs(long timeSecs))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ ass lastBlockSeenTimeSecs = timeSecs)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Returns the UNIX time in seconds since the epoch extracted from the last best seen block header.  This timestamp
     ; is <b>not</b> the local time at which the block was first observed by this application but rather what the block
     ; (i.e. miner) self declares.  It is allowed to have some significant drift from the real time at which the block
     ; was found, although most miners do use accurate times.  If this wallet is old and does not have a recorded
     ; time then this method returns zero.
     ;;
    #_public
    (§ method long getLastBlockSeenTimeSecs())
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ return lastBlockSeenTimeSecs)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Returns a {@link Date} representing the time extracted from the last best seen block header.  This timestamp
     ; is <b>not</b> the local time at which the block was first observed by this application but rather what the block
     ; (i.e. miner) self declares.  It is allowed to have some significant drift from the real time at which the block
     ; was found, although most miners do use accurate times.  If this wallet is old and does not have a recorded
     ; time then this method returns null.
     ;;
    #_nilable
    #_public
    (§ method Date getLastBlockSeenTime())
    (ß
        #_final
        (§ var long secs = getLastBlockSeenTimeSecs())
        (§ return (secs == 0) ? nil :else new Date(secs * 1000))
    )

    ;;;
     ; Returns the height of the last seen best-chain block.  Can be 0 if a wallet is brand new or -1 if the wallet
     ; is old and doesn't have that data.
     ;;
    #_public
    (§ method int getLastBlockSeenHeight())
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ return lastBlockSeenHeight)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Get the version of the Wallet.
     ; This is an int you can use to indicate which versions of wallets your code understands,
     ; and which come from the future (and hence cannot be safely loaded).
     ;;
    #_public
    (§ method int getVersion())
    (ß
        (§ return version)
    )

    ;;;
     ; Set the version number of the wallet.  See {@link Wallet#getVersion()}.
     ;;
    #_public
    (§ method void setVersion(int version))
    (ß
        (§ ass this.version = version)
    )

    ;;;
     ; Set the description of the wallet.
     ; This is a Unicode encoding string typically entered by the user as descriptive text for the wallet.
     ;;
    #_public
    (§ method void setDescription(String description))
    (ß
        (§ ass this.description = description)
    )

    ;;;
     ; Get the description of the wallet.  See {@link Wallet#setDescription(String)}.
     ;;
    #_public
    (§ method String getDescription())
    (ß
        (§ return description)
    )

    ;;;
     ; <p>It's possible to calculate a wallets balance from multiple points of view.  This enum selects which
     ; {@link #getBalance(BalanceType)} should use.</p>
     ;
     ; <p>Consider a real-world example: you buy a snack costing $5 but you only have a $10 bill.  At the start
     ; you have $10 viewed from every possible angle.  After you order the snack you hand over your $10 bill.
     ; From the perspective of your wallet you have zero dollars (AVAILABLE).  But you know in a few seconds the
     ; shopkeeper will give you back $5 change so most people in practice would say they have $5 (ESTIMATED).</p>
     ;
     ; <p>The fact that the wallet can track transactions which are not spendable by itself ("watching wallets")
     ; adds another type of balance to the mix.  Although the wallet won't do this by default, advanced use cases
     ; that override the relevancy checks can end up with a mix of spendable and unspendable transactions.</p>
     ;;
    #_public
    (§ enum BalanceType
        ;;;
         ; Balance calculated assuming all pending transactions are in fact included into the best chain by miners.
         ; This includes the value of immature coinbase transactions.
         ;;
        (§ item ESTIMATED)

        ;;;
         ; Balance that could be safely used to create new spends, if we had all the needed private keys.  This is
         ; whatever the default coin selector would make available, which by default means transaction outputs with at
         ; least 1 confirmation and pending transactions created by our own wallet which have been propagated across
         ; the network.  Whether we <i>actually</i> have the private keys or not is irrelevant for this balance type.
         ;;
        (§ item AVAILABLE)

        ;;; Same as ESTIMATED but only for outputs we have the private keys for and can sign ourselves. ;;
        (§ item ESTIMATED_SPENDABLE)
        ;;; Same as AVAILABLE but only for outputs we have the private keys for and can sign ourselves. ;;
        (§ item AVAILABLE_SPENDABLE)
    )

    ;;;
     ; Returns the AVAILABLE balance of this wallet.
     ; See {@link BalanceType#AVAILABLE} for details on what this means.
     ;;
    #_public
    (§ method Coin getBalance())
    (ß
        (§ return getBalance(BalanceType.AVAILABLE))
    )

    ;;;
     ; Returns the balance of this wallet as calculated by the provided balanceType.
     ;;
    #_public
    (§ method Coin getBalance(BalanceType balanceType))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ if (balanceType == BalanceType.AVAILABLE || balanceType == BalanceType.AVAILABLE_SPENDABLE))
            (ß
                (§ var List<TransactionOutput> candidates = calculateAllSpendCandidates(true, balanceType == BalanceType.AVAILABLE_SPENDABLE))
                (§ var CoinSelection selection = coinSelector.select(NetworkParameters.MAX_MONEY, candidates))
                (§ return selection.valueGathered)
            )
            (§ elseif (balanceType == BalanceType.ESTIMATED || balanceType == BalanceType.ESTIMATED_SPENDABLE))
            (ß
                (§ var List<TransactionOutput> all = calculateAllSpendCandidates(false, balanceType == BalanceType.ESTIMATED_SPENDABLE))
                (§ var Coin value = Coin.ZERO)
                (§ for (TransactionOutput out :for all))
                    (§ ass value = value.add(out.getValue()))
                (§ return value)
            )
            (§ else)
            (ß
                (§ throw new AssertionError("Unknown balance type")) ;; Unreachable.
            )
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Returns the balance that would be considered spendable by the given coin selector, including watched outputs
     ; (i.e. balance includes outputs we don't have the private keys for).  Just asks it to select as many coins as
     ; possible and returns the total.
     ;;
    #_public
    (§ method Coin getBalance(CoinSelector selector))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ call Preconditions.checkNotNull(selector))

            (§ var List<TransactionOutput> candidates = calculateAllSpendCandidates(true, false))
            (§ var CoinSelection selection = selector.select(params.getMaxMoney(), candidates))
            (§ return selection.valueGathered)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    #_private
    #_static
    (§ class BalanceFutureRequest
        #_public
        (§ field SettableFuture<Coin> future)
        #_public
        (§ field Coin value)
        #_public
        (§ field BalanceType type)
    )
    #_guarded-by(ß "lock")
    #_private
    (§ field List<BalanceFutureRequest> balanceFutureRequests = Lists.newLinkedList())

    ;;;
     ; <p>Returns a future that will complete when the balance of the given type has become equal or larger to the
     ; given value.  If the wallet already has a large enough balance the future is returned in a pre-completed state.
     ; Note that this method is not blocking, if you want to actually wait immediately, you have to call .get() on
     ; the result.</p>
     ;
     ; <p>Also note that by the time the future completes, the wallet may have changed yet again if something else
     ; is going on in parallel, so you should treat the returned balance as advisory and be prepared for sending
     ; money to fail!  Finally please be aware that any listeners on the future will run either on the calling thread
     ; if it completes immediately, or eventually on a background thread if the balance is not yet at the right
     ; level.  If you do something that means you know the balance should be sufficient to trigger the future,
     ; you can use {@link org.bitcoinj.utils.Threading#waitForUserCode()} to block until the future had a
     ; chance to be updated.</p>
     ;;
    #_public
    (§ method ListenableFuture<Coin> getBalanceFuture(#_final Coin value, #_final BalanceType type))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            #_final
            (§ var SettableFuture<Coin> future = SettableFuture.create())
            #_final
            (§ var Coin current = getBalance(type))
            (§ if (0 <= current.compareTo(value)))
            (ß
                ;; Already have enough.
                (§ call future.set(current))
            )
            (§ else)
            (ß
                ;; Will be checked later in checkBalanceFutures.  We don't just add an event listener for ourselves
                ;; here so that running getBalanceFuture().get() in the user code thread works - generally we must
                ;; avoid giving the user back futures that require the user code thread to be free.
                (§ var BalanceFutureRequest req = new BalanceFutureRequest())
                (§ ass req.future = future)
                (§ ass req.value = value)
                (§ ass req.type = type)
                (§ call balanceFutureRequests.add(req))
            )
            (§ return future)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;; Runs any balance futures in the user code thread.
    #_suppress(ß "FieldAccessNotGuarded")
    #_private
    (§ method void checkBalanceFuturesLocked(#_nilable Coin avail))
    (ß
        (§ call Preconditions.checkState(lock.isHeldByCurrentThread()))

        #_final
        (§ var ListIterator<BalanceFutureRequest> it = balanceFutureRequests.listIterator())
        (§ while (it.hasNext()))
        (ß
            #_final
            (§ var BalanceFutureRequest req = it.next())
            (§ var Coin val = getBalance(req.type)) ;; This could be slow for lots of futures.
            (§ if (val.compareTo(req.value) < 0))
                (§ continue)
            ;; Found one that's finished.
            (§ call it.remove())
            #_final
            (§ var Coin v = val)
            ;; Don't run any user-provided future listeners with our lock held.
            (§ call Threading.USER_THREAD.execute(new Runnable()
            (ß
                #_override
                #_public
                (§ method void run())
                (ß
                    (§ call req.future.set(v))
                )
            )))
        )
    )

    ;;;
     ; Returns the amount of bitcoin ever received via output.  <b>This is not the balance!</b>  If an output
     ; spends from a transaction whose inputs are also to our wallet, the input amounts are deducted from the
     ; outputs contribution, with a minimum of zero contribution.  The idea behind this is we avoid double
     ; counting money sent to us.
     ; @return the total amount of satoshis received, regardless of whether it was spent or not.
     ;;
    #_public
    (§ method Coin getTotalReceived())
    (ß
        (§ var Coin total = Coin.ZERO)

        ;; Include outputs to us if they were not just change outputs, i.e. the inputs to us summed to less
        ;; than the outputs to us.
        (§ for (Transaction tx :for transactions.values()))
        (ß
            (§ var Coin txTotal = Coin.ZERO)
            (§ for (TransactionOutput output :for tx.getOutputs()))
            (ß
                (§ if (output.isMine(this)))
                    (§ ass txTotal = txTotal.add(output.getValue()))
            )
            (§ for (TransactionInput in :for tx.getInputs()))
            (ß
                (§ var TransactionOutput prevOut = in.getConnectedOutput())
                (§ if (prevOut != nil && prevOut.isMine(this)))
                    (§ ass txTotal = txTotal.subtract(prevOut.getValue()))
            )
            (§ if (txTotal.isPositive()))
                (§ ass total = total.add(txTotal))
        )
        (§ return total)
    )

    ;;;
     ; Returns the amount of bitcoin ever sent via output.  If an output is sent to our own wallet, because of
     ; change or rotating keys or whatever, we do not count it.  If the wallet was involved in a shared transaction,
     ; i.e. there is some input to the transaction that we don't have the key for, then we multiply the sum of
     ; the output values by the proportion of satoshi coming in to our inputs.  Essentially we treat inputs as
     ; pooling into the transaction, becoming fungible and being equally distributed to all outputs.
     ; @return the total amount of satoshis sent by us.
     ;;
    #_public
    (§ method Coin getTotalSent())
    (ß
        (§ var Coin total = Coin.ZERO)

        (§ for (Transaction tx :for transactions.values()))
        (ß
            ;; Count spent outputs to only if they were not to us.  This means we don't count change outputs.
            (§ var Coin txOutputTotal = Coin.ZERO)
            (§ for (TransactionOutput out :for tx.getOutputs()))
            (ß
                (§ if (!out.isMine(this)))
                    (§ ass txOutputTotal = txOutputTotal.add(out.getValue()))
            )

            ;; Count the input values to us
            (§ var Coin txOwnedInputsTotal = Coin.ZERO)
            (§ for (TransactionInput in :for tx.getInputs()))
            (ß
                (§ var TransactionOutput prevOut = in.getConnectedOutput())
                (§ if (prevOut != nil && prevOut.isMine(this)))
                    (§ ass txOwnedInputsTotal = txOwnedInputsTotal.add(prevOut.getValue()))
            )

            ;; If there is an input that isn't from us, i.e. this is a shared transaction.
            (§ var Coin txInputsTotal = tx.getInputSum())
            (§ if (txOwnedInputsTotal != txInputsTotal))
            (ß
                ;; Multiply our output total by the appropriate proportion to account for the inputs that we don't own.
                (§ var BigInteger txOutputTotalNum = new BigInteger(txOutputTotal.toString()))
                (§ ass txOutputTotalNum = txOutputTotalNum.multiply(new BigInteger(txOwnedInputsTotal.toString())))
                (§ ass txOutputTotalNum = txOutputTotalNum.divide(new BigInteger(txInputsTotal.toString())))
                (§ ass txOutputTotal = Coin.valueOf(txOutputTotalNum.longValue()))
            )
            (§ ass total = total.add(txOutputTotal))
        )
        (§ return total)
    )

    ;;; A SendResult is returned to you as part of sending coins to a recipient. ;;
    #_public
    #_static
    (§ class SendResult
        ;;; The Bitcoin transaction message that moves the money. ;;
        #_public
        (§ field Transaction tx)
        ;;;
         ; A future that will complete once the tx message has been successfully broadcast to the network.
         ; This is just the result of calling broadcast.future().
         ;;
        #_public
        (§ field ListenableFuture<Transaction> broadcastComplete)
        ;;; The broadcast object returned by the linked TransactionBroadcaster. ;;
        #_public
        (§ field TransactionBroadcast broadcast)
    )

    ;;;
     ; Enumerates possible resolutions for missing signatures.
     ;;
    #_public
    (§ enum MissingSigsMode
        ;;; Input script will have OP_0 instead of missing signatures. ;;
        (§ item USE_OP_ZERO)
        ;;;
         ; Missing signatures will be replaced by dummy sigs.  This is useful when you'd like to know the
         ; fee for a transaction without knowing the user's password, as fee depends on size.
         ;;
        (§ item USE_DUMMY_SIG)
        ;;;
         ; If signature is missing, {@link org.bitcoinj.signers.TransactionSigner.MissingSignatureException}
         ; will be thrown for P2SH and {@link ECKey.MissingPrivateKeyException} for other tx types.
         ;;
        (§ item THROW)
    )

    ;;;
     ; <p>Statelessly creates a transaction that sends the given value to address.  The change is sent to
     ; {@link Wallet#currentChangeAddress()}, so you must have added at least one key.</p>
     ;
     ; <p>If you just want to send money quickly, you probably want
     ; {@link Wallet#sendCoins(TransactionBroadcaster, Address, Coin)} instead.  That will create the sending
     ; transaction, commit to the wallet and broadcast it to the network all in one go.  This method is lower
     ; level and lets you see the proposed transaction before anything is done with it.</p>
     ;
     ; <p>This is a helper method that is equivalent to using {@link SendRequest#to(Address, Coin)}
     ; followed by {@link Wallet#completeTx(Wallet.SendRequest)} and returning the requests transaction object.
     ; Note that this means a fee may be automatically added if required, if you want more control over the process,
     ; just do those two steps yourself.</p>
     ;
     ; <p>IMPORTANT: This method does NOT update the wallet.  If you call createSend again you may get two transactions
     ; that spend the same coins.  You have to call {@link Wallet#commitTx(Transaction)} on the created transaction to
     ; prevent this, but that should only occur once the transaction has been accepted by the network.  This implies
     ; you cannot have more than one outstanding sending tx at once.</p>
     ;
     ; <p>You MUST ensure that the value is not smaller than {@link Transaction#MIN_NONDUST_OUTPUT} or the transaction
     ; will almost certainly be rejected by the network as dust.</p>
     ;
     ; @param address The Bitcoin address to send the money to.
     ; @param value How much currency to send.
     ; @return either the created Transaction or null if there are insufficient coins.
     ; @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
     ; @throws DustySendRequested if the resultant transaction would violate the dust rules.
     ; @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
     ; @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process.
     ; @throws MultipleOpReturnRequested if there is more than one OP_RETURN output for the resultant transaction.
     ;;
    #_public
    (§ method Transaction createSend(Address address, Coin value))
        (§ throws InsufficientMoneyException)
    (ß
        (§ var SendRequest req = SendRequest.to(address, value))
        (§ if (params.getId().equals(NetworkParameters.ID_UNITTESTNET)))
            (§ ass req.shuffleOutputs = false)
        (§ call completeTx(req))
        (§ return req.tx)
    )

    ;;;
     ; Sends coins to the given address but does not broadcast the resulting pending transaction.  It is still
     ; stored in the wallet, so when the wallet is added to a {@link PeerGroup} or {@link Peer} the transaction
     ; will be announced to the network.  The given {@link SendRequest} is completed first using
     ; {@link Wallet#completeTx(Wallet.SendRequest)} to make it valid.
     ;
     ; @return the Transaction that was created.
     ; @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
     ; @throws IllegalArgumentException if you try and complete the same SendRequest twice.
     ; @throws DustySendRequested if the resultant transaction would violate the dust rules.
     ; @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
     ; @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process.
     ; @throws MultipleOpReturnRequested if there is more than one OP_RETURN output for the resultant transaction.
     ;;
    #_public
    (§ method Transaction sendCoinsOffline(SendRequest request))
        (§ throws InsufficientMoneyException)
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ call completeTx(request))
            (§ call commitTx(request.tx))
            (§ return request.tx)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; <p>Sends coins to the given address, via the given {@link PeerGroup}.  Change is returned to
     ; {@link Wallet#currentChangeAddress()}.  Note that a fee may be automatically added if one may be required
     ; for the transaction to be confirmed.</p>
     ;
     ; <p>The returned object provides both the transaction, and a future that can be used to learn when the broadcast
     ; is complete.  Complete means, if the PeerGroup is limited to only one connection, when it was written out to
     ; the socket.  Otherwise when the transaction is written out and we heard it back from a different peer.</p>
     ;
     ; <p>Note that the sending transaction is committed to the wallet immediately, not when the transaction is
     ; successfully broadcast.  This means that even if the network hasn't heard about your transaction you won't be
     ; able to spend those same coins again.</p>
     ;
     ; <p>You MUST ensure that value is not smaller than {@link Transaction#MIN_NONDUST_OUTPUT} or the transaction will
     ; almost certainly be rejected by the network as dust.</p>
     ;
     ; @param broadcaster A {@link TransactionBroadcaster} to use to send the transactions out.
     ; @param to Which address to send coins to.
     ; @param value How much value to send.
     ; @return an object containing the transaction that was created, and a future for the broadcast of it.
     ; @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
     ; @throws DustySendRequested if the resultant transaction would violate the dust rules.
     ; @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
     ; @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process.
     ; @throws MultipleOpReturnRequested if there is more than one OP_RETURN output for the resultant transaction.
     ;;
    #_public
    (§ method SendResult sendCoins(TransactionBroadcaster broadcaster, Address to, Coin value))
        (§ throws InsufficientMoneyException)
    (ß
        (§ var SendRequest request = SendRequest.to(to, value))
        (§ return sendCoins(broadcaster, request))
    )

    ;;;
     ; <p>Sends coins according to the given request, via the given {@link TransactionBroadcaster}.</p>
     ;
     ; <p>The returned object provides both the transaction, and a future that can be used to learn when the broadcast
     ; is complete.  Complete means, if the PeerGroup is limited to only one connection, when it was written out to
     ; the socket.  Otherwise when the transaction is written out and we heard it back from a different peer.</p>
     ;
     ; <p>Note that the sending transaction is committed to the wallet immediately, not when the transaction is
     ; successfully broadcast.  This means that even if the network hasn't heard about your transaction you won't be
     ; able to spend those same coins again.</p>
     ;
     ; @param broadcaster The target to use for broadcast.
     ; @param request The SendRequest that describes what to do, get one using static methods on SendRequest itself.
     ; @return an object containing the transaction that was created, and a future for the broadcast of it.
     ; @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
     ; @throws IllegalArgumentException if you try and complete the same SendRequest twice.
     ; @throws DustySendRequested if the resultant transaction would violate the dust rules.
     ; @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
     ; @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process.
     ; @throws MultipleOpReturnRequested if there is more than one OP_RETURN output for the resultant transaction.
     ;;
    #_public
    (§ method SendResult sendCoins(TransactionBroadcaster broadcaster, SendRequest request))
        (§ throws InsufficientMoneyException)
    (ß
        ;; Should not be locked here, as we're going to call into the broadcaster and that might want to hold its
        ;; own lock.  sendCoinsOffline handles everything that needs to be locked.
        (§ call Preconditions.checkState(!lock.isHeldByCurrentThread()))

        ;; Commit the TX to the wallet immediately so the spent coins won't be reused.
        ;; TODO: We should probably allow the request to specify tx commit only after the network has accepted it.
        (§ var Transaction tx = sendCoinsOffline(request))
        (§ var SendResult result = new SendResult())
        (§ ass result.tx = tx)
        ;; The tx has been committed to the pending pool by this point (via sendCoinsOffline -> commitTx), so it has
        ;; a txConfidenceListener registered.  Once the tx is broadcast the peers will update the memory pool with the
        ;; count of seen peers, the memory pool will update the transaction confidence object, that will invoke the
        ;; txConfidenceListener which will in turn invoke the wallets event listener onTransactionConfidenceChanged
        ;; method.
        (§ ass result.broadcast = broadcaster.broadcastTransaction(tx))
        (§ ass result.broadcastComplete = result.broadcast.future())
        (§ return result)
    )

    ;;;
     ; Satisfies the given {@link SendRequest} using the default transaction broadcaster configured either via
     ; {@link PeerGroup#addWallet(Wallet)} or directly with {@link #setTransactionBroadcaster(TransactionBroadcaster)}.
     ;
     ; @param request The SendRequest that describes what to do, get one using static methods on SendRequest itself.
     ; @return an object containing the transaction that was created, and a future for the broadcast of it.
     ; @throws IllegalStateException if no transaction broadcaster has been configured.
     ; @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
     ; @throws IllegalArgumentException if you try and complete the same SendRequest twice.
     ; @throws DustySendRequested if the resultant transaction would violate the dust rules.
     ; @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
     ; @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process.
     ; @throws MultipleOpReturnRequested if there is more than one OP_RETURN output for the resultant transaction.
     ;;
    #_public
    (§ method SendResult sendCoins(SendRequest request))
        (§ throws InsufficientMoneyException)
    (ß
        (§ var TransactionBroadcaster broadcaster = vTransactionBroadcaster)
        (§ call Preconditions.checkState(broadcaster != nil, "No transaction broadcaster is configured"))
        (§ return sendCoins(broadcaster, request))
    )

    ;;;
     ; Sends coins to the given address, via the given {@link Peer}.  Change is returned to {@link Wallet#currentChangeAddress()}.
     ; If an exception is thrown by {@link Peer#sendMessage(Message)} the transaction is still committed, so the pending
     ; transaction must be broadcast <b>by you</b> at some other time.  Note that a fee may be automatically added
     ; if one may be required for the transaction to be confirmed.
     ;
     ; @return the {@link Transaction} that was created or null if there was insufficient balance to send the coins.
     ; @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
     ; @throws IllegalArgumentException if you try and complete the same SendRequest twice.
     ; @throws DustySendRequested if the resultant transaction would violate the dust rules.
     ; @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
     ; @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process.
     ; @throws MultipleOpReturnRequested if there is more than one OP_RETURN output for the resultant transaction.
     ;;
    #_public
    (§ method Transaction sendCoins(Peer peer, SendRequest request))
        (§ throws InsufficientMoneyException)
    (ß
        (§ var Transaction tx = sendCoinsOffline(request))
        (§ call peer.sendMessage(tx))
        (§ return tx)
    )

    ;;;
     ; Class of exceptions thrown in {@link Wallet#completeTx(SendRequest)}.
     ;;
    #_public
    #_static
    (§ class CompletionException extends RuntimeException)

    ;;;
     ; Thrown if the resultant transaction would violate the dust rules (an output that's too small to be worthwhile).
     ;;
    #_public
    #_static
    (§ class DustySendRequested extends CompletionException)

    ;;;
     ; Thrown if there is more than one OP_RETURN output for the resultant transaction.
     ;;
    #_public
    #_static
    (§ class MultipleOpReturnRequested extends CompletionException)

    ;;;
     ; Thrown when we were trying to empty the wallet, and the total amount of money we were trying to empty after
     ; being reduced for the fee was smaller than the min payment.
     ; Note that the missing field will be null in this case.
     ;;
    #_public
    #_static
    (§ class CouldNotAdjustDownwards extends CompletionException)

    ;;;
     ; Thrown if the resultant transaction is too big for Bitcoin to process.  Try breaking up the amounts of value.
     ;;
    #_public
    #_static
    (§ class ExceededMaxTransactionSize extends CompletionException)

    ;;;
     ; Given a spend request containing an incomplete transaction, makes it valid by adding outputs and signed inputs
     ; according to the instructions in the request.  The transaction in the request is modified by this method.
     ;
     ; @param req A SendRequest that contains the incomplete transaction and details for how to make it valid.
     ; @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
     ; @throws IllegalArgumentException if you try and complete the same SendRequest twice.
     ; @throws DustySendRequested if the resultant transaction would violate the dust rules.
     ; @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
     ; @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process.
     ; @throws MultipleOpReturnRequested if there is more than one OP_RETURN output for the resultant transaction.
     ;;
    #_public
    (§ method void completeTx(SendRequest req))
        (§ throws InsufficientMoneyException)
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ call Preconditions.checkArgument(!req.completed, "Given SendRequest has already been completed."))

            ;; Calculate the amount of value we need to import.
            (§ var Coin value = Coin.ZERO)
            (§ for (TransactionOutput output :for req.tx.getOutputs()))
                (§ ass value = value.add(output.getValue()))

            (§ call log.info("Completing send tx with {} outputs totalling {} and a fee of {}/kB", req.tx.getOutputs().size(), value.toFriendlyString(), req.feePerKb.toFriendlyString()))

            ;; If any inputs have already been added, we don't need to get their value from wallet.
            (§ var Coin totalInput = Coin.ZERO)
            (§ for (TransactionInput input :for req.tx.getInputs()))
            (ß
                (§ if (input.getConnectedOutput() != nil))
                    (§ ass totalInput = totalInput.add(input.getConnectedOutput().getValue()))
                (§ else)
                    (§ call log.warn("SendRequest transaction already has inputs but we don't know how much they are worth - they will be added to fee."))
            )
            (§ ass value = value.subtract(totalInput))

            (§ var List<TransactionInput> originalInputs = new ArrayList<>(req.tx.getInputs()))

            ;; Check for dusty sends and the OP_RETURN limit.
            (§ if (req.ensureMinRequiredFee && !req.emptyWallet)) ;; Min fee checking is handled later for emptyWallet.
            (ß
                (§ var int opReturnCount = 0)
                (§ for (TransactionOutput output :for req.tx.getOutputs()))
                (ß
                    (§ if (output.isDust()))
                        (§ throw new DustySendRequested())
                    (§ if (output.getScriptPubKey().isOpReturn()))
                        (§ ass opReturnCount = opReturnCount + 1)
                )
                (§ if (1 < opReturnCount)) ;; Only 1 OP_RETURN per transaction allowed.
                    (§ throw new MultipleOpReturnRequested())
            )

            ;; Calculate a list of ALL potential candidates for spending and then ask a coin selector to provide us
            ;; with the actual outputs that'll be used to gather the required amount of value.  In this way, users
            ;; can customize coin selection policies.  The call below will ignore immature coinbases and outputs
            ;; we don't have the keys for.
            (§ var List<TransactionOutput> candidates = calculateAllSpendCandidates(true, req.missingSigsMode == MissingSigsMode.THROW))

            (§ var CoinSelection bestCoinSelection)
            (§ var TransactionOutput bestChangeOutput = nil)
            (§ var List<Coin> updatedOutputValues = nil)
            (§ if (!req.emptyWallet))
            (ß
                ;; This can throw InsufficientMoneyException.
                (§ var FeeCalculation feeCalculation = calculateFee(req, value, originalInputs, req.ensureMinRequiredFee, candidates))
                (§ ass bestCoinSelection = feeCalculation.bestCoinSelection)
                (§ ass bestChangeOutput = feeCalculation.bestChangeOutput)
                (§ ass updatedOutputValues = feeCalculation.updatedOutputValues)
            )
            (§ else)
            (ß
                ;; We're being asked to empty the wallet.  What this means is ensuring "tx" has only a single output
                ;; of the total value we can currently spend as determined by the selector, and then subtracting the fee.
                (§ call Preconditions.checkState(req.tx.getOutputs().size() == 1, "Empty wallet TX must have a single output only."))

                (§ var CoinSelector selector = (req.coinSelector == nil) ? coinSelector :else req.coinSelector)
                (§ ass bestCoinSelection = selector.select(params.getMaxMoney(), candidates))
                (§ ass candidates = nil) ;; Selector took ownership and might have changed candidates.  Don't access again.
                (§ call req.tx.getOutput(0).setValue(bestCoinSelection.valueGathered))
                (§ call log.info("  emptying {}", bestCoinSelection.valueGathered.toFriendlyString()))
            )

            (§ for (TransactionOutput output :for bestCoinSelection.gathered))
                (§ call req.tx.addInput(output))

            (§ if (req.emptyWallet))
            (ß
                #_final
                (§ var Coin feePerKb = (req.feePerKb == nil) ? Coin.ZERO :else req.feePerKb)
                (§ if (!adjustOutputDownwardsForFee(req.tx, bestCoinSelection, feePerKb, req.ensureMinRequiredFee)))
                    (§ throw new CouldNotAdjustDownwards())
            )

            (§ if (updatedOutputValues != nil))
            (ß
                (§ for (int i = 0 :for i < updatedOutputValues.size() :for i = i + 1))
                    (§ call req.tx.getOutput(i).setValue(updatedOutputValues.get(i)))
            )

            (§ if (bestChangeOutput != nil))
            (ß
                (§ call req.tx.addOutput(bestChangeOutput))
                (§ call log.info("  with {} change", bestChangeOutput.getValue().toFriendlyString()))
            )

            ;; Now shuffle the outputs to obfuscate which is the change.
            (§ if (req.shuffleOutputs))
                (§ call req.tx.shuffleOutputs())

            ;; Now sign the inputs, thus proving that we are entitled to redeem the connected outputs.
            (§ if (req.signInputs))
                (§ call signTransaction(req))

            ;; Check size.
            #_final
            (§ var int size = req.tx.unsafeBitcoinSerialize().length)
            (§ if (Transaction.MAX_STANDARD_TX_SIZE < size))
                (§ throw new ExceededMaxTransactionSize())

            ;; Label the transaction as being self created.  We can use this later to spend its change output even before
            ;; the transaction is confirmed.  We deliberately won't bother notifying listeners here as there's not much
            ;; point - the user isn't interested in a confidence transition they made themselves.
            (§ call req.tx.getConfidence().setSource(TransactionConfidence.Source.SELF))
            ;; Label the transaction as being a user requested payment.  This can be used to render GUI wallet
            ;; transaction lists more appropriately, especially when the wallet starts to generate transactions itself
            ;; for internal purposes.
            (§ call req.tx.setPurpose(Transaction.Purpose.USER_PAYMENT))
            ;; Record the exchange rate that was valid when the transaction was completed.
            (§ call req.tx.setExchangeRate(req.exchangeRate))
            (§ call req.tx.setMemo(req.memo))
            (§ ass req.completed = true)
            (§ call log.info("  completed: {}", req.tx))
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; <p>Given a send request containing transaction, attempts to sign it's inputs.  This method expects
     ; the transaction to have all necessary inputs connected or they will be ignored.</p>
     ; <p>Actual signing is done by pluggable {@link #signers} and it's not guaranteed that
     ; the transaction will be complete in the end.</p>
     ;;
    #_public
    (§ method void signTransaction(SendRequest req))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ var Transaction tx = req.tx)
            (§ var List<TransactionInput> inputs = tx.getInputs())
            (§ var List<TransactionOutput> outputs = tx.getOutputs())
            (§ call Preconditions.checkState(0 < inputs.size()))
            (§ call Preconditions.checkState(0 < outputs.size()))

            (§ var KeyBag maybeDecryptingKeyBag = new DecryptingKeyBag(this, req.aesKey))

            (§ var int numInputs = tx.getInputs().size())
            (§ for (int i = 0 :for i < numInputs :for i = i + 1))
            (ß
                (§ var TransactionInput txIn = tx.getInput(i))
                ;; Missing connected output, assuming already signed.
                (§ if (txIn.getConnectedOutput() == nil))
                    (§ continue)

                (§ try)
                (ß
                    ;; We assume if its already signed, its hopefully got a SIGHASH type that will not invalidate when
                    ;; we sign missing pieces (to check this would require either assuming any signatures are signing
                    ;; standard output types or a way to get processed signatures out of script execution).
                    (§ call txIn.getScriptSig().correctlySpends(tx, i, txIn.getConnectedOutput().getScriptPubKey()))
                    (§ call log.warn("Input {} already correctly spends output, assuming SIGHASH type used will be safe and skipping signing.", i))
                    (§ continue)
                )
                (§ catch (ScriptException e))
                (ß
                    (§ call log.debug("Input contained an incorrect signature", e))
                    ;; Expected.
                )

                (§ var Script scriptPubKey = txIn.getConnectedOutput().getScriptPubKey())
                (§ var RedeemData redeemData = txIn.getConnectedRedeemData(maybeDecryptingKeyBag))
                (§ call Preconditions.checkNotNull(redeemData, "Transaction exists in wallet that we cannot redeem: %s", txIn.getOutpoint().getHash()))
                (§ call txIn.setScriptSig(scriptPubKey.createEmptyInputScript(redeemData.keys.get(0), redeemData.redeemScript)))
            )

            (§ var TransactionSigner.ProposedTransaction proposal = new TransactionSigner.ProposedTransaction(tx))
            (§ for (TransactionSigner signer :for signers))
            (ß
                (§ if (!signer.signInputs(proposal, maybeDecryptingKeyBag)))
                    (§ call log.info("{} returned false for the tx", signer.getClass().getName()))
            )

            ;; Resolve missing sigs if any.
            (§ call new MissingSigResolutionSigner(req.missingSigsMode).signInputs(proposal, maybeDecryptingKeyBag))
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;; Reduce the value of the first output of a transaction to pay the given feePerKb as appropriate for its size. ;;
    #_private
    (§ method boolean adjustOutputDownwardsForFee(Transaction tx, CoinSelection coinSelection, Coin feePerKb, boolean ensureMinRequiredFee))
    (ß
        #_final
        (§ var int size = tx.unsafeBitcoinSerialize().length + estimateBytesForSigning(coinSelection))
        (§ var Coin fee = feePerKb.multiply(size).divide(1000))
        (§ if (ensureMinRequiredFee && fee.compareTo(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE) < 0))
            (§ ass fee = Transaction.REFERENCE_DEFAULT_MIN_TX_FEE)
        (§ var TransactionOutput output = tx.getOutput(0))
        (§ call output.setValue(output.getValue().subtract(fee)))
        (§ return !output.isDust())
    )

    ;;;
     ; Returns a list of the outputs that can potentially be spent, i.e. that we have the keys for and are unspent
     ; according to our knowledge of the block chain.
     ;;
    #_public
    (§ method List<TransactionOutput> calculateAllSpendCandidates())
    (ß
        (§ return calculateAllSpendCandidates(true, true))
    )

    ;;;
     ; Returns a list of all outputs that are being tracked by this wallet taking into account the flags.
     ;
     ; @param excludeImmatureCoinbases Whether to ignore coinbase outputs that we will be able to spend in future once they mature.
     ; @param excludeUnsignable Whether to ignore outputs that we are tracking but don't have the keys to sign for.
     ;;
    #_public
    (§ method List<TransactionOutput> calculateAllSpendCandidates(boolean excludeImmatureCoinbases, boolean excludeUnsignable))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ var List<TransactionOutput> candidates = new ArrayList<>(myUnspents.size()))
            (§ for (TransactionOutput output :for myUnspents))
            (ß
                (§ if (excludeUnsignable && !canSignFor(output.getScriptPubKey())))
                    (§ continue)
                (§ var Transaction transaction = Preconditions.checkNotNull(output.getParentTransaction()))
                (§ if (excludeImmatureCoinbases && !transaction.isMature()))
                    (§ continue)
                (§ call candidates.add(output))
            )
            (§ return candidates)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Returns true if this wallet has at least one of the private keys needed to sign for this scriptPubKey.
     ; Returns false if the form of the script is not known or if the script is OP_RETURN.
     ;;
    #_public
    (§ method boolean canSignFor(Script script))
    (ß
        (§ if (script.isSentToRawPubKey()))
        (ß
            (§ var byte[] pubkey = script.getPubKey())
            (§ var ECKey key = findKeyFromPubKey(pubkey))
            (§ return (key != nil && (key.isEncrypted() || key.hasPrivKey())))
        )

        (§ if (script.isPayToScriptHash()))
        (ß
            (§ var RedeemData data = findRedeemDataFromScriptHash(script.getPubKeyHash()))
            (§ return (data != nil && canSignFor(data.redeemScript)))
        )

        (§ if (script.isSentToAddress()))
        (ß
            (§ var ECKey key = findKeyFromPubHash(script.getPubKeyHash()))
            (§ return (key != nil && (key.isEncrypted() || key.hasPrivKey())))
        )

        (§ if (script.isSentToMultiSig()))
        (ß
            (§ for (ECKey pubkey :for script.getPubKeys()))
            (ß
                (§ var ECKey key = findKeyFromPubKey(pubkey.getPubKey()))
                (§ if (key != nil && (key.isEncrypted() || key.hasPrivKey())))
                    (§ return true)
            )
        )
        (§ elseif (script.isSentToCLTVPaymentChannel()))
        (ß
            ;; Any script for which we are the recipient or sender counts.
            (§ var byte[] sender = script.getCLTVPaymentChannelSenderPubKey())
            (§ var ECKey senderKey = findKeyFromPubKey(sender))
            (§ if (senderKey != nil && (senderKey.isEncrypted() || senderKey.hasPrivKey())))
                (§ return true)

            (§ var byte[] recipient = script.getCLTVPaymentChannelRecipientPubKey())
            (§ var ECKey recipientKey = findKeyFromPubKey(sender))
            (§ if (recipientKey != nil && (recipientKey.isEncrypted() || recipientKey.hasPrivKey())))
                (§ return true)
        )
        (§ return false)
    )

    ;;; Returns the {@link CoinSelector} object which controls which outputs can be spent by this wallet. ;;
    #_public
    (§ method CoinSelector getCoinSelector())
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ return coinSelector)
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; A coin selector is responsible for choosing which outputs to spend when creating transactions.  The default
     ; selector implements a policy of spending transactions that appeared in the best chain and pending transactions
     ; that were created by this wallet, but not others.  You can override the coin selector for any given send
     ; operation by changing {@link SendRequest#coinSelector}.
     ;;
    #_public
    (§ method void setCoinSelector(CoinSelector coinSelector))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            (§ ass this.coinSelector = Preconditions.checkNotNull(coinSelector))
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Convenience wrapper for <tt>setCoinSelector(Wallet.AllowUnconfirmedCoinSelector.get())</tt>.  If this method
     ; is called on the wallet then transactions will be used for spending regardless of their confidence.  This can
     ; be dangerous - only use this if you absolutely know what you're doing!
     ;;
    #_public
    (§ method void allowSpendingUnconfirmedTransactions())
    (ß
        (§ call setCoinSelector(AllowUnconfirmedCoinSelector.get()))
    )

    ;;;
     ; A custom {@link TransactionOutput} that is free standing.  This contains all the information
     ; required for spending without actually having all the linked data (i.e parent tx).
     ;
     ;;
    #_private
    (§ class FreeStandingTransactionOutput extends TransactionOutput
        #_private
        (§ field UTXO output)
        #_private
        (§ field int chainHeight)

        ;;;
         ; Construct a free standing Transaction Output.
         ; @param params The network parameters.
         ; @param output The stored output (free standing).
         ;;
        #_public
        (§ constructor FreeStandingTransactionOutput(NetworkParameters params, UTXO output, int chainHeight))
        (ß
            (§ super (params, nil, output.getValue(), output.getScript().getProgram()))

            (§ ass this.output = output)
            (§ ass this.chainHeight = chainHeight)
        )

        ;;;
         ; Get the {@link UTXO}.
         ; @return the stored output.
         ;;
        #_public
        (§ method UTXO getUTXO())
        (ß
            (§ return output)
        )

        ;;;
         ; Get the depth within the chain of the parent tx, depth is 1 if the output height is the height
         ; of the latest block.
         ; @return the depth.
         ;;
        #_override
        #_public
        (§ method int getParentTransactionDepthInBlocks())
        (ß
            (§ return chainHeight - output.getHeight() + 1)
        )

        #_override
        #_public
        (§ method int getIndex())
        (ß
            (§ return (int) output.getIndex())
        )

        #_override
        #_public
        (§ method Sha256Hash getParentTransactionHash())
        (ß
            (§ return output.getHash())
        )
    )

    #_private
    #_static
    (§ class TxOffsetPair implements Comparable<TxOffsetPair>
        #_public
        #_final
        (§ field Transaction tx)
        #_public
        #_final
        (§ field int offset)

        #_public
        (§ constructor TxOffsetPair(Transaction tx, int offset))
        (ß
            (§ ass this.tx = tx)
            (§ ass this.offset = offset)
        )

        #_override
        #_public
        (§ method int compareTo(TxOffsetPair o))
        (ß
            ;; Note that in this implementation compareTo() is not consistent with equals().
            (§ return Ints.compare(offset, o.offset))
        )
    )

    ;;;
     ; <p>Don't call this directly.  It's not intended for API users.</p>
     ;
     ; <p>Called by the {@link BlockChain} when the best chain (representing total work done) has changed.
     ; This can cause the number of confirmations of a transaction to go higher, lower, drop to zero and
     ; can even result in a transaction going dead (will never confirm) due to a double spend.</p>
     ;
     ; <p>The oldBlocks/newBlocks lists are ordered height-wise from top first to bottom last.</p>
     ;;
    #_override
    #_public
    (§ method void reorganize(StoredBlock splitPoint, List<StoredBlock> oldBlocks, List<StoredBlock> newBlocks))
        (§ throws VerificationException)
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            ;; This runs on any peer thread with the block chain locked.
            ;;
            ;; The reorganize functionality of the wallet is tested in ChainSplitTest.java
            ;;
            ;; receive() has been called on the block that is triggering the re-org before this is called,
            ;; with type of SIDE_CHAIN.
            ;;
            ;; Note that this code assumes blocks are not invalid - if blocks contain duplicated transactions,
            ;; transactions that double spend etc then we can calculate the incorrect result.  This could open up
            ;; obscure DoS attacks if someone successfully mines a throwaway invalid block and feeds it to us, just
            ;; to try and corrupt the internal data structures.  We should try harder to avoid this but it's tricky
            ;; because there are so many ways the block can be invalid.

            ;; Avoid spuriously informing the user of wallet/tx confidence changes whilst we're re-organizing.
            (§ call Preconditions.checkState(confidenceChanged.size() == 0))
            (§ call Preconditions.checkState(!insideReorg))
            (§ ass insideReorg = true)
            (§ call Preconditions.checkState(onWalletChangedSuppressions == 0))
            (§ ass onWalletChangedSuppressions = onWalletChangedSuppressions + 1)

            ;; Map block hash to transactions that appear in it.  We ensure that the map values are sorted according
            ;; to their relative position within those blocks.
            (§ var ArrayListMultimap<Sha256Hash, TxOffsetPair> mapBlockTx = ArrayListMultimap.create())
            (§ for (Transaction tx :for getTransactions(true)))
            (ß
                (§ var Map<Sha256Hash, Integer> appearsIn = tx.getAppearsInHashes())
                (§ if (appearsIn == nil))
                    (§ continue) ;; Pending.
                (§ for (Map.Entry<Sha256Hash, Integer> block :for appearsIn.entrySet()))
                    (§ call mapBlockTx.put(block.getKey(), new TxOffsetPair(tx, block.getValue())))
            )
            (§ for (Sha256Hash blockHash :for mapBlockTx.keySet()))
                (§ call Collections.sort(mapBlockTx.get(blockHash)))

            (§ var List<Sha256Hash> oldBlockHashes = new ArrayList<>(oldBlocks.size()))
            (§ call log.info("Old part of chain (top to bottom):"))
            (§ for (StoredBlock b :for oldBlocks))
            (ß
                (§ call log.info("  {}", b.getHeader().getHashAsString()))
                (§ call oldBlockHashes.add(b.getHeader().getHash()))
            )
            (§ call log.info("New part of chain (top to bottom):"))
            (§ for (StoredBlock b :for newBlocks))
                (§ call log.info("  {}", b.getHeader().getHashAsString()))

            (§ call Collections.reverse(newBlocks)) ;; Need bottom-to-top but we get top-to-bottom.

            ;; For each block in the old chain, disconnect the transactions in reverse order.
            (§ var LinkedList<Transaction> oldChainTxns = Lists.newLinkedList())
            (§ for (Sha256Hash blockHash :for oldBlockHashes))
            (ß
                (§ for (TxOffsetPair pair :for mapBlockTx.get(blockHash)))
                (ß
                    (§ var Transaction tx = pair.tx)
                    #_final
                    (§ var Sha256Hash txHash = tx.getHash())
                    (§ if (tx.isCoinBase()))
                    (ß
                        ;; All the transactions that we have in our wallet which spent this coinbase are now invalid
                        ;; and will never confirm.  Hopefully this should never happen - that's the point of the maturity
                        ;; rule that forbids spending of coinbase transactions for 100 blocks.
                        ;;
                        ;; This could be recursive, although of course because we don't have the full transaction
                        ;; graph we can never reliably kill all transactions we might have that were rooted in
                        ;; this coinbase tx.  Some can just go pending forever, like the Bitcoin Core.  However we
                        ;; can do our best.
                        (§ call log.warn("Coinbase killed by re-org: {}", tx.getHashAsString()))
                        (§ call killTxns(ImmutableSet.of(tx), nil))
                    )
                    (§ else)
                    (ß
                        (§ for (TransactionOutput output :for tx.getOutputs()))
                        (ß
                            (§ var TransactionInput input = output.getSpentBy())
                            (§ if (input != nil))
                            (ß
                                (§ if (output.isMine(this)))
                                    (§ call Preconditions.checkState(myUnspents.add(output)))
                                (§ call input.disconnect())
                            )
                        )
                        (§ call oldChainTxns.add(tx))
                        (§ call unspent.remove(txHash))
                        (§ call spent.remove(txHash))
                        (§ call Preconditions.checkState(!pending.containsKey(txHash)))
                        (§ call Preconditions.checkState(!dead.containsKey(txHash)))
                    )
                )
            )

            ;; Put all the disconnected transactions back into the pending pool and re-connect them.
            (§ for (Transaction tx :for oldChainTxns))
            (ß
                ;; Coinbase transactions on the old part of the chain are dead for good and won't come back unless
                ;; there's another re-org.
                (§ if (tx.isCoinBase()))
                    (§ continue)
                (§ call log.info("  ->pending {}", tx.getHash()))

                (§ call tx.getConfidence().setConfidenceType(ConfidenceType.PENDING)) ;; Wipe height/depth/work data.
                (§ call confidenceChanged.put(tx, TransactionConfidence.Listener.ChangeReason.TYPE))
                (§ call addWalletTransaction(Pool.PENDING, tx))
                (§ call updateForSpends(tx, false))
            )

            ;; Note that dead transactions stay dead.  Consider a chain that Finney attacks T1 and replaces it with
            ;; T2, so we move T1 into the dead pool.  If there's now a re-org to a chain that doesn't include T2, it
            ;; doesn't matter - the miners deleted T1 from their mempool, will resurrect T2 and put that into the
            ;; mempool and so T1 is still seen as a losing double spend.

            ;; The old blocks have contributed to the depth for all the transactions in the
            ;; wallet that are in blocks up to and including the chain split block.
            ;; The total depth is calculated here and then subtracted from the appropriate transactions.
            (§ var int depthToSubtract = oldBlocks.size())
            (§ ass log.info("depthToSubtract = " + depthToSubtract))
            ;; Remove depthToSubtract from all transactions in the wallet except for pending.
            (§ call subtractDepth(depthToSubtract, spent.values()))
            (§ call subtractDepth(depthToSubtract, unspent.values()))
            (§ call subtractDepth(depthToSubtract, dead.values()))

            ;; The effective last seen block is now the split point so set the lastSeenBlockHash.
            (§ call setLastBlockSeenHash(splitPoint.getHeader().getHash()))

            ;; For each block in the new chain, work forwards calling receive() and notifyNewBestBlock().
            ;; This will pull them back out of the pending pool, or if the tx didn't appear in the old chain
            ;; and does appear in the new chain, will treat it as such and possibly kill pending transactions
            ;; that conflict.
            (§ for (StoredBlock block :for newBlocks))
            (ß
                (§ call log.info("Replaying block {}", block.getHeader().getHashAsString()))
                (§ for (TxOffsetPair pair :for mapBlockTx.get(block.getHeader().getHash())))
                (ß
                    (§ call log.info("  tx {}", pair.tx.getHash()))
                    (§ try)
                    (ß
                        (§ call receive(pair.tx, block, BlockChain.NewBlockType.BEST_CHAIN, pair.offset))
                    )
                    (§ catch (ScriptException e))
                    (ß
                        (§ throw new RuntimeException(e)) ;; Cannot happen as these blocks were already verified.
                    )
                )
                (§ call notifyNewBestBlock(block))
            )
            (§ call isConsistentOrThrow())
            #_final
            (§ var Coin balance = getBalance())
            (§ call log.info("post-reorg balance is {}", balance.toFriendlyString()))
            ;; Inform event listeners that a re-org took place.
            (§ call queueOnReorganize())
            (§ ass insideReorg = false)
            (§ ass onWalletChangedSuppressions = onWalletChangedSuppressions - 1)
            (§ call maybeQueueOnWalletChanged())
            (§ call checkBalanceFuturesLocked(balance))
            (§ call informConfidenceListenersIfNotReorganizing())
            (§ call saveLater())
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )

    ;;;
     ; Subtract the supplied depth from the given transactions.
     ;;
    #_private
    (§ method void subtractDepth(int depthToSubtract, Collection<Transaction> transactions))
    (ß
        (§ for (Transaction tx :for transactions))
        (ß
            (§ if (tx.getConfidence().getConfidenceType() == ConfidenceType.BUILDING))
            (ß
                (§ call tx.getConfidence().setDepthInBlocks(tx.getConfidence().getDepthInBlocks() - depthToSubtract))
                (§ call confidenceChanged.put(tx, TransactionConfidence.Listener.ChangeReason.DEPTH))
            )
        )
    )

    #_private
    #_final
    (§ field ArrayList<TransactionOutPoint> bloomOutPoints = Lists.newArrayList())
    ;; Used to track whether we must automatically begin/end a filter calculation and calc outpoints/take the locks.
    #_private
    #_final
    (§ field AtomicInteger bloomFilterGuard = new AtomicInteger(0))

    #_override
    #_public
    (§ method void beginBloomFilterCalculation())
    (ß
        (§ if (1 < bloomFilterGuard.incrementAndGet()))
            (§ return)

        (§ call lock.lock())
        (§ call keyChainGroupLock.lock())
        ;; noinspection FieldAccessNotGuarded
        (§ call calcBloomOutPointsLocked())
    )

    #_private
    (§ method void calcBloomOutPointsLocked())
    (ß
        ;; TODO: This could be done once and then kept up to date.
        (§ call bloomOutPoints.clear())
        (§ var Set<Transaction> all = new HashSet<>())
        (§ call all.addAll(unspent.values()))
        (§ call all.addAll(spent.values()))
        (§ call all.addAll(pending.values()))

        (§ for (Transaction tx :for all))
        (ß
            (§ for (TransactionOutput out :for tx.getOutputs()))
            (ß
                (§ try)
                (ß
                    (§ if (isTxOutputBloomFilterable(out)))
                        (§ call bloomOutPoints.add(out.getOutPointFor()))
                )
                (§ catch (ScriptException e))
                (ß
                    ;; If it is ours, we parsed the script correctly, so this shouldn't happen.
                    (§ throw new RuntimeException(e))
                )
            )
        )
    )

    #_override
    #_guarded-by(ß "keyChainGroupLock")
    #_public
    (§ method void endBloomFilterCalculation())
    (ß
        (§ if (0 < bloomFilterGuard.decrementAndGet()))
            (§ return)

        (§ call bloomOutPoints.clear())
        (§ call keyChainGroupLock.unlock())
        (§ call lock.unlock())
    )

    ;;;
     ; Returns the number of distinct data items (note: NOT keys) that will be inserted into a bloom filter,
     ; when it is constructed.
     ;;
    #_override
    #_public
    (§ method int getBloomFilterElementCount())
    (ß
        (§ call beginBloomFilterCalculation())
        (§ try)
        (ß
            (§ return bloomOutPoints.size() + keyChainGroup.getBloomFilterElementCount())
        )
        (§ finally)
        (ß
            (§ call endBloomFilterCalculation())
        )
    )

    ;;;
     ; Gets a bloom filter that contains all of the public keys from this wallet, and which will provide the given
     ; false-positive rate.  See the docs for {@link BloomFilter} for a brief explanation of anonymity when using filters.
     ;;
    #_public
    (§ method BloomFilter getBloomFilter(double falsePositiveRate))
    (ß
        (§ call beginBloomFilterCalculation())
        (§ try)
        (ß
            (§ return getBloomFilter(getBloomFilterElementCount(), falsePositiveRate, (long)(Math.random() * Long.MAX_VALUE)))
        )
        (§ finally)
        (ß
            (§ call endBloomFilterCalculation())
        )
    )

    ;;;
     ; <p>Gets a bloom filter that contains all of the public keys from this wallet, and which will provide the given
     ; false-positive rate if it has size elements.  Keep in mind that you will get 2 elements in the bloom filter for
     ; each key in the wallet, for the public key and the hash of the public key (address form).</p>
     ;
     ; <p>This is used to generate a BloomFilter which can be {@link BloomFilter#merge(BloomFilter)}d with another.
     ; It could also be used if you have a specific target for the filter's size.</p>
     ;
     ; <p>See the docs for {@link BloomFilter(int, double)} for a brief explanation of anonymity when using bloom
     ; filters.</p>
     ;;
    #_override
    #_guarded-by(ß "keyChainGroupLock")
    #_public
    (§ method BloomFilter getBloomFilter(int size, double falsePositiveRate, long nTweak))
    (ß
        (§ call beginBloomFilterCalculation())
        (§ try)
        (ß
            (§ var BloomFilter filter = keyChainGroup.getBloomFilter(size, falsePositiveRate, nTweak))
            (§ for (TransactionOutPoint point :for bloomOutPoints))
                (§ call filter.insert(point.unsafeBitcoinSerialize()))
            (§ return filter)
        )
        (§ finally)
        (ß
            (§ call endBloomFilterCalculation())
        )
    )

    ;; Returns true if the output is one that won't be selected by a data element matching in the scriptSig.
    #_private
    (§ method boolean isTxOutputBloomFilterable(TransactionOutput out))
    (ß
        (§ var Script script = out.getScriptPubKey())
        (§ var boolean isScriptTypeSupported = (script.isSentToRawPubKey() || script.isPayToScriptHash()))
        (§ return (isScriptTypeSupported && myUnspents.contains(out)))
    )

    ;;;
     ; Used by {@link Peer} to decide whether or not to discard this block and any blocks building upon it, in case
     ; the Bloom filter used to request them may be exhausted, that is, not have sufficient keys in the deterministic
     ; sequence within it to reliably find relevant transactions.
     ;;
    #_public
    (§ method boolean checkForFilterExhaustion(FilteredBlock block))
    (ß
        (§ call keyChainGroupLock.lock())
        (§ try)
        (ß
            (§ var int epoch = keyChainGroup.getCombinedKeyLookaheadEpochs())
            (§ for (Transaction tx :for block.getAssociatedTransactions().values()))
                (§ call markKeysAsUsed(tx))
            (§ var int newEpoch = keyChainGroup.getCombinedKeyLookaheadEpochs())
            (§ call Preconditions.checkState(epoch <= newEpoch))
            ;; If the key lookahead epoch has advanced, there was a call to importKeys and the PeerGroup already has a
            ;; pending request to recalculate the filter queued up on another thread.  The calling Peer should abandon
            ;; block at this point and await a new filter before restarting the download.
            (§ return (epoch < newEpoch))
        )
        (§ finally)
        (ß
            (§ call keyChainGroupLock.unlock())
        )
    )

    #_private
    #_static
    (§ class FeeCalculation
        ;; Selected UTXOs to spend.
        #_public
        (§ field CoinSelection bestCoinSelection)
        ;; Change output (may be null if no change).
        #_public
        (§ field TransactionOutput bestChangeOutput)
        ;; List of output values adjusted downwards when recipients pay fees (may be null if no adjustment needed).
        #_public
        (§ field List<Coin> updatedOutputValues)
    )

    #_private
    (§ method FeeCalculation calculateFee(SendRequest req, Coin value, List<TransactionInput> originalInputs, boolean needAtLeastReferenceFee, List<TransactionOutput> candidates))
        (§ throws InsufficientMoneyException)
    (ß
        (§ call Preconditions.checkState(lock.isHeldByCurrentThread()))
        (§ var FeeCalculation result)
        (§ var Coin fee = Coin.ZERO)
        (§ while (true))
        (ß
            (§ ass result = new FeeCalculation())
            (§ var Transaction tx = new Transaction(params))
            (§ call addSuppliedInputs(tx, req.tx.getInputs()))

            (§ var Coin valueNeeded = value)
            (§ if (!req.recipientsPayFees))
                (§ ass valueNeeded = valueNeeded.add(fee))
            (§ if (req.recipientsPayFees))
                (§ ass result.updatedOutputValues = new ArrayList<Coin>())

            (§ for (int i = 0 :for i < req.tx.getOutputs().size() :for i = i + 1))
            (ß
                (§ var TransactionOutput output = new TransactionOutput(params, tx, req.tx.getOutputs().get(i).bitcoinSerialize(), 0))
                (§ if (req.recipientsPayFees))
                (ß
                    ;; Subtract fee equally from each selected recipient.
                    (§ call output.setValue(output.getValue().subtract(fee.divide(req.tx.getOutputs().size()))))
                    ;; First receiver pays the remainder not divisible by output count.
                    (§ if (i == 0))
                    (ß
                        ;; Subtract fee equally from each selected recipient.
                        (§ call output.setValue(output.getValue().subtract(fee.divideAndRemainder(req.tx.getOutputs().size())[1])))
                    )
                    (§ call result.updatedOutputValues.add(output.getValue()))
                    (§ if (output.getMinNonDustValue().isGreaterThan(output.getValue())))
                        (§ throw new CouldNotAdjustDownwards())
                )
                (§ call tx.addOutput(output))
            )

            (§ var CoinSelector selector = (req.coinSelector == nil) ? coinSelector :else req.coinSelector)
            ;; selector is allowed to modify candidates list.
            (§ var CoinSelection selection = selector.select(valueNeeded, new LinkedList<>(candidates)))
            (§ ass result.bestCoinSelection = selection)
            ;; Can we afford this?
            (§ if (selection.valueGathered.compareTo(valueNeeded) < 0))
            (ß
                (§ var Coin valueMissing = valueNeeded.subtract(selection.valueGathered))
                (§ throw new InsufficientMoneyException(valueMissing))
            )

            (§ var Coin change = selection.valueGathered.subtract(valueNeeded))
            (§ if (change.isGreaterThan(Coin.ZERO)))
            (ß
                ;; The value of the inputs is greater than what we want to send.  Just like in real life then,
                ;; we need to take back some coins ... this is called "change".  Add another output that sends the change
                ;; back to us.  The address comes either from the request or currentChangeAddress() as a default.
                (§ var Address changeAddress = req.changeAddress)
                (§ if (changeAddress == nil))
                    (§ ass changeAddress = currentChangeAddress())

                (§ var TransactionOutput changeOutput = new TransactionOutput(params, tx, change, changeAddress))
                (§ if (req.recipientsPayFees && changeOutput.isDust()))
                (ß
                    ;; We do not move dust-change to fees, because the sender would end up paying more than requested.
                    ;; This would be against the purpose of the all-inclusive feature.
                    ;; So instead we raise the change and deduct from the first recipient.
                    (§ var Coin missingToNotBeDust = changeOutput.getMinNonDustValue().subtract(changeOutput.getValue()))
                    (§ call changeOutput.setValue(changeOutput.getValue().add(missingToNotBeDust)))
                    (§ var TransactionOutput firstOutput = tx.getOutputs().get(0))
                    (§ call firstOutput.setValue(firstOutput.getValue().subtract(missingToNotBeDust)))
                    (§ call result.updatedOutputValues.set(0, firstOutput.getValue()))
                    (§ if (firstOutput.isDust()))
                        (§ throw new CouldNotAdjustDownwards())
                )

                (§ if (changeOutput.isDust()))
                (ß
                    ;; Never create dust outputs; if we would, just add the dust to the fee.
                    ;; Oscar comment: This seems like a way to make the condition below "if (!fee.isLessThan(feeNeeded))" to become true.
                    ;; This is a non-easy to understand way to do that.
                    ;; Maybe there are other effects I am missing.
                    (§ ass fee = fee.add(changeOutput.getValue()))
                )
                (§ else)
                (ß
                    (§ call tx.addOutput(changeOutput))
                    (§ ass result.bestChangeOutput = changeOutput)
                )
            )

            (§ for (TransactionOutput selectedOutput :for selection.gathered))
            (ß
                (§ var TransactionInput input = tx.addInput(selectedOutput))
                ;; If the scriptBytes don't default to none, our size calculations will be thrown off.
                (§ call Preconditions.checkState(input.getScriptBytes().length == 0))
            )

            (§ var int size = tx.unsafeBitcoinSerialize().length)
            (§ ass size = size + estimateBytesForSigning(selection))

            (§ var Coin feePerKb = req.feePerKb)
            (§ if (needAtLeastReferenceFee && feePerKb.compareTo(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE) < 0))
                (§ ass feePerKb = Transaction.REFERENCE_DEFAULT_MIN_TX_FEE)

            (§ var Coin feeNeeded = feePerKb.multiply(size).divide(1000))

            (§ if (!fee.isLessThan(feeNeeded)))
            (ß
                ;; Done, enough fee included.
                (§ break)
            )

            ;; Include more fee and try again.
            (§ ass fee = feeNeeded)
        )
        (§ return result)
    )

    #_private
    (§ method void addSuppliedInputs(Transaction tx, List<TransactionInput> originalInputs))
    (ß
        (§ for (TransactionInput input :for originalInputs))
            (§ call tx.addInput(new TransactionInput(params, tx, input.bitcoinSerialize())))
    )

    #_private
    (§ method int estimateBytesForSigning(CoinSelection selection))
    (ß
        (§ var int size = 0)
        (§ for (TransactionOutput output :for selection.gathered))
        (ß
            (§ try)
            (ß
                (§ var Script script = output.getScriptPubKey())
                (§ var ECKey key = nil)
                (§ var Script redeemScript = nil)
                (§ if (script.isSentToAddress()))
                (ß
                    (§ ass key = findKeyFromPubHash(script.getPubKeyHash()))
                    (§ call Preconditions.checkNotNull(key, "Coin selection includes unspendable outputs"))
                )
                (§ elseif (script.isPayToScriptHash()))
                (ß
                    (§ ass redeemScript = findRedeemDataFromScriptHash(script.getPubKeyHash()).redeemScript)
                    (§ call Preconditions.checkNotNull(redeemScript, "Coin selection includes unspendable outputs"))
                )
                (§ ass size = size + script.getNumberOfBytesRequiredToSpend(key, redeemScript))
            )
            (§ catch (ScriptException e))
            (ß
                ;; If this happens it means an output script in a wallet tx could not be understood.  That
                ;; should never happen, if it does it means the wallet has got into an inconsistent state.
                (§ throw new IllegalStateException(e))
            )
        )
        (§ return size)
    )

    ;; Wallet maintenance transactions.  These transactions may not be directly connected to a payment the user is
    ;; making.  They may be instead key rotation transactions for when old keys are suspected to be compromised,
    ;; de/re-fragmentation transactions for when our output sizes are inappropriate or suboptimal, privacy transactions
    ;; and so on.  Because these transactions may require user intervention in some way (e.g. entering their password)
    ;; the wallet application is expected to poll the Wallet class to get SendRequests.  Ideally security systems like
    ;; hardware wallets or risk analysis providers are programmed to auto-approve transactions that send from our own
    ;; keys back to our own keys.

    ;;;
     ; <p>Specifies that the given {@link TransactionBroadcaster}, typically a {@link PeerGroup}, should be used for
     ; sending transactions to the Bitcoin network by default.  Some sendCoins methods let you specify a broadcaster
     ; explicitly, in that case, they don't use this broadcaster.  If null is specified then the wallet won't attempt
     ; to broadcast transactions itself.</p>
     ;
     ; <p>You don't normally need to call this.  A {@link PeerGroup} will automatically set itself as the wallets
     ; broadcaster when you use {@link PeerGroup#addWallet(Wallet)}.  A wallet can use the broadcaster when you ask
     ; it to send money, but in future also at other times to implement various features that may require asynchronous
     ; re-organisation of the wallet contents on the block chain.  For instance, in future the wallet may choose to
     ; optimise itself to reduce fees or improve privacy.</p>
     ;;
    #_public
    (§ method void setTransactionBroadcaster(#_nilable org.bitcoinj.core.TransactionBroadcaster broadcaster))
    (ß
        (§ var Transaction[] toBroadcast = (ß ))
        (§ call lock.lock())
        (§ try)
        (ß
            (§ if (vTransactionBroadcaster == broadcaster))
                (§ return)
            (§ ass vTransactionBroadcaster = broadcaster)
            (§ if (broadcaster == nil))
                (§ return)
            (§ ass toBroadcast = pending.values().toArray(toBroadcast))
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
        ;; Now use it to upload any pending transactions we have that are marked as not being seen by any peers yet.
        ;; Don't hold the wallet lock whilst doing this, so if the broadcaster accesses the wallet at some point there
        ;; is no inversion.
        (§ for (Transaction tx :for toBroadcast))
        (ß
            (§ var ConfidenceType confidenceType = tx.getConfidence().getConfidenceType())
            (§ call Preconditions.checkState(confidenceType == ConfidenceType.PENDING || confidenceType == ConfidenceType.IN_CONFLICT, "Expected PENDING or IN_CONFLICT, was %s.", confidenceType))
            ;; Re-broadcast even if it's marked as already seen for two reasons:
            ;; 1. Old wallets may have transactions marked as broadcast by 1 peer when
            ;;    in reality the network never saw it, due to bugs.
            ;; 2. It can't really hurt.
            (§ call log.info("New broadcaster so uploading waiting tx {}", tx.getHash()))
            (§ call broadcaster.broadcastTransaction(tx))
        )
    )

    ;;;
     ; When a key rotation time is set, and money controlled by keys created before the given timestamp T will be
     ; automatically respent to any key that was created after T.  This can be used to recover from a situation where
     ; a set of keys is believed to be compromised.  Once the time is set transactions will be created and broadcast
     ; immediately.  New coins that come in after calling this method will be automatically respent immediately.
     ; The rotation time is persisted to the wallet. You can stop key rotation by calling this method again with zero
     ; as the argument.
     ;;
    #_public
    (§ method void setKeyRotationTime(Date time))
    (ß
        (§ call setKeyRotationTime(time.getTime() / 1000))
    )

    ;;;
     ; Returns the key rotation time, or null if unconfigured.
     ; See {@link #setKeyRotationTime(Date)} for a description of the field.
     ;;
    #_public
    #_nilable
    (§ method Date getKeyRotationTime())
    (ß
        #_final
        (§ var long keyRotationTimestamp = vKeyRotationTimestamp)
        (§ return (keyRotationTimestamp != 0) ? new Date(keyRotationTimestamp * 1000) :else nil)
    )

    ;;;
     ; <p>When a key rotation time is set, any money controlled by keys created before the given timestamp T will be
     ; automatically respent to any key that was created after T.  This can be used to recover from a situation where
     ; a set of keys is believed to be compromised.  You can stop key rotation by calling this method again with zero
     ; as the argument.  Once set up, calling {@link #doMaintenance(org.spongycastle.crypto.params.KeyParameter, boolean)}
     ; will create and possibly send rotation transactions: but it won't be done automatically (because you might have
     ; to ask for the users password).</p>
     ;
     ; <p>The given time cannot be in the future.</p>
     ;;
    #_public
    (§ method void setKeyRotationTime(long unixTimeSeconds))
    (ß
        (§ call Preconditions.checkArgument(unixTimeSeconds <= Utils.currentTimeSeconds(), "Given time (%s) cannot be in the future.", Utils.dateTimeFormat(unixTimeSeconds * 1000)))
        (§ ass vKeyRotationTimestamp = unixTimeSeconds)
        (§ call saveNow())
    )

    ;;; Returns whether the keys creation time is before the key rotation time, if one was set. ;;
    #_public
    (§ method boolean isKeyRotating(ECKey key))
    (ß
        (§ var long time = vKeyRotationTimestamp)
        (§ return (time != 0 && key.getCreationTimeSeconds() < time))
    )

    ;;;
     ; A wallet app should call this from time to time in order to let the wallet craft and send transactions needed
     ; to re-organise coins internally.  A good time to call this would be after receiving coins for an unencrypted
     ; wallet, or after sending money for an encrypted wallet.  If you have an encrypted wallet and just want to know
     ; if some maintenance needs doing, call this method with andSend set to false and look at the returned list of
     ; transactions.  Maintenance might also include internal changes that involve some processing or work but
     ; which don't require making transactions - these will happen automatically unless the password is required
     ; in which case an exception will be thrown.
     ;
     ; @param aesKey The users password, if any.
     ; @param signAndSend If true, send the transactions via the tx broadcaster and return them, if false just return them.
     ; @return a list of transactions that the wallet just made/will make for internal maintenance.  Might be empty.
     ; @throws org.bitcoinj.wallet.DeterministicUpgradeRequiresPassword if key rotation requires the users password.
     ;;
    #_public
    (§ method ListenableFuture<List<Transaction>> doMaintenance(#_nilable KeyParameter aesKey, boolean signAndSend))
        (§ throws DeterministicUpgradeRequiresPassword)
    (ß
        (§ var List<Transaction> txns)
        (§ call lock.lock())
        (§ call keyChainGroupLock.lock())
        (§ try)
        (ß
            (§ ass txns = maybeRotateKeys(aesKey, signAndSend))
            (§ if (!signAndSend))
                (§ return Futures.immediateFuture(txns))
        )
        (§ finally)
        (ß
            (§ call keyChainGroupLock.unlock())
            (§ call lock.unlock())
        )
        (§ call Preconditions.checkState(!lock.isHeldByCurrentThread()))
        (§ var ArrayList<ListenableFuture<Transaction>> futures = new ArrayList<>(txns.size()))
        (§ var TransactionBroadcaster broadcaster = vTransactionBroadcaster)
        (§ for (Transaction tx :for txns))
        (ß
            (§ try)
            (ß
                #_final
                (§ var ListenableFuture<Transaction> future = broadcaster.broadcastTransaction(tx).future())
                (§ call futures.add(future))
                (§ call Futures.addCallback(future, new FutureCallback<Transaction>()
                (ß
                    #_override
                    #_public
                    (§ method void onSuccess(Transaction transaction))
                    (ß
                        (§ call log.info("Successfully broadcast key rotation tx: {}", transaction))
                    )

                    #_override
                    #_public
                    (§ method void onFailure(Throwable throwable))
                    (ß
                        (§ call log.error("Failed to broadcast key rotation tx", throwable))
                    )
                )))
            )
            (§ catch (Exception e))
            (ß
                (§ call log.error("Failed to broadcast rekey tx", e))
            )
        )
        (§ return Futures.allAsList(futures))
    )

    ;; Checks to see if any coins are controlled by rotating keys and if so, spends them.
    #_guarded-by(ß "keyChainGroupLock")
    #_private
    (§ method List<Transaction> maybeRotateKeys(#_nilable KeyParameter aesKey, boolean sign))
        (§ throws DeterministicUpgradeRequiresPassword)
    (ß
        (§ call Preconditions.checkState(lock.isHeldByCurrentThread()))
        (§ call Preconditions.checkState(keyChainGroupLock.isHeldByCurrentThread()))

        (§ var List<Transaction> results = Lists.newLinkedList())
        ;; TODO: Handle chain replays here.
        #_final
        (§ var long keyRotationTimestamp = vKeyRotationTimestamp)
        (§ if (keyRotationTimestamp == 0))
            (§ return results) ;; Nothing to do.

        ;; We might have to create a new HD hierarchy if the previous ones are now rotating.
        (§ var boolean allChainsRotating = true)
        (§ for (DeterministicKeyChain chain :for keyChainGroup.getDeterministicKeyChains()))
        (ß
            (§ if (keyRotationTimestamp <= chain.getEarliestKeyCreationTime()))
            (ß
                (§ ass allChainsRotating = false)
                (§ break)
            )
        )
        (§ if (allChainsRotating))
        (ß
            (§ try)
            (ß
                (§ if (keyChainGroup.getImportedKeys().isEmpty()))
                (ß
                    (§ call log.info("All HD chains are currently rotating and we have no random keys, creating fresh HD chain ..."))
                    (§ call keyChainGroup.createAndActivateNewHDChain())
                )
                (§ else)
                (ß
                    (§ call log.info("All HD chains are currently rotating, attempting to create a new one from the next oldest non-rotating key material ..."))
                    (§ call keyChainGroup.upgradeToDeterministic(keyRotationTimestamp, aesKey))
                    (§ call log.info(" ... upgraded to HD again, based on next best oldest key."))
                )
            )
            (§ catch (AllRandomKeysRotating _))
            (ß
                (§ call log.info(" ... no non-rotating random keys available, generating entirely new HD tree: backup required after this."))
                (§ call keyChainGroup.createAndActivateNewHDChain())
            )
            (§ call saveNow())
        )

        ;; Because transactions are size limited, we might not be able to re-key the entire wallet in one go.  So loop
        ;; around here until we no longer produce transactions with the max number of inputs.  That means we're fully
        ;; done, at least for now (we may still get more transactions later and this method will be reinvoked).
        (§ var Transaction tx)
        (§ do)
        (ß
            (§ ass tx = rekeyOneBatch(keyRotationTimestamp, aesKey, results, sign))
            (§ if (tx != nil))
                (§ call results.add(tx))
        )
        (§ again (tx != nil && tx.getInputs().size() == KeyTimeCoinSelector.MAX_SIMULTANEOUS_INPUTS))

        (§ return results)
    )

    #_nilable
    #_private
    (§ method Transaction rekeyOneBatch(long timeSecs, #_nilable KeyParameter aesKey, List<Transaction> others, boolean sign))
    (ß
        (§ call lock.lock())
        (§ try)
        (ß
            ;; Build the transaction using some custom logic for our special needs.  Last parameter to
            ;; KeyTimeCoinSelector is whether to ignore pending transactions or not.
            ;;
            ;; We ignore pending outputs because trying to rotate these is basically racing an attacker, and
            ;; we're quite likely to lose and create stuck double spends.  Also, some users who have 0.9 wallets
            ;; have already got stuck double spends in their wallet due to the Bloom-filtering block reordering
            ;; bug that was fixed in 0.10, thus, making a re-key transaction depend on those would cause it to
            ;; never confirm at all.
            (§ var CoinSelector keyTimeSelector = new KeyTimeCoinSelector(this, timeSecs, true))
            (§ var FilteringCoinSelector selector = new FilteringCoinSelector(keyTimeSelector))
            (§ for (Transaction other :for others))
                (§ call selector.excludeOutputsSpentBy(other))
            ;; TODO: Make this use the standard SendRequest.
            (§ var CoinSelection toMove = selector.select(Coin.ZERO, calculateAllSpendCandidates()))
            (§ if (toMove.valueGathered.equals(Coin.ZERO)))
                (§ return nil) ;; Nothing to do.

            (§ call maybeUpgradeToHD(aesKey))
            (§ var Transaction rekeyTx = new Transaction(params))
            (§ for (TransactionOutput output :for toMove.gathered))
                (§ call rekeyTx.addInput(output))
            ;; When not signing, don't waste addresses.
            (§ call rekeyTx.addOutput(toMove.valueGathered, sign ? freshReceiveAddress() :else currentReceiveAddress()))
            (§ if (!adjustOutputDownwardsForFee(rekeyTx, toMove, Transaction.DEFAULT_TX_FEE, true)))
            (ß
                (§ call log.error("Failed to adjust rekey tx for fees."))
                (§ return nil)
            )

            (§ call rekeyTx.getConfidence().setSource(TransactionConfidence.Source.SELF))
            (§ call rekeyTx.setPurpose(Transaction.Purpose.KEY_ROTATION))
            (§ var SendRequest req = SendRequest.forTx(rekeyTx))
            (§ ass req.aesKey = aesKey)
            (§ if (sign))
                (§ call signTransaction(req))
            ;; KeyTimeCoinSelector should never select enough inputs to push us oversize.
            (§ call Preconditions.checkState(rekeyTx.unsafeBitcoinSerialize().length < Transaction.MAX_STANDARD_TX_SIZE))
            (§ return rekeyTx)
        )
        (§ catch (VerificationException e))
        (ß
            (§ throw new RuntimeException(e)) ;; Cannot happen.
        )
        (§ finally)
        (ß
            (§ call lock.unlock())
        )
    )
)

#_(ns org.bitcoinj.wallet #_"WalletFiles"
    (:import #_[java.io *]
             [java.util Date]
             #_[java.util.concurrent *]
             #_[java.util.concurrent.atomic *])
    (:import [com.google.common.base Preconditions Stopwatch]
             #_[org.slf4j *])
  #_(:require #_[org.bitcoinj.core *]
             #_[org.bitcoinj.utils *]))

;;;
 ; A class that handles atomic and optionally delayed writing of the wallet file to disk.  In future: backups too.
 ; It can be useful to delay writing of a wallet file to disk on slow devices where disk and serialization overhead
 ; can come to dominate the chain processing speed, i.e. on Android phones.  By coalescing writes and doing
 ; serialization and disk IO on a background thread performance can be improved.
 ;;
#_public
(§ class WalletFiles
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(WalletFiles.class))

    #_private
    #_final
    (§ field Wallet wallet)
    #_private
    #_final
    (§ field ScheduledThreadPoolExecutor executor)
    #_private
    #_final
    (§ field File file)
    #_private
    #_final
    (§ field AtomicBoolean savePending)
    #_private
    #_final
    (§ field long delay)
    #_private
    #_final
    (§ field TimeUnit delayTimeUnit)
    #_private
    #_final
    (§ field Callable<Void> saver)

    #_private
    #_volatile
    (§ field Listener vListener)

    ;;;
     ; Implementors can do pre/post treatment of the wallet file.  Useful for adjusting permissions and other things.
     ;;
    #_public
    (§ interface Listener
        ;;;
         ; Called on the auto-save thread when a new temporary file is created but before the wallet data is saved
         ; to it.  If you want to do something here like adjust permissions, go ahead and do so.
         ;;
        (§ method void onBeforeAutoSave(File tempFile))

        ;;;
         ; Called on the auto-save thread after the newly created temporary file has been filled with data and renamed.
         ;;
        (§ method void onAfterAutoSave(File newlySavedFile))
    )

    ;;;
     ; Initialize atomic and optionally delayed writing of the wallet file to disk.  Note the initial wallet state isn't
     ; saved automatically.  The {@link Wallet} calls {@link #saveNow()} or {@link #saveLater()} as wallet state changes,
     ; depending on the urgency of the changes.
     ;;
    #_public
    (§ constructor WalletFiles(#_final Wallet wallet, File file, long delay, TimeUnit delayTimeUnit))
    (ß
        ;; An executor that starts up threads when needed and shuts them down later.
        (§ ass this.executor = new ScheduledThreadPoolExecutor(1, new ContextPropagatingThreadFactory("Wallet autosave thread", Thread.MIN_PRIORITY)))
        (§ call this.executor.setKeepAliveTime(5, TimeUnit.SECONDS))
        (§ call this.executor.allowCoreThreadTimeOut(true))
        (§ call this.executor.setExecuteExistingDelayedTasksAfterShutdownPolicy(false))
        (§ ass this.wallet = Preconditions.checkNotNull(wallet))
        ;; File must only be accessed from the auto-save executor from now on, to avoid simultaneous access.
        (§ ass this.file = Preconditions.checkNotNull(file))
        (§ ass this.savePending = new AtomicBoolean())
        (§ ass this.delay = delay)
        (§ ass this.delayTimeUnit = Preconditions.checkNotNull(delayTimeUnit))

        (§ ass this.saver = new Callable<Void>()
        (ß
            #_override
            #_public
            (§ method Void call())
                (§ throws Exception)
            (ß
                ;; Runs in an auto save thread.
                (§ if (!savePending.getAndSet(false)))
                (ß
                    ;; Some other scheduled request already beat us to it.
                    (§ return nil)
                )
                (§ var Date lastBlockSeenTime = wallet.getLastBlockSeenTime())
                (§ call log.info("Background saving wallet; last seen block is height {}, date {}, hash {}", wallet.getLastBlockSeenHeight(), (lastBlockSeenTime != nil) ? Utils.dateTimeFormat(lastBlockSeenTime) :else "unknown", wallet.getLastBlockSeenHash()))
                (§ call saveNowInternal())
                (§ return nil)
            )
        ))
    )

    ;;;
     ; The given listener will be called on the autosave thread before and after the wallet is saved to disk.
     ;;
    #_public
    (§ method void setListener(#_non-nil Listener listener))
    (ß
        (§ ass this.vListener = Preconditions.checkNotNull(listener))
    )

    ;;; Actually write the wallet file to disk, using an atomic rename when possible.  Runs on the current thread. ;;
    #_public
    (§ method void saveNow())
        (§ throws IOException)
    (ß
        ;; Can be called by any thread. However the wallet is locked whilst saving, so we can have two saves
        ;; in flight, but they will serialize (using different temp files).
        (§ var Date lastBlockSeenTime = wallet.getLastBlockSeenTime())
        (§ call log.info("Saving wallet; last seen block is height {}, date {}, hash {}", wallet.getLastBlockSeenHeight(), (lastBlockSeenTime != nil) ? Utils.dateTimeFormat(lastBlockSeenTime) :else "unknown", wallet.getLastBlockSeenHash()))
        (§ call saveNowInternal())
    )

    #_private
    (§ method void saveNowInternal())
        (§ throws IOException)
    (ß
        #_final
        (§ var Stopwatch watch = Stopwatch.createStarted())
        (§ var File directory = file.getAbsoluteFile().getParentFile())
        (§ var File temp = File.createTempFile("wallet", nil, directory))
        #_final
        (§ var Listener listener = vListener)
        (§ if (listener != nil))
            (§ call listener.onBeforeAutoSave(temp))
        (§ call wallet.saveToFile(temp, file))
        (§ if (listener != nil))
            (§ call listener.onAfterAutoSave(file))
        (§ call watch.stop())
        (§ call log.info("Save completed in {}", watch))
    )

    ;;; Queues up a save in the background.  Useful for not very important wallet changes. ;;
    #_public
    (§ method void saveLater())
    (ß
        (§ if (savePending.getAndSet(true)))
            (§ return) ;; Already pending.

        (§ call executor.schedule(saver, delay, delayTimeUnit))
    )

    ;;; Shut down auto-saving. ;;
    #_public
    (§ method void shutdownAndWait())
    (ß
        (§ call executor.shutdown())
        (§ try)
        (ß
            (§ call executor.awaitTermination(Long.MAX_VALUE, TimeUnit.DAYS)) ;; forever
        )
        (§ catch (InterruptedException e))
        (ß
            (§ throw new RuntimeException(e))
        )
    )
)

#_(ns org.bitcoinj.wallet #_"WalletProtobufSerializer"
    (:import [java.io IOException InputStream OutputStream]
             [java.math BigInteger]
             [java.net InetAddress UnknownHostException]
             #_[java.util *])
    (:import [com.google.common.base Preconditions]
             [com.google.common.collect Lists]
             [com.google.protobuf ByteString CodedInputStream CodedOutputStream TextFormat WireFormat]
             [org.slf4j Logger LoggerFactory])
  #_(:require #_[org.bitcoinj.core *]
             [org.bitcoinj.core.TransactionConfidence ConfidenceType]
             [org.bitcoinj.crypto KeyCrypter KeyCrypterScrypt]
             [org.bitcoinj.script Script]
             [org.bitcoinj.signers LocalTransactionSigner TransactionSigner]
             [org.bitcoinj.utils ExchangeRate Fiat]
             [org.bitcoinj.wallet.Protos.Wallet EncryptionType]))

;;;
 ; Serialize and de-serialize a wallet to a byte stream containing a
 ; <a href="https://developers.google.com/protocol-buffers/docs/overview">protocol buffer</a>.  Protocol buffers are
 ; a data interchange format developed by Google with an efficient binary representation, a type safe specification
 ; language and compilers that generate code to work with those data structures for many languages.  Protocol buffers
 ; can have their format evolved over time: conceptually they represent data using (tag, length, value) tuples.  The
 ; format is defined by the <tt>wallet.proto</tt> file in the bitcoinj source distribution.
 ;
 ; This class is used through its static methods.  The most common operations are writeWallet and readWallet, which do
 ; the obvious operations on Output/InputStreams.  You can use a {@link java.io.ByteArrayInputStream} and equivalent
 ; {@link java.io.ByteArrayOutputStream} if you'd like byte arrays instead.  The protocol buffer can also be manipulated
 ; in its object form if you'd like to modify the flattened data structure before serialization to binary.
 ;
 ; You can extend the wallet format with additional fields specific to your application if you want, but make sure
 ; to either put the extra data in the provided extension areas, or select tag numbers that are unlikely to be used
 ; by anyone else.
 ;
 ; @author Miron Cuperman
 ; @author Andreas Schildbach
 ;;
#_public
(§ class WalletProtobufSerializer
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(WalletProtobufSerializer.class))

    ;;; Current version used for serializing wallets.  A version higher than this is considered from the future. ;;
    #_public
    #_static
    #_final
    (§ field int CURRENT_WALLET_VERSION = Protos.Wallet.getDefaultInstance().getVersion())
    ;; 512 MB
    #_private
    #_static
    #_final
    (§ field int WALLET_SIZE_LIMIT = 512 * 1024 * 1024)
    ;; Used for de-serialization.
    #_protected
    (§ field Map<ByteString, Transaction> txMap)

    #_private
    (§ field int walletWriteBufferSize = CodedOutputStream.DEFAULT_BUFFER_SIZE)

    #_public
    (§ interface WalletFactory
        (§ method Wallet create(NetworkParameters params, KeyChainGroup keyChainGroup))
    )

    #_private
    #_final
    (§ field WalletFactory factory)
    #_private
    (§ field KeyChainFactory keyChainFactory)

    #_public
    (§ constructor WalletProtobufSerializer())
    (ß
        (§ this (new WalletFactory()
        (ß
            #_override
            #_public
            (§ method Wallet create(NetworkParameters params, KeyChainGroup keyChainGroup))
            (ß
                (§ return new Wallet(params, keyChainGroup))
            )
        )))
    )

    #_public
    (§ constructor WalletProtobufSerializer(WalletFactory factory))
    (ß
        (§ ass txMap = new HashMap<>())
        (§ ass this.factory = factory)
        (§ ass this.keyChainFactory = new DefaultKeyChainFactory())
    )

    #_public
    (§ method void setKeyChainFactory(KeyChainFactory keyChainFactory))
    (ß
        (§ ass this.keyChainFactory = keyChainFactory)
    )

    ;;;
     ; Change buffer size for writing wallet to output stream.
     ; Default is {@link com.google.protobuf.CodedOutputStream.DEFAULT_BUFFER_SIZE}.
     ; @param walletWriteBufferSize Buffer size in bytes.
     ;;
    #_public
    (§ method void setWalletWriteBufferSize(int walletWriteBufferSize))
    (ß
        (§ ass this.walletWriteBufferSize = walletWriteBufferSize)
    )

    ;;;
     ; Formats the given wallet (transactions and keys) to the given output stream in protocol buffer format.
     ;
     ; Equivalent to <tt>walletToProto(wallet).writeTo(output)</tt>.
     ;;
    #_public
    (§ method void writeWallet(Wallet wallet, OutputStream output))
        (§ throws IOException)
    (ß
        (§ var Protos.Wallet walletProto = walletToProto(wallet))
        #_final
        (§ var CodedOutputStream codedOutput = CodedOutputStream.newInstance(output, this.walletWriteBufferSize))
        (§ call walletProto.writeTo(codedOutput))
        (§ call codedOutput.flush())
    )

    ;;;
     ; Returns the given wallet formatted as text.  The text format is that used by protocol buffers and although
     ; it can also be parsed using {@link TextFormat#merge(CharSequence, com.google.protobuf.Message.Builder)},
     ; it is designed more for debugging than storage.  It is not well specified and wallets are largely binary data
     ; structures anyway, consisting as they do of keys (large random numbers) and {@link Transaction}s which also
     ; mostly contain keys and hashes.
     ;;
    #_public
    (§ method String walletToText(Wallet wallet))
    (ß
        (§ var Protos.Wallet walletProto = walletToProto(wallet))
        (§ return TextFormat.printToString(walletProto))
    )

    ;;;
     ; Converts the given wallet to the object representation of the protocol buffers.  This can be modified, or
     ; additional data fields set, before serialization takes place.
     ;;
    #_public
    (§ method Protos.Wallet walletToProto(Wallet wallet))
    (ß
        (§ var Protos.Wallet.Builder walletBuilder = Protos.Wallet.newBuilder())
        (§ call walletBuilder.setNetworkIdentifier(wallet.getNetworkParameters().getId()))
        (§ if (wallet.getDescription() != nil))
            (§ call walletBuilder.setDescription(wallet.getDescription()))

        (§ for (WalletTransaction wtx :for wallet.getWalletTransactions()))
        (ß
            (§ var Protos.Transaction txProto = makeTxProto(wtx))
            (§ call walletBuilder.addTransaction(txProto))
        )

        (§ call walletBuilder.addAllKey(wallet.serializeKeyChainGroupToProtobuf()))

        ;; Populate the lastSeenBlockHash field.
        (§ var Sha256Hash lastSeenBlockHash = wallet.getLastBlockSeenHash())
        (§ if (lastSeenBlockHash != nil))
        (ß
            (§ call walletBuilder.setLastSeenBlockHash(hashToByteString(lastSeenBlockHash)))
            (§ call walletBuilder.setLastSeenBlockHeight(wallet.getLastBlockSeenHeight()))
        )
        (§ if (0 < wallet.getLastBlockSeenTimeSecs()))
            (§ call walletBuilder.setLastSeenBlockTimeSecs(wallet.getLastBlockSeenTimeSecs()))

        ;; Populate the scrypt parameters.
        (§ var KeyCrypter keyCrypter = wallet.getKeyCrypter())
        (§ if (keyCrypter == nil))
        (ß
            ;; The wallet is unencrypted.
            (§ call walletBuilder.setEncryptionType(EncryptionType.UNENCRYPTED))
        )
        (§ else)
        (ß
            ;; The wallet is encrypted.
            (§ call walletBuilder.setEncryptionType(keyCrypter.getUnderstoodEncryptionType()))
            (§ if (keyCrypter instanceof KeyCrypterScrypt))
            (ß
                (§ var KeyCrypterScrypt keyCrypterScrypt = (KeyCrypterScrypt)keyCrypter)
                (§ call walletBuilder.setEncryptionParameters(keyCrypterScrypt.getScryptParameters()))
            )
            (§ else)
            (ß
                ;; Some other form of encryption has been specified that we do not know how to persist.
                (§ throw new RuntimeException("The wallet has encryption of type '" + keyCrypter.getUnderstoodEncryptionType() + "' but this WalletProtobufSerializer does not know how to persist this."))
            )
        )

        (§ if (wallet.getKeyRotationTime() != nil))
        (ß
            (§ var long timeSecs = wallet.getKeyRotationTime().getTime() / 1000)
            (§ call walletBuilder.setKeyRotationTime(timeSecs))
        )

        (§ for (TransactionSigner signer :for wallet.getTransactionSigners()))
        (ß
            ;; Do not serialize LocalTransactionSigner as it's being added implicitly.
            (§ if (signer instanceof LocalTransactionSigner))
                (§ continue)

            (§ var Protos.TransactionSigner.Builder protoSigner = Protos.TransactionSigner.newBuilder())
            (§ call protoSigner.setClassName(signer.getClass().getName()))
            (§ call protoSigner.setData(ByteString.copyFrom(signer.serialize())))
            (§ call walletBuilder.addTransactionSigners(protoSigner))
        )

        ;; Populate the wallet version.
        (§ call walletBuilder.setVersion(wallet.getVersion()))

        (§ return walletBuilder.build())
    )

    #_private
    #_static
    (§ method Protos.Transaction makeTxProto(WalletTransaction wtx))
    (ß
        (§ var Transaction tx = wtx.getTransaction())
        (§ var Protos.Transaction.Builder txBuilder = Protos.Transaction.newBuilder())

        (§ call txBuilder.setPool(getProtoPool(wtx)).setHash(hashToByteString(tx.getHash())).setVersion((int)tx.getVersion()))

        (§ if (tx.getUpdateTime() != nil))
            (§ call txBuilder.setUpdatedAt(tx.getUpdateTime().getTime()))

        (§ if (0 < tx.getLockTime()))
            (§ call txBuilder.setLockTime((int)tx.getLockTime()))

        ;; Handle inputs.
        (§ for (TransactionInput input :for tx.getInputs()))
        (ß
            (§ var Protos.TransactionInput.Builder inputBuilder = Protos.TransactionInput.newBuilder().setScriptBytes(ByteString.copyFrom(input.getScriptBytes())).setTransactionOutPointHash(hashToByteString(input.getOutpoint().getHash())).setTransactionOutPointIndex((int)input.getOutpoint().getIndex()))
            (§ if (input.hasSequence()))
                (§ call inputBuilder.setSequence((int)input.getSequenceNumber()))
            (§ if (input.getValue() != nil))
                (§ call inputBuilder.setValue(input.getValue().value))
            (§ call txBuilder.addTransactionInput(inputBuilder))
        )

        ;; Handle outputs.
        (§ for (TransactionOutput output :for tx.getOutputs()))
        (ß
            (§ var Protos.TransactionOutput.Builder outputBuilder = Protos.TransactionOutput.newBuilder().setScriptBytes(ByteString.copyFrom(output.getScriptBytes())).setValue(output.getValue().value))
            #_final
            (§ var TransactionInput spentBy = output.getSpentBy())
            (§ if (spentBy != nil))
            (ß
                (§ var Sha256Hash spendingHash = spentBy.getParentTransaction().getHash())
                (§ var int spentByTransactionIndex = spentBy.getParentTransaction().getInputs().indexOf(spentBy))
                (§ call outputBuilder.setSpentByTransactionHash(hashToByteString(spendingHash)).setSpentByTransactionIndex(spentByTransactionIndex))
            )
            (§ call txBuilder.addTransactionOutput(outputBuilder))
        )

        ;; Handle which blocks tx was seen in.
        #_final
        (§ var Map<Sha256Hash, Integer> appearsInHashes = tx.getAppearsInHashes())
        (§ if (appearsInHashes != nil))
        (ß
            (§ for (Map.Entry<Sha256Hash, Integer> entry :for appearsInHashes.entrySet()))
            (ß
                (§ call txBuilder.addBlockHash(hashToByteString(entry.getKey())))
                (§ call txBuilder.addBlockRelativityOffsets(entry.getValue()))
            )
        )

        (§ if (tx.hasConfidence()))
        (ß
            (§ var TransactionConfidence confidence = tx.getConfidence())
            (§ var Protos.TransactionConfidence.Builder confidenceBuilder = Protos.TransactionConfidence.newBuilder())
            (§ call writeConfidence(txBuilder, confidence, confidenceBuilder))
        )

        (§ var Protos.Transaction.Purpose purpose)
        (§ switch (tx.getPurpose()))
        (ß
            (§ case UNKNOWN)
                (§ ass purpose = Protos.Transaction.Purpose.UNKNOWN)
                (§ break)
            (§ case USER_PAYMENT)
                (§ ass purpose = Protos.Transaction.Purpose.USER_PAYMENT)
                (§ break)
            (§ case KEY_ROTATION)
                (§ ass purpose = Protos.Transaction.Purpose.KEY_ROTATION)
                (§ break)
            (§ case ASSURANCE_CONTRACT_CLAIM)
                (§ ass purpose = Protos.Transaction.Purpose.ASSURANCE_CONTRACT_CLAIM)
                (§ break)
            (§ case ASSURANCE_CONTRACT_PLEDGE)
                (§ ass purpose = Protos.Transaction.Purpose.ASSURANCE_CONTRACT_PLEDGE)
                (§ break)
            (§ case ASSURANCE_CONTRACT_STUB)
                (§ ass purpose = Protos.Transaction.Purpose.ASSURANCE_CONTRACT_STUB)
                (§ break)
            (§ case RAISE_FEE)
                (§ ass purpose = Protos.Transaction.Purpose.RAISE_FEE)
                (§ break)
            (§ default)
                (§ throw new RuntimeException("New tx purpose serialization not implemented."))
        )
        (§ call txBuilder.setPurpose(purpose))

        (§ var ExchangeRate exchangeRate = tx.getExchangeRate())
        (§ if (exchangeRate != nil))
        (ß
            (§ var Protos.ExchangeRate.Builder exchangeRateBuilder = Protos.ExchangeRate.newBuilder().setCoinValue(exchangeRate.coin.value).setFiatValue(exchangeRate.fiat.value).setFiatCurrencyCode(exchangeRate.fiat.currencyCode))
            (§ call txBuilder.setExchangeRate(exchangeRateBuilder))
        )

        (§ if (tx.getMemo() != nil))
            (§ call txBuilder.setMemo(tx.getMemo()))

        (§ return txBuilder.build())
    )

    #_private
    #_static
    (§ method Protos.Transaction.Pool getProtoPool(WalletTransaction wtx))
    (ß
        (§ switch (wtx.getPool()))
        (ß
            (§ case UNSPENT)
                (§ return Protos.Transaction.Pool.UNSPENT)
            (§ case SPENT)
                (§ return Protos.Transaction.Pool.SPENT)
            (§ case DEAD)
                (§ return Protos.Transaction.Pool.DEAD)
            (§ case PENDING)
                (§ return Protos.Transaction.Pool.PENDING)
            (§ default)
                (§ throw new RuntimeException("Unreachable"))
        )
    )

    #_private
    #_static
    (§ method void writeConfidence(Protos.Transaction.Builder txBuilder, TransactionConfidence confidence, Protos.TransactionConfidence.Builder confidenceBuilder))
    (ß
        (§ sync confidence)
        (ß
            (§ call confidenceBuilder.setType(Protos.TransactionConfidence.Type.valueOf(confidence.getConfidenceType().getValue())))
            (§ if (confidence.getConfidenceType() == ConfidenceType.BUILDING))
            (ß
                (§ call confidenceBuilder.setAppearedAtHeight(confidence.getAppearedAtChainHeight()))
                (§ call confidenceBuilder.setDepth(confidence.getDepthInBlocks()))
            )
            (§ if (confidence.getConfidenceType() == ConfidenceType.DEAD))
            (ß
                ;; Copy in the overriding transaction, if available.
                ;; (A dead coinbase transaction has no overriding transaction).
                (§ if (confidence.getOverridingTransaction() != nil))
                (ß
                    (§ var Sha256Hash overridingHash = confidence.getOverridingTransaction().getHash())
                    (§ call confidenceBuilder.setOverridingTransaction(hashToByteString(overridingHash)))
                )
            )
            (§ var TransactionConfidence.Source source = confidence.getSource())
            (§ switch (source))
            (ß
                (§ case SELF)
                    (§ call confidenceBuilder.setSource(Protos.TransactionConfidence.Source.SOURCE_SELF))
                    (§ break)
                (§ case NETWORK)
                    (§ call confidenceBuilder.setSource(Protos.TransactionConfidence.Source.SOURCE_NETWORK))
                    (§ break)
                (§ case UNKNOWN)
                    ;; Fall through.
                (§ default)
                    (§ call confidenceBuilder.setSource(Protos.TransactionConfidence.Source.SOURCE_UNKNOWN))
                    (§ break)
            )
        )

        (§ for (PeerAddress address :for confidence.getBroadcastBy()))
        (ß
            (§ var Protos.PeerAddress proto = Protos.PeerAddress.newBuilder().setIpAddress(ByteString.copyFrom(address.getAddr().getAddress())).setPort(address.getPort()).setServices(address.getServices().longValue()).build())
            (§ call confidenceBuilder.addBroadcastBy(proto))
        )
        (§ var Date lastBroadcastedAt = confidence.getLastBroadcastedAt())
        (§ if (lastBroadcastedAt != nil))
            (§ call confidenceBuilder.setLastBroadcastedAt(lastBroadcastedAt.getTime()))
        (§ call txBuilder.setConfidence(confidenceBuilder))
    )

    #_public
    #_static
    (§ method ByteString hashToByteString(Sha256Hash hash))
    (ß
        (§ return ByteString.copyFrom(hash.getBytes()))
    )

    #_public
    #_static
    (§ method Sha256Hash byteStringToHash(ByteString bs))
    (ß
        (§ return Sha256Hash.wrap(bs.toByteArray()))
    )

    ;;;
     ; <p>Loads wallet data from the given protocol buffer and inserts it into the given Wallet object.
     ; This is primarily useful when you wish to pre-register extension objects.  Note that if loading
     ; fails the provided Wallet object may be in an indeterminate state and should be thrown away.</p>
     ;
     ; <p>A wallet can be unreadable for various reasons, such as inability to open the file, corrupt data,
     ; internally inconsistent data and so on.  You should always handle
     ; {@link UnreadableWalletException} and communicate failure to the user in an appropriate manner.</p>
     ;
     ; @throws UnreadableWalletException in various error conditions (see description).
     ;;
    #_public
    (§ method Wallet readWallet(InputStream input))
        (§ throws UnreadableWalletException)
    (ß
        (§ return readWallet(input, false))
    )

    ;;;
     ; <p>Loads wallet data from the given protocol buffer and inserts it into the given Wallet object.
     ; This is primarily useful when you wish to pre-register extension objects.  Note that if loading
     ; fails the provided Wallet object may be in an indeterminate state and should be thrown away.  Do not
     ; simply call this method again on the same Wallet object with {@code forceReset} set {@code true}.
     ; It won't work.</p>
     ;
     ; <p>If {@code forceReset} is {@code true}, then no transactions are loaded from the wallet, and
     ; it is configured to replay transactions from the blockchain (as if the wallet had been loaded and
     ; {@link Wallet.reset} had been called immediately thereafter).
     ;
     ; <p>A wallet can be unreadable for various reasons, such as inability to open the file, corrupt data,
     ; internally inconsistent data and so on. You should always handle
     ; {@link UnreadableWalletException} and communicate failure to the user in an appropriate manner.</p>
     ;
     ; @throws UnreadableWalletException in various error conditions (see description).
     ;;
    #_public
    (§ method Wallet readWallet(InputStream input, boolean forceReset))
        (§ throws UnreadableWalletException)
    (ß
        (§ try)
        (ß
            (§ var Protos.Wallet walletProto = parseToProto(input))
            #_final
            (§ var String paramsID = walletProto.getNetworkIdentifier())
            (§ var NetworkParameters params = NetworkParameters.fromID(paramsID))
            (§ if (params == nil))
                (§ throw new UnreadableWalletException("Unknown network parameters ID " + paramsID))

            (§ return readWallet(params, walletProto, forceReset))
        )
        (§ catch (IOException e))
        (ß
            (§ throw new UnreadableWalletException("Could not parse input stream to protobuf", e))
        )
        (§ catch (IllegalStateException e))
        (ß
            (§ throw new UnreadableWalletException("Could not parse input stream to protobuf", e))
        )
        (§ catch (IllegalArgumentException e))
        (ß
            (§ throw new UnreadableWalletException("Could not parse input stream to protobuf", e))
        )
    )

    ;;;
     ; <p>Loads wallet data from the given protocol buffer and inserts it into the given Wallet object.
     ; This is primarily useful when you wish to pre-register extension objects.  Note that if loading
     ; fails, the provided Wallet object may be in an indeterminate state and should be thrown away.</p>
     ;
     ; <p>A wallet can be unreadable for various reasons, such as inability to open the file, corrupt
     ; data, internally inconsistent data and so on.  You should always handle
     ; {@link UnreadableWalletException} and communicate failure to the user in an appropriate manner.</p>
     ;
     ; @throws UnreadableWalletException in various error conditions (see description).
     ;;
    #_public
    (§ method Wallet readWallet(NetworkParameters params, Protos.Wallet walletProto))
        (§ throws UnreadableWalletException)
    (ß
        (§ return readWallet(params, walletProto, false))
    )

    ;;;
     ; <p>Loads wallet data from the given protocol buffer and inserts it into the given Wallet object.
     ; This is primarily useful when you wish to pre-register extension objects.  Note that if loading
     ; fails, the provided Wallet object may be in an indeterminate state and should be thrown away.  Do not
     ; simply call this method again on the same Wallet object with {@code forceReset} set {@code true}.
     ; It won't work.</p>
     ;
     ; <p>If {@code forceReset} is {@code true}, then no transactions are loaded from the wallet, and it is
     ; configured to replay transactions from the blockchain (as if the wallet had been loaded and
     ; {@link Wallet.reset} had been called immediately thereafter).
     ;
     ; <p>A wallet can be unreadable for various reasons, such as inability to open the file, corrupt data,
     ; internally inconsistent data and so on.  You should always handle
     ; {@link UnreadableWalletException} and communicate failure to the user in an appropriate manner.</p>
     ;
     ; @throws UnreadableWalletException in various error conditions (see description).
     ;;
    #_public
    (§ method Wallet readWallet(NetworkParameters params, Protos.Wallet walletProto, boolean forceReset))
        (§ throws UnreadableWalletException)
    (ß
        (§ if (CURRENT_WALLET_VERSION < walletProto.getVersion()))
            (§ throw new UnreadableWalletException.FutureVersion())
        (§ if (!walletProto.getNetworkIdentifier().equals(params.getId())))
            (§ throw new UnreadableWalletException.WrongNetwork())

        ;; Read the scrypt parameters that specify how encryption and decryption is performed.
        (§ var KeyChainGroup keyChainGroup)
        (§ if (walletProto.hasEncryptionParameters()))
        (ß
            (§ var Protos.ScryptParameters encryptionParameters = walletProto.getEncryptionParameters())
            #_final
            (§ var KeyCrypterScrypt keyCrypter = new KeyCrypterScrypt(encryptionParameters))
            (§ ass keyChainGroup = KeyChainGroup.fromProtobufEncrypted(params, walletProto.getKeyList(), keyCrypter, keyChainFactory))
        )
        (§ else)
        (ß
            (§ ass keyChainGroup = KeyChainGroup.fromProtobufUnencrypted(params, walletProto.getKeyList(), keyChainFactory))
        )

        (§ var Wallet wallet = factory.create(params, keyChainGroup))
        (§ if (walletProto.hasDescription()))
            (§ call wallet.setDescription(walletProto.getDescription()))

        (§ if (forceReset))
        (ß
            ;; Should mirror Wallet.reset().
            (§ call wallet.setLastBlockSeenHash(nil))
            (§ call wallet.setLastBlockSeenHeight(-1))
            (§ call wallet.setLastBlockSeenTimeSecs(0))
        )
        (§ else)
        (ß
            ;; Read all transactions and insert into the txMap.
            (§ for (Protos.Transaction txProto :for walletProto.getTransactionList()))
                (§ call readTransaction(txProto, wallet.getParams()))

            ;; Update transaction outputs to point to inputs that spend them.
            (§ for (Protos.Transaction txProto :for walletProto.getTransactionList()))
            (ß
                (§ var WalletTransaction wtx = connectTransactionOutputs(params, txProto))
                (§ call wallet.addWalletTransaction(wtx))
            )

            ;; Update the lastBlockSeenHash.
            (§ if (!walletProto.hasLastSeenBlockHash()))
                (§ call wallet.setLastBlockSeenHash(nil))
            (§ else)
                (§ call wallet.setLastBlockSeenHash(byteStringToHash(walletProto.getLastSeenBlockHash())))

            (§ if (!walletProto.hasLastSeenBlockHeight()))
                (§ call wallet.setLastBlockSeenHeight(-1))
            (§ else)
                (§ call wallet.setLastBlockSeenHeight(walletProto.getLastSeenBlockHeight()))

            ;; Will default to zero if not present.
            (§ call wallet.setLastBlockSeenTimeSecs(walletProto.getLastSeenBlockTimeSecs()))

            (§ if (walletProto.hasKeyRotationTime()))
                (§ call wallet.setKeyRotationTime(new Date(walletProto.getKeyRotationTime() * 1000)))
        )

        (§ for (Protos.TransactionSigner signerProto :for walletProto.getTransactionSignersList()))
        (ß
            (§ try)
            (ß
                (§ var Class signerClass = Class.forName(signerProto.getClassName()))
                (§ var TransactionSigner signer = (TransactionSigner)signerClass.newInstance())
                (§ call signer.deserialize(signerProto.getData().toByteArray()))
                (§ call wallet.addTransactionSigner(signer))
            )
            (§ catch (Exception e))
            (ß
                (§ throw new UnreadableWalletException("Unable to deserialize TransactionSigner instance: " + signerProto.getClassName(), e))
            )
        )

        (§ if (walletProto.hasVersion()))
            (§ call wallet.setVersion(walletProto.getVersion()))

        ;; Make sure the object can be re-used to read another wallet without corruption.
        (§ call txMap.clear())

        (§ return wallet)
    )

    ;;;
     ; Returns the loaded protocol buffer from the given byte stream.  You normally want
     ; {@link Wallet#loadFromFile(java.io.File)} instead - this method is designed for
     ; low level work involving the wallet file format itself.
     ;;
    #_public
    #_static
    (§ method Protos.Wallet parseToProto(InputStream input))
        (§ throws IOException)
    (ß
        (§ var CodedInputStream codedInput = CodedInputStream.newInstance(input))
        (§ call codedInput.setSizeLimit(WALLET_SIZE_LIMIT))
        (§ return Protos.Wallet.parseFrom(codedInput))
    )

    #_private
    (§ method void readTransaction(Protos.Transaction txProto, NetworkParameters params))
        (§ throws UnreadableWalletException)
    (ß
        (§ var Transaction tx = new Transaction(params))

        (§ call tx.setVersion(txProto.getVersion()))

        (§ if (txProto.hasUpdatedAt()))
            (§ call tx.setUpdateTime(new Date(txProto.getUpdatedAt())))

        (§ for (Protos.TransactionOutput outputProto :for txProto.getTransactionOutputList()))
        (ß
            (§ var Coin value = Coin.valueOf(outputProto.getValue()))
            (§ var byte[] scriptBytes = outputProto.getScriptBytes().toByteArray())
            (§ var TransactionOutput output = new TransactionOutput(params, tx, value, scriptBytes))
            (§ call tx.addOutput(output))
        )

        (§ for (Protos.TransactionInput inputProto :for txProto.getTransactionInputList()))
        (ß
            (§ var byte[] scriptBytes = inputProto.getScriptBytes().toByteArray())
            (§ var TransactionOutPoint outpoint = new TransactionOutPoint(params, inputProto.getTransactionOutPointIndex() & 0xffffffff, byteStringToHash(inputProto.getTransactionOutPointHash())))
            (§ var Coin value = inputProto.hasValue() ? Coin.valueOf(inputProto.getValue()) :else nil)
            (§ var TransactionInput input = new TransactionInput(params, tx, scriptBytes, outpoint, value))
            (§ if (inputProto.hasSequence()))
                (§ call input.setSequenceNumber(0xffffffff & inputProto.getSequence()))
            (§ call tx.addInput(input))
        )

        (§ for (int i = 0 :for i < txProto.getBlockHashCount() :for i = i + 1))
        (ß
            (§ var ByteString blockHash = txProto.getBlockHash(i))
            (§ var int relativityOffset = 0)
            (§ if (0 < txProto.getBlockRelativityOffsetsCount()))
                (§ ass relativityOffset = txProto.getBlockRelativityOffsets(i))
            (§ call tx.addBlockAppearance(byteStringToHash(blockHash), relativityOffset))
        )

        (§ if (txProto.hasLockTime()))
            (§ call tx.setLockTime(0xffffffff & txProto.getLockTime()))

        (§ if (txProto.hasPurpose()))
        (ß
            (§ switch (txProto.getPurpose()))
            (ß
                (§ case UNKNOWN)
                    (§ call tx.setPurpose(Transaction.Purpose.UNKNOWN))
                    (§ break)
                (§ case USER_PAYMENT)
                    (§ call tx.setPurpose(Transaction.Purpose.USER_PAYMENT))
                    (§ break)
                (§ case KEY_ROTATION)
                    (§ call tx.setPurpose(Transaction.Purpose.KEY_ROTATION))
                    (§ break)
                (§ case ASSURANCE_CONTRACT_CLAIM)
                    (§ call tx.setPurpose(Transaction.Purpose.ASSURANCE_CONTRACT_CLAIM))
                    (§ break)
                (§ case ASSURANCE_CONTRACT_PLEDGE)
                    (§ call tx.setPurpose(Transaction.Purpose.ASSURANCE_CONTRACT_PLEDGE))
                    (§ break)
                (§ case ASSURANCE_CONTRACT_STUB)
                    (§ call tx.setPurpose(Transaction.Purpose.ASSURANCE_CONTRACT_STUB))
                    (§ break)
                (§ case RAISE_FEE)
                    (§ call tx.setPurpose(Transaction.Purpose.RAISE_FEE))
                    (§ break)
                (§ default)
                    (§ throw new RuntimeException("New purpose serialization not implemented"))
            )
        )
        (§ else)
        (ß
            ;; Old wallet: assume a user payment as that's the only reason a new tx would have been created back then.
            (§ call tx.setPurpose(Transaction.Purpose.USER_PAYMENT))
        )

        (§ if (txProto.hasExchangeRate()))
        (ß
            (§ var Protos.ExchangeRate exchangeRateProto = txProto.getExchangeRate())
            (§ call tx.setExchangeRate(new ExchangeRate(Coin.valueOf(exchangeRateProto.getCoinValue()), Fiat.valueOf(exchangeRateProto.getFiatCurrencyCode(), exchangeRateProto.getFiatValue()))))
        )

        (§ if (txProto.hasMemo()))
            (§ call tx.setMemo(txProto.getMemo()))

        ;; Transaction should now be complete.
        (§ var Sha256Hash protoHash = byteStringToHash(txProto.getHash()))
        (§ if (!tx.getHash().equals(protoHash)))
            (§ throw new UnreadableWalletException(String.format(Locale.US, "Transaction did not deserialize completely: %s vs %s", tx.getHash(), protoHash)))
        (§ if (txMap.containsKey(txProto.getHash())))
            (§ throw new UnreadableWalletException("Wallet contained duplicate transaction " + byteStringToHash(txProto.getHash())))
        (§ call txMap.put(txProto.getHash(), tx))
    )

    #_private
    (§ method WalletTransaction connectTransactionOutputs(#_final NetworkParameters params, #_final org.bitcoinj.wallet.Protos.Transaction txProto))
        (§ throws UnreadableWalletException)
    (ß
        (§ var Transaction tx = txMap.get(txProto.getHash()))
        #_final
        (§ var WalletTransaction.Pool pool)
        (§ switch (txProto.getPool()))
        (ß
            (§ case DEAD)
                (§ ass pool = WalletTransaction.Pool.DEAD)
                (§ break)
            (§ case PENDING)
                (§ ass pool = WalletTransaction.Pool.PENDING)
                (§ break)
            (§ case SPENT)
                (§ ass pool = WalletTransaction.Pool.SPENT)
                (§ break)
            (§ case UNSPENT)
                (§ ass pool = WalletTransaction.Pool.UNSPENT)
                (§ break)
            ;; Upgrade old wallets: inactive pool has been merged with the pending pool.
            ;; Remove this some time after 0.9 is old and everyone has upgraded.
            ;; There should not be any spent outputs in this tx as old wallets would not allow them to be spent in this state.
            (§ case INACTIVE)
            (§ case PENDING_INACTIVE)
                (§ ass pool = WalletTransaction.Pool.PENDING)
                (§ break)
            (§ default)
                (§ throw new UnreadableWalletException("Unknown transaction pool: " + txProto.getPool()))
        )

        (§ for (int i = 0 :for i < tx.getOutputs().size() :for i = i + 1))
        (ß
            (§ var TransactionOutput output = tx.getOutputs().get(i))
            #_final
            (§ var Protos.TransactionOutput transactionOutput = txProto.getTransactionOutput(i))
            (§ if (transactionOutput.hasSpentByTransactionHash()))
            (ß
                #_final
                (§ var ByteString spentByTransactionHash = transactionOutput.getSpentByTransactionHash())
                (§ var Transaction spendingTx = txMap.get(spentByTransactionHash))
                (§ if (spendingTx == nil))
                    (§ throw new UnreadableWalletException(String.format(Locale.US, "Could not connect %s to %s", tx.getHashAsString(), byteStringToHash(spentByTransactionHash))))

                #_final
                (§ var int spendingIndex = transactionOutput.getSpentByTransactionIndex())
                (§ var TransactionInput input = Preconditions.checkNotNull(spendingTx.getInput(spendingIndex)))
                (§ call input.connect(output))
            )
        )

        (§ if (txProto.hasConfidence()))
        (ß
            (§ var Protos.TransactionConfidence confidenceProto = txProto.getConfidence())
            (§ var TransactionConfidence confidence = tx.getConfidence())
            (§ call readConfidence(params, tx, confidenceProto, confidence))
        )

        (§ return new WalletTransaction(pool, tx))
    )

    #_private
    (§ method void readConfidence(#_final NetworkParameters params, #_final Transaction tx, #_final Protos.TransactionConfidence confidenceProto, #_final TransactionConfidence confidence))
        (§ throws UnreadableWalletException)
    (ß
        ;; We are lenient here because tx confidence is not an essential part of the wallet.
        ;; If the tx has an unknown type of confidence, ignore.
        (§ if (!confidenceProto.hasType()))
        (ß
            (§ call log.warn("Unknown confidence type for tx {}", tx.getHashAsString()))
            (§ return)
        )

        (§ var ConfidenceType confidenceType)
        (§ switch (confidenceProto.getType()))
        (ß
            (§ case BUILDING)
                (§ ass confidenceType = ConfidenceType.BUILDING)
                (§ break)
            (§ case DEAD)
                (§ ass confidenceType = ConfidenceType.DEAD)
                (§ break)
            ;; These two are equivalent (must be able to read old wallets).
            (§ case NOT_IN_BEST_CHAIN)
                (§ ass confidenceType = ConfidenceType.PENDING)
                (§ break)
            (§ case PENDING)
                (§ ass confidenceType = ConfidenceType.PENDING)
                (§ break)
            (§ case IN_CONFLICT)
                (§ ass confidenceType = ConfidenceType.IN_CONFLICT)
                (§ break)
            (§ case UNKNOWN)
                ;; Fall through.
            (§ default)
                (§ ass confidenceType = ConfidenceType.UNKNOWN)
                (§ break)
        )
        (§ call confidence.setConfidenceType(confidenceType))
        (§ if (confidenceProto.hasAppearedAtHeight()))
        (ß
            (§ if (confidence.getConfidenceType() != ConfidenceType.BUILDING))
            (ß
                (§ call log.warn("Have appearedAtHeight but not BUILDING for tx {}", tx.getHashAsString()))
                (§ return)
            )
            (§ call confidence.setAppearedAtChainHeight(confidenceProto.getAppearedAtHeight()))
        )

        (§ if (confidenceProto.hasDepth()))
        (ß
            (§ if (confidence.getConfidenceType() != ConfidenceType.BUILDING))
            (ß
                (§ call log.warn("Have depth but not BUILDING for tx {}", tx.getHashAsString()))
                (§ return)
            )
            (§ call confidence.setDepthInBlocks(confidenceProto.getDepth()))
        )

        (§ if (confidenceProto.hasOverridingTransaction()))
        (ß
            (§ if (confidence.getConfidenceType() != ConfidenceType.DEAD))
            (ß
                (§ call log.warn("Have overridingTransaction but not OVERRIDDEN for tx {}", tx.getHashAsString()))
                (§ return)
            )
            (§ var Transaction overridingTransaction = txMap.get(confidenceProto.getOverridingTransaction()))
            (§ if (overridingTransaction == nil))
            (ß
                (§ call log.warn("Have overridingTransaction that is not in wallet for tx {}", tx.getHashAsString()))
                (§ return)
            )
            (§ call confidence.setOverridingTransaction(overridingTransaction))
        )

        (§ for (Protos.PeerAddress proto :for confidenceProto.getBroadcastByList()))
        (ß
            (§ var InetAddress ip)
            (§ try)
            (ß
                (§ ass ip = InetAddress.getByAddress(proto.getIpAddress().toByteArray()))
            )
            (§ catch (UnknownHostException e))
            (ß
                (§ throw new UnreadableWalletException("Peer IP address does not have the right length", e))
            )

            (§ var int port = proto.getPort())
            (§ var int protocolVersion = params.getProtocolVersionNum(NetworkParameters.ProtocolVersion.CURRENT))
            (§ var BigInteger services = BigInteger.valueOf(proto.getServices()))
            (§ var PeerAddress address = new PeerAddress(params, ip, port, protocolVersion, services))
            (§ call confidence.markBroadcastBy(address))
        )

        (§ if (confidenceProto.hasLastBroadcastedAt()))
            (§ call confidence.setLastBroadcastedAt(new Date(confidenceProto.getLastBroadcastedAt())))

        (§ switch (confidenceProto.getSource()))
        (ß
            (§ case SOURCE_SELF)
                (§ call confidence.setSource(TransactionConfidence.Source.SELF))
                (§ break)
            (§ case SOURCE_NETWORK)
                (§ call confidence.setSource(TransactionConfidence.Source.NETWORK))
                (§ break)
            (§ case SOURCE_UNKNOWN)
                ;; Fall through.
            (§ default)
                (§ call confidence.setSource(TransactionConfidence.Source.UNKNOWN))
                (§ break)
        )
    )

    ;;;
     ; Cheap test to see if input stream is a wallet.  This checks for a magic value at the beginning of the stream.
     ;
     ; @param is Input stream to test.
     ; @return true if input stream is a wallet.
     ;;
    #_public
    #_static
    (§ method boolean isWallet(InputStream is))
    (ß
        (§ try)
        (ß
            #_final
            (§ var CodedInputStream cis = CodedInputStream.newInstance(is))
            #_final
            (§ var int tag = cis.readTag())
            #_final
            (§ var int field = WireFormat.getTagFieldNumber(tag))
            (§ if (field != 1)) ;; network_identifier
                (§ return false)

            #_final
            (§ var String network = cis.readString())
            (§ return (NetworkParameters.fromID(network) != nil))
        )
        (§ catch (IOException _))
        (ß
            (§ return false)
        )
    )
)

#_(ns org.bitcoinj.wallet #_"WalletTransaction"
    (:import [com.google.common.base Preconditions])
  #_(:require [org.bitcoinj.core Transaction]))

;;;
 ; Stores data about a transaction that is only relevant to the {@link org.bitcoinj.wallet.Wallet} class.
 ;;
#_public
(§ class WalletTransaction
    #_public
    (§ enum Pool
        (§ item UNSPENT) ;; unspent in best chain
        (§ item SPENT) ;; spent in best chain
        (§ item DEAD) ;; double-spend in alt chain
        (§ item PENDING) ;; a pending tx we would like to go into the best chain
    )
    #_private
    #_final
    (§ field Transaction transaction)
    #_private
    #_final
    (§ field Pool pool)

    #_public
    (§ constructor WalletTransaction(Pool pool, Transaction transaction))
    (ß
        (§ ass this.pool = Preconditions.checkNotNull(pool))
        (§ ass this.transaction = transaction)
    )

    #_public
    (§ method Transaction getTransaction())
    (ß
        (§ return transaction)
    )

    #_public
    (§ method Pool getPool())
    (ß
        (§ return pool)
    )
)

#_(ns org.bitcoinj.wallet.listeners #_"KeyChainEventListener"
    (:import [java.util List])
  #_(:require [org.bitcoinj.core ECKey]
             [org.bitcoinj.wallet KeyChain]))

#_public
(§ interface KeyChainEventListener
    ;;;
     ; Called whenever a new key is added to the key chain, whether that be via an explicit addition or due to some
     ; other automatic derivation.  See the documentation for your {@link KeyChain} implementation for details on
     ; what can trigger this event.
     ;;
    (§ method void onKeysAdded(List<ECKey> keys))
)

#_(ns org.bitcoinj.wallet.listeners #_"WalletChangeEventListener"
  #_(:require [org.bitcoinj.wallet Wallet]))

;;;
 ; <p>Implementors are called when the contents of the wallet changes, for instance due to receiving/sending money
 ; or a block chain re-organize.</p>
 ;;
#_public
(§ interface WalletChangeEventListener
    ;;;
     ; <p>Designed for GUI applications to refresh their transaction lists.  This callback is invoked in the following
     ; situations:</p>
     ;
     ; <ol>
     ;     <li>A new block is received (and thus building transactions got more confidence).</li>
     ;     <li>A pending transaction is received.</li>
     ;     <li>A pending transaction changes confidence due to some non-new-block related event,
     ;     such as being announced by more peers or by  a double-spend conflict being observed.</li>
     ;     <li>A re-organize occurs. Call occurs only if the re-org modified any of our transactions.</li>
     ;     <li>A new spend is committed to the wallet.</li>
     ;     <li>The wallet is reset and all transactions removed.<li>
     ; </ol>
     ;
     ; <p>When this is called you can refresh the UI contents from the wallet contents.  It's more efficient to use
     ; this rather than onTransactionConfidenceChanged() + onReorganize() because you only get one callback per block
     ; rather than one per transaction per block.  Note that this is <b>not</b> called when a key is added.</p>
     ;;
    (§ method void onWalletChanged(Wallet wallet))
)

#_(ns org.bitcoinj.wallet.listeners #_"WalletCoinsReceivedEventListener"
  #_(:require [org.bitcoinj.core Coin Transaction]
             [org.bitcoinj.wallet Wallet]))

;;;
 ; <p>Implementors are called when the contents of the wallet changes, for instance due to receiving/sending money
 ; or a block chain re-organize.</p>
 ;;
#_public
(§ interface WalletCoinsReceivedEventListener
    ;;;
     ; This is called when a transaction is seen that sends coins <b>to</b> this wallet, either because it was
     ; broadcast across the network or because a block was received.  If a transaction is seen when it was broadcast,
     ; onCoinsReceived won't be called again when a block containing it is received.  If you want to know when such
     ; a transaction receives its first confirmation, register a {@link TransactionConfidence} event listener using
     ; the object retrieved via {@link org.bitcoinj.core.Transaction#getConfidence()}.  It's safe to modify the
     ; wallet in this callback, for example, by spending the transaction just received.
     ;
     ; @param wallet The wallet object that received the coins.
     ; @param tx The transaction which sent us the coins.
     ; @param prevBalance Balance before the coins were received.
     ; @param newBalance This is the 'estimated' balance.
     ;;
    (§ method void onCoinsReceived(Wallet wallet, Transaction tx, Coin prevBalance, Coin newBalance))
)

#_(ns org.bitcoinj.wallet.listeners #_"WalletCoinsSentEventListener"
  #_(:require [org.bitcoinj.core Coin Transaction]
             [org.bitcoinj.wallet Wallet]))

;;;
 ; <p>Implementors are called when the contents of the wallet changes, for instance due to receiving/sending money
 ; or a block chain re-organize.</p>
 ;;
#_public
(§ interface WalletCoinsSentEventListener
    ;;;
     ; This is called when a transaction is seen that sends coins <b>from</b> this wallet, either because it
     ; was broadcast across the network or because a block was received.  This may at first glance seem useless,
     ; because in the common case you already know about such transactions because you created them with the
     ; Wallets createSend/sendCoins methods.  However when you have a wallet containing only keys, and you wish
     ; to replay the block chain to fill it with transactions, it's useful to find out when a transaction is
     ; discovered that sends coins from the wallet.
     ;
     ; It's safe to modify the wallet from inside this callback, but if you're replaying the block chain you should
     ; be careful to avoid such modifications.  Otherwise your changes may be overridden by new data from the chain.
     ;
     ; @param wallet The wallet object that this callback relates to (that sent the coins).
     ; @param tx The transaction that sent the coins to someone else.
     ; @param prevBalance The wallets balance before this transaction was seen.
     ; @param newBalance The wallets balance after this transaction was seen.  This is the 'estimated' balance.
     ;;
    (§ method void onCoinsSent(Wallet wallet, Transaction tx, Coin prevBalance, Coin newBalance))
)

#_(ns org.bitcoinj.wallet.listeners #_"WalletReorganizeEventListener"
  #_(:require [org.bitcoinj.wallet Wallet]))

;;;
 ; <p>Implementors are called when the wallet is reorganized.</p>
 ;;
#_public
(§ interface WalletReorganizeEventListener
    ;; TODO: Finish onReorganize to be more useful.
    ;;;
     ; <p>This is called when a block is received that triggers a block chain re-organization.</p>
     ;
     ; <p>A re-organize means that the consensus (chain) of the network has diverged and now changed from
     ; what we believed it was previously.  Usually this won't matter because the new consensus will include
     ; all our old transactions assuming we are playing by the rules.  However it's theoretically possible
     ; for our balance to change in arbitrary ways, most likely, we could lose some money we thought we had.</p>
     ;
     ; <p>It is safe to use methods of wallet whilst inside this callback.</p>
     ;;
    (§ method void onReorganize(Wallet wallet))
)
